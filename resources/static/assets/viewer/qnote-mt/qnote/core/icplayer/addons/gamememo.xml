<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="gamememo" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Pairs" nameLabel="gamememo_property_pairs" type="list">
			<property isLocalized="true" name="A (text)" nameLabel="gamememo_property_pair_a_text" type="string"/>
			<property name="A (image)" nameLabel="gamememo_property_pair_a_image" type="image"/>
			<property name="A (alt text)" nameLabel="gamememo_property_alt_text_style_a" type="string"/>
			<property isLocalized="true" name="B (text)" nameLabel="gamememo_property_pair_b_text" type="string"/>
			<property name="B (image)" nameLabel="gamememo_property_pair_b_image" type="image"/>
			<property name="B (alt text)" nameLabel="gamememo_property_alt_text_style_a" type="string"/>
		</property>
		<property name="Columns" nameLabel="gamememo_property_columns" type="string"/>
		<property name="Rows" nameLabel="gamememo_property_rows" type="string"/>
		<property name="Use two styles for cards" nameLabel="gamememo_property_use_two_styles_for_cards" type="boolean"/>
		<property name="Image for style A" nameLabel="gamememo_property_image_for_style_a" type="image"/>
		<property name="Image for style B" nameLabel="gamememo_property_image_for_style_b" type="image"/>
		<property name="Style A cover alt text" nameLabel="gamememo_property_alt_text_style_a" type="string"/>
		<property name="Style B cover alt text" nameLabel="gamememo_property_alt_text_style_b" type="string"/>
		<property name="Keep cards aspect ratio" nameLabel="gamememo_property_keep_cards_aspect_ratio" type="boolean"/>
		<property name="Show cards for preview" nameLabel="gamememo_property_show_cards_for_preview" type="boolean"/>
        <property name="Is Not Activity" nameLabel="gamememo_property_is_not_activity" type="boolean"/>
        <property name="Image Mode" nameLabel="gamememo_property_image_mode" type="{Original, Stretch, KeepAspect}"/>
        <property name="Keep wrong marking" nameLabel="gamememo_property_keep_wrong_marking" type="boolean"/>
        <property name="Time to solve" nameLabel="gamememo_property_time_to_solve" type="string"/>
        <property name="Session ended message" nameLabel="gamememo_property_session_ended_message" type="html"/>
		<property name="Click to turn over incorrect pair" nameLabel="gamememo_property_click_to_turn_over_incorrect_pair" type="boolean"/>
		<property name="Show all answers in gradual show answers mode" nameLabel="gamememo_property_show_all_answers_in_gradual_show_answers_mode" type="boolean"/>
		<property displayName="Lang attribute" name="langAttribute" nameLabel="Connection_property_lang_attribute" type="string"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="Connection_property_speech_texts" type="staticlist">

            <property name="Revealed" nameLabel="gamememo_revealed" type="staticrow">
                <property name="Revealed" nameLabel="gamememo_revealed" type="string"/>
            </property>

			<property name="Paired" nameLabel="gamememo_paired" type="staticrow">
                <property name="Paired" nameLabel="gamememo_paired" type="string"/>
            </property>

			<property name="Value" nameLabel="gamememo_value_of" type="staticrow">
                <property name="Value" nameLabel="gamememo_value_of" type="string"/>
            </property>

			<property name="WrongColor" nameLabel="gamememo_wrong_color" type="staticrow">
                <property name="WrongColor" nameLabel="gamememo_wrong_color" type="string"/>
            </property>

			<property name="Match" nameLabel="gamememo_match" type="staticrow">
                <property name="Match" nameLabel="gamememo_match" type="string"/>
            </property>

			<property name="NotMatch" nameLabel="gamememo_not_match" type="staticrow">
                <property name="NotMatch" nameLabel="gamememo_not_match" type="string"/>
            </property>

			<property name="CurrentlySelected" nameLabel="gamememo_currently_selected" type="staticrow">
                <property name="CurrentlySelected" nameLabel="gamememo_currently_selected" type="string"/>
            </property>

			<property name="TurnOver" nameLabel="gamememo_turn_over" type="staticrow">
                <property name="TurnOver" nameLabel="gamememo_turn_over" type="string"/>
            </property>

			<property name="OutOf" nameLabel="gamememo_out_of" type="staticrow">
                <property name="OutOf" nameLabel="gamememo_out_of" type="string"/>
            </property>

			<property name="Found" nameLabel="gamememo_found" type="staticrow">
                <property name="Found" nameLabel="gamememo_found" type="string"/>
            </property>

			<property name="RevealedCards" nameLabel="gamememo_revealed_cards" type="staticrow">
                <property name="RevealedCards" nameLabel="gamememo_revealed_cards" type="string"/>
            </property>

		</property>
	</model>
<css>.gamememo_container table {&#13;
    border-spacing: 0;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.gamememo_container table td {&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    position: relative;&#13;
}&#13;
&#13;
.gamememo_container table td img {&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
&#13;
}&#13;
&#13;
.gamememo_container p {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.gamememo_container div.cell {&#13;
    float: left;&#13;
    position: relative;&#13;
    overflow: hidden;&#13;
}&#13;
&#13;
&#13;
.gamememo_container div.placeholder {&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    right: 0;&#13;
    bottom: 0;&#13;
    overflow: hidden;&#13;
}&#13;
&#13;
.gamememo_container div.front {&#13;
    cursor: pointer;&#13;
}&#13;
&#13;
.gamememo_container div.front_A {&#13;
    background: #ff0000;&#13;
}&#13;
&#13;
.gamememo_container div.front_A:hover {&#13;
    background: #aa0000;&#13;
}&#13;
&#13;
.gamememo_container div.front_B {&#13;
    background: #0000ff;&#13;
}&#13;
&#13;
.gamememo_container div.front_B:hover {&#13;
    background: #0000bb;&#13;
}&#13;
&#13;
.gamememo_container div.mismatch_mark {&#13;
    color: #cc0000;&#13;
    font-weight: bold;&#13;
    font-size: 64pt;&#13;
    text-align: center;&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    width: 100%;&#13;
    vertical-align: middle;&#13;
    margin-top: -0.15ex;&#13;
    cursor: default;&#13;
    line-height: normal;&#13;
}&#13;
&#13;
.gamememo_container .memo-lock-screen {&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    background-color: #cc0000;&#13;
    opacity: 0.5;&#13;
}&#13;
&#13;
.gamememo_container .memo-lock-screen-info {&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    width: 100%;&#13;
    margin-top: 10%;&#13;
    text-align: center;&#13;
    color: #ffffff;&#13;
}&#13;
&#13;
.gamememo_container div.tick_mark {&#13;
    color: #11cc11;&#13;
    font-weight: bold;&#13;
    font-size: 64pt;&#13;
    text-align: center;&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    width: 100%;&#13;
    vertical-align: middle;&#13;
    margin-top: -0.15ex;&#13;
    cursor: default;&#13;
    line-height: normal;&#13;
}&#13;
&#13;
.gamememo_container .keyboard_navigation_active_element {&#13;
    box-shadow: inset 0px 0px 0px 2px #00ff44 !important;&#13;
  	outline: none;&#13;
}&#13;
&#13;
.gamememo_container span.gamememo_alt_text {&#13;
    clip: rect(1px, 1px, 1px, 1px);&#13;
    height: 1px;&#13;
    width: 1px;&#13;
    overflow: hidden;&#13;
    position: absolute !important;&#13;
}&#13;
</css><view>&lt;div&gt;&lt;/div&gt;&#13;
</view><preview>&lt;div&gt;&lt;/div&gt;&#13;
</preview><presenter>function Addongamememo_create(){&#13;
    var presenter = function(){};&#13;
&#13;
    var playerController;&#13;
    var textParser;&#13;
    var eventBus;&#13;
    var keyboardController = null;&#13;
    var isWCAGOn = false;&#13;
    var screenLocked = false;&#13;
&#13;
    presenter.isShowErrorsMode = false;&#13;
&#13;
    function MemoKeyboardController(elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
    }&#13;
    MemoKeyboardController.prototype = Object.create(KeyboardController.prototype);&#13;
    MemoKeyboardController.prototype.constructor = MemoKeyboardController;&#13;
&#13;
    MemoKeyboardController.prototype.getTarget = function (element) {&#13;
        return element.find('.placeholder');&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.selectAction = function () {&#13;
        if (!this.keyboardNavigationCurrentElement.hasClass('was-clicked')) {&#13;
            this.keyboardNavigationCurrentElement.find('.front.placeholder').click();&#13;
        }&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.nextElement = function (event) {&#13;
        if (screenLocked) return;&#13;
        if (event.keyCode == 9) {&#13;
            return this.handleTab(event);&#13;
        }&#13;
        if ((this.keyboardNavigationCurrentElementIndex + 1) % presenter.columnCount !== 0) {&#13;
            KeyboardController.prototype.nextElement.call(this, event);&#13;
            presenter.readCurrentCell(false);&#13;
        }&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.previousElement = function (event) {&#13;
        if (screenLocked) return;&#13;
        if (event.keyCode == 9) {&#13;
            return this.handleTab(event);&#13;
        }&#13;
         if (this.keyboardNavigationCurrentElementIndex % presenter.columnCount !== 0) {&#13;
             KeyboardController.prototype.previousElement.call(this, event);&#13;
             presenter.readCurrentCell(false);&#13;
         }&#13;
&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.nextRow = function (event) {&#13;
        event.preventDefault();&#13;
        if (screenLocked) return;&#13;
        if (this.keyboardNavigationCurrentElementIndex + presenter.columnCount &lt; this.keyboardNavigationElementsLen) {&#13;
             KeyboardController.prototype.nextRow.call(this, event);&#13;
             presenter.readCurrentCell(false);&#13;
         }&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.previousRow = function (event) {&#13;
        event.preventDefault();&#13;
        if (screenLocked) return;&#13;
        if (this.keyboardNavigationCurrentElementIndex - presenter.columnCount &gt;= 0) {&#13;
             KeyboardController.prototype.previousRow.call(this, event);&#13;
             presenter.readCurrentCell(false);&#13;
         }&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.enter = function (event) {&#13;
        var wasActive = this.keyboardNavigationActive;&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
        if(event) {&#13;
            if (!event.shiftKey) {&#13;
                if (!screenLocked) {&#13;
                    if (!wasActive &amp;&amp; presenter.isShowErrorsMode) {&#13;
                        var TextVoices = presenter.getCellTextVoices(this.keyboardNavigationCurrentElementIndex, {prefix: true, color: true});&#13;
                        TextVoices = TextVoices.concat(presenter.getCompletionTextVoices());&#13;
                        presenter.speak(TextVoices);&#13;
                    } else {&#13;
                        presenter.readCurrentCell(true);&#13;
                    }&#13;
                } else {&#13;
                    var $container = $('&lt;div&gt;&lt;/div&gt;');&#13;
                    $container.html(presenter.sessionEndedMessage);&#13;
                    var TextVoices = window.TTSUtils.getTextVoiceArrayFromElement($container, presenter.configuration.langTag);&#13;
                    presenter.speak(TextVoices);&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.handleTab = function (event) {&#13;
        if (event) {&#13;
            if (!event.shiftKey) {&#13;
                var nextIndex = this.getNextActiveElementIndex();&#13;
                if (nextIndex != null &amp;&amp; nextIndex != this.keyboardNavigationCurrentElementIndex) {&#13;
                    this.switchElement(nextIndex - this.keyboardNavigationCurrentElementIndex);&#13;
                    presenter.readCurrentCell(false);&#13;
                }&#13;
            } else {&#13;
                var prevIndex = this.getPreviousActiveElementIndex();&#13;
                if (prevIndex != null &amp;&amp; prevIndex != this.keyboardNavigationCurrentElementIndex) {&#13;
                    this.switchElement(prevIndex - this.keyboardNavigationCurrentElementIndex);&#13;
                    presenter.readCurrentCell(false);&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.getPreviousActiveElementIndex = function () {&#13;
      var currentIndex = this.keyboardNavigationCurrentElementIndex - 1;&#13;
      while ( currentIndex &gt;= 0) {&#13;
          if (presenter.isCardActive(currentIndex)) {&#13;
              return currentIndex;&#13;
          } else {&#13;
              currentIndex = currentIndex - 1;&#13;
          }&#13;
      }&#13;
      return null;&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.getNextActiveElementIndex = function () {&#13;
      var currentIndex = this.keyboardNavigationCurrentElementIndex + 1;&#13;
      while ( currentIndex &lt; this.keyboardNavigationElementsLen) {&#13;
          if (presenter.isCardActive(currentIndex)) {&#13;
              return currentIndex;&#13;
          } else {&#13;
              currentIndex = currentIndex + 1;&#13;
          }&#13;
      }&#13;
      return null;&#13;
    };&#13;
&#13;
    MemoKeyboardController.prototype.resetPosition = function () {&#13;
        this.switchElement(0 - this.keyboardNavigationCurrentElementIndex);&#13;
    };&#13;
&#13;
    presenter.isCardActive = function(index) {&#13;
        if (index &lt; 0 || index &gt;= keyboardController.keyboardNavigationElementsLen) return false;&#13;
&#13;
        if (presenter.isShowAnswersActive) return true;&#13;
&#13;
        // test if card is already revealed&#13;
        var $card = $(keyboardController.keyboardNavigationElements[index]);&#13;
        if ($card.is('.was-clicked') || $card.find('.was-clicked').length &gt; 0) return false;&#13;
&#13;
        // test if card has the same style as the one currently clicked&#13;
        if (presenter.useTwoStyles &amp;&amp; presenter.state == presenter.STATES.CLICKED_FIRST) {&#13;
            var serializedCard = presenter.serializedCards[index];&#13;
            var clickedStyle = 0;&#13;
            if (presenter.cardClickedStyle == 'B') clickedStyle = 1;&#13;
            if (serializedCard.cardStyle == clickedStyle) return false;&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.readCurrentCell = function (extraData) {&#13;
        var index = keyboardController.keyboardNavigationCurrentElementIndex;&#13;
&#13;
        // SHOW ANSWERS MODE&#13;
        if(presenter.isShowAnswersActive) {&#13;
            var serializedFirstCard = presenter.serializedCards[index];&#13;
            var secondIndex = -1;&#13;
            for (var i = 0; i &lt; presenter.serializedCards.length; i++) {&#13;
                if(i != index &amp;&amp; presenter.serializedCards[i].cardId == serializedFirstCard.cardId) {&#13;
                    secondIndex = i;&#13;
                    break;&#13;
                }&#13;
            }&#13;
            if (secondIndex &lt; 0) {&#13;
                presenter.speak(presenter.getCellTextVoices(index, {prefix: true, color: true, value: true}));&#13;
                return;&#13;
            }&#13;
            var TextVoices = presenter.getCellTextVoices(index, {prefix: false, color: false, value: extraData});&#13;
            TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.match));&#13;
            TextVoices = TextVoices.concat(presenter.getCellTextVoices(secondIndex, {prefix: false, color: false, value: extraData}));&#13;
            presenter.speak(TextVoices);&#13;
            return;&#13;
        }&#13;
&#13;
        // SHOW ERRORS MODE&#13;
        if (presenter.isShowErrorsMode) {&#13;
            var readValue = extraData || !presenter.serializedCards[index].revealed;&#13;
&#13;
            var TextVoices = presenter.getCellTextVoices(index, {prefix: true, color: true, value: readValue});&#13;
            var serializedFirstCard = presenter.serializedCards[index];&#13;
            if (serializedFirstCard.revealed) {&#13;
                var secondIndex = -1;&#13;
                for (var i = 0; i &lt; presenter.serializedCards.length; i++) {&#13;
                    if (i != index &amp;&amp; presenter.serializedCards[i].cardId == serializedFirstCard.cardId) {&#13;
                        secondIndex = i;&#13;
                        break;&#13;
                    }&#13;
                }&#13;
                if (secondIndex &lt; 0) {&#13;
                    presenter.speak(presenter.getCellTextVoices(index, {prefix: true, color: true, value: true}));&#13;
                    return;&#13;
                }&#13;
                TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.match));&#13;
                TextVoices = TextVoices.concat(presenter.getCellTextVoices(secondIndex, {prefix: false, color: extraData, value: extraData}));&#13;
            }&#13;
            if (extraData) {&#13;
                if (presenter.state == presenter.STATES.CLICKED_SECOND) {&#13;
                    if (!presenter.serializedCards[index].revealed) {&#13;
                        var $card = $(keyboardController.keyboardNavigationElements[index]);&#13;
                        if (($card.is('.was-clicked') || $card.find('.was-clicked').length &gt; 0)) {&#13;
                            var revealedCards = presenter.getRevealedCards();&#13;
                            var secondIndex = -1;&#13;
                            if (revealedCards[0] === index) {&#13;
                                secondIndex = revealedCards[1];&#13;
                            } else {&#13;
                                secondIndex = revealedCards[0];&#13;
                            }&#13;
                            TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.notMatch));&#13;
                            TextVoices = TextVoices.concat(presenter.getCellTextVoices(secondIndex, {prefix: false, color: true, value: true}));&#13;
                        }&#13;
                    }&#13;
                }&#13;
                TextVoices = TextVoices.concat(presenter.getCompletionTextVoices());&#13;
            }&#13;
&#13;
            presenter.speak(TextVoices);&#13;
            return;&#13;
        }&#13;
&#13;
        // WORK MODE&#13;
&#13;
        // read the value when providing extra data or when the cell is revealed, but not paired&#13;
        var readValue = extraData || !presenter.serializedCards[index].revealed;&#13;
&#13;
        TextVoices = presenter.getCellTextVoices(index, {prefix: true, color: true, value: readValue});&#13;
        if (presenter.serializedCards[index].revealed) {&#13;
            var secondIndex = -1;&#13;
                for (var i = 0; i &lt; presenter.serializedCards.length; i++) {&#13;
                    if (i != index &amp;&amp; presenter.serializedCards[i].cardId == presenter.serializedCards[index].cardId) {&#13;
                        secondIndex = i;&#13;
                        break;&#13;
                    }&#13;
                }&#13;
                if (secondIndex &gt; -1) {&#13;
                    TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.match));&#13;
                    TextVoices = TextVoices.concat(presenter.getCellTextVoices(secondIndex, {prefix: false, color: extraData, value: extraData}));&#13;
                }&#13;
        }&#13;
        if (extraData) {&#13;
            if (presenter.state == presenter.STATES.CLICKED_FIRST) {&#13;
                var selectedIndex = presenter.getCardIndex(presenter.cardClickedFirst);&#13;
                if (index != selectedIndex) {&#13;
                    TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.currentlySelected));&#13;
                    var currentlySelectedVoiceIndex = TextVoices.length - 1;&#13;
                    TextVoices = TextVoices.concat(presenter.getCellTextVoices(presenter.getCardIndex(presenter.cardClickedFirst), {prefix: false, color: true, value: true}));&#13;
                    if (TextVoices.length &gt; currentlySelectedVoiceIndex+1) {&#13;
                        TextVoices[currentlySelectedVoiceIndex].text += " " + TextVoices[currentlySelectedVoiceIndex+ 1 ].text;&#13;
                        TextVoices.splice(currentlySelectedVoiceIndex + 1, 1);&#13;
                    }&#13;
                }&#13;
            } else if (presenter.state == presenter.STATES.CLICKED_SECOND) {&#13;
                if (!presenter.serializedCards[index].revealed) {&#13;
                    var $card = $(keyboardController.keyboardNavigationElements[index]);&#13;
                    if (($card.is('.was-clicked') || $card.find('.was-clicked').length &gt; 0)) {&#13;
                        var revealedCards = presenter.getRevealedCards();&#13;
                        var secondIndex = -1;&#13;
                        if (revealedCards[0] === index) {&#13;
                            secondIndex = revealedCards[1];&#13;
                        } else {&#13;
                            secondIndex = revealedCards[0];&#13;
                        }&#13;
                        TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.notMatch));&#13;
                        TextVoices = TextVoices.concat(presenter.getCellTextVoices(secondIndex, {prefix: false, color: true, value: true}));&#13;
                    }&#13;
                }&#13;
            }&#13;
            TextVoices = TextVoices.concat(presenter.getCompletionTextVoices());&#13;
        }&#13;
        presenter.speak(TextVoices);&#13;
    };&#13;
&#13;
    /*&#13;
    * Returns an array of numbers, each indicating the index of a card that is revealed, but not paired&#13;
    * */&#13;
    presenter.getRevealedCards = function() {&#13;
        var foundCards = [];&#13;
        for (var i = 0; i &lt; keyboardController.keyboardNavigationElementsLen; i++) {&#13;
            var $card = $(keyboardController.keyboardNavigationElements[i]);&#13;
            if (!presenter.serializedCards[i].revealed &amp;&amp; ($card.is('.was-clicked') || $card.find('.was-clicked').length &gt; 0)) {&#13;
                foundCards.push(i);&#13;
            }&#13;
        }&#13;
        return foundCards;&#13;
    };&#13;
&#13;
    presenter.getCardIndex = function($card) {&#13;
        var query = '';&#13;
        if ($card.hasClass('cell')) {&#13;
            query = '.cell';&#13;
        } else if ($card.hasClass('card')) {&#13;
            query = '.card';&#13;
        } else {&#13;
            return null;&#13;
        }&#13;
        var cardIndex = -1;&#13;
        presenter.viewContainer.find(query).each(function(index){&#13;
            if ($(this).is($card)) cardIndex = index;&#13;
        });&#13;
        if (cardIndex &gt;= 0) return cardIndex;&#13;
        return null;&#13;
    };&#13;
&#13;
    /*&#13;
    * get TextVoice array for a specified cell&#13;
    *&#13;
    * Parameters&#13;
    *   index - cell index in keyboardNavigationElements array ( it should be the same in cards and serializedCards )&#13;
    *   args - an object specifying any additional information that should be passed to the TextVoices array. It can&#13;
    *       have following fields:&#13;
    *       prefix - add 'revealed' or 'paired' at the beginning where applicable&#13;
    *       color - if using two colors, read the color alt text before cell's coordinates&#13;
    *       value - read the value of the cell&#13;
    *&#13;
    * Returns&#13;
    *   an Array of TextVoiceObjects&#13;
    * */&#13;
    presenter.getCellTextVoices = function(index, args) {&#13;
        if (args == null) args = {};&#13;
        if(args.prefix == null) {&#13;
            args.prefix = false;&#13;
        }&#13;
        if(args.color == null) {&#13;
            args.color = false;&#13;
        }&#13;
        if(args.value == null) {&#13;
            args.value = false;&#13;
        }&#13;
        if (index == null || index &lt; 0 || index &gt;= keyboardController.keyboardNavigationElementsLen) return [];&#13;
&#13;
        var row = Math.floor(index / presenter.columnCount) + 1;&#13;
        var alphabet = "ABCDEFGHIJKLMNOPRSTQWXYZ";&#13;
        var columnIndex = index % presenter.columnCount;&#13;
        var columnLetter = alphabet[columnIndex % alphabet.length];&#13;
        var serializedCard = presenter.serializedCards[index];&#13;
        var styleAlt = '';&#13;
        if(args.color  &amp;&amp; presenter.useTwoStyles) {&#13;
            if (serializedCard.cardStyle == 1) {&#13;
                styleAlt = presenter.configuration.altTextStyleB;&#13;
            } else {&#13;
                styleAlt = presenter.configuration.altTextStyleA;&#13;
            }&#13;
        }&#13;
        var title = styleAlt + ' ' + columnLetter + row;&#13;
&#13;
        var $card = $(keyboardController.keyboardNavigationElements[index]);&#13;
        var revealed = ($card.is('.was-clicked') || $card.find('.was-clicked').length &gt; 0);&#13;
&#13;
        var TextVoices = [];&#13;
&#13;
        if (args.prefix &amp;&amp; revealed) {&#13;
            if (serializedCard.revealed) {&#13;
                TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.paired));&#13;
            } else {&#13;
                TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.revealed));&#13;
            }&#13;
        }&#13;
&#13;
        TextVoices.push(window.TTSUtils.getTextVoiceObject(title));&#13;
&#13;
        if (args.value &amp;&amp; (revealed || $card.hasClass('cell-show-answers'))) {&#13;
            TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.value));&#13;
&#13;
            var content = '';&#13;
            if (serializedCard.type == "text") {&#13;
                content = serializedCard.content;&#13;
            } else {&#13;
                content = presenter.cards[index].attr('alt');&#13;
            }&#13;
            TextVoices.push(window.TTSUtils.getTextVoiceObject(content, presenter.configuration.langTag));&#13;
        }&#13;
&#13;
        return TextVoices;&#13;
    };&#13;
&#13;
    presenter.getCompletionTextVoices = function() {&#13;
       var total = presenter.serializedCards.length / 2;&#13;
       var found = 0;&#13;
       for ( var i = 0; i &lt; presenter.serializedCards.length; i++) {&#13;
           if (presenter.serializedCards[i].revealed) found += 1;&#13;
       }&#13;
       found = found / 2;&#13;
&#13;
       var revealed = presenter.getRevealedCards().length;&#13;
&#13;
       var TextVoices = [];&#13;
       TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.found));&#13;
       TextVoices.push(window.TTSUtils.getTextVoiceObject(String(found)));&#13;
       TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.outOf));&#13;
       TextVoices.push(window.TTSUtils.getTextVoiceObject(String(total)));&#13;
       if (!presenter.isShowAnswersActive) {&#13;
           TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.revealedCards));&#13;
           TextVoices.push(window.TTSUtils.getTextVoiceObject(String(revealed)));&#13;
       }&#13;
       return TextVoices;&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        playerController = controller;&#13;
        textParser = new TextParserProxy(controller.getTextParser());&#13;
    };&#13;
&#13;
    presenter.setEventBus = function (wrappedEventBus) {&#13;
        eventBus = wrappedEventBus;&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function (isOn) {&#13;
        isWCAGOn = isOn;&#13;
    };&#13;
&#13;
    presenter.numberToCardType = function(n) {&#13;
        if(n == 0) {&#13;
            return 'A';&#13;
        } else if(n == 1) {&#13;
            return 'B';&#13;
        } else {&#13;
            throw new Error('presenter.numberToCardType accepts only values 0 and 1');&#13;
        }&#13;
    };&#13;
&#13;
    // Fisher-Yates algorithm&#13;
    // based on http://sedition.com/perl/javascript-fy.html&#13;
    presenter.shuffleArray = function(a) {&#13;
        var i = a.length;&#13;
        if ( i == 0 ) return [];&#13;
&#13;
        while ( --i ) {&#13;
            var j = Math.floor( Math.random() * ( i + 1 ) );&#13;
            var tempi = a[i];&#13;
            a[i] = a[j];&#13;
            a[j] = tempi;&#13;
        }&#13;
&#13;
        return a;&#13;
    };&#13;
&#13;
    // Fisher-Yates algorithm&#13;
    // based on http://sedition.com/perl/javascript-fy.html&#13;
    presenter.shuffleTwoArrays = function(a1, a2) {&#13;
        var i = a1.length;&#13;
        if ( i == 0 ) return [[],[]];&#13;
&#13;
        while ( --i ) {&#13;
            var j = Math.floor( Math.random() * ( i + 1 ) );&#13;
&#13;
            var temp1i = a1[i];&#13;
            a1[i] = a1[j];&#13;
            a1[j] = temp1i;&#13;
&#13;
            var temp2i = a2[i];&#13;
            a2[i] = a2[j];&#13;
            a2[j] = temp2i;&#13;
        }&#13;
&#13;
        return [a1, a2];&#13;
    };&#13;
&#13;
    presenter.STATES = {&#13;
        READY: 0,&#13;
        CLICKED_FIRST: 1,&#13;
        CLICKED_SECOND: 2&#13;
    };&#13;
&#13;
    presenter.state = presenter.STATES.READY;&#13;
&#13;
    presenter.cardClickedFirst = null;&#13;
    presenter.cardClickedSecond = null;&#13;
    presenter.cardClickedFirstId = null;&#13;
    presenter.cardClickedSecondId = null;&#13;
    presenter.cardClickedStyle = null;&#13;
    presenter.areClickedCardsHiddenInGSAMode = false;&#13;
&#13;
    presenter.errorCount = 0;&#13;
    presenter.score = 0;&#13;
    presenter.maxScore = null;&#13;
    presenter.timeToSolve = 0;&#13;
    presenter.timer = null;&#13;
    presenter.sessionStarted = null;&#13;
    presenter.spendTime = 0;&#13;
&#13;
    presenter.preview = false;&#13;
    presenter.previewCards = false;&#13;
&#13;
    presenter.cards = [];&#13;
    presenter.serializedCards = [];&#13;
    presenter.rowCount = null;&#13;
    presenter.columnCount = null;&#13;
    presenter.useTwoStyles = false;&#13;
    presenter.keepAspectRatio = false;&#13;
    presenter.styleAImage = null;&#13;
    presenter.styleBImage = null;&#13;
&#13;
    presenter.model = null;&#13;
&#13;
    presenter.requestedRowHeight = null;&#13;
    presenter.requestedColumnWidth = null;&#13;
&#13;
    presenter.ERROR_MESSAGES = {&#13;
        PAIRS_NOT_SPECIFIED: "Pairs are not specified",&#13;
        ROWS_NOT_SPECIFIED: "Amount of rows is not specified",&#13;
        COLUMNS_NOT_SPECIFIED: "Amount of columns is not specified",&#13;
        INVALID_GEOMETRY: "Invalid amount of columns and/or rows - their multiplication must be even",&#13;
        AMOUNT_OF_PAIRS_OTHER_THAN_GEOMETRY: "Invalid amount of pairs: for %columns% columns and %rows% rows there should be defined %pairs% pairs",&#13;
        PAIR_MEMBER_SPECIFIED_TWICE: "Pair %pair% is invalid: its member \"%member%\" is specified both as a text and an image",&#13;
        PAIR_MEMBERS_NOT_SPECIFIED: "Pair %pair% is invalid: its members are not specified"&#13;
    };&#13;
&#13;
    presenter.showErrorMessage = function(message, substitutions) {&#13;
        var errorContainer;&#13;
        if(typeof(substitutions) == 'undefined') {&#13;
            errorContainer = '&lt;p&gt;' + message + '&lt;/p&gt;';&#13;
        } else {&#13;
            var messageSubst = message;&#13;
            for(var key in substitutions) {&#13;
                if (!substitutions.hasOwnProperty(key)) continue;&#13;
                messageSubst = messageSubst.replace('%' + key + '%', substitutions[key]);&#13;
            }&#13;
            errorContainer = '&lt;p&gt;' + messageSubst + '&lt;/p&gt;';&#13;
        }&#13;
&#13;
        presenter.viewContainer.html(errorContainer);&#13;
    };&#13;
&#13;
    function getTimeToSolve(model) {&#13;
        var tts = model['Time to solve'];&#13;
        // parse time to solve and return it in seconds&#13;
        tts = parseInt(tts, 10);&#13;
        return tts&#13;
    }&#13;
&#13;
    presenter.upgradeModel = function(model) {&#13;
        var upgradedModel = presenter.upgradeModelAddTTS(model);&#13;
        upgradedModel = upgradeModelAddShowAllAnswersInGSAModeProperty(upgradedModel);&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeModelAddTTS = function(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!upgradedModel['langAttribute']) {&#13;
            upgradedModel['langAttribute'] = '';&#13;
        }&#13;
&#13;
        if (!upgradedModel['speechTexts']) {&#13;
            upgradedModel['speechTexts'] = {&#13;
                Revealed: {Revealed: "Revealed"},&#13;
                Paired: {Paired: "Paired"},&#13;
                Value: {Value: "with a value of"},&#13;
                WrongColor: {WrongColor: "Incorrect card color"},&#13;
                Match: {Match: "Matches"},&#13;
                NotMatch: {NotMatch: "Doesn't match"},&#13;
                CurrentlySelected: {CurrentlySelected: "Currently selected"},&#13;
                TurnOver: {TurnOver: "Incorrect pair was turned over"},&#13;
                OutOf: {OutOf: "Out of"},&#13;
                Found: {Found: "Found"},&#13;
                RevealedCards: {RevealedCards: "Number of revealed cards"}&#13;
            }&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    function upgradeModelAddShowAllAnswersInGSAModeProperty(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if(!upgradedModel['Show all answers in gradual show answers mode']){&#13;
            upgradedModel['Show all answers in gradual show answers mode'] = false;&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    function getSpeechTextProperty (rawValue, defaultValue) {&#13;
        var value = rawValue.trim();&#13;
&#13;
        if (value === undefined || value === null || value === '') {&#13;
            return defaultValue;&#13;
        }&#13;
&#13;
        return value;&#13;
    }&#13;
&#13;
    presenter.setSpeechTexts = function(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            revealed:  'Revealed',&#13;
            paired: 'Paired',&#13;
            value: 'with a value of',&#13;
            wrongColor: 'Incorrect card color',&#13;
            match: 'Matches',&#13;
            notMatch: 'Doesn\'t match',&#13;
            currentlySelected: 'Currently selected',&#13;
            turnOver: 'Incorrect pair was turned over',&#13;
            outOf: 'out of',&#13;
            found: 'found',&#13;
            revealedCards: 'Number of revealed cards'&#13;
        };&#13;
&#13;
        if (!speechTexts) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            revealed:    getSpeechTextProperty(speechTexts['Revealed']['Revealed'], presenter.speechTexts.revealed),&#13;
            paired: getSpeechTextProperty(speechTexts['Paired']['Paired'], presenter.speechTexts.paired),&#13;
            value:  getSpeechTextProperty(speechTexts['Value']['Value'], presenter.speechTexts.value),&#13;
            wrongColor:     getSpeechTextProperty(speechTexts['WrongColor']['WrongColor'], presenter.speechTexts.wrongColor),&#13;
            match:   getSpeechTextProperty(speechTexts['Match']['Match'], presenter.speechTexts.match),&#13;
            notMatch:      getSpeechTextProperty(speechTexts['NotMatch']['NotMatch'], presenter.speechTexts.notMatch),&#13;
            currentlySelected:        getSpeechTextProperty(speechTexts['CurrentlySelected']['CurrentlySelected'], presenter.speechTexts.currentlySelected),&#13;
            turnOver:        getSpeechTextProperty(speechTexts['TurnOver']['TurnOver'], presenter.speechTexts.turnOver),&#13;
            outOf:        getSpeechTextProperty(speechTexts['OutOf']['OutOf'], presenter.speechTexts.outOf),&#13;
            found:        getSpeechTextProperty(speechTexts['Found']['Found'], presenter.speechTexts.found),&#13;
            revealedCards:        getSpeechTextProperty(speechTexts['RevealedCards']['RevealedCards'], presenter.speechTexts.revealedCards)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        presenter.setSpeechTexts(model['speechTexts']);&#13;
&#13;
        if(model['Pairs'].length == 0) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.PAIRS_NOT_SPECIFIED&#13;
            };&#13;
        }&#13;
&#13;
        if(parseInt(model['Columns']) &lt;= 0 || isNaN(parseInt(model['Columns'])) ) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.COLUMNS_NOT_SPECIFIED&#13;
            };&#13;
        }&#13;
&#13;
        if(parseInt(model['Rows']) &lt;= 0 || isNaN(parseInt(model['Rows']))) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.ROWS_NOT_SPECIFIED&#13;
            };&#13;
        }&#13;
&#13;
        if((parseInt(model['Rows']) * parseInt(model['Columns'])) % 2 == 1) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.INVALID_GEOMETRY&#13;
            };&#13;
        }&#13;
&#13;
        if(parseInt(model['Rows']) * parseInt(model['Columns']) != model['Pairs'].length * 2) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.AMOUNT_OF_PAIRS_OTHER_THAN_GEOMETRY,&#13;
                errorMessageSubstitutions: {&#13;
                    rows: parseInt(model['Rows']),&#13;
                    columns: parseInt(model['Columns']),&#13;
                    pairs: parseInt(model['Rows']) * parseInt(model['Columns']) / 2&#13;
                }&#13;
            };&#13;
        }&#13;
&#13;
&#13;
        for(var i = 0; i &lt; model['Pairs'].length; i++) {&#13;
            if(model['Pairs'][i]['A (text)'] == "" &amp;&amp; model['Pairs'][i]['A (image)'] == "" &amp;&amp;&#13;
                model['Pairs'][i]['B (text)'] == "" &amp;&amp; model['Pairs'][i]['B (image)'] == "") {&#13;
                return {&#13;
                    isError: true,&#13;
                    errorMessage: presenter.ERROR_MESSAGES.PAIR_MEMBERS_NOT_SPECIFIED,&#13;
                    errorMessageSubstitutions: {&#13;
                        pair: i + 1&#13;
                    }&#13;
                };&#13;
            }&#13;
            for(var n = 0; n &lt;= 1; n++) {&#13;
                if(model['Pairs'][i][presenter.numberToCardType(n) + ' (text)'] != "" &amp;&amp; model['Pairs'][i][presenter.numberToCardType(n) + ' (image)'] != "") {&#13;
                    return {&#13;
                        isError: true,&#13;
                        errorMessage: presenter.ERROR_MESSAGES.PAIR_MEMBER_SPECIFIED_TWICE,&#13;
                        errorMessageSubstitutions: {&#13;
                            pair: i + 1,&#13;
                            member: presenter.numberToCardType(n)&#13;
                        }&#13;
                    };&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.maxScore = model['Pairs'].length;&#13;
        presenter.rowCount = parseInt(model['Rows']);&#13;
        presenter.columnCount = parseInt(model['Columns']);&#13;
        presenter.useTwoStyles = model['Use two styles for cards'] == 'True';&#13;
        presenter.keepAspectRatio = model['Keep cards aspect ratio'] == 'True';&#13;
        presenter.previewCards = model['Show cards for preview'] == 'True';&#13;
        presenter.styleAImage = model['Image for style A'] != '' ? model['Image for style A'] : null;&#13;
        presenter.styleBImage = model['Image for style B'] != '' ? model['Image for style B'] : null;&#13;
        presenter.isActivity = !(ModelValidationUtils.validateBoolean(model['Is Not Activity']));&#13;
        presenter.imageMode = model['Image Mode'];&#13;
        presenter.keppWrongMarking = ModelValidationUtils.validateBoolean(model['Keep wrong marking']);&#13;
        presenter.timeToSolve = getTimeToSolve(model);&#13;
        presenter.sessionEndedMessage = model['Session ended message'];&#13;
&#13;
        var viewWidth = parseInt(presenter.viewContainer.css('width'));&#13;
        var viewHeight = parseInt(presenter.viewContainer.css('height'));&#13;
&#13;
        presenter.requestedColumnWidth = Math.round(viewWidth / presenter.columnCount);&#13;
        presenter.requestedRowHeight = Math.round(viewHeight / presenter.rowCount);&#13;
&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            ID: model.ID,&#13;
            pairs: model['Pairs'],&#13;
            isVisible: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            isVisibleByDefault: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            isTabindexEnabled: ModelValidationUtils.validateBoolean(model["Is Tabindex Enabled"]),&#13;
            clickToTurnOverIncorrectPair: ModelValidationUtils.validateBoolean(model["Click to turn over incorrect pair"]),&#13;
            showAllAnswersInGradualShowAnswersMode: ModelValidationUtils.validateBoolean(model["Show all answers in gradual show answers mode"]),&#13;
            altTextStyleA: model['Style A cover alt text'],&#13;
            altTextStyleB: model['Style B cover alt text'],&#13;
            langTag: model['langAttribute']&#13;
        };&#13;
    };&#13;
&#13;
    presenter.slideUpAnimation = function ($element, successFunction) {&#13;
        var distance = $element.outerHeight();&#13;
        $element.animate({bottom: (distance + 'px')}, 200, function () {&#13;
            $(this).css({&#13;
                visibility: 'hidden',&#13;
                bottom: 0&#13;
            });&#13;
&#13;
            successFunction();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.slideDownAnimation = function ($element, successFunction) {&#13;
        var distance = $element.outerHeight();&#13;
&#13;
        if(presenter.imageMode == 'KeepAspect') {&#13;
            $element.css('visibility', 'visible');&#13;
        } else {&#13;
             $element.css({'bottom': (distance + 'px'), visibility: 'visible'})&#13;
                .animate({bottom: 0}, 200);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showCard = function(cell) {&#13;
        var successFunction = function () {&#13;
            presenter.slideDownAnimation(cell.children(".back"));&#13;
        };&#13;
&#13;
        presenter.slideUpAnimation(cell.children(".front"), successFunction);&#13;
&#13;
        if(!presenter.isShowAnswersActive){&#13;
            cell.addClass('was-clicked');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideCard = function(cell) {&#13;
        var successFunction = function () {&#13;
            presenter.slideDownAnimation(cell.children(".front"));&#13;
        };&#13;
&#13;
        presenter.slideUpAnimation(cell.children(".back"), successFunction);&#13;
        cell.removeClass('exposed-in-GSA-mode');&#13;
&#13;
        if(!presenter.isShowAnswersActive){&#13;
            cell.removeClass('was-clicked');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showClickedCardsInGSAMode = function () {&#13;
        if (presenter.areClickedCardsHiddenInGSAMode) {&#13;
            if (presenter.cardClickedFirst) {&#13;
                presenter.showCard(presenter.cardClickedFirst);&#13;
                presenter.cardClickedFirst.addClass('was-clicked');&#13;
            }&#13;
            if (presenter.cardClickedSecond) {&#13;
                presenter.showCard(presenter.cardClickedSecond);&#13;
                presenter.cardClickedSecond.addClass('was-clicked');&#13;
            }&#13;
            presenter.areClickedCardsHiddenInGSAMode = false;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.hideClickedCardsInGSAMode = function () {&#13;
        if (!presenter.areClickedCardsHiddenInGSAMode) {&#13;
            if (presenter.cardClickedFirst) {&#13;
                presenter.hideCard(presenter.cardClickedFirst);&#13;
                presenter.cardClickedFirst.removeClass('was-clicked');&#13;
            }&#13;
            if (presenter.cardClickedSecond) {&#13;
                presenter.hideCard(presenter.cardClickedSecond);&#13;
                presenter.cardClickedSecond.removeClass('was-clicked');&#13;
            }&#13;
            presenter.areClickedCardsHiddenInGSAMode = true;&#13;
        }&#13;
    }&#13;
&#13;
    function getMarkDiv(markType, height) {&#13;
        var factory = {&#13;
            "tick": function () {&#13;
                return $('&lt;div class="tick_mark"&gt;&amp;check;&lt;/div&gt;');&#13;
            },&#13;
&#13;
            "mismatch": function () {&#13;
                return $('&lt;div class="mismatch_mark"&gt;&amp;times;&lt;/div&gt;');&#13;
            }&#13;
        };&#13;
&#13;
        var mark = factory[markType]();&#13;
&#13;
        mark.css({&#13;
            opacity: 0.8,&#13;
            fontSize: Math.round(parseInt(height) * 0.95) + 'px'&#13;
        });&#13;
&#13;
        return mark;&#13;
    }&#13;
&#13;
    function fadeOutMark (mark, time) {&#13;
        mark.fadeOut(time, function () {&#13;
            mark.remove();&#13;
        });&#13;
    }&#13;
&#13;
    function setMarkHeight (mark) {&#13;
        mark.css('top', Math.round(parseInt(mark.css('height')) * -0.08) + 'px');&#13;
    }&#13;
&#13;
    presenter.markCardMismatch = function(cell, heightProbeCell) {&#13;
        var mark = getMarkDiv("mismatch", heightProbeCell.parent().css('height'));&#13;
&#13;
        cell.parent().append(mark);&#13;
&#13;
        setMarkHeight(mark);&#13;
        if (!presenter.keppWrongMarking) {&#13;
            fadeOutMark(mark, 1300)&#13;
        }&#13;
    };&#13;
&#13;
    presenter.markCardTick = function(cell, heightProbeCell) {&#13;
        var mark = getMarkDiv("tick", heightProbeCell.parent().css('height'));&#13;
        cell.parent().append(mark);&#13;
&#13;
        setMarkHeight(mark);&#13;
        fadeOutMark(mark, 1300)&#13;
    };&#13;
&#13;
&#13;
    presenter.prepareGrid = function() {&#13;
        var cards = [];&#13;
        var serializedCards = [];&#13;
        var card;&#13;
        var serializedCard;&#13;
&#13;
        var pairs = presenter.configuration.pairs;&#13;
&#13;
        for(var n = 0; n &lt;= 1; n++) {&#13;
            for(var j = 0; j &lt; pairs.length; j++) {&#13;
&#13;
                if(pairs[j][presenter.numberToCardType(n) + ' (text)'] != "") {&#13;
                    card = $('&lt;p&gt;&lt;/p&gt;').text(pairs[j][presenter.numberToCardType(n) + ' (text)']);&#13;
                    serializedCard = { revealed: false, type: "text", content: pairs[j][presenter.numberToCardType(n) + ' (text)'] }&#13;
&#13;
                } else {&#13;
                    card = $('&lt;img/&gt;').attr({ src: pairs[j][presenter.numberToCardType(n) + ' (image)']});&#13;
&#13;
                    var altText = pairs[j][presenter.numberToCardType(n) + ' (alt text)'];&#13;
                    if (altText !== '' &amp;&amp; altText !== undefined) {&#13;
                        card.attr('alt', altText);&#13;
                    }&#13;
&#13;
                    serializedCard = { revealed: false, type: "image", content: pairs[j][presenter.numberToCardType(n) + ' (image)'] }&#13;
                }&#13;
&#13;
                card.addClass('card').attr({'card_id' : j, 'card_style' : n});&#13;
                cards.push(card);&#13;
&#13;
                serializedCard.cardStyle = n;&#13;
                serializedCard.cardId = j;&#13;
                serializedCards.push(serializedCard);&#13;
            }&#13;
        }&#13;
&#13;
        presenter.cards = cards;&#13;
        presenter.serializedCards = serializedCards;&#13;
&#13;
        presenter.shuffleCards();&#13;
    };&#13;
&#13;
    presenter.shuffleCards = function() {&#13;
        var shuffled = presenter.shuffleTwoArrays(presenter.cards, presenter.serializedCards);&#13;
&#13;
        presenter.cards = shuffled[0];&#13;
        presenter.serializedCards = shuffled[1];&#13;
    };&#13;
&#13;
    presenter.prepareGridFromSavedState = function(savedCards) {&#13;
        var cards = [], card,&#13;
            pairs = presenter.model['Pairs'], src;&#13;
&#13;
        for(var i = 0; i &lt; savedCards.length; i++) {&#13;
            if(savedCards[i].type == "text") {&#13;
                card = $('&lt;p&gt;&lt;/p&gt;').text(savedCards[i].content);&#13;
            } else {&#13;
                src = pairs[savedCards[i].cardId][presenter.numberToCardType(savedCards[i].cardStyle) + ' (image)'];&#13;
                card = $('&lt;img/&gt;').attr({ src: src });&#13;
&#13;
                var altText = pairs[savedCards[i].cardId][presenter.numberToCardType(savedCards[i].cardStyle) + ' (alt text)']&#13;
                if (altText !== undefined &amp;&amp; altText !== '') {&#13;
                    card.attr('alt', altText);&#13;
                }&#13;
            }&#13;
            card.addClass('card').attr({'card_id' : savedCards[i].cardId, 'card_style' : savedCards[i].cardStyle });&#13;
            cards.push(card);&#13;
        }&#13;
&#13;
        presenter.cards = cards;&#13;
        presenter.serializedCards = savedCards;&#13;
    };&#13;
&#13;
    presenter.handleCardClickedFirst = function(card) {&#13;
        presenter.state = presenter.STATES.CLICKED_FIRST;&#13;
        if(presenter.imageMode == 'KeepAspect'){&#13;
            if(card.hasClass('cell')){&#13;
                presenter.cardClickedFirst = card;&#13;
            }else{&#13;
                presenter.cardClickedFirst = card.parent();&#13;
            }&#13;
        }else{&#13;
            presenter.cardClickedFirst = card;&#13;
        }&#13;
        presenter.showCard(presenter.cardClickedFirst);&#13;
&#13;
        if(presenter.useTwoStyles) {&#13;
            presenter.cardClickedStyle = presenter.numberToCardType(parseInt(presenter.cardClickedFirst.find('.card').attr('card_style')));&#13;
            presenter.viewContainer.find("div.front_" + presenter.cardClickedStyle).css('cursor', 'default');&#13;
        }&#13;
&#13;
        if (keyboardController) {&#13;
            var TextVoices = [];&#13;
            TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.revealed));&#13;
            TextVoices = TextVoices.concat(presenter.getCellTextVoices(keyboardController.keyboardNavigationCurrentElementIndex, {prefix: false, color: true, value: true}));&#13;
            presenter.speak(TextVoices);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.cardReveal = function () {&#13;
        var cells = presenter.viewContainer.find('.cell');&#13;
        presenter.serializedCards[$.inArray(presenter.cardClickedFirst[0], cells)].revealed = true;&#13;
        presenter.serializedCards[$.inArray(presenter.cardClickedSecond[0], cells)].revealed = true;&#13;
    };&#13;
&#13;
    presenter.addScoreAndSentEvent = function () {&#13;
        presenter.cardReveal();&#13;
&#13;
        presenter.score++;&#13;
&#13;
        if (presenter.isAllOK()) {&#13;
            removeTimers();&#13;
            var now = new Date();&#13;
            presenter.spendTime += now - presenter.sessionStarted;&#13;
            presenter.sessionStarted = null;&#13;
            if (presenter.isActivity) {&#13;
                presenter.sendAllOKEvent();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createBaseEventData = function () {&#13;
        return {&#13;
            source: presenter.ID ,&#13;
            item: "",&#13;
            value: "",&#13;
            score: ""&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createItemEventData = function (firstID, secondID, isCorrect) {&#13;
        var eventData = presenter.createBaseEventData();&#13;
        var firstId = parseInt(firstID)+1;&#13;
        var secondId = parseInt(secondID)+1;&#13;
&#13;
        eventData.item = firstId+"-"+secondId;&#13;
        eventData.value = '1';&#13;
        eventData.score = isCorrect ? "1" : "0";&#13;
&#13;
        if (!presenter.isActivity) {&#13;
            eventData.score = "";&#13;
        }&#13;
&#13;
        return eventData;&#13;
    };&#13;
&#13;
    presenter.sendEventData = function (eventData) {&#13;
        eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    function numberToCardType(element) {&#13;
        if (element.is("img")) {&#13;
            return element.parent().parent().find('.card').attr('card_style');&#13;
        } else {&#13;
            return element.parent().find('.card').attr('card_style');&#13;
        }&#13;
    }&#13;
&#13;
    presenter.onCardClicked = function(e) {&#13;
        e.stopPropagation();&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.sessionStarted === null) {&#13;
            presenter.startSession();&#13;
        }&#13;
&#13;
        var eventData;&#13;
        var cardId = $(e.target).parent().find('.card').attr('card_id');&#13;
&#13;
        if(presenter.useTwoStyles) {&#13;
            var clickedStyle;&#13;
            clickedStyle = presenter.numberToCardType(parseInt(numberToCardType($(e.target))));&#13;
            if(clickedStyle == presenter.cardClickedStyle) {&#13;
                presenter.speak([window.TTSUtils.getTextVoiceObject(presenter.speechTexts.wrongColor)]);&#13;
                return;&#13;
            }&#13;
        }&#13;
&#13;
        if(presenter.configuration.clickToTurnOverIncorrectPair &amp;&amp; presenter.STATES.CLICKED_SECOND) {&#13;
&#13;
        }&#13;
&#13;
        switch(presenter.state) {&#13;
            case presenter.STATES.READY:&#13;
                presenter.handleCardClickedFirst($(e.target).parent());&#13;
                break;&#13;
&#13;
            case presenter.STATES.CLICKED_FIRST:&#13;
                presenter.state = presenter.STATES.CLICKED_SECOND;&#13;
&#13;
                if(presenter.imageMode == 'KeepAspect'){&#13;
                    if($(e.target).parent().hasClass('cell')){&#13;
                        presenter.cardClickedSecond = $(e.target).parent();&#13;
                    }else{&#13;
                        presenter.cardClickedSecond = $(e.target).parent().parent();&#13;
                    }&#13;
                }else{&#13;
                    presenter.cardClickedSecond = $(e.target).parent();&#13;
                }&#13;
&#13;
                presenter.showCard(presenter.cardClickedSecond);&#13;
&#13;
                presenter.cardClickedFirstId = presenter.cardClickedFirst.find('.card').attr('card_id');&#13;
                presenter.cardClickedSecondId = presenter.cardClickedSecond.find('.card').attr('card_id');&#13;
&#13;
                var firstIndex = presenter.getCardIndex(presenter.cardClickedFirst);&#13;
&#13;
                var TextVoices = [];&#13;
                TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.revealed));&#13;
                TextVoices = TextVoices.concat(presenter.getCellTextVoices(keyboardController.keyboardNavigationCurrentElementIndex, {prefix: false, color: true, value: true}));&#13;
&#13;
                if(presenter.cardClickedFirstId != presenter.cardClickedSecondId) {&#13;
                    presenter.errorCount++;&#13;
                    presenter.markCardMismatch(presenter.cardClickedFirst.find(".card"), presenter.cardClickedFirst.find(".card"));&#13;
                    presenter.markCardMismatch(presenter.cardClickedSecond.find(".card"), presenter.cardClickedFirst.find(".card"));&#13;
&#13;
                    eventData = presenter.createItemEventData(presenter.cardClickedFirstId, presenter.cardClickedSecondId,  false);&#13;
                    presenter.sendEventData(eventData);&#13;
                    presenter.isCorrectMark = false;&#13;
                    TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.notMatch));&#13;
                } else {&#13;
                    presenter.markCardTick(presenter.cardClickedFirst.find(".card"), presenter.cardClickedFirst.find(".card"));&#13;
                    presenter.markCardTick(presenter.cardClickedSecond.find(".card"), presenter.cardClickedFirst.find(".card"));&#13;
&#13;
                    eventData = presenter.createItemEventData(presenter.cardClickedFirstId, presenter.cardClickedSecondId, true);&#13;
                    presenter.sendEventData(eventData);&#13;
&#13;
                    presenter.addScoreAndSentEvent();&#13;
                    presenter.isCorrectMark = true;&#13;
                    TextVoices.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.match));&#13;
&#13;
                    presenter.cardClickedFirst = null;&#13;
                    presenter.cardClickedSecond = null;&#13;
                }&#13;
                TextVoices = TextVoices.concat(presenter.getCellTextVoices(firstIndex, {prefix: false, color: true, value: true}));&#13;
                presenter.speak(TextVoices);&#13;
&#13;
                if(presenter.useTwoStyles) {&#13;
                    presenter.viewContainer.find("div.front_" + presenter.cardClickedStyle).css('cursor', '');&#13;
                    presenter.cardClickedStyle = null;&#13;
                }&#13;
&#13;
                break;&#13;
&#13;
            case presenter.STATES.CLICKED_SECOND:&#13;
                if(presenter.cardClickedFirstId != presenter.cardClickedSecondId) {&#13;
                    presenter.hideCard(presenter.cardClickedFirst);&#13;
                    presenter.hideCard(presenter.cardClickedSecond);&#13;
                }&#13;
&#13;
                if(presenter.configuration.clickToTurnOverIncorrectPair &amp;&amp; !presenter.isCorrectMark) {&#13;
                    presenter.cardClickedFirst = null;&#13;
                    presenter.state = presenter.STATES.READY;&#13;
                    presenter.speak([window.TTSUtils.getTextVoiceObject(presenter.speechTexts.turnOver)]);&#13;
                } else {&#13;
                    presenter.handleCardClickedFirst($(e.target).parent());&#13;
                }&#13;
&#13;
                presenter.cardClickedSecond = null;&#13;
                presenter.cardClickedFirstId = null;&#13;
                presenter.cardClickedSecondId = null;&#13;
&#13;
                if (presenter.keppWrongMarking) {&#13;
                    var mark = presenter.viewContainer.find('.mismatch_mark');&#13;
                    fadeOutMark(mark, 1000);&#13;
                }&#13;
&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onBackClick = function () {&#13;
        if(presenter.STATES.CLICKED_SECOND &amp;&amp; presenter.configuration.clickToTurnOverIncorrectPair &amp;&amp; !presenter.isCorrectMark) {&#13;
            if(presenter.cardClickedFirstId != presenter.cardClickedSecondId) {&#13;
                presenter.hideCard(presenter.cardClickedFirst);&#13;
                presenter.hideCard(presenter.cardClickedSecond);&#13;
            }&#13;
&#13;
            presenter.cardClickedFirst = null;&#13;
            presenter.state = presenter.STATES.READY;&#13;
            presenter.cardClickedSecond = null;&#13;
            presenter.cardClickedFirstId = null;&#13;
            presenter.cardClickedSecondId = null;&#13;
&#13;
            if (presenter.keppWrongMarking) {&#13;
                var mark = presenter.viewContainer.find('.mismatch_mark');&#13;
                fadeOutMark(mark, 1000);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createGrid = function() {&#13;
        var cards = presenter.cards;&#13;
        var keyboardNavigationElements = [];&#13;
&#13;
        var $container = $('&lt;div class="gamememo_container"&gt;&lt;/div&gt;');&#13;
&#13;
        if(presenter.keepAspectRatio) {&#13;
            if(presenter.requestedRowHeight &gt; presenter.requestedColumnWidth) {&#13;
                $container.css('height', (presenter.requestedColumnWidth * presenter.rowCount) + 'px');&#13;
            } else if (presenter.requestedColumnWidth &gt;= presenter.requestedRowHeight) {&#13;
                $container.css('width', (presenter.requestedRowHeight * presenter.columnCount) + 'px');&#13;
                $container.css('height', (presenter.requestedRowHeight * presenter.rowCount) + 'px');&#13;
            }&#13;
        } else {&#13;
            $container.css({&#13;
                width: presenter.viewContainer.css('width'),&#13;
                height: presenter.viewContainer.css('height')&#13;
            });&#13;
        }&#13;
&#13;
        var columnWidthPercent = (100.0 / presenter.columnCount) + '%';&#13;
        var rowHeightPercent = (100.0 / presenter.rowCount) + '%';&#13;
&#13;
        for(var r = 0; r &lt; presenter.rowCount; r++) {&#13;
&#13;
            for(var c = 0; c &lt; presenter.columnCount; c++) {&#13;
                var front = $('&lt;div class="front placeholder"&gt;&lt;/div&gt;')&#13;
                    .addClass(presenter.useTwoStyles ?&#13;
                    'front_' + presenter.numberToCardType(parseInt(cards[r * presenter.columnCount + c].attr('card_style'))) :&#13;
                    'front_A');&#13;
&#13;
                if(!presenter.preview) {&#13;
                    front.click(presenter.onCardClicked);&#13;
                }&#13;
&#13;
                var back = $('&lt;div class="back placeholder"&gt;&lt;/div&gt;')&#13;
                    .append(cards[r * presenter.columnCount + c]);&#13;
&#13;
                var cell = $('&lt;div class="cell"&gt;&lt;/div&gt;').css({&#13;
                    height : rowHeightPercent,&#13;
                    width : columnWidthPercent&#13;
                });&#13;
&#13;
                if (presenter.configuration.isTabindexEnabled) {&#13;
                    cell.attr("tabindex", "0");&#13;
                }&#13;
&#13;
                if(!presenter.preview) {&#13;
                    cell.append(back).append(front);&#13;
                    back.click(presenter.onBackClick);&#13;
                } else {&#13;
                    if(presenter.previewCards) {&#13;
                        back.css('display', 'block');&#13;
                        cell.append(back);&#13;
&#13;
                    } else {&#13;
                        cell.append(back).append(front);&#13;
                    }&#13;
                }&#13;
&#13;
                $container.append(cell);&#13;
                keyboardNavigationElements.push(cell);&#13;
            }&#13;
        }&#13;
        if (keyboardController !== null) {&#13;
            keyboardController.reload(keyboardNavigationElements, presenter.columnCount);&#13;
        } else {&#13;
            keyboardController = new MemoKeyboardController(keyboardNavigationElements, presenter.columnCount);&#13;
        }&#13;
&#13;
        if(presenter.styleAImage != null){&#13;
            var frontDivA = $container.find('div.front_A');&#13;
            presenter.setDivImage(frontDivA, presenter.styleAImage, presenter.configuration.altTextStyleA);&#13;
        }&#13;
&#13;
        if(presenter.styleBImage != null){&#13;
            var frontDivB = $container.find('div.front_B');&#13;
            presenter.setDivImage(frontDivB, presenter.styleBImage, presenter.configuration.altTextStyleB);&#13;
        }&#13;
&#13;
        presenter.viewContainer.children('div').append($container);&#13;
&#13;
        $container.find('p.card').each(function(i, e) {&#13;
            var element = $(e);&#13;
            element.css({&#13;
                position : 'absolute',&#13;
                width : '100%',&#13;
                top : Math.round((parseInt(element.parent().css('height')) - parseInt(element.css('height'))) / 2) + 'px'&#13;
            });&#13;
        });&#13;
&#13;
        if(!presenter.preview || (presenter.preview &amp;&amp; !presenter.previewCards))&#13;
            $container.find('div.back').css('visibility', 'hidden');&#13;
&#13;
        if(presenter.imageMode == 'Stretch'){&#13;
            presenter.viewContainer.find('.gamememo_container .cell .back.placeholder img').css({&#13;
                'width': '100%',&#13;
                'height': '100%'&#13;
            });&#13;
        }&#13;
&#13;
        if(presenter.imageMode == 'KeepAspect'){&#13;
            presenter.viewContainer.find('.gamememo_container .cell .back.placeholder img').css({&#13;
                'display': 'block',&#13;
                'max-width': presenter.requestedColumnWidth,&#13;
                'max-height': presenter.requestedRowHeight,&#13;
                'width': 'auto',&#13;
                'height': 'auto'&#13;
            });&#13;
&#13;
            presenter.viewContainer.find('.gamememo_container .cell .back.placeholder img').load(function () {&#13;
                presenter.viewContainer.find('.gamememo_container .cell .back.placeholder').each(function () {&#13;
                    centerImage(this);&#13;
                });&#13;
            });&#13;
&#13;
            presenter.viewContainer.find('img').load(function () {&#13;
                presenter.viewContainer.find('div.front_A').each(function () {&#13;
                    centerImage(this);&#13;
                });&#13;
            });&#13;
&#13;
            presenter.viewContainer.find('img').load(function () {&#13;
                presenter.viewContainer.find('div.front_B').each(function () {&#13;
                    centerImage(this);&#13;
                });&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setDivImage = function($div, image, altText) {&#13;
        var encodedURI = encodeURI(image);&#13;
&#13;
        if (presenter.imageMode == 'Stretch') {&#13;
            $div.css({&#13;
                'background': 'url(' + encodedURI + ')',&#13;
                'background-size': '100% 100%'&#13;
            });&#13;
        } else if(presenter.imageMode == 'KeepAspect') {&#13;
            var img = $('&lt;img&gt;');&#13;
            img.attr('src', encodedURI);&#13;
            img.css({&#13;
                'display': 'block',&#13;
                'max-width': presenter.requestedColumnWidth,&#13;
                'max-height': presenter.requestedRowHeight,&#13;
                'width': 'auto',&#13;
                'height': 'auto'&#13;
            });&#13;
            $div.append(img);&#13;
            $div.css('background', 'transparent');&#13;
        } else {&#13;
            $div.css({&#13;
                'background': 'url(' + encodedURI + ')'&#13;
            });&#13;
        }&#13;
&#13;
        if (altText !== undefined) {&#13;
            var altTextSpan = document.createElement('span');&#13;
            altTextSpan.innerText = altText;&#13;
            altTextSpan.className = 'gamememo_alt_text';&#13;
            $div.append(altTextSpan);&#13;
        }&#13;
    };&#13;
&#13;
    function centerImage(element) {&#13;
        var imgTop = ($(element).height() - $(element).find('img').height())/2;&#13;
        var imgLeft = ($(element).width() - $(element).find('img').width())/2;&#13;
&#13;
        $(element).find('img').css({&#13;
            'top': imgTop+'px',&#13;
            'left': imgLeft+'px',&#13;
            'position': 'relative'&#13;
        });&#13;
    }&#13;
&#13;
    presenter.initializeLogic = function(view, model) {&#13;
        presenter.viewContainer = $(view);&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.model = model;&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        presenter.ID = model.ID;&#13;
        if(presenter.configuration.isError) {&#13;
            presenter.showErrorMessage(presenter.configuration.errorMessage, presenter.configuration.errorMessageSubstitutions);&#13;
        } else {&#13;
            presenter.prepareGrid();&#13;
            presenter.createGrid();&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.destroy = function () {&#13;
        removeTimers();&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.preview = false;&#13;
        presenter.initializeLogic(view, model);&#13;
        var events = ['ShowAnswers', 'HideAnswers', 'GradualShowAnswers', 'GradualHideAnswers'];&#13;
        for (var i = 0; i &lt; events.length; i++) {&#13;
            eventBus.addEventListener(events[i], this);&#13;
        }&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
        view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved(ev) {&#13;
            if (ev.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.preview = true;&#13;
        presenter.initializeLogic(view, model);&#13;
    };&#13;
&#13;
    var sendSessionEvent = function (eventType) {&#13;
        var eventData = {&#13;
            'source': presenter.ID,&#13;
            'item': eventType,&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
        eventBus.sendEvent('ItemSelected', eventData);&#13;
    };&#13;
&#13;
    presenter.startSession = function () {&#13;
        if (presenter.timeToSolve &gt; 0) {&#13;
            presenter.sessionStarted = new Date();&#13;
            var timeout = presenter.timeToSolve*1000 - presenter.spendTime;&#13;
            if (timeout &lt;= 0 ){&#13;
                presenter.setLockScreen();&#13;
            } else {&#13;
                presenter.timer = setTimeout(presenter.setLockScreen, timeout);&#13;
                presenter.timeInterval = setInterval(presenter.sendTimerEvent, 1000);&#13;
                sendSessionEvent('startSession');&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
     function formatTime(seconds) {&#13;
        var minutes = Math.floor(seconds / 60);&#13;
        minutes = (minutes &gt;= 10) ? minutes : "0" + minutes;&#13;
        seconds = Math.floor(seconds % 60);&#13;
        seconds = (seconds &gt;= 10) ? seconds : "0" + seconds;&#13;
        return minutes + ":" + seconds;&#13;
    }&#13;
&#13;
    presenter.sendTimerEvent = function AddonMemo_sendTimerEvent() {&#13;
        var now = new Date(),&#13;
        spendTime = Math.round(((now - presenter.sessionStarted) + presenter.spendTime) / 1000),&#13;
        remainingTime = presenter.timeToSolve - spendTime,&#13;
        progress = Math.round(100 * spendTime / presenter.timeToSolve),&#13;
        eventData = {&#13;
            'source': presenter.ID,&#13;
            'item': progress,&#13;
            'value': formatTime(spendTime),&#13;
        };&#13;
        eventBus.sendEvent('ItemConsumed', eventData);&#13;
    };&#13;
&#13;
    function removeTimers() {&#13;
        if (presenter.timeInterval){&#13;
            clearInterval(presenter.timeInterval);&#13;
        }&#13;
        if (presenter.timer){&#13;
            clearTimeout(presenter.timer);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setLockScreen = function AddonMemo_setLockScreen() {&#13;
        presenter.turnOffUserInteraction();&#13;
        var gamememo_container = presenter.viewContainer.find('.gamememo_container');&#13;
        var lockScreen = $('&lt;div class="memo-lock-screen"&gt;&lt;/div&gt;'),&#13;
            lockScreenInfo = $('&lt;div class="memo-lock-screen-info"&gt;&lt;/div&gt;');&#13;
&#13;
        var sessionEndedMessage = presenter.sessionEndedMessage;&#13;
        if (textParser) {&#13;
            sessionEndedMessage = textParser.parse(sessionEndedMessage);&#13;
        }&#13;
        lockScreenInfo.html(sessionEndedMessage);&#13;
        gamememo_container.append(lockScreen);&#13;
        gamememo_container.append(lockScreenInfo);&#13;
        sendSessionEvent('endSession');&#13;
        removeTimers();&#13;
        var TextVoices = window.TTSUtils.getTextVoiceArrayFromElement(lockScreenInfo,presenter.configuration.langTag);&#13;
        presenter.speak(TextVoices);&#13;
        screenLocked = true;&#13;
    };&#13;
&#13;
    presenter.removeLockScreen = function AddonMemo_removeLockScreen() {&#13;
        var gamememo_container = presenter.viewContainer.find('.gamememo_container');&#13;
        gamememo_container.find('.memo-lock-screen').remove();&#13;
        gamememo_container.find('.memo-lock-screen-info').remove();&#13;
        screenLocked = false;&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        var state ={&#13;
            score: presenter.score,&#13;
            errorCount: presenter.errorCount,&#13;
            cards: presenter.serializedCards,&#13;
            isVisible: presenter.configuration.isVisible&#13;
        };&#13;
        if (presenter.timeToSolve &gt; 0) {&#13;
            var spendTime = presenter.spendTime;&#13;
            if (presenter.sessionStarted !== null) {&#13;
                var now = new Date();&#13;
                spendTime += now - presenter.sessionStarted&#13;
            }&#13;
            state['spendTime'] = spendTime;&#13;
        }&#13;
        return JSON.stringify(state);&#13;
    };&#13;
&#13;
    presenter.setState = function(state) {&#13;
        var stateObj = JSON.parse(state);&#13;
&#13;
        if (stateObj.spendTime) {&#13;
            presenter.spendTime = stateObj.spendTime;&#13;
        }&#13;
        presenter.viewContainer.html('&lt;div&gt;&lt;/div&gt;');&#13;
        presenter.score = stateObj.score;&#13;
        presenter.errorCount = stateObj.errorCount;&#13;
        presenter.state = presenter.STATES.READY;&#13;
&#13;
        presenter.prepareGridFromSavedState(stateObj.cards);&#13;
        presenter.createGrid();&#13;
&#13;
        var cell;&#13;
&#13;
        for(var i = 0; i &lt; stateObj.cards.length; i++) {&#13;
            if(stateObj.cards[i].revealed) {&#13;
                cell = $(presenter.viewContainer.find(".cell")[i]);&#13;
&#13;
                cell.children(".front").css('visibility', 'hidden');&#13;
                cell.children(".back").css('visibility', 'visible');&#13;
                cell.addClass("was-clicked");&#13;
            }&#13;
        }&#13;
&#13;
        if (stateObj.isVisible != undefined) {&#13;
            presenter.configuration.isVisible = stateObj.isVisible;&#13;
            presenter.setVisibility(presenter.configuration.isVisible);&#13;
        }&#13;
&#13;
        if (presenter.timeToSolve &amp;&amp; presenter.spendTime &amp;&amp;&#13;
            (presenter.timeToSolve*1000 &lt;= presenter.spendTime)){&#13;
                presenter.setLockScreen();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.concealAllCards = function () {&#13;
        $.each(presenter.serializedCards, function (index, value) {&#13;
            value.revealed = false;&#13;
        });&#13;
    };&#13;
&#13;
&#13;
    presenter.reset = function(){&#13;
        presenter.viewContainer.html('&lt;div&gt;&lt;/div&gt;');&#13;
        presenter.score = 0;&#13;
        presenter.errorCount = 0;&#13;
        presenter.state = presenter.STATES.READY;&#13;
&#13;
        presenter.cardClickedFirst = null;&#13;
        presenter.cardClickedSecond = null;&#13;
        presenter.cardClickedFirstId = null;&#13;
        presenter.cardClickedSecondId = null;&#13;
        presenter.areClickedCardsHiddenInGSAMode = false;&#13;
&#13;
        presenter.isShowErrorsMode = false;&#13;
&#13;
        presenter.prepareGrid();&#13;
        presenter.createGrid();&#13;
        presenter.concealAllCards();&#13;
&#13;
        MathJax.CallBack.Queue().Push(function () {MathJax.Hub.Typeset(presenter.viewContainer.find(".gamememo_container")[0])});&#13;
&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        if (presenter.timeToSolve) {&#13;
            presenter.spendTime = 0;&#13;
            presenter.sessionStarted = null;&#13;
            presenter.removeLockScreen();&#13;
            removeTimers()&#13;
        }&#13;
        if (keyboardController &amp;&amp; keyboardController.keyboardNavigationActive) {&#13;
            keyboardController.resetPosition();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function() {&#13;
        if (!presenter.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var lastErrorCount = presenter.errorCount;&#13;
        presenter.errorCount = 0;&#13;
&#13;
        return lastErrorCount;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function() {&#13;
        return presenter.isActivity ? presenter.maxScore : 0;&#13;
    };&#13;
&#13;
    presenter.getScore = function() {&#13;
        return presenter.isActivity ? presenter.score : 0;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (presenter.configuration.isErrorMode) return;&#13;
&#13;
        var commands = {&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'showAnswers' : presenter.showAnswers,&#13;
            'hideAnswers' : presenter.hideAnswers,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore();&#13;
    };&#13;
&#13;
     presenter.sendAllOKEvent = function () {&#13;
        var eventData = {&#13;
            'source': presenter.ID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.isActivity) {&#13;
            presenter.turnOffUserInteraction();&#13;
&#13;
            markCardsWithCorrectWrongStyle(filterClickedCards(getClickedCards()), true);&#13;
        }&#13;
        presenter.isShowErrorsMode = true;&#13;
    };&#13;
&#13;
    function getClickedCards() {&#13;
        return filterClickedCards(presenter.viewContainer.find('.cell.was-clicked'));&#13;
    }&#13;
&#13;
    function filterClickedCards(clickedCards) {&#13;
        var filteredArray = [];&#13;
        for(var i = 0; i &lt; clickedCards.length; i++) {&#13;
            filteredArray.push(clickedCards[i]);&#13;
        }&#13;
&#13;
        return filteredArray;&#13;
    }&#13;
&#13;
    function filterCardsById (cardsArray, id) {&#13;
        return cardsArray.filter(function (element) {&#13;
                return ($(element).find("[card_id]").attr("card_id") ==  id);&#13;
        });&#13;
    }&#13;
&#13;
    function getStyleAction (isAdding) {&#13;
        if (isAdding) {&#13;
            return function (element, style) {&#13;
                $(element).addClass(style);&#13;
            };&#13;
        }&#13;
&#13;
        return function (element, style) {&#13;
            $(element).removeClass(style);&#13;
        };&#13;
    }&#13;
&#13;
    function markCardsWithCorrectWrongStyle (clickedCards, isAdding) {&#13;
        var styleAction = getStyleAction(isAdding);&#13;
&#13;
&#13;
        function styleWithCorrect(element) {&#13;
            styleAction(element, "cell-correct");&#13;
        }&#13;
&#13;
        function styleWithWrong(element) {&#13;
            styleAction(element, "cell-wrong");&#13;
        }&#13;
&#13;
        var usedIds = [];&#13;
&#13;
        clickedCards.map(function (element) {&#13;
            var id = $(element).find("[card_id]").attr("card_id");&#13;
&#13;
            if (usedIds.indexOf(id) == -1) {&#13;
&#13;
                var cardsById = filterCardsById(clickedCards, id);&#13;
&#13;
                if (cardsById.length == 2) {&#13;
                    cardsById.map(styleWithCorrect);&#13;
                } else {&#13;
                    cardsById.map(styleWithWrong);&#13;
                }&#13;
                usedIds.push(id);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    function getClickablePartOfCards() {&#13;
        return presenter.viewContainer.find(".front.placeholder");&#13;
    }&#13;
&#13;
    function unbindOnCardsCollection (cardsCollection) {&#13;
        for(var i = 0; i &lt; cardsCollection.length; i++) {&#13;
            $(cardsCollection[i]).unbind();&#13;
        }&#13;
    }&#13;
&#13;
    function bindClickInteractionOnCardsCollection (cardsCollection) {&#13;
        for(var i = 0; i &lt; cardsCollection.length; i++) {&#13;
            $(cardsCollection[i]).click(presenter.onCardClicked);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.turnOffUserInteraction = function () {&#13;
        keyboardController.selectEnabled(false);&#13;
        unbindOnCardsCollection(getClickablePartOfCards());&#13;
    };&#13;
&#13;
    presenter.turnOnUserInteraction = function () {&#13;
        keyboardController.selectEnabled(true);&#13;
        bindClickInteractionOnCardsCollection(getClickablePartOfCards());&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.isActivity) {&#13;
            presenter.turnOnUserInteraction();&#13;
            markCardsWithCorrectWrongStyle(getClickedCards(), false);&#13;
        }&#13;
        presenter.isShowErrorsMode = false;&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, data) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "GradualShowAnswers") {&#13;
            if (presenter.configuration.ID == data.moduleID) {&#13;
                presenter.gradualShowAnswers();&#13;
            } else {&#13;
                presenter.activitiesCount = presenter.getActivitiesCount();&#13;
                presenter.isShowAnswersActive = true;&#13;
            }&#13;
        }&#13;
&#13;
        if (eventName == "GradualHideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (!presenter.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
        presenter.isShowErrorsMode = false;&#13;
&#13;
        presenter.showCard(presenter.viewContainer.find('.cell'));&#13;
        presenter.viewContainer.find('.cell').addClass('cell-show-answers');&#13;
        keyboardController.selectEnabled(false);&#13;
    };&#13;
&#13;
    presenter.getIfUnexposedCardInGSAMode = function(currentCard) {&#13;
        if (!currentCard.hasClass('was-clicked') &amp;&amp; !currentCard.hasClass('exposed-in-GSA-mode')) {&#13;
            return currentCard;&#13;
        }&#13;
        return undefined;&#13;
    }&#13;
&#13;
    presenter.showInGSAModeIfCardsMatch = function(firstCard, secondCard) {&#13;
        firstCardId = firstCard.find('.card').attr('card_id');&#13;
        secondCardId = secondCard.find('.card').attr('card_id');&#13;
        if (firstCardId === secondCardId) {&#13;
            presenter.showCard(firstCard);&#13;
            presenter.showCard(secondCard);&#13;
            firstCard.addClass('exposed-in-GSA-mode');&#13;
            secondCard.addClass('exposed-in-GSA-mode');&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.gradualShowAnswers = function () {&#13;
        if (!presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            if (!presenter.isActivity) {&#13;
                return;&#13;
            }&#13;
&#13;
            presenter.hideClickedCardsInGSAMode();&#13;
&#13;
            presenter.isShowAnswersActive = true;&#13;
            presenter.isShowErrorsMode = false;&#13;
&#13;
            var currentCard = presenter.viewContainer.find('.cell').first();&#13;
            const numberOfCards = presenter.viewContainer.find('.cell').length;&#13;
            var firstCard;&#13;
            for (var i = 0; i &lt; numberOfCards; i++) {&#13;
                if (firstCard === undefined) {&#13;
                    firstCard = presenter.getIfUnexposedCardInGSAMode(currentCard);&#13;
                } else {&#13;
                    var matched = presenter.showInGSAModeIfCardsMatch(firstCard, currentCard);&#13;
                    if (matched) {&#13;
                        break;&#13;
                    }&#13;
                }&#13;
                currentCard = currentCard.next();&#13;
            }&#13;
            keyboardController.selectEnabled(false);&#13;
        } else {&#13;
            presenter.showAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (!presenter.isActivity || !presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.showClickedCardsInGSAMode();&#13;
&#13;
        presenter.viewContainer.find('.cell').removeClass('cell-show-answers');&#13;
        presenter.viewContainer.find('.cell').removeClass('exposed-in-GSA-mode');&#13;
        presenter.viewContainer.find('.cell').find('.back').css('visibility', 'hidden');&#13;
        presenter.viewContainer.find('.cell').find('.front').css('visibility', 'visible');&#13;
&#13;
        presenter.viewContainer.find('.was-clicked').find('.front').css('visibility', 'hidden');&#13;
        presenter.viewContainer.find('.was-clicked').find('.back').css('visibility', 'visible');&#13;
&#13;
        presenter.isShowAnswersActive = false;&#13;
        keyboardController.selectEnabled(true);&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        if (presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            return 1;&#13;
        }&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            const numberOfCards = presenter.viewContainer.find('.cell').length;&#13;
            var cardsLeftCounter = 0;&#13;
            var currentCard = presenter.viewContainer.find('.cell').first();&#13;
            for (i = 0; i &lt; numberOfCards; i++) {&#13;
                currentCardIsClicked = ((presenter.cardClickedFirst &amp;&amp; currentCard[0] === presenter.cardClickedFirst[0])&#13;
                                     || (presenter.cardClickedSecond &amp;&amp; currentCard[0] === presenter.cardClickedSecond[0]))&#13;
                if (!currentCard.hasClass('was-clicked') || currentCardIsClicked) {&#13;
                    cardsLeftCounter++;&#13;
                }&#13;
                currentCard = currentCard.next();&#13;
            }&#13;
            presenter.activitiesCount = cardsLeftCounter / 2;&#13;
        }&#13;
        return presenter.activitiesCount;&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.viewContainer.css("visibility", isVisible ? "visible" : "hidden");&#13;
        presenter.viewContainer.css("display", isVisible ? "block" : "none");&#13;
    };&#13;
&#13;
    presenter.keyboardController = function(keycode, isShiftKeyDown, event) {&#13;
        keyboardController.handle(keycode, isShiftKeyDown, event)&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function (playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.speak = function(data) {&#13;
      var tts = presenter.getTextToSpeechOrNull(playerController);&#13;
&#13;
        if (tts &amp;&amp; isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>