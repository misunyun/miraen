<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Shape_Tracing" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="Shape image" nameLabel="Shape_Tracing_property_shape_image" type="image"/>
        <property name="Show Shape image" nameLabel="Shape_Tracing_property_show_shape_image" type="boolean"/>
        <property name="Hide Shape image on check" nameLabel="Shape_Tracing_property_hide_shape_image_on_check" type="boolean"/>
        <property name="Show Boundaries (editor)" nameLabel="Shape_Tracing_property_show_boundaries_editor" type="boolean"/>
        <property name="Background image" nameLabel="Shape_Tracing_property_background_image" type="image"/>
        <property name="Correct number of lines" nameLabel="Shape_Tracing_property_correct_number_of_lines" type="string"/>
        <property name="Points' coordinates" nameLabel="Shape_Tracing_property_points_coordinates" type="text"/>
        <property displayName="Mind points' order" name="isPointsOrder" nameLabel="Shape_Tracing_property_is_points_order" type="boolean"/>
        <property name="Color" nameLabel="Shape_Tracing_property_color" type="string"/>
        <property displayName="Thickness" name="Pen Thickness" nameLabel="Shape_Tracing_property_pen_thickness" type="string"/>
        <property name="Opacity" nameLabel="Shape_Tracing_property_opacity" type="string"/>
        <property name="Border" nameLabel="Shape_Tracing_property_border" type="string"/>
        <property name="Correct Answer Image" nameLabel="Shape_Tracing_property_correct_answer_image" type="image"/>
    </model>
<css>.addon_Shape_Tracing .outer {&#13;
    position: relative;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.addon_Shape_Tracing .outer .drawing,&#13;
.addon_Shape_Tracing .outer .drawing-main,&#13;
.addon_Shape_Tracing .outer .background,&#13;
.addon_Shape_Tracing .outer .shape {&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    -ms-touch-action: none;&#13;
    touch-action: none;&#13;
}&#13;
.addon_Shape_Tracing .outer .correctImage {&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    -ms-touch-action: none;&#13;
    touch-action: none;&#13;
}&#13;
&#13;
.addon_Shape_Tracing .outer .drawing,&#13;
.addon_Shape_Tracing .outer .drawing-main {&#13;
    cursor: crosshair;&#13;
}&#13;
&#13;
.shape-tracing-wrapper.outer {&#13;
    position: relative;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.shape-tracing-wrapper.outer .drawing,&#13;
.shape-tracing-wrapper.outer .drawing-main,&#13;
.shape-tracing-wrapper.outer .background,&#13;
.shape-tracing-wrapper.outer .shape {&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    -ms-touch-action: none;&#13;
    touch-action: none;&#13;
}&#13;
&#13;
.shape-tracing-wrapper.outer .correctImage {&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    -ms-touch-action: none;&#13;
    touch-action: none;&#13;
}&#13;
&#13;
.shape-tracing-wrapper.outer .drawing,&#13;
.shape-tracing-wrapper.outer .drawing-main {&#13;
    cursor: crosshair;&#13;
}&#13;
</css><view>&lt;div class="outer shape-tracing-wrapper"&gt;&#13;
    &lt;div class="shape"&gt;&lt;/div&gt;&#13;
    &lt;div class="background"&gt;&lt;/div&gt;&#13;
    &lt;div class="correctImage"&gt;&lt;/div&gt;&#13;
    &lt;canvas class="drawing-main"&gt;&lt;/canvas&gt;&#13;
    &lt;canvas class="drawing"&gt;&lt;/canvas&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="outer shape-tracing-wrapper"&gt;&#13;
    &lt;div class="shape"&gt;&lt;/div&gt;&#13;
    &lt;div class="background"&gt;&lt;/div&gt;&#13;
    &lt;div class="correctImage"&gt;&lt;/div&gt;&#13;
    &lt;canvas class="drawing-main"&gt;&lt;/canvas&gt;&#13;
    &lt;canvas class="drawing"&gt;&lt;/canvas&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonShape_Tracing_create() {&#13;
&#13;
    var NO_POINT = 0;&#13;
&#13;
    function returnErrorObject(ec) { return { isValid: false, errorCode: ec }; }&#13;
&#13;
    function returnCorrectObject(v) { return { isValid: true, value: v }; }&#13;
&#13;
    function getDistance(p1, p2) {&#13;
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));&#13;
    }&#13;
&#13;
    Array.prototype.last = Array.prototype.last || function() {&#13;
        return this.length === 0 ? null : this[this.length - 1];&#13;
    };&#13;
&#13;
    Array.prototype.removeNeighbourDuplicates = Array.prototype.removeNeighbourDuplicates || function() {&#13;
        var result = [], last = null;&#13;
&#13;
        for (var i=0; i&lt;this.length; i++) {&#13;
            if (this[i] !== last) {&#13;
                result.push(this[i]);&#13;
                last = this[i];&#13;
            }&#13;
        }&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    var presenter = function() {};&#13;
&#13;
    // work-around for double line in android browser&#13;
    function setOverflowWorkAround(turnOn) {&#13;
&#13;
        if (!MobileUtils.isAndroidWebBrowser(window.navigator.userAgent)) { return false; }&#13;
&#13;
        var android_ver = MobileUtils.getAndroidVersion(window.navigator.userAgent);&#13;
        if (["4.1.1", "4.1.2", "4.2.2", "4.3", "4.4.2"].indexOf(android_ver) !== -1) {&#13;
&#13;
            presenter.$view.parents("*").each(function() {&#13;
                var overflow = null;&#13;
                if (turnOn) {&#13;
                    $(this).attr("data-overflow", $(this).css("overflow"));&#13;
                    $(this).css("overflow", "visible");&#13;
                } else {&#13;
                    overflow = $(this).attr("data-overflow");&#13;
                    if (overflow !== "") {&#13;
                        $(this).css("overflow", overflow);&#13;
                    }&#13;
                    $(this).removeAttr("data-overflow");&#13;
                }&#13;
            });&#13;
&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    presenter.data = {&#13;
        divID: "",&#13;
        width: 0,&#13;
        height: 0,&#13;
        zoom: 1,&#13;
&#13;
        startColor: "black",&#13;
        borderPositions: [],&#13;
        activePointsPositions: [],&#13;
        isPencilActive: true,&#13;
        isStarted: false,&#13;
        isAllPointsChecked: false,&#13;
        currentPointNumber: 1,&#13;
        numberOfLines: 0,&#13;
        numberOfDescentsFromShape: 0,&#13;
        isShowErrorOn: false,&#13;
        incorrect: false,&#13;
        isAllOk: false,&#13;
        drawingOpacity: 1,&#13;
&#13;
        pencilThickness: 0,&#13;
&#13;
        shapeImageLoaded: null,&#13;
        shapeImageLoadedDeferred: null&#13;
    };&#13;
&#13;
    var canvasData = {&#13;
        main: { canvas: null, context: null },&#13;
        temp: { canvas: null, context: null }&#13;
    };&#13;
&#13;
    var points = [];&#13;
&#13;
    presenter.cursorPosition = {&#13;
        pre_x: 0,&#13;
        pre_y: 0,&#13;
        x: 0,&#13;
        y: 0&#13;
    };&#13;
&#13;
    var LINE_END_SIGN = 'Up';&#13;
    var DOT_SIGN = 'Dot';&#13;
&#13;
    var eventBus;&#13;
    var isOutsideShape = false;&#13;
    var directionPoints = [];&#13;
&#13;
    presenter.pointsArray = [];&#13;
    presenter.pointsHistory = [];&#13;
&#13;
    // direction from p1 to p2&#13;
    function calculateDrawingDirection(p1, p2) {&#13;
        var deltaY = p1.y - p2.y;&#13;
        var deltaX = p1.x - p2.x;&#13;
        var angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;&#13;
        /*&#13;
            ANGLES:&#13;
            N 90&#13;
            W 0&#13;
            E (180, -180)&#13;
            S (-90)&#13;
         */&#13;
        if (angle &gt;= 112 &amp;&amp; angle &lt; 157) {&#13;
            return 'NE';&#13;
        } else if (angle &gt;= 67 &amp;&amp; angle &lt; 112) {&#13;
            return 'N';&#13;
        } else if (angle &gt;= 22 &amp;&amp; angle &lt; 67) {&#13;
            return 'NW';&#13;
        } else if (angle &gt;= -22 &amp;&amp; angle &lt; 22) {&#13;
            return 'W';&#13;
        } else if (angle &gt;= -67 &amp;&amp; angle &lt; -22) {&#13;
            return 'SW';&#13;
        } else if (angle &gt;= -112 &amp;&amp; angle &lt; -67) {&#13;
            return 'S';&#13;
        } else if (angle &gt;= -157 &amp;&amp; angle &lt; -112) {&#13;
            return 'SE';&#13;
        } else {&#13;
            return 'E';&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    function initPointsArray() {&#13;
        for (var i=0; i&lt;presenter.configuration.points.length; i++) {&#13;
            presenter.pointsArray.push(i + 1);&#13;
        }&#13;
    }&#13;
&#13;
    function initCanvasData() {&#13;
        canvasData.main.canvas = presenter.$view.find('.drawing-main')[0];&#13;
        canvasData.main.context = canvasData.main.canvas.getContext('2d');&#13;
        canvasData.temp.canvas = presenter.$view.find('.drawing')[0];&#13;
        canvasData.temp.context = canvasData.temp.canvas.getContext('2d');&#13;
    }&#13;
&#13;
    function resetCanvas() {&#13;
        turnOffEventListeners();&#13;
        $(canvasData.main.canvas).remove();&#13;
        $(canvasData.temp.canvas).remove();&#13;
&#13;
        var $main = $('&lt;canvas&gt;&lt;/canvas&gt;').addClass('drawing-main');&#13;
        var $temp = $('&lt;canvas&gt;&lt;/canvas&gt;').addClass('drawing');&#13;
&#13;
        presenter.$view.find('.shape-tracing-wrapper').append($main);&#13;
        presenter.$view.find('.shape-tracing-wrapper').append($temp);&#13;
&#13;
        initCanvasData();&#13;
        resizeCanvas(canvasData.main.canvas);&#13;
        resizeCanvas(canvasData.temp.canvas);&#13;
        turnOnEventListeners();&#13;
    }&#13;
&#13;
    function resetAddon(isPencilActive) {&#13;
        turnOffEventListeners();&#13;
        turnOnEventListeners();&#13;
&#13;
        canvasData.temp.context.clearRect(0, 0, presenter.data.width, presenter.data.height);&#13;
        canvasData.main.context.clearRect(0, 0, presenter.data.width, presenter.data.height);&#13;
&#13;
        presenter.data.isAllPointsChecked = presenter.configuration.points.length === 0;&#13;
        presenter.data.isPencilActive = isPencilActive;&#13;
        presenter.data.isStarted = false;&#13;
        presenter.data.currentPointNumber = 1;&#13;
        presenter.data.numberOfLines = 0;&#13;
        presenter.data.numberOfDescentsFromShape = 0;&#13;
        presenter.data.pencilThickness = presenter.configuration.penThickness;&#13;
        presenter.data.incorrect = false;&#13;
        presenter.data.isAllOk = false;&#13;
        directionPoints = [];&#13;
        presenter.pointsHistory = [];&#13;
        isOutsideShape = false;&#13;
        points = [];&#13;
&#13;
        initPointsArray();&#13;
&#13;
        presenter.configuration.color = presenter.data.startColor;&#13;
&#13;
        if (!presenter.configuration.isShowShapeImage &amp;&amp; presenter.configuration.isShowShapeImageOnCheck) {&#13;
            presenter.layer.hide();&#13;
        }&#13;
&#13;
        $(canvasData.temp.canvas).removeClass("correct wrong");&#13;
        presenter.setVisibility(presenter.visibleByDefault);&#13;
        presenter.configuration.isVisible = presenter.visibleByDefault;&#13;
&#13;
        resetCanvas();&#13;
&#13;
        setOverflowWorkAround(true);&#13;
        setOverflowWorkAround(false);&#13;
    }&#13;
&#13;
    function createEventObject(_item, _value, _score) {&#13;
        return {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': '' + _item,&#13;
            'value': '' + _value,&#13;
            'score': '' + _score&#13;
        };&#13;
    }&#13;
&#13;
    function eventCreator() {&#13;
        function sendEventScore(isCorrect) {&#13;
            presenter.data.isAllOk = isCorrect;&#13;
            eventBus.sendEvent('ValueChanged', createEventObject('allOk', '', isCorrect ? '1' : '0'));&#13;
        }&#13;
&#13;
        function sendEventValue(isCorrect) {&#13;
            presenter.data.isAllOk = isCorrect;&#13;
            eventBus.sendEvent('ValueChanged', createEventObject('', isCorrect ? '1' : '0', ''));&#13;
        }&#13;
&#13;
        var pointsLength = presenter.configuration.points.length;&#13;
        var correctNumOfLines = presenter.configuration.numberOfLines;&#13;
        var descentsFromShape = presenter.data.numberOfDescentsFromShape;&#13;
        var isAllPointsChecked = presenter.data.isAllPointsChecked;&#13;
&#13;
        function isCorrectNumberOfLines() {&#13;
            var numOfDrawLines = presenter.data.numberOfLines;&#13;
            return numOfDrawLines &gt;= correctNumOfLines[0] &amp;&amp; correctNumOfLines[1] &lt;= numOfDrawLines;&#13;
        }&#13;
&#13;
        if (pointsLength === 0 &amp;&amp; correctNumOfLines.length === 0) {&#13;
            if (descentsFromShape === 0) {&#13;
                sendEventScore(true);&#13;
            } else {&#13;
                sendEventValue(false);&#13;
            }&#13;
        } else if (pointsLength !== 0 &amp;&amp; correctNumOfLines.length === 0) {&#13;
            if (descentsFromShape === 0 &amp;&amp; isAllPointsChecked) {&#13;
                sendEventScore(true);&#13;
            } else {&#13;
                sendEventValue(false);&#13;
            }&#13;
        } else if (pointsLength === 0 &amp;&amp; correctNumOfLines.length !== 0) {&#13;
            if (isCorrectNumberOfLines() &amp;&amp; descentsFromShape === 0) {&#13;
                sendEventScore(true);&#13;
            } else {&#13;
                sendEventValue(false);&#13;
            }&#13;
        } else {&#13;
            if (isAllPointsChecked &amp;&amp; !isCorrectNumberOfLines()) {&#13;
                // to remember that user was on all points in incorrect number of lines&#13;
                presenter.data.incorrect = true;&#13;
            }&#13;
&#13;
            if (isCorrectNumberOfLines() &amp;&amp; isAllPointsChecked &amp;&amp; descentsFromShape === 0 &amp;&amp; !presenter.data.incorrect) {&#13;
                sendEventScore(true);&#13;
            } else {&#13;
                sendEventValue(false);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.initActivePointsPositions = function() {&#13;
        // init 2D array filled with zeros&#13;
        for (var col=0; col&lt;presenter.data.height; col++) {&#13;
            var row = [];&#13;
            for (var ro=0; ro&lt;presenter.data.width; ro++) {&#13;
                row.push(0);&#13;
            }&#13;
            presenter.data.activePointsPositions.push(row);&#13;
        }&#13;
&#13;
        // mark o=points on array&#13;
        for (var pointNumber=0; pointNumber&lt;presenter.configuration.points.length; pointNumber++) {&#13;
            var x = presenter.configuration.points[pointNumber][0];&#13;
            var y = presenter.configuration.points[pointNumber][1];&#13;
            var r = presenter.configuration.points[pointNumber][2];&#13;
&#13;
            for (var i=y-r; i&lt;=y+r; i++) {&#13;
                for (var j=x-r; j&lt;=x+r; j++) {&#13;
                    if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; presenter.data.width &amp;&amp; i &lt; presenter.data.height) {&#13;
                        if (r * r &gt;= (x-j) * (x-j) + (y-i) * (y-i)) {&#13;
                            presenter.data.activePointsPositions[i][j] = pointNumber + 1;&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    function calculateBorderCoordinates() {&#13;
        function isBoundaryColor(r, g, b, a) {&#13;
            return (r &lt; 250 &amp;&amp; g &lt; 250 &amp;&amp; b &lt; 250) &amp;&amp; a === 255;&#13;
//            return (r !== 255 || g !== 255 || b !== 255) &amp;&amp; a === 255;&#13;
        }&#13;
&#13;
        //var ctx = presenter.layer.getContext('2d');&#13;
        var ctx = presenter.layer.getCanvas().getContext();&#13;
        var pt = ctx.getImageData(0, 0, presenter.data.width, presenter.data.height);&#13;
        var data = pt.data;&#13;
        var row;&#13;
&#13;
        for (var y=0; y&lt;presenter.data.height; y++) {&#13;
            row = [];&#13;
            for (var x=0; x&lt;presenter.data.width; x++) {&#13;
                var index = 4 * ((presenter.data.width * y) + x);&#13;
                row.push(isBoundaryColor(data[index+0], data[index+1], data[index+2], data[index+3]));&#13;
            }&#13;
            presenter.data.borderPositions.push(row);&#13;
        }&#13;
    }&#13;
&#13;
    function showFoundBoundaryPoints() {&#13;
        var ctx = presenter.layerBG.getContext('2d');&#13;
        var imgData = ctx.getImageData(0, 0, presenter.data.width, presenter.data.height);&#13;
&#13;
        for (var i=0; i&lt;presenter.data.height; i++) {&#13;
            for (var j=0; j&lt;presenter.data.width; j++) {&#13;
                if (presenter.data.borderPositions[i][j]) {&#13;
                    var index = 4 * (i * presenter.data.width + j);&#13;
                    imgData.data[index + 0] = 255;&#13;
                    imgData.data[index + 1] = 0;&#13;
                    imgData.data[index + 2] = 0;&#13;
                    imgData.data[index + 3] = 255;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        ctx.putImageData(imgData, 0, 0, presenter.data.width, presenter.data.height);&#13;
    }&#13;
&#13;
    function colorNameToHex(color) {&#13;
        var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff","beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887","cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff","darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f","darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1","darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff","firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff","gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f","honeydew":"#f0fff0","hotpink":"#ff69b4","indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c","lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2","lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de","lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6","magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee","mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5","navajowhite":"#ffdead","navy":"#000080","oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6","palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080","red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1","saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4","tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0","violet":"#ee82ee","wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5","yellow":"#ffff00","yellowgreen":"#9acd32"};&#13;
        var parsedColor = Array.isArray(color) ? color[0] : color;&#13;
&#13;
        if (typeof colors[parsedColor.toLowerCase()] !== 'undefined') {&#13;
            return colors[parsedColor.toLowerCase()];&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    function drawActivePoints() {&#13;
        for (var i=0; i&lt;presenter.configuration.points.length; i++) {&#13;
            var point = new Kinetic.Circle({&#13;
                x: presenter.configuration.points[i][0],&#13;
                y: presenter.configuration.points[i][1],&#13;
                radius: presenter.configuration.points[i][2],&#13;
                fill: 'rgba(0,255,0,0.25)',&#13;
                stroke: 'green',&#13;
                strokeWidth: 2&#13;
            });&#13;
            presenter.layerBG.add(point);&#13;
        }&#13;
&#13;
        presenter.stageBG.add(presenter.layerBG);&#13;
    }&#13;
&#13;
    function drawBoxMouseData(box_width, box_height) {&#13;
        var position = -4;&#13;
        presenter.box = new Kinetic.Rect({&#13;
            x: position, y: position,&#13;
            stroke: '#555',&#13;
            fill: '#ddd',&#13;
            width: box_width,&#13;
            height: box_height,&#13;
            cornerRadius: 7,&#13;
            opacity: 0.6&#13;
        });&#13;
        presenter.text = new Kinetic.Text({&#13;
            x: position, y: position,&#13;
            text: prepearText(0, 0),&#13;
            fontSize: 15,&#13;
            fontFamily: 'Calibri',&#13;
            fill: '#555',&#13;
            width: box_width,&#13;
            padding: 4,&#13;
            align: 'center'&#13;
        });&#13;
&#13;
        presenter.layerBG.add(presenter.box);&#13;
        presenter.layerBG.add(presenter.text);&#13;
        presenter.stageBG.add(presenter.layerBG);&#13;
    }&#13;
&#13;
    function prepearText(x, y) {&#13;
        function addZerosToNumber(n) {&#13;
            switch (n.toString().length) {&#13;
                case 1: return "000" + n;&#13;
                case 2: return "00" + n;&#13;
                case 3: return "0" + n;&#13;
                default: return "" + n;&#13;
            }&#13;
        }&#13;
&#13;
        return "X:" + addZerosToNumber(x) + "\nY:" + addZerosToNumber(y);&#13;
    }&#13;
&#13;
    function cursorCoordinates() {&#13;
        drawBoxMouseData(52, 37);&#13;
&#13;
        presenter.data.shapeImageLoaded.then(function() {&#13;
            var moduleSelector = $('.moduleSelector[data-id="'+presenter.configuration.ID+'"]');&#13;
            moduleSelector.on('mousemove', function(e) {&#13;
                var x = e.offsetX, y = e.offsetY;&#13;
&#13;
                presenter.text.setText(prepearText(x, y));&#13;
                presenter.layerBG.draw();&#13;
            });&#13;
        });&#13;
&#13;
        presenter.$view.find(".drawing").on('mousemove', function(e) {&#13;
            e.stopPropagation();&#13;
&#13;
            var x = e.offsetX, y = e.offsetY;&#13;
&#13;
            presenter.text.setText(prepearText(x, y));&#13;
            presenter.layerBG.draw();&#13;
        });&#13;
    }&#13;
&#13;
    function drawBackGroundImage(isPreview) {&#13;
        presenter.stageBG = new Kinetic.Stage({&#13;
            container: presenter.data.divID + "_background",&#13;
            height: presenter.data.height,&#13;
            width: presenter.data.width&#13;
        });&#13;
&#13;
        presenter.layerBG = new Kinetic.Layer();&#13;
        if (presenter.configuration.backgroundImage !== '') {&#13;
            var backgroundImage = new Image();&#13;
            backgroundImage.onload = function() {&#13;
                var BGimg = new Kinetic.Image({&#13;
                    x: 0,&#13;
                    y: 0,&#13;
                    height: presenter.data.height,&#13;
                    width: presenter.data.width,&#13;
                    image: backgroundImage&#13;
                });&#13;
&#13;
                presenter.layerBG.add(BGimg);&#13;
                presenter.stageBG.add(presenter.layerBG);&#13;
&#13;
                if (isPreview) {&#13;
                    cursorCoordinates();&#13;
                    drawActivePoints();&#13;
                }&#13;
            };&#13;
&#13;
            backgroundImage.src = presenter.configuration.backgroundImage;&#13;
        } else {&#13;
            if (isPreview) {&#13;
                cursorCoordinates();&#13;
                drawActivePoints();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function drawShapeImage(isPreview) {&#13;
        presenter.stage = new Kinetic.Stage({&#13;
            container: presenter.data.divID + "_shape",&#13;
            height: presenter.data.height,&#13;
            width: presenter.data.width&#13;
        });&#13;
        presenter.layer = new Kinetic.Layer();&#13;
        var image = new Image();&#13;
        image.onload = function() {&#13;
            var img = new Kinetic.Image({&#13;
                x: 0,&#13;
                y: 0,&#13;
                image: image,&#13;
                height: presenter.data.height,&#13;
                width: presenter.data.width&#13;
            });&#13;
&#13;
            presenter.layer.add(img);&#13;
            presenter.stage.add(presenter.layer);&#13;
&#13;
            calculateBorderCoordinates();&#13;
&#13;
            if (!presenter.configuration.isShowShapeImage) {&#13;
                presenter.layer.hide();&#13;
            }&#13;
&#13;
            if (isPreview) {&#13;
                if (presenter.configuration.isShowFoundBoundaries) {&#13;
                    showFoundBoundaryPoints();&#13;
                }&#13;
            }&#13;
            presenter.data.shapeImageLoadedDeferred.resolve();&#13;
        };&#13;
&#13;
        image.src = presenter.configuration.shapeImage;&#13;
    }&#13;
&#13;
    function checkGCS(url) {&#13;
        if (url === undefined) {&#13;
            return url;&#13;
        }&#13;
        if(url.indexOf("/file/serve/") == 0){&#13;
            return url + "?no_gcs=true";&#13;
        }&#13;
&#13;
        return url;&#13;
    }&#13;
&#13;
    function drawCorrectAnswerImage(isPreview) {&#13;
        presenter.stageCorrect = new Kinetic.Stage({&#13;
            container: presenter.data.divID + "_correctImage",&#13;
            height: presenter.data.height,&#13;
            width: presenter.data.width&#13;
        });&#13;
        presenter.correctAnswerlayer = new Kinetic.Layer();&#13;
        var correctImage = new Image();&#13;
        correctImage.onload = function() {&#13;
            var correctImg = new Kinetic.Image({&#13;
                x: 0, y: 0,&#13;
                image: correctImage,&#13;
                height: presenter.data.height,&#13;
                width: presenter.data.width&#13;
            });&#13;
&#13;
            presenter.correctAnswerlayer.add(correctImg);&#13;
            presenter.stageCorrect.add(presenter.correctAnswerlayer);&#13;
&#13;
            calculateBorderCoordinates();&#13;
        };&#13;
&#13;
        correctImage.src = presenter.configuration.correctAnswerImage;&#13;
    }&#13;
&#13;
    function updateCursorPosition(e) {&#13;
        presenter.cursorPosition.pre_x = presenter.cursorPosition.x;&#13;
        presenter.cursorPosition.pre_y = presenter.cursorPosition.y;&#13;
&#13;
        var canvas = canvasData.temp.canvas;&#13;
        var rect = canvas.getBoundingClientRect();&#13;
&#13;
        if (e.clientX === undefined) {&#13;
            presenter.cursorPosition.x = parseInt((event.targetTouches[0].pageX - $(canvas).offset().left) / presenter.data.zoom, 10);&#13;
            presenter.cursorPosition.y = parseInt((event.targetTouches[0].pageY - $(canvas).offset().top) / presenter.data.zoom, 10);&#13;
        } else {&#13;
            presenter.cursorPosition.x = parseInt((e.clientX - rect.left) / presenter.data.zoom, 10);&#13;
            presenter.cursorPosition.y = parseInt((e.clientY - rect.top) / presenter.data.zoom, 10);&#13;
        }&#13;
&#13;
        directionPoints.push({ x: presenter.cursorPosition.x, y: presenter.cursorPosition.y });&#13;
    }&#13;
&#13;
    function upDateCheckPointsHistory(x, y) {&#13;
        var point = presenter.data.activePointsPositions[y][x];&#13;
        var lastPointInArray = presenter.pointsHistory.last();&#13;
&#13;
        if (point !== lastPointInArray) {&#13;
            presenter.pointsHistory.push(point);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.isShapeCoveredInCircle = function(x, y, r) {&#13;
        r = parseInt(r, 10);&#13;
        var increase = r &lt; 4 ? r : 4;&#13;
&#13;
        for (var i=y-r; i&lt;=y+r; i += increase) {&#13;
            for (var j=x-r; j&lt;=x+r; j += increase) {&#13;
                if (i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; j &lt; presenter.data.width &amp;&amp; i &lt; presenter.data.height) {&#13;
                    if (r * r &gt;= (x-j) * (x-j) + (y-i) * (y-i)) {&#13;
                        if (!presenter.data.borderPositions[i][j]) return false;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.isThisActivePointAndCheck = function(x, y) {&#13;
        // check if point is in array&#13;
        var result = presenter.pointsArray.indexOf(presenter.data.activePointsPositions[x][y]) !== -1;&#13;
&#13;
        // remove point from array&#13;
        presenter.pointsArray = presenter.pointsArray.filter(function(n) { return n !== presenter.data.activePointsPositions[x][y] });&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.isPositionInDefinedPoint = function(x, y, r) {&#13;
        r = parseInt(r, 10);&#13;
&#13;
        for (var i=y-r; i&lt;=y+r; i += 3) {&#13;
            for (var j=x-r; j&lt;=x+r; j += 3) {&#13;
                if (i &gt; 0 &amp;&amp; j &gt; 0 &amp;&amp; j &lt; presenter.data.width &amp;&amp; i &lt; presenter.data.height) {&#13;
                    if (r * r &lt;= (x-j) * (x-j) + (y-i) * (y-i)) {&#13;
                        upDateCheckPointsHistory(x, y);&#13;
&#13;
                        // if points' order does matter&#13;
                        if (presenter.configuration.isCheckPointsOrder) {&#13;
                            if (presenter.data.activePointsPositions[i][j] === presenter.data.currentPointNumber) {&#13;
                                return true;&#13;
                            }&#13;
                        // if not then find any point&#13;
                        } else {&#13;
                            if (presenter.isThisActivePointAndCheck(i, j)) {&#13;
                                return true;&#13;
                            }&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    function checkCorrectness() {&#13;
        const x = parseInt(presenter.cursorPosition.x, 10);&#13;
        const y = parseInt(presenter.cursorPosition.y, 10);&#13;
        const point = scalePoint({x: x, y: y});&#13;
        if (presenter.isShapeCoveredInCircle(point.x, point.y, presenter.data.pencilThickness / 2)) {&#13;
            isOutsideShape = false;&#13;
        } else {&#13;
            if (!isOutsideShape) {&#13;
                presenter.data.numberOfDescentsFromShape++;&#13;
                isOutsideShape = true;&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.isPositionInDefinedPoint(point.x, point.y, presenter.data.pencilThickness / 2)) {&#13;
            presenter.data.currentPointNumber++;&#13;
            if (presenter.data.currentPointNumber &gt; presenter.configuration.points.length) {&#13;
                presenter.data.isAllPointsChecked = true;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function scalePoint({x, y}) {&#13;
        const scaledPoint = {x: x, y: y};&#13;
        if (!presenter.playerController) {&#13;
            return scaledPoint;&#13;
        }&#13;
&#13;
        const scale = presenter.playerController.getScaleInformation();&#13;
        if (scale.scaleX !== 1.0 || scale.scaleY !== 1.0) {&#13;
            scaledPoint.x = Math.floor(scaledPoint.x / scale.scaleX);&#13;
            scaledPoint.y = Math.floor(scaledPoint.y / scale.scaleY);&#13;
        }&#13;
        return scaledPoint;&#13;
    }&#13;
&#13;
    function draw(e, notPropagate) {&#13;
        if (notPropagate) {&#13;
            e.stopPropagation();&#13;
            e.preventDefault();&#13;
        }&#13;
&#13;
        updateCursorPosition(e);&#13;
&#13;
        var ctx = canvasData.temp.context;&#13;
        var can = canvasData.temp.canvas;&#13;
&#13;
        ctx.globalAlpha = presenter.data.drawingOpacity;&#13;
        ctx.lineWidth = presenter.data.pencilThickness;&#13;
        ctx.lineJoin = 'round';&#13;
        ctx.lineCap = 'round';&#13;
        ctx.strokeStyle = presenter.configuration.color;&#13;
        ctx.fillStyle = presenter.configuration.color;&#13;
&#13;
&#13;
        var point = {x: presenter.cursorPosition.x, y: presenter.cursorPosition.y};&#13;
        var scale = presenter.playerController.getScaleInformation();&#13;
        if (scale.scaleX !== 1.0 || scale.scaleY !== 1.0) {&#13;
            point.x = point.x / scale.scaleX;&#13;
            point.y = point.y / scale.scaleY;&#13;
        }&#13;
        points.push(point);&#13;
&#13;
        if (points.length &lt; 3) {&#13;
            ctx.beginPath();&#13;
            ctx.arc(points[0].x, points[0].y, presenter.data.pencilThickness / 2, 0, Math.PI * 2, !0);&#13;
            ctx.fill();&#13;
            ctx.closePath();&#13;
        } else {&#13;
            ctx.clearRect(0, 0, can.width, can.height);&#13;
&#13;
            ctx.beginPath();&#13;
            ctx.moveTo(points[0].x, points[0].y);&#13;
&#13;
            for (var i=1; i&lt;points.length-2; i++) {&#13;
                var x = (points[i].x + points[i + 1].x) / 2;&#13;
                var y = (points[i].y + points[i + 1].y) / 2;&#13;
&#13;
                ctx.quadraticCurveTo(points[i].x, points[i].y, x, y);&#13;
            }&#13;
&#13;
            ctx.quadraticCurveTo(&#13;
                points[i].x, points[i].y,&#13;
                points[i + 1].x, points[i + 1].y&#13;
            );&#13;
            ctx.stroke();&#13;
        }&#13;
&#13;
        if (presenter.data.isPencilActive) {&#13;
            // active only on drawing, disable when eraser&#13;
            checkCorrectness();&#13;
        }&#13;
    }&#13;
&#13;
    function turnOnEventListeners() {&#13;
        var $canvas = $(canvasData.temp.canvas);&#13;
&#13;
        $canvas.on('click', function(e) {&#13;
            e.stopPropagation();&#13;
        });&#13;
&#13;
        // TOUCH&#13;
        if (MobileUtils.isEventSupported('touchstart')) {&#13;
            connectTouchEvents($canvas);&#13;
        }&#13;
&#13;
        // MOUSE&#13;
        connectMouseEvents($canvas);&#13;
    }&#13;
&#13;
    function connectTouchEvents($canvas) {&#13;
        var isWorkaroundOn = false;&#13;
&#13;
        $canvas.on('touchstart', function(e) {&#13;
            presenter.data.numberOfLines++;&#13;
&#13;
            if (presenter.data.isPencilActive) {&#13;
                presenter.data.isStarted = true;&#13;
                setOverflowWorkAround(true);&#13;
                draw(e, false);&#13;
            } else {&#13;
                resetAddon(false);&#13;
            }&#13;
        });&#13;
&#13;
        $canvas.on('touchmove', function(e) {&#13;
            if (presenter.data.isPencilActive) {&#13;
                presenter.data.isStarted = true;&#13;
                if (!isWorkaroundOn) {&#13;
                    setOverflowWorkAround(true);&#13;
                }&#13;
                drawWithoutPropagation(e);&#13;
            } else {&#13;
                resetAddon(false);&#13;
            }&#13;
&#13;
        });&#13;
&#13;
        $canvas.on('touchend', function() {&#13;
            if (presenter.data.isPencilActive) {&#13;
                eventCreator();&#13;
            }&#13;
&#13;
            canvasData.main.context.drawImage(canvasData.temp.canvas, 0, 0);&#13;
            canvasData.temp.context.clearRect(0, 0, canvasData.temp.canvas.width, canvasData.temp.canvas.height);&#13;
&#13;
            points = [];&#13;
            directionPoints.push('Up');&#13;
&#13;
            setOverflowWorkAround(false);&#13;
            isWorkaroundOn = false;&#13;
        });&#13;
    }&#13;
    &#13;
    function drawWithoutPropagation (e) {&#13;
        draw(e, true);&#13;
    }&#13;
&#13;
    function connectMouseEvents($canvas) {&#13;
        var isDown = false;&#13;
&#13;
        $canvas.on('mousedown', function(e) {&#13;
            isDown = true;&#13;
            draw(e, false);&#13;
            $canvas.on('mousemove', drawWithoutPropagation);&#13;
&#13;
            if (presenter.data.isPencilActive) {&#13;
                presenter.data.isStarted = true;&#13;
                presenter.data.numberOfLines++;&#13;
            } else {&#13;
                resetAddon(false);&#13;
            }&#13;
        });&#13;
&#13;
        $canvas.on('mouseup mouseleave', function() {&#13;
            $canvas.off('mousemove', drawWithoutPropagation);&#13;
            if (isDown &amp;&amp; presenter.data.isPencilActive) {&#13;
                eventCreator();&#13;
                isDown = false;&#13;
            }&#13;
&#13;
            canvasData.main.context.drawImage(canvasData.temp.canvas, 0, 0);&#13;
            canvasData.temp.context.clearRect(0, 0, canvasData.temp.canvas.width, canvasData.temp.canvas.height);&#13;
&#13;
            points = [];&#13;
        });&#13;
&#13;
        $canvas.on('mouseup', function() {&#13;
            directionPoints.push('Up');&#13;
        });&#13;
    }&#13;
&#13;
    function turnOffEventListeners() {&#13;
        var $canvas = $(canvasData.temp.canvas);&#13;
        $canvas.off("touchstart touchend touchmove");&#13;
        $canvas.off("mousedown mouseup mouseleave mousemove");&#13;
    }&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        SI01: "Property Shape image cannot be empty",&#13;
&#13;
        P02: "Wrong amount of numbers in every line in Points' coordinates property",&#13;
        P03: "Points' coordinates are out of canvas range",&#13;
        P04: "Non numeric value in points' coordinates property",&#13;
&#13;
        C01: "Wrong value in property: Color",&#13;
&#13;
        T02: "Property Thickness cannot be less then 1 and more then 40",&#13;
&#13;
        O01: "Property Opacity has to be between 0 and 1",&#13;
&#13;
        B01: "Property Border hat to be between 0 and 5"&#13;
    };&#13;
&#13;
    function parseImage(img) {&#13;
        if (ModelValidationUtils.isStringWithPrefixEmpty(img, "/file/")) {&#13;
            return returnErrorObject("SI01");&#13;
        }&#13;
&#13;
        return returnCorrectObject(img);&#13;
    }&#13;
&#13;
    function parseBGImage(BGImage) {&#13;
        return returnCorrectObject(BGImage);&#13;
    }&#13;
&#13;
    function parseNumberOfLines(lines) {&#13;
        if (ModelValidationUtils.isStringEmpty(lines)) {&#13;
            return returnCorrectObject([]);&#13;
        }&#13;
&#13;
        lines = lines.split(';').map(function (num) { return parseInt(num, 10); });&#13;
        lines = lines.length === 1 ? lines.concat(lines) : lines;&#13;
&#13;
        return returnCorrectObject(lines);&#13;
    }&#13;
&#13;
    function parsePoints(points) {&#13;
        if (ModelValidationUtils.isStringEmpty(points)) {&#13;
            return returnCorrectObject([]);&#13;
        }&#13;
&#13;
        // e.g. "1;1;1\n2;2;2\n3;3;3" =&gt; [[1,1,1], [2,2,2], [3,3,3]]&#13;
        points = Helpers.splitLines(points).map(function(line) { return line.split(';').map(function(num){ return parseInt(num, 10) }) });&#13;
&#13;
        for (var i=0, len=points.length; i&lt;len; i++) {&#13;
            if (points[i].length !== 3) {&#13;
                return returnErrorObject("P02");&#13;
            }&#13;
&#13;
            if (points[i][0] &lt; 0 || points[i][1] &lt; 0 || points[i][0] &gt; presenter.data.width || points[i][1] &gt; presenter.data.height) {&#13;
                return returnErrorObject("P03");&#13;
            }&#13;
        }&#13;
&#13;
        return returnCorrectObject(points);&#13;
    }&#13;
&#13;
    function parseColor(color) {&#13;
        color = color.trim();&#13;
        if (ModelValidationUtils.isStringEmpty(color)) {&#13;
            return returnCorrectObject('#000000');&#13;
        }&#13;
&#13;
        if (color[0] === '#' &amp;&amp; !(color.length === 7 || color.length === 4)) {&#13;
            return returnErrorObject("C01");&#13;
        }&#13;
&#13;
        if (color[0] !== '#') {&#13;
            color = colorNameToHex(color);&#13;
            if (!color) return returnErrorObject("C01");&#13;
        }&#13;
&#13;
        return returnCorrectObject(color);&#13;
    }&#13;
&#13;
    function parseThickness(thickness) {&#13;
        if (ModelValidationUtils.isStringEmpty(thickness)) {&#13;
            return returnCorrectObject(10);&#13;
        }&#13;
&#13;
        thickness = parseInt(thickness, 10);&#13;
&#13;
        if (1 &gt; thickness || thickness &gt; 40) {&#13;
            return returnErrorObject("T02");&#13;
        }&#13;
&#13;
        return returnCorrectObject(thickness);&#13;
    }&#13;
&#13;
    function parseOpacity(opacity) {&#13;
        opacity = opacity || 1;&#13;
        opacity = parseFloat(opacity);&#13;
&#13;
        if (0 &gt; opacity || opacity &gt; 1) {&#13;
            return returnErrorObject("O01");&#13;
        }&#13;
&#13;
        return returnCorrectObject(opacity);&#13;
    }&#13;
&#13;
    function parseBorder(border) {&#13;
        border = border || 0;&#13;
        border = parseInt(border, 10);&#13;
&#13;
        if (0 &gt; border || border &gt; 5) {&#13;
            return returnErrorObject("B01");&#13;
        }&#13;
&#13;
        return returnCorrectObject(border);&#13;
    }&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var validatedShapeImage = parseImage(model["Shape image"]);&#13;
        if (!validatedShapeImage.isValid) {&#13;
            return returnErrorObject(validatedShapeImage.errorCode);&#13;
        }&#13;
&#13;
        var validatedBGImage = parseBGImage(model["Background image"]);&#13;
        if (!validatedBGImage.isValid) {&#13;
            return returnErrorObject(validatedBGImage.errorCode);&#13;
        }&#13;
&#13;
        var validatedCorrectNumberOfLines = parseNumberOfLines(model["Correct number of lines"]);&#13;
        if (!validatedCorrectNumberOfLines.isValid) {&#13;
            return returnErrorObject(validatedCorrectNumberOfLines.errorCode);&#13;
        }&#13;
&#13;
        var validatedPoints = parsePoints(model["Points' coordinates"]);&#13;
        if (!validatedPoints.isValid) {&#13;
            return returnErrorObject(validatedPoints.errorCode);&#13;
        }&#13;
&#13;
        var validatedColor = parseColor(model["Color"]);&#13;
        if (!validatedColor.isValid) {&#13;
            return returnErrorObject(validatedColor.errorCode);&#13;
        }&#13;
&#13;
        presenter.data.startColor = validatedColor.value;&#13;
&#13;
        var validatedThickness_Pen = parseThickness(model["Pen Thickness"]);&#13;
        if (!validatedThickness_Pen.isValid) {&#13;
            return returnErrorObject(validatedThickness_Pen.errorCode);&#13;
        }&#13;
&#13;
        var validatedOpacity = parseOpacity(model["Opacity"]);&#13;
        if (!validatedOpacity.isValid) {&#13;
            return returnErrorObject(validatedOpacity.errorCode);&#13;
        }&#13;
&#13;
        var validatedBorder = parseBorder(model["Border"]);&#13;
        if (!validatedBorder.isValid) {&#13;
            return returnErrorObject(validatedBorder.errorCode);&#13;
        }&#13;
&#13;
        return {&#13;
            shapeImage: checkGCS(validatedShapeImage.value),&#13;
            isShowShapeImage: ModelValidationUtils.validateBoolean(model["Show Shape image"]),&#13;
            isShowShapeImageOnCheck: !ModelValidationUtils.validateBoolean(model["Hide Shape image on check"]),&#13;
            isShowFoundBoundaries: ModelValidationUtils.validateBoolean(model["Show Boundaries (editor)"]),&#13;
            backgroundImage: checkGCS(validatedBGImage.value),&#13;
            numberOfLines: validatedCorrectNumberOfLines.value,&#13;
            points: validatedPoints.value,&#13;
            isCheckPointsOrder: ModelValidationUtils.validateBoolean(model["isPointsOrder"]),&#13;
            color: validatedColor.value,&#13;
            penThickness: validatedThickness_Pen.value,&#13;
            opacity: validatedOpacity.value,&#13;
            border: validatedBorder.value,&#13;
            correctAnswerImage: checkGCS(model["Correct Answer Image"]),&#13;
            numberOfPoints: validatedPoints.value.length,&#13;
&#13;
            ID: model.ID,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            isValid: true&#13;
        }&#13;
    };&#13;
&#13;
    function resizeCanvas(elem) {&#13;
        var container = $(elem).parent();&#13;
&#13;
        elem.width = container.width();&#13;
        elem.height = container.height();&#13;
    }&#13;
&#13;
    presenter.presenterLogic = function(view, model, isPreview) {&#13;
        presenter.data.shapeImageLoadedDeferred = new $.Deferred();&#13;
        presenter.data.shapeImageLoaded = presenter.data.shapeImageLoadedDeferred.promise();&#13;
&#13;
        presenter.$view = $(view);&#13;
&#13;
        Kinetic.pixelRatio = 1;&#13;
        var zoom = $('#_icplayer').css('zoom');&#13;
        presenter.data.zoom = zoom == "" || zoom == undefined || isNaN(zoom) ? 1 : zoom;&#13;
        presenter.data.width = parseInt(model["Width"], 10);&#13;
        presenter.data.height = parseInt(model["Height"], 10);&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return false;&#13;
        }&#13;
&#13;
        presenter.initializeCanvas(isPreview);&#13;
&#13;
        if (!isPreview) {&#13;
            turnOnEventListeners();&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
        presenter.visibleByDefault = presenter.configuration.isVisible;&#13;
&#13;
        presenter.$view.find('div.correctImage').css('display', 'none');&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.initializeCanvas = function(isPreview) {&#13;
        initPointsArray();&#13;
&#13;
        presenter.data.isAllPointsChecked = presenter.configuration.points.length === 0;&#13;
        presenter.data.pencilThickness = presenter.configuration.penThickness;&#13;
&#13;
        presenter.initActivePointsPositions();&#13;
&#13;
        if (presenter.configuration.border !== 0) {&#13;
            presenter.$view.css('border', presenter.configuration.border + 'px solid black');&#13;
        }&#13;
&#13;
        presenter.data.divID = presenter.configuration.ID + (isPreview ? "_preview" : "_run");&#13;
&#13;
        presenter.$view.find("div.background").attr('id', presenter.data.divID + "_background");&#13;
        presenter.$view.find("div.shape").attr('id', presenter.data.divID + "_shape");&#13;
        presenter.$view.find("div.correctImage").attr('id', presenter.data.divID + "_correctImage");&#13;
&#13;
        presenter.$view.css('opacity', presenter.configuration.opacity);&#13;
&#13;
        initCanvasData();&#13;
&#13;
        resizeCanvas(canvasData.main.canvas);&#13;
        resizeCanvas(canvasData.temp.canvas);&#13;
&#13;
        drawBackGroundImage(isPreview);&#13;
        drawShapeImage(isPreview);&#13;
&#13;
        presenter.data.shapeImageLoaded.then(function() {&#13;
            if (presenter.configuration.correctAnswerImage &amp;&amp; !isPreview) {&#13;
                drawCorrectAnswerImage(isPreview);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
&#13;
        eventBus.addEventListener('ShowAnswers', this);&#13;
        eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
        eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    presenter.setThickness = function(thickness) {&#13;
        presenter.data.pencilThickness = parseThickness(thickness).value;&#13;
    };&#13;
&#13;
    presenter.setColor = function(color) {&#13;
        presenter.data.isPencilActive = true;&#13;
        presenter.configuration.color = parseColor(color).value;&#13;
    };&#13;
&#13;
    presenter.setEraserOn = function() {&#13;
        presenter.data.isPencilActive = false;&#13;
    };&#13;
&#13;
    presenter.setEraserOff = function() {&#13;
        presenter.data.isPencilActive = true;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.setOpacity = function(opacity) {&#13;
        presenter.data.drawingOpacity = parseOpacity(opacity[0]).value;&#13;
    };&#13;
&#13;
    presenter.descentsFromShape = function() {&#13;
        return presenter.data.numberOfDescentsFromShape;&#13;
    };&#13;
&#13;
    presenter.numberOfLines = function() {&#13;
        return presenter.data.numberOfLines;&#13;
    };&#13;
&#13;
    presenter.pointsMissed = function() {&#13;
        var points = presenter.pointsHistory.filter(function(p) { return p !== NO_POINT });&#13;
        var result = [];&#13;
&#13;
        for (var i=1; i&lt;presenter.configuration.numberOfPoints+1; i++) {&#13;
            if (points.indexOf(i) === -1) {&#13;
                result.push(i);&#13;
            }&#13;
        }&#13;
&#13;
        return result.length;&#13;
    };&#13;
&#13;
    function parseLinesToDots(points, distance) {&#13;
        function getLineFromIndex(points, index) {&#13;
            var result = [];&#13;
&#13;
            for (var i=index; i&lt;points.length; i++) {&#13;
                if (points[i] === LINE_END_SIGN) {&#13;
                    return result;&#13;
                } else {&#13;
                    result.push(points[i]);&#13;
                }&#13;
            }&#13;
&#13;
            return result;&#13;
        }&#13;
&#13;
        var result = [], i = 0;&#13;
&#13;
        while (i &lt; points.length) {&#13;
            var line = getLineFromIndex(points, i);&#13;
&#13;
            if (line.length === 1 || getDistance(line[0], line.last()) &lt; distance) {&#13;
                result.push(DOT_SIGN);&#13;
            } else {&#13;
                result = result.concat(line);&#13;
            }&#13;
&#13;
            result.push(LINE_END_SIGN);&#13;
&#13;
            i += line.length + 1;&#13;
        }&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    presenter.getDirections = function() {&#13;
        function hasUndefinedValue() {&#13;
            for (var i=0; i&lt;arguments.length; i++) {&#13;
                if (arguments[i] === undefined) {&#13;
                    return true;&#13;
                }&#13;
            }&#13;
&#13;
            return false;&#13;
        }&#13;
&#13;
        if (directionPoints.length === 0) {&#13;
            return [];&#13;
        }&#13;
&#13;
        var MIN_DISTANCE = 8;&#13;
        directionPoints = parseLinesToDots(directionPoints.removeNeighbourDuplicates(), MIN_DISTANCE);&#13;
&#13;
        var result = [], i = 0,&#13;
            p1 = directionPoints[0],&#13;
            p2 = directionPoints[1];&#13;
&#13;
        while (i &lt; directionPoints.length-1) {&#13;
            while (p1 === LINE_END_SIGN || p1 === DOT_SIGN) {&#13;
                result.push(p1);&#13;
                i++;&#13;
                p1 = directionPoints[i];&#13;
                p2 = directionPoints[i + 1];&#13;
            }&#13;
&#13;
            if (hasUndefinedValue(p1, p2)) {&#13;
                break;&#13;
            }&#13;
&#13;
            if (getDistance(p1, p2) &gt; MIN_DISTANCE) {&#13;
                result.push(calculateDrawingDirection(p1, p2));&#13;
                p1 = directionPoints[i + 1];&#13;
            }&#13;
&#13;
            p2 = directionPoints[i + 2];&#13;
&#13;
            while (p2 === LINE_END_SIGN || p2 === DOT_SIGN) {&#13;
                result.push(p2);&#13;
                i++;&#13;
                p1 = directionPoints[i];&#13;
                p2 = directionPoints[i + 1];&#13;
            }&#13;
&#13;
            i++;&#13;
        }&#13;
&#13;
        return result.removeNeighbourDuplicates();&#13;
    };&#13;
&#13;
    function getDrawnUniqueValues() {&#13;
        var uniqueValues = [];&#13;
        var points = presenter.pointsHistory.filter(function(p) { return p !== NO_POINT });&#13;
&#13;
        for (var i = 0; i &lt; points.length; i++) {&#13;
            if (uniqueValues.indexOf(points[i]) === -1) {&#13;
                uniqueValues.push(points[i]);&#13;
            }&#13;
        }&#13;
&#13;
        return uniqueValues;&#13;
    }&#13;
&#13;
    presenter.isOrderCorrect = function(skipPoints) {&#13;
        skipPoints = skipPoints === 'true' || skipPoints === true;&#13;
&#13;
        var i, previous = -1;&#13;
        var drawnPoints = getDrawnUniqueValues();&#13;
        if (skipPoints) {&#13;
            for (i = 0; i &lt; drawnPoints.length; i++) {&#13;
                if (previous &gt; drawnPoints[i]) {&#13;
                    return false;&#13;
                }&#13;
                previous = drawnPoints[i];&#13;
            }&#13;
        } else {&#13;
            for (i = 0; i &lt; drawnPoints.length; i++) {&#13;
                if (drawnPoints[i] !== i + 1) {&#13;
                    return false;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.isOrderCorrectCommand = function(params) {&#13;
        return presenter.isOrderCorrect(params[0]);&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            "reset": presenter.reset,&#13;
            "show": presenter.show,&#13;
            "hide": presenter.hide,&#13;
            "setEraserOn": presenter.setEraserOn,&#13;
            "setEraserOff": presenter.setEraserOff,&#13;
            "setThickness": presenter.setThickness,&#13;
            "showAnswers": presenter.showAnswers,&#13;
            "hideAnswers": presenter.hideAnswers,&#13;
            "setColor": presenter.setColor,&#13;
            "setOpacity": presenter.setOpacity,&#13;
            "isOrderCorrect": presenter.isOrderCorrectCommand&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    function countScore() {&#13;
        var correctLinesNum = presenter.configuration.numberOfLines;&#13;
        var linesNum = presenter.data.numberOfLines;&#13;
        var numOfDesc = presenter.data.numberOfDescentsFromShape;&#13;
&#13;
        if (correctLinesNum.length === 0) {&#13;
            if (numOfDesc === 0 &amp;&amp; presenter.data.isAllPointsChecked) {&#13;
                return 1;&#13;
            } else {&#13;
                return 0;&#13;
            }&#13;
        } else {&#13;
            if (correctLinesNum[0] &lt;= linesNum &amp;&amp; linesNum &lt;= correctLinesNum[1] &amp;&amp; numOfDesc === 0 &amp;&amp; presenter.data.isAllPointsChecked) {&#13;
                return 1;&#13;
            } else {&#13;
                return 0;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        turnOffEventListeners();&#13;
&#13;
        if (presenter.data.isStarted) {&#13;
            $(canvasData.temp.canvas).addClass(countScore() === 1 ? "correct" : "wrong");&#13;
            if (!presenter.configuration.isShowShapeImage &amp;&amp; presenter.configuration.isShowShapeImageOnCheck) {&#13;
                presenter.layer.show();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        turnOffEventListeners();&#13;
        turnOnEventListeners();&#13;
&#13;
        if (!presenter.configuration.isShowShapeImage) {&#13;
            presenter.layer.hide();&#13;
        }&#13;
&#13;
        $(canvasData.temp.canvas).removeClass("correct wrong");&#13;
    };&#13;
&#13;
    presenter.reset = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        resetAddon(true);&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function() {&#13;
        if (!presenter.data.isStarted) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return countScore() === 0 ? 1 : 0;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function() {&#13;
        return 1;&#13;
    };&#13;
&#13;
    presenter.getScore = function() {&#13;
        if (!presenter.data.isStarted) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return countScore();&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        return JSON.stringify({&#13;
            imgData: canvasData.main.canvas.toDataURL("image/png"),&#13;
            isPencilActive: presenter.data.isPencilActive,&#13;
            color: presenter.configuration.color,&#13;
            currentPointNumber: presenter.data.currentPointNumber,&#13;
            numberOfLines: presenter.data.numberOfLines,&#13;
            numberOfDescentsFromShape: presenter.data.numberOfDescentsFromShape,&#13;
            isAllPointsChecked: presenter.data.isAllPointsChecked,&#13;
            isAllOk: presenter.data.isAllOk,&#13;
            pointsArray: presenter.pointsArray,&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            directionPoints: directionPoints&#13;
        });&#13;
    };&#13;
&#13;
    presenter.upgradeStateForVisibility = function(state) {&#13;
        if (state.isVisible === undefined) {&#13;
            state.isVisible = true;&#13;
        }&#13;
&#13;
        return state;&#13;
    };&#13;
&#13;
    presenter.upgradeStateForOpacity = function(state) {&#13;
        if (state.opacity === undefined) {&#13;
            state.opacity = 0.9;&#13;
        }&#13;
&#13;
        return state;&#13;
    };&#13;
&#13;
    presenter.upgradeStateForDirectionPoints = function(state) {&#13;
        if (state.directionPoints === undefined) {&#13;
            state.directionPoints = [];&#13;
        }&#13;
&#13;
        return state;&#13;
    };&#13;
&#13;
    presenter.upgradeState = function (parsedState) {&#13;
        parsedState = presenter.upgradeStateForVisibility(parsedState);&#13;
        parsedState = presenter.upgradeStateForOpacity(parsedState);&#13;
        parsedState = presenter.upgradeStateForDirectionPoints(parsedState);&#13;
&#13;
        return parsedState;&#13;
    };&#13;
&#13;
    presenter.setState = function(state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsedState = presenter.upgradeState(JSON.parse(state));&#13;
&#13;
        presenter.data.isStarted = true; // state is non empty =&gt; exercise is started&#13;
        presenter.data.currentPointNumber = parsedState.currentPointNumber;&#13;
        presenter.data.numberOfLines = parsedState.numberOfLines;&#13;
        presenter.data.numberOfDescentsFromShape = parsedState.numberOfDescentsFromShape;&#13;
        presenter.data.isAllPointsChecked = parsedState.isAllPointsChecked;&#13;
        presenter.data.isAllOk = parsedState.isAllOk || false;&#13;
        presenter.pointsArray = parsedState.pointsArray;&#13;
        presenter.configuration.isVisible = parsedState.isVisible;&#13;
        directionPoints = parsedState.directionPoints;&#13;
&#13;
        var savedImg = new Image();&#13;
        savedImg.onload = function() {&#13;
            canvasData.main.context.drawImage(savedImg, 0, 0);&#13;
&#13;
            presenter.configuration.color = JSON.parse(state).color;&#13;
            if (!JSON.parse(state).isPencilActive) {&#13;
                presenter.setEraserOn();&#13;
            }&#13;
&#13;
            setOverflowWorkAround(true);&#13;
            setOverflowWorkAround(false);&#13;
        };&#13;
&#13;
        savedImg.src = checkGCS(JSON.parse(state).imgData);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.isAllOk = function() {&#13;
        return presenter.data.isAllOk;&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function() {&#13;
        presenter.isShowAnswersActive = true;&#13;
        presenter.setWorkMode();&#13;
        turnOffEventListeners();&#13;
&#13;
        if (presenter.configuration.correctAnswerImage) {&#13;
            presenter.layer.hide();&#13;
            presenter.$view.find('.correctImage').css('display', 'block');&#13;
        } else {&#13;
            presenter.layer.show();&#13;
        }&#13;
&#13;
        presenter.$view.find('.background').addClass('shape-tracing-show-answers');&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function() {&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.$view.find('.background').removeClass('shape-tracing-show-answers');&#13;
&#13;
        if (presenter.correctAnswerlayer) {&#13;
            presenter.$view.find('.correctImage').css('display', 'none');&#13;
        }&#13;
        if (presenter.configuration.isShowShapeImage) {&#13;
            presenter.layer.show();&#13;
        } else {&#13;
            presenter.layer.hide();&#13;
        }&#13;
        turnOffEventListeners();&#13;
        turnOnEventListeners();&#13;
        presenter.isShowAnswersActive = false;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>