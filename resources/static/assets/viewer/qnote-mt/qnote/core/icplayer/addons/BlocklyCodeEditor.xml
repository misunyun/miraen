<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="BlocklyCodeEditor" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="sceneID" nameLabel="BlocklyCodeEditor_property_scene_id" type="string"/>
		<property displayName="Toolbox" name="toolbox" nameLabel="BlocklyCodeEditor_property_toolbox" type="list">
			<property name="blockName" nameLabel="BlocklyCodeEditor_property_block_name" type="editableselect">
				<property name="colour_rgb" nameLabel="Blockly_translation_RGB_color" type="text"/>
				<property name="text_append" nameLabel="Blockly_translation_append_text" type="text"/>
				<property name="math_arithmetic" nameLabel="Blockly_translation_arithmetic" type="text"/>
				<property name="math_single" nameLabel="Blockly_translation_basic_functions" type="text"/>
				<property name="colour_blend" nameLabel="Blockly_translation_blend_color" type="text"/>
				<property name="logic_boolean" nameLabel="Blockly_translation_boolean" type="text"/>
				<property name="controls_flow_statements" nameLabel="Blockly_translation_break" type="text"/>
				<property name="math_change" nameLabel="Blockly_translation_change_variable" type="text"/>
				<property name="text_charAt" nameLabel="Blockly_translation_char_at" type="text"/>
				<property name="colour_picker" nameLabel="Blockly_translation_color_picker" type="text"/>
				<property name="logic_compare" nameLabel="Blockly_translation_compare" type="text"/>
				<property name="math_constant" nameLabel="Blockly_translation_constants" type="text"/>
				<property name="math_constrain" nameLabel="Blockly_translation_constrain" type="text"/>
				<property name="lists_split" nameLabel="Blockly_translation_create_list_from" type="text"/>
				<property name="lists_repeat" nameLabel="Blockly_translation_create_list_with_item" type="text"/>
				<property name="lists_create_with" nameLabel="Blockly_translation_create_list" type="text"/>
				<property name="controls_forEach" nameLabel="Blockly_translation_for_each" type="text"/>
				<property name="controls_for" nameLabel="Blockly_translation_for" type="text"/>
				<property name="lists_getIndex" nameLabel="Blockly_translation_get_list_element" type="text"/>
				<property name="lists_getSublist" nameLabel="Blockly_translation_get_sublist" type="text"/>
				<property name="variables_get" nameLabel="Blockly_translation_get_variable" type="text"/>
				<property name="controls_if" nameLabel="Blockly_translation_if" type="text"/>
				<property name="lists_isEmpty" nameLabel="Blockly_translation_is_empty_list" type="text"/>
				<property name="text_isEmpty" nameLabel="Blockly_translation_is_empty_text" type="text"/>
				<property name="text_join" nameLabel="Blockly_translation_join_text" type="text"/>
				<property name="lists_indexOf" nameLabel="Blockly_translation_list_index_of" type="text"/>
				<property name="lists_length" nameLabel="Blockly_translation_list_length" type="text"/>
				<property name="logic_operation" nameLabel="Blockly_translation_logic_operation" type="text"/>
				<property name="logic_ternary" nameLabel="Blockly_translation_logic_ternary" type="text"/>
				<property name="math_on_list" nameLabel="Blockly_translation_math_list_functions" type="text"/>
				<property name="math_modulo" nameLabel="Blockly_translation_modulo" type="text"/>
				<property name="logic_negate" nameLabel="Blockly_translation_negate" type="text"/>
				<property name="logic_null" nameLabel="Blockly_translation_null" type="text"/>
				<property name="math_number_property" nameLabel="Blockly_translation_number_property" type="text"/>
				<property name="math_number" nameLabel="Blockly_translation_number" type="text"/>
				<property name="text_print" nameLabel="Blockly_translation_print" type="text"/>
				<property name="text_prompt_ext" nameLabel="Blockly_translation_prompt_for" type="text"/>
				<property name="colour_random" nameLabel="Blockly_translation_random_color" type="text"/>
				<property name="math_random_float" nameLabel="Blockly_translation_random_fraction" type="text"/>
				<property name="math_random_int" nameLabel="Blockly_translation_random_integer" type="text"/>
				<property name="controls_whileUntil" nameLabel="Blockly_translation_repeat_while/until" type="text"/>
				<property name="controls_repeat_ext" nameLabel="Blockly_translation_repeat" type="text"/>
				<property name="math_round" nameLabel="Blockly_translation_round" type="text"/>
				<property name="lists_setIndex" nameLabel="Blockly_translation_set_list_element" type="text"/>
				<property name="variables_set" nameLabel="Blockly_translation_set_variable" type="text"/>
				<property name="lists_sort" nameLabel="Blockly_translation_sort_list" type="text"/>
				<property name="text_getSubstring" nameLabel="Blockly_translation_substring" type="text"/>
				<property name="text_indexOf" nameLabel="Blockly_translation_text_index_of" type="text"/>
				<property name="text_length" nameLabel="Blockly_translation_text_length" type="text"/>
				<property name="text" nameLabel="Blockly_translation_text" type="text"/>
				<property name="text_changeCase" nameLabel="Blockly_translation_to_upper/lower_case" type="text"/>
				<property name="math_trig" nameLabel="Blockly_translation_trigonometry" type="text"/>
				<property name="text_trim" nameLabel="Blockly_translation_trim" type="text"/>
				<property name="variables_editor" nameLabel="Blockly_translation_variables_editor" type="text"/>
				<property name="grid_scene_commands" nameLabel="Blockly_translation_scene_commands" type="text"/>
				<property name="custom" nameLabel="Blockly_translation_custom" type="string"/>
			</property>
			<property displayName="Category" name="blockCategory" nameLabel="BlocklyCodeEditor_property_block_category" type="string"/>
			<property displayName="Is Disabled" name="blockIsDisabled" nameLabel="BlocklyCodeEditor_property_block_is_disabled" type="boolean"/>
		</property>
		<property displayName="Custom Blocks" name="customBlocks" nameLabel="BlocklyCodeEditor_property_custom_blocks" type="list">
			<property displayName="Name" name="customBlockName" nameLabel="BlocklyCodeEditor_property_custom_block_name" type="string"/>
			<property displayName="Title" name="customBlockTitle" nameLabel="BlocklyCodeEditor_property_custom_block_title" type="string"/>
			<property displayName="Color" name="customBlockColor" nameLabel="BlocklyCodeEditor_property_custom_block_color" type="string"/>
			<property displayName="Inputs" name="customBlockInputs" nameLabel="BlocklyCodeEditor_property_custom_block_inputs" type="string"/>
			<property displayName="Inputs Type" name="customBlockInputsType" nameLabel="BlocklyCodeEditor_property_custom_block_inputs_type" type="string"/>
			<property displayName="Inputs Text" name="customBlockInputsText" nameLabel="BlocklyCodeEditor_property_custom_block_inputs_text" type="string"/>			<property displayName="Code" name="customBlockCode" nameLabel="BlocklyCodeEditor_property_custom_block_code" type="text"/>
			<property displayName="Connection" name="customBlockOutput" nameLabel="BlocklyCodeEditor_property_custom_block_output" type="{None,Left,Top,Bottom,Top-Bottom}"/>
			<property displayName="Connection Type" name="customBlockOutputType" nameLabel="BlocklyCodeEditor_property_custom_block_output_type" type="string"/>
		</property>
		<property displayName="Block limit" name="maxBlocksLimit" nameLabel="BlocklyCodeEditor_property_max_block_limit" type="string"/>
		<property displayName="Hide Run" name="hideRun" nameLabel="BlocklyCodeEditor_property_hide_run" type="boolean"/>
		<property name="blocksTranslation" nameLabel="BlocklyCodeEditor_property_blocksTranslation" type="text"/>
		<property name="initialConfiguration" nameLabel="BlocklyCodeEditor_property_initial_configuration" type="text"/>
	</model>
<css>.blocklyEditor-wrapper button {&#13;
    margin-top: 10px;&#13;
}&#13;
&#13;
.blockly-cover {&#13;
    top : 0;&#13;
    position : absolute;&#13;
    width : 100%;&#13;
    height : 100%;&#13;
    background-color: gray;&#13;
    opacity: .5;&#13;
}&#13;
</css><view>&lt;div class="blocklyEditor-wrapper"&gt;&#13;
    &lt;div class="blockly-code-editor-editor"&gt;&lt;/div&gt;&#13;
    &lt;button class="blockly-code-editor-run"&gt;Run&lt;/button&gt;&#13;
&lt;/div&gt;&#13;
&#13;
</view><preview>&lt;div class="blocklyEditor-wrapper"&gt;&#13;
    &lt;div class="blockly-code-editor-editor"&gt;&lt;/div&gt;&#13;
    &lt;button class="blockly-code-editor-run"&gt;Run&lt;/button&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>/**&#13;
 * KNOWN ISSUES:&#13;
 *      Toolbox Menu&#13;
 *          - when header is on page, the toolbox is moved by header height and there is need to change it top property,&#13;
 *          issue due to blockly library have lack of setting toolbox under parent HTML element, instead it places on page&#13;
 *&#13;
 *          - updatingToolbox do not update toolbox menu element ".blocklyFlyout", after updating toolbox there is need to update&#13;
 *          transform translate to width of ".blocklyToolboxDiv"&#13;
 */&#13;
function AddonBlocklyCodeEditor_create () {&#13;
    var presenter = function () {};&#13;
&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        "SI01": "Scene id must have value",&#13;
        "SI02": "You must add scene id if you want to add scene toolbox",&#13;
        "CN01": "Color must be integer positive value in range 0..360",&#13;
        "CE01": "Addon can't have blocks with category and without category in the same time",&#13;
        "DN01": "Custom block name must be unique",&#13;
        "IE01": "Undefined input or connection type",&#13;
        "OE01": "Undefined connection type",&#13;
        "DE01": "Duplicated elements in toolbox",&#13;
        "BL01": "Block limit must be  0 or positive integer number",&#13;
        "BL02": "Block limit is float number but should be integer value.",&#13;
        "VN01": "Input name must be a valid JS variable name",&#13;
        "UB01": "Undefined block in toolbox",&#13;
        "TP01": "Translation in Toolbox is not a valid JSON.",&#13;
        "TP02": "Translation is not a valid JSON",&#13;
        "VE01": "Variable editor must have category name"&#13;
    };&#13;
&#13;
    presenter.inputsType = {&#13;
        "ANY" : "Any",&#13;
        "BOOLEAN" : "Boolean",&#13;
        "NUMBER" : "Number",&#13;
        "STRING" : "String",&#13;
        "ARRAY" : "Array"&#13;
    };&#13;
    presenter.connections = {&#13;
        "NONE" : function Blockly_NONE_Connection_function () {return ""; },&#13;
        "LEFT" : function Blockly_LEFT_Connection_function (type) {return "this.setOutput(true,'" + type + "');"; },&#13;
        "TOP" :  function Blockly_TOP_Connection_function (type) {return "this.setPreviousStatement(true,'" + type + "');";},&#13;
        "BOTTOM" : function Blockly_BOTTOM_Connection_function (type) {return "this.setNextStatement(true,'" + type + "');";},&#13;
        "TOP-BOTTOM" : function Blockly_TOP_BOTTOM_Connection_function (firstType, secondType) { return presenter.connections["TOP"](firstType) + presenter.connections["BOTTOM"](secondType); }&#13;
    };&#13;
&#13;
    presenter.DEFAULT_BLOCKS_TRANSLATION_LABELS = [&#13;
         "controls_if",&#13;
         "logic_compare",&#13;
         "logic_operation",&#13;
         "logic_negate",&#13;
         "logic_boolean",&#13;
         "logic_null",&#13;
         "logic_ternary",&#13;
         "controls_repeat_ext",&#13;
         "controls_whileUntil",&#13;
         "controls_for",&#13;
         "controls_forEach",&#13;
         "controls_flow_statements",&#13;
         "math_number",&#13;
         "math_arithmetic",&#13;
         "math_single",&#13;
         "math_trig",&#13;
         "math_constant",&#13;
         "math_number_property",&#13;
         "math_round",&#13;
         "math_on_list",&#13;
         "math_modulo",&#13;
         "math_constrain",&#13;
         "math_random_int",&#13;
         "math_random_float",&#13;
         "text",&#13;
         "text_join",&#13;
         "text_append",&#13;
         "text_length",&#13;
         "text_isEmpty",&#13;
         "text_indexOf",&#13;
         "text_charAt",&#13;
         "text_getSubstring",&#13;
         "text_changeCase",&#13;
         "text_trim",&#13;
         "text_print",&#13;
         "text_prompt_ext",&#13;
         "lists_create_with",&#13;
         "lists_repeat",&#13;
         "lists_length",&#13;
         "lists_getIndex",&#13;
         "lists_isEmpty",&#13;
         "lists_indexOf",&#13;
         "lists_setIndex",&#13;
         "lists_getSublist",&#13;
         "lists_split",&#13;
         "lists_sort",&#13;
         "colour_picker",&#13;
         "colour_random",&#13;
         "colour_rgb",&#13;
         "colour_blend",&#13;
         "math_change",&#13;
         "variables_set",&#13;
         "variables_get",&#13;
         "variables_editor"&#13;
    ];&#13;
&#13;
    presenter.javaScriptBlocksCode = [];&#13;
    presenter.blockDefinitions = [];&#13;
&#13;
    presenter.configuration = {&#13;
        hideRun: null,&#13;
        sceneID: null,&#13;
        sceneModule: null,&#13;
        workspace: null,&#13;
        toolboxXML: "",&#13;
        addSceneToolbox: false,&#13;
        sceneToolboxName: "",&#13;
        sceneToolboxIsCategory: false,&#13;
        isPreview: false,&#13;
        isValid: false,&#13;
        haveSceneID: true,&#13;
        isVisible: true,&#13;
        visibleByDefault: true,&#13;
        pageLoaded: false,&#13;
        blocksTranslation: {}&#13;
    };&#13;
&#13;
    function isPreviewDecorator(func) {&#13;
        if (!presenter.configuration.isPreview) {&#13;
            return func;&#13;
        } else {&#13;
            return function Blockly_empty_preview_decorator_function () {};&#13;
        }&#13;
    }&#13;
&#13;
    presenter.run = function Blockly_run_function (view, model) {&#13;
        presenter.runLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function Blockly_createPreview_function (view, model) {&#13;
        presenter.runLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function Blockly_setPlayerController_function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = presenter.playerController.getEventBus();&#13;
        presenter.eventBus.addEventListener('PageLoaded', this, true);&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.runLogic = function Blockly_runLogic_function (view, model, isPreview) {&#13;
        presenter.configuration.isPreview = isPreview;&#13;
        presenter.configuration = $.extend(presenter.configuration, presenter.validateModel(model));&#13;
&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
&#13;
        presenter.setRunButton();&#13;
        presenter.setEditorCss();&#13;
        presenter.addUserBlocks();&#13;
        presenter.createWorkspace(view, isPreview);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.visibleByDefault || isPreview);&#13;
&#13;
        isPreviewDecorator(presenter.connectHandlers)();&#13;
&#13;
        isPreviewDecorator(presenter.updateToolbox)();&#13;
&#13;
        isPreviewDecorator(presenter.setConfiguration)(presenter.configuration.initialConfiguration);&#13;
&#13;
        presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved_Blockly (ev) {&#13;
            if (ev.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
&#13;
        if (isPreview) {&#13;
            presenter.$view.css('z-index','0');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setConfiguration = function(configuration) {&#13;
        if(configuration) {&#13;
            var xml = Blockly.Xml.textToDom(configuration);&#13;
            Blockly.Xml.domToWorkspace(xml, presenter.configuration.workspace);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getConfiguration = function() {&#13;
        var xml = Blockly.Xml.workspaceToDom(presenter.configuration.workspace);&#13;
        return Blockly.Xml.domToText(xml);&#13;
    };&#13;
&#13;
    presenter.createWorkspace = function (view, isPreview) {&#13;
        var editor = $(view).find(".blockly-code-editor-editor")[0];&#13;
        var toolboxXML = "";&#13;
        if (isPreview) {&#13;
            toolboxXML = presenter.getPreviewToolbox();&#13;
        } else {&#13;
            toolboxXML = presenter.getToolboxXML();&#13;
        }&#13;
&#13;
        presenter.configuration.workspace = Blockly.inject(editor, {&#13;
            toolbox: toolboxXML,&#13;
            sounds: false,&#13;
            maxBlocks: presenter.configuration.maxBlocks&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setEditorCss = function () {&#13;
        presenter.$view.find(".blockly-code-editor-editor").css({&#13;
            width: presenter.$view.width(),&#13;
            height: presenter.$view.height()&#13;
        });&#13;
    };&#13;
&#13;
    presenter.addUserBlocks = function () {&#13;
        eval(presenter.configuration.customBlocksXML.code);&#13;
        eval(presenter.configuration.customBlocksXML.blockDefinitions);&#13;
    };&#13;
&#13;
    presenter.addBlocksTranslations = function Blockly_addGoogleBlocksTranslations_function () {&#13;
        for (var key in presenter.configuration.blocksTranslation) {&#13;
            if (presenter.configuration.blocksTranslation.hasOwnProperty(key)) {&#13;
                Blockly.Msg[StringUtils.format('{0}', key)] = presenter.configuration.blocksTranslation[key];&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.destroy = function Blockly_destroy_function () {&#13;
        var key, i;&#13;
        if (presenter.configuration.isPreview) {&#13;
            $("#content").off("scroll", presenter.scrollFixHandler);&#13;
        }&#13;
&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        presenter.configuration.workspace.dispose();&#13;
&#13;
        presenter.configuration.workspace = null;&#13;
&#13;
        presenter.$view.find(".blockly-code-editor-run").off();&#13;
        presenter.$view = null;&#13;
        presenter.view = null;&#13;
        presenter.configuration = null;&#13;
&#13;
        for (i = 0; i &lt; presenter.javaScriptBlocksCode.length; i++) {&#13;
            delete Blockly.JavaScript[presenter.javaScriptBlocksCode[i]];&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; presenter.blockDefinitions.length; i++) {&#13;
            delete Blockly.Blocks[presenter.blockDefinitions[i]];&#13;
        }&#13;
&#13;
        presenter.javaScriptBlocksCode = null;&#13;
        presenter.blockDefinitions = null;&#13;
&#13;
        for (key in presenter.connections) {&#13;
            if (presenter.connections.hasOwnProperty(key)) {&#13;
                presenter.connections[key] = null;&#13;
            }&#13;
        }&#13;
&#13;
        presenter.connections = null;&#13;
        presenter.removePresenterFunctions();&#13;
    };&#13;
&#13;
    presenter.removePresenterFunctions = function Blockly_removePresenterFunctions_function() {&#13;
        presenter.removePresenterFunctions = null;&#13;
        presenter.destroy = null;&#13;
        presenter.ERROR_CODES = null;&#13;
        presenter.inputsType = null;&#13;
        presenter.connections = null;&#13;
        presenter.DEFAULT_BLOCKS_TRANSLATION_LABELS = null;&#13;
        presenter.run = null;&#13;
        presenter.scrollToolboxPreviewFix = null;&#13;
        presenter.scrollFixHandler = null;&#13;
        presenter.createPreview = null;&#13;
        presenter.setPlayerController = null;&#13;
        presenter.runLogic = null;&#13;
        presenter.addGoogleBlocksTranslations = null;&#13;
        presenter.validateModel = null;&#13;
        presenter.validateBlockLimit = null;&#13;
        presenter.validateBlocksTranslation = null;&#13;
        presenter.validateToolboxNamesWithCustomBlocks = null;&#13;
        presenter.validateSceneId = null;&#13;
        presenter.validateToolbox = null;&#13;
        presenter.validateTranslations = null;&#13;
        presenter.validateInputsType = null;&#13;
        presenter.validateConnection = null;&#13;
        presenter.validateBlock = null;&#13;
        presenter.convertCustomBlockToJS = null;&#13;
        presenter.convertCustomBlocksToJS = null;&#13;
        presenter.validateCustomBlocks = null;&#13;
        presenter.connectHandlers = null;&#13;
        presenter.setRunButton = null;&#13;
        presenter.executeCommand = null;&#13;
        presenter.hide = null;&#13;
        presenter.show = null;&#13;
        presenter.setVisibility = null;&#13;
        presenter.getWorkspaceCode = null;&#13;
        presenter.getToolboxXML = null;&#13;
        presenter.onEventReceived = null;&#13;
        presenter.addCustomBlocks = null;&#13;
        presenter.getSceneModuleOnPageLoaded = null;&#13;
        presenter.updateToolbox = null;&#13;
        presenter.getState = null;&#13;
        presenter.setState= null;&#13;
        presenter.setState = null;&#13;
        presenter.setShowErrorsMode = null;&#13;
        presenter.setWorkMode = null;&#13;
        presenter.showAnswers = null;&#13;
        presenter.hideAnswers = null;&#13;
        presenter.coverAddon = null;&#13;
        presenter.removeAddonCover = null;&#13;
        presenter.coverToolbox = null;&#13;
        presenter.removeToolboxCover = null;&#13;
    };&#13;
&#13;
    presenter.validateIfToolboxHaveOnlyCategoryOrNot = function (validatedToolbox) {&#13;
        var isCategory = false;&#13;
        var isWithoutCategory = false;&#13;
        for (var key in validatedToolbox.value.categories) {&#13;
            if (validatedToolbox.value.categories.hasOwnProperty(key)) {&#13;
                var blocks = validatedToolbox.value.categories[key];&#13;
                for (var i = 0; i &lt; blocks.length; i++) {&#13;
                    if (blocks[i].isCategory) {&#13;
                        isCategory = true;&#13;
                    } else {&#13;
                        isWithoutCategory = true;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            if (isCategory &amp;&amp; isWithoutCategory) {&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.configuration.addSceneToolbox) {&#13;
            if (presenter.configuration.sceneToolboxIsCategory) {&#13;
                isCategory = true;&#13;
            } else {&#13;
                isWithoutCategory = true;&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isError: isCategory === isWithoutCategory,&#13;
            errorCode: "CE01"&#13;
        };&#13;
    };&#13;
    presenter.validateModel = function Blockly_validateModel_function(model) {&#13;
        var haveSceneID = true;&#13;
        var validatedIsVisible = ModelValidationUtils.validateBoolean(model['Is Visible']);&#13;
&#13;
        var validatedToolbox = presenter.validateToolbox(model['toolbox']);&#13;
        if (!validatedToolbox.isValid) {&#13;
            return validatedToolbox;&#13;
        }&#13;
&#13;
        var validatedSceneId = presenter.validateSceneId(model["sceneID"]);&#13;
        if (!validatedSceneId.isValid) {&#13;
            haveSceneID = false;&#13;
        }&#13;
&#13;
        var validatedCustomBlocks = presenter.validateCustomBlocks(model["customBlocks"]);&#13;
        if (!validatedCustomBlocks.isValid) {&#13;
            return validatedCustomBlocks;&#13;
        }&#13;
&#13;
        var validatedBlockLimit = presenter.validateBlockLimit(model['maxBlocksLimit']);&#13;
        if (!validatedBlockLimit.isValid) {&#13;
            return validatedBlockLimit;&#13;
        }&#13;
&#13;
        var validatedToolboxNamesWithCustomBlocks = presenter.validateToolboxNamesWithCustomBlocks(validatedToolbox.value.categories, validatedCustomBlocks);&#13;
        if (!validatedToolboxNamesWithCustomBlocks.isValid) {&#13;
            return validatedToolboxNamesWithCustomBlocks;&#13;
        }&#13;
&#13;
        var validatedBlocksTranslations = presenter.validateBlocksTranslation(model['blocksTranslation']);&#13;
        if (!validatedBlocksTranslations.isValid) {&#13;
            return validatedBlocksTranslations;&#13;
        }&#13;
&#13;
        var validatedMixedCategories = presenter.validateIfToolboxHaveOnlyCategoryOrNot(validatedToolbox);&#13;
        if (validatedMixedCategories.isError) {&#13;
            return validatedMixedCategories;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            visibleByDefault: validatedIsVisible,&#13;
            haveSceneID: haveSceneID,&#13;
            hideRun: ModelValidationUtils.validateBoolean(model["hideRun"]),&#13;
            sceneID: validatedSceneId.value,&#13;
            toolboxXML: validatedToolbox.value.categories,&#13;
            customBlocksXML: presenter.convertCustomBlocksToJS(validatedCustomBlocks.value),&#13;
            maxBlocks: validatedBlockLimit.value,&#13;
            blocksTranslation: $.extend(validatedToolbox.value.translations, validatedBlocksTranslations.value),&#13;
            initialConfiguration: model["initialConfiguration"]&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateBlockLimit = function Blockly_validateBlockLimit_function(blockModel) {&#13;
        if (ModelValidationUtils.isStringEmpty(blockModel.trim())) {&#13;
            blockModel = "0";&#13;
        }&#13;
&#13;
        var validatedBlockLimit = ModelValidationUtils.validateInteger(blockModel);&#13;
        if (!validatedBlockLimit.isValid || validatedBlockLimit.value &lt; 0) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "BL01"&#13;
            };&#13;
        }&#13;
&#13;
        /*&#13;
            Find all characters without numbers&#13;
         */&#13;
        if (blockModel.trim().match(/[^0-9]/) !== null) {&#13;
             return {&#13;
                isValid: false,&#13;
                errorCode: "BL02"&#13;
            };&#13;
        }&#13;
        return validatedBlockLimit;&#13;
    };&#13;
&#13;
    presenter.validateBlocksTranslation = function Blockly_validateBlocksTranslation_function (blocksTranslations) {&#13;
        if (ModelValidationUtils.isStringEmpty(blocksTranslations.trim())){&#13;
            return {&#13;
                isValid: true,&#13;
                value: {}&#13;
            }&#13;
        }&#13;
&#13;
        var parsedValue = {};&#13;
        try {&#13;
            parsedValue = JSON.parse(blocksTranslations);&#13;
        } catch (error) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "TP02"&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value : parsedValue&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateToolboxNamesWithCustomBlocks = function Blockly_validateToolboxNamesWithCustomBlocks_function (toolbox, customblocks) {&#13;
        for (var key in toolbox) {&#13;
            if (toolbox.hasOwnProperty(key)) {&#13;
                var category = toolbox[key];&#13;
                for (var blockInCategoryIndex = 0; blockInCategoryIndex &lt; category.length; blockInCategoryIndex++) {&#13;
                    if (presenter.DEFAULT_BLOCKS_TRANSLATION_LABELS.indexOf(category[blockInCategoryIndex].name)  == -1) {&#13;
                        var founded = false;&#13;
                        for (var customBlockIndex = 0; customBlockIndex &lt; customblocks.value.length; customBlockIndex++) {&#13;
                            if (customblocks.value[customBlockIndex].name == category[blockInCategoryIndex].name) {&#13;
                                founded = true;&#13;
                                break;&#13;
                            }&#13;
                        }&#13;
                        if (!founded) {&#13;
                            return {&#13;
                                isValid: false,&#13;
                                errorCode: "UB01"&#13;
                            }&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateSceneId = function Blockly_Code_Editor_validate_scene_id (sceneId) {&#13;
        if (ModelValidationUtils.isStringEmpty(sceneId)) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "SI01"&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: sceneId&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateToolbox = function Blockly_Code_Editor_validate_toolbox (toolbox) {&#13;
        var categories = {};&#13;
        var elements = [];&#13;
        var translations = {};&#13;
&#13;
        for (var index = 0; index &lt; toolbox.length; index++) {&#13;
            var toolboxElement = toolbox[index];&#13;
            if (toolboxElement['blockName'].name != "custom") {&#13;
                if (elements.indexOf(toolboxElement['blockName'].name) != -1) {&#13;
                    return {&#13;
                        isValid: false,&#13;
                        errorCode: "DE01"&#13;
                    };&#13;
                }&#13;
            }&#13;
            elements.push(toolboxElement['blockName'].name);&#13;
&#13;
            var validatedTranslations = presenter.validateTranslations(toolboxElement);&#13;
            if (!validatedTranslations.isValid) {&#13;
                return validatedTranslations;&#13;
            }&#13;
&#13;
            $.extend(translations, validatedTranslations.value);&#13;
            var validatedCategory = null;&#13;
            if (toolboxElement['blockName'].name == "custom") {&#13;
                validatedCategory = addToCategory(categories, toolboxElement['blockCategory'], toolboxElement['blockName'].value, toolboxElement['blockIsDisabled']);&#13;
            } else if (toolboxElement['blockName'].name == "grid_scene_commands") {&#13;
                validatedCategory = addToCategory(categories, toolboxElement['blockCategory'], "grid_scene_commands", toolboxElement['blockIsDisabled']);&#13;
            } else {&#13;
                validatedCategory = addToCategory(categories, toolboxElement['blockCategory'], toolboxElement['blockName'].name, toolboxElement['blockIsDisabled']);&#13;
            }&#13;
            if (!validatedCategory.isValid) {&#13;
                return validatedCategory;&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {&#13;
                categories: categories,&#13;
                translations: translations&#13;
            }&#13;
        };&#13;
    };&#13;
&#13;
&#13;
&#13;
    function addToCategory(categories, categoryName, blockName, isDisabled) {&#13;
        if (blockName == '') {&#13;
            return {&#13;
                isValid: true&#13;
            };&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.validateBoolean(isDisabled)) {&#13;
            return {&#13;
                isValid: true&#13;
            };&#13;
        }&#13;
&#13;
        var haveCategory = true;&#13;
        if (categoryName.trim() === '') {&#13;
            haveCategory = false;&#13;
            categoryName = "Empty";&#13;
        }&#13;
&#13;
        if (blockName === "variables_editor" &amp;&amp; !haveCategory) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "VE01"&#13;
            };&#13;
        }&#13;
&#13;
        if (categories[categoryName] == null) {&#13;
            categories[categoryName] = [];&#13;
        }&#13;
&#13;
        if (blockName != "grid_scene_commands") {&#13;
            categories[categoryName].push({&#13;
                name: blockName,&#13;
                isCategory: haveCategory&#13;
            });&#13;
        } else {&#13;
            presenter.configuration.addSceneToolbox = true;&#13;
            presenter.configuration.sceneToolboxIsCategory = haveCategory;&#13;
            presenter.configuration.sceneToolboxName = categoryName;&#13;
        }&#13;
        return {&#13;
            isValid: true&#13;
        };&#13;
    }&#13;
&#13;
    presenter.validateTranslations = function Blockly_validateTranslations_function (toolboxElement) {&#13;
        if (presenter.DEFAULT_BLOCKS_TRANSLATION_LABELS.indexOf(toolboxElement['blockName'].name) != -1 || (toolboxElement['blockName'].name == "grid_scene_commands")) {&#13;
            var parsedValue = "";&#13;
            try {&#13;
                parsedValue = JSON.parse(toolboxElement['blockName'].value);&#13;
            } catch (error) {&#13;
                return {&#13;
                    isValid: false,&#13;
                    errorCode: "TP01"&#13;
                };&#13;
            }&#13;
            return {&#13;
                isValid: true,&#13;
                value: parsedValue&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {}&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateType = function Blockly_validateType_function (type) {&#13;
        if (type.toUpperCase().trim() in presenter.inputsType) {&#13;
            return {&#13;
                isValid: true,&#13;
                value: presenter.inputsType[type.toUpperCase().trim()]&#13;
            };&#13;
        }&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: "IE01"&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateInputsType = function Blockly_validateInputsType_function (inputsType, inputsLength) {&#13;
        if (inputsLength == 0) {&#13;
            return {&#13;
                isValid:true,&#13;
                value : []&#13;
            };&#13;
        }&#13;
&#13;
        var validatedInputTypes = [];&#13;
        var separatedInputsType = [];&#13;
        if (!ModelValidationUtils.isStringEmpty(inputsType.trim())) {&#13;
            separatedInputsType = inputsType.split(",");&#13;
        }&#13;
        for (var actualPosition = separatedInputsType.length; actualPosition &lt; inputsLength.length; actualPosition++) {&#13;
            separatedInputsType.push("Any");&#13;
        }&#13;
&#13;
        for (var key in separatedInputsType) {&#13;
            if (separatedInputsType.hasOwnProperty(key)) {&#13;
                var validatedType = presenter.validateType(separatedInputsType[key]);&#13;
                if (!validatedType.isValid) {&#13;
                    return validatedType;&#13;
                }&#13;
                validatedInputTypes.push(validatedType.value);&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: validatedInputTypes&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateConnection = function Blockly_validateConnection_function (connection) {&#13;
        if (connection.toUpperCase().trim() in presenter.connections) {&#13;
            return {&#13;
                isValid: true,&#13;
                value: connection.toUpperCase().trim()&#13;
            };&#13;
        }&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: "OE01"&#13;
        };&#13;
    };&#13;
&#13;
&#13;
    presenter.validateBlock = function Blockly_validateBlock_function (customBlock) {&#13;
        var validatedColor =  ModelValidationUtils.validateIntegerInRange(customBlock['customBlockColor'], 360, 0);&#13;
        if (!validatedColor.isValid) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "CN01"&#13;
            };&#13;
        }&#13;
&#13;
        var inputs = customBlock['customBlockInputs'].split(",");&#13;
        if (ModelValidationUtils.isStringEmpty(customBlock['customBlockInputs'])) {&#13;
            inputs = [];&#13;
        }&#13;
        for (var i = 0; i &lt; inputs.length; i++) {&#13;
            if (!ModelValidationUtils.validateJSVariableName(inputs[i].trim()).isValid) {&#13;
                return {&#13;
                    isValid: false,&#13;
                    errorCode: "VN01"&#13;
                };&#13;
            }&#13;
        }&#13;
&#13;
        var validatedInputsType = presenter.validateInputsType(customBlock['customBlockInputsType'], inputs.length);&#13;
        if (!validatedInputsType.isValid) {&#13;
            return validatedInputsType;&#13;
        }&#13;
&#13;
        var inputsText = customBlock['customBlockInputsText'].split(",");&#13;
        for (var actualPosition = inputsText.length; actualPosition &lt; inputs.length; actualPosition++) {&#13;
            inputsText.push("");&#13;
        }&#13;
        var validatedConnection = presenter.validateConnection(customBlock['customBlockOutput']);&#13;
        if (!validatedConnection.isValid) {&#13;
            return validatedConnection;&#13;
        }&#13;
&#13;
        var validatedConnectionsType = presenter.validateInputsType(customBlock['customBlockOutputType'], 2);&#13;
        if (!validatedConnectionsType.isValid) {&#13;
            return validatedConnectionsType;&#13;
        }&#13;
&#13;
        var isTitle = !ModelValidationUtils.isStringEmpty(customBlock['customBlockTitle']);&#13;
        var validatedTitle = {&#13;
            isValid: true,&#13;
            value: null&#13;
        };&#13;
&#13;
        if (isTitle) {&#13;
            validatedTitle.value = customBlock['customBlockTitle'];&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            name:  customBlock['customBlockName'],&#13;
            color: validatedColor.value,&#13;
            inputs: inputs,&#13;
            inputsText: inputsText,&#13;
            inputsType: validatedInputsType.value,&#13;
            code: customBlock['customBlockCode'].replace(/\r?\n|\r/g,""),   //Removing all new line sings&#13;
            connection: validatedConnection.value,&#13;
            connectionType: validatedConnectionsType.value,&#13;
            title: validatedTitle.value&#13;
&#13;
        };&#13;
    };&#13;
&#13;
&#13;
    presenter.convertCustomBlockToJS = function Blockly_convertCustomBlockToJS_function (customBlock) {&#13;
        var blockDefinitions = presenter.createBlockDefinition(customBlock);&#13;
        var code = presenter.createCode(customBlock);&#13;
&#13;
        presenter.blockDefinitions.push(customBlock.name);&#13;
        presenter.javaScriptBlocksCode.push(customBlock.name);&#13;
&#13;
        return {&#13;
            blockDefinitions: blockDefinitions,&#13;
            code: code&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createCode = function Blockly_createCode_function (customBlock) {&#13;
        var variables = presenter.getCustomBlockVariablesCode(customBlock);&#13;
&#13;
        var code = StringUtils.format("Blockly.JavaScript['{0}'] = function(block) {", customBlock.name);&#13;
        code = presenter.extractInputsValuesFromBlock(customBlock, code);&#13;
        code = presenter.addVariablesToCode(customBlock, code, variables);&#13;
        code += "return code;};";&#13;
&#13;
        return code;&#13;
    };&#13;
&#13;
    presenter.getCustomBlockVariablesCode = function (customBlock) {&#13;
        var variables = "";&#13;
        for (var inputIndex = 0; inputIndex &lt; customBlock.inputs.length; inputIndex++) {&#13;
            variables += StringUtils.format("'var {0} = ' + {1} + ';' + ", customBlock.inputs[inputIndex], customBlock.inputs[inputIndex]);&#13;
        }&#13;
        return variables;&#13;
    };&#13;
&#13;
    presenter.extractInputsValuesFromBlock = function (customBlock, code) {&#13;
        for (var inputKey in customBlock.inputs) {&#13;
            if (customBlock.inputs.hasOwnProperty(inputKey)) {&#13;
                code += StringUtils.format("var {0} = Blockly.JavaScript.valueToCode(block, '{1}', Blockly.JavaScript.ORDER_ATOMIC);", customBlock.inputs[inputKey], customBlock.inputs[inputKey]);&#13;
            }&#13;
        }&#13;
        return code;&#13;
    };&#13;
&#13;
    presenter.addVariablesToCode = function (customBlock, code, variables) {&#13;
        if (customBlock.connection.toUpperCase() === "LEFT") {&#13;
            return code + StringUtils.format("var code = [eval('(function Blockly_createCode_function_creating (){{0}}())'), Blockly.JavaScript.ORDER_ATOMIC];", customBlock.code);&#13;
        } else {&#13;
            return code + StringUtils.format("var code = {0}'{1}';", variables, customBlock.code);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createBlockDefinition = function Blockly_createBlockDefinition_function (customBlock) {&#13;
        var blockDefinition = StringUtils.format("Blockly.Blocks['{0}'] = { ", customBlock.name)&#13;
            + "init: function Blockly_init_function_creating() {";&#13;
&#13;
        if (customBlock.title != null) {&#13;
            blockDefinition += StringUtils.format("this.appendDummyInput().appendField('{0}');", customBlock.title);&#13;
        }&#13;
&#13;
        for (var inputKey in customBlock.inputs) {&#13;
            if (customBlock.inputs.hasOwnProperty(inputKey)) {&#13;
                blockDefinition += StringUtils.format("this.appendValueInput('{0}')", customBlock.inputs[inputKey]);&#13;
                blockDefinition += StringUtils.format(".setCheck('{0}')", customBlock.inputsType[inputKey]);&#13;
                blockDefinition += StringUtils.format(".appendField('{0}');", customBlock.inputsText[inputKey]);&#13;
            }&#13;
        }&#13;
&#13;
        if (customBlock.connection.toUpperCase() != "NONE" &amp;&amp; customBlock.connection.toUpperCase() != "TOP-BOTTOM") {&#13;
            blockDefinition += presenter.connections[customBlock.connection.toUpperCase()](customBlock.connectionType[0]);&#13;
        } else if (customBlock.connection.toUpperCase() == "TOP-BOTTOM") {&#13;
            blockDefinition += presenter.connections["TOP-BOTTOM"](customBlock.connectionType[0], customBlock.connectionType[1]);&#13;
        }&#13;
&#13;
        blockDefinition += StringUtils.format("this.setColour({0});", customBlock.color);&#13;
        blockDefinition += StringUtils.format("this.setTooltip('');}};");&#13;
&#13;
        return blockDefinition;&#13;
    };&#13;
&#13;
    presenter.convertCustomBlocksToJS = function Blockly_convertCustomBlocksToJS_function (customBlocks) {&#13;
        var stringJS = {&#13;
            blockDefinitions: "",&#13;
            code: ""&#13;
        };&#13;
&#13;
        for (var key in customBlocks) {&#13;
            if (customBlocks.hasOwnProperty(key)) {&#13;
                var convertedCode = presenter.convertCustomBlockToJS(customBlocks[key]);&#13;
                stringJS.blockDefinitions += convertedCode.blockDefinitions;&#13;
                stringJS.code += convertedCode.code;&#13;
            }&#13;
        }&#13;
&#13;
        return stringJS;&#13;
    };&#13;
&#13;
    presenter.validateCustomBlocks = function Blockly_validateCustomBlocks_function (customBlocksList) {&#13;
        var blocks = [];&#13;
        var names = [];&#13;
&#13;
        for (var customBlockKey in customBlocksList) {&#13;
            if (customBlocksList.hasOwnProperty(customBlockKey)) {&#13;
                if (ModelValidationUtils.isStringEmpty(customBlocksList[customBlockKey]['customBlockName'])) {&#13;
                    continue;&#13;
                }&#13;
                var customBlock = customBlocksList[customBlockKey];&#13;
                var validatedBlock = presenter.validateBlock(customBlock);&#13;
                if (!validatedBlock.isValid) {&#13;
                    return validatedBlock;&#13;
                }&#13;
                blocks.push(validatedBlock);&#13;
            }&#13;
        }&#13;
&#13;
        for (var i = 0; i &lt; blocks.length; i++) {&#13;
            if (names.indexOf(blocks[i].name) !== -1) {&#13;
                return {&#13;
                    isValid: false,&#13;
                    errorCode: 'DN01'&#13;
                }&#13;
            }&#13;
            names.push(blocks[i].name);&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: blocks&#13;
        };&#13;
    };&#13;
&#13;
    presenter.connectHandlers = function Blockly_connectHandlers_function() {&#13;
        var $runButton = presenter.$view.find(".blockly-code-editor-run");&#13;
        $runButton.click(function Blockly_runClick_function () {&#13;
            if (presenter.configuration.sceneModule !== null) {&#13;
                var code = Blockly.JavaScript.workspaceToCode(presenter.configuration.workspace);&#13;
                presenter.configuration.sceneModule.executeCode(code);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setRunButton = function Blockly_setRunButton_function () {&#13;
        if (presenter.configuration.hideRun) {&#13;
            var $runButton = presenter.$view.find(".blockly-code-editor-run");&#13;
            $runButton.css({&#13;
                "display": "none"&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    presenter.executeCommand = function Blockly_executeCommand_function (name, params) {&#13;
        var commands = {&#13;
            'getWorkspaceCode' : presenter.getWorkspaceCode,&#13;
            'show' : presenter.show,&#13;
            'hide' : presenter.hide,&#13;
            'getConfiguration' : presenter.getConfiguration&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.hide = function Blockly_hide_function () {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.show = function Blockly_show_function () {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function Blockly_setVisibility_function (isVisible) {&#13;
        presenter.configuration.isVisible = isVisible;&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
        var $blocklyToolboxDiv = $('.blocklyToolboxDiv');&#13;
        $blocklyToolboxDiv.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
    };&#13;
&#13;
    presenter.getWorkspaceCode = function Blockly_getWorkspaceCode_function () {&#13;
        return Blockly.JavaScript.workspaceToCode(presenter.configuration.workspace);&#13;
    };&#13;
&#13;
    presenter.getToolboxXML = function Blockly_getToolboxXML_function () {&#13;
        var toolbox = '&lt;xml&gt;';&#13;
        toolbox = StringUtils.format("{0}{1}", toolbox, generateXMLFromCategories(presenter.configuration.toolboxXML));&#13;
        toolbox = StringUtils.format("{0}{1}", toolbox, generateXMLWithoutCategories(presenter.configuration.toolboxXML));&#13;
        toolbox = StringUtils.format("{0}{1}", toolbox, "&lt;/xml&gt;");&#13;
        return toolbox;&#13;
    };&#13;
&#13;
    presenter.getPreviewToolbox = function () {&#13;
        var toolbox = "&lt;xml&gt;";&#13;
        toolbox += "&lt;block type=\"lists_create_with\"&gt;";&#13;
        toolbox += "&lt;mutation items=\"3\"&gt;&lt;/mutation&gt;";&#13;
        toolbox += "&lt;/block&gt;";&#13;
        toolbox += "&lt;block type=\"controls_repeat_ext\"&gt;";&#13;
        toolbox += "&lt;value name=\"TIMES\"&gt;";&#13;
        toolbox += "&lt;shadow type=\"math_number\"&gt;";&#13;
        toolbox += "&lt;field name=\"NUM\"&gt;10&lt;/field&gt;";&#13;
        toolbox += "&lt;/shadow&gt;";&#13;
        toolbox += "&lt;/value&gt;";&#13;
        toolbox += "&lt;/block&gt;";&#13;
        toolbox += "&lt;block type=\"math_constant\"&gt;";&#13;
        toolbox += "&lt;field name=\"CONSTANT\"&gt;PI&lt;/field&gt;";&#13;
        toolbox += "&lt;/block&gt;";&#13;
        toolbox += "&lt;block type=\"controls_for\"&gt;";&#13;
        toolbox += "&lt;field name=\"VAR\"&gt;i&lt;/field&gt;";&#13;
        toolbox += "&lt;value name=\"FROM\"&gt;";&#13;
        toolbox += "&lt;shadow type=\"math_number\"&gt;";&#13;
        toolbox += "&lt;field name=\"NUM\"&gt;1&lt;/field&gt;";&#13;
        toolbox += "&lt;/shadow&gt;";&#13;
        toolbox += "&lt;/value&gt;";&#13;
        toolbox += "&lt;value name=\"TO\"&gt;";&#13;
        toolbox += "&lt;shadow type=\"math_number\"&gt;";&#13;
        toolbox += "&lt;field name=\"NUM\"&gt;10&lt;/field&gt;";&#13;
        toolbox += "&lt;/shadow&gt;";&#13;
        toolbox += "&lt;/value&gt;";&#13;
        toolbox += "&lt;value name=\"BY\"&gt;";&#13;
        toolbox += "&lt;shadow type=\"math_number\"&gt;";&#13;
        toolbox += "&lt;field name=\"NUM\"&gt;1&lt;/field&gt;";&#13;
        toolbox += "&lt;/shadow&gt;";&#13;
        toolbox += "&lt;/value&gt;";&#13;
        toolbox += "&lt;/block&gt;";&#13;
        toolbox += "&lt;/xml&gt;";&#13;
&#13;
        return toolbox;&#13;
    };&#13;
&#13;
    function generateXMLWithoutCategories (categories) {&#13;
        var toolboxText = "";&#13;
        if (categories.hasOwnProperty("Empty")) {&#13;
            for (var key in categories["Empty"]) {&#13;
                if (categories["Empty"].hasOwnProperty(key)) {&#13;
                    if (!categories["Empty"][key].isCategory) {&#13;
                        toolboxText = StringUtils.format("{0}&lt;block type='{1}'&gt;&lt;/block&gt;", toolboxText, categories["Empty"][key].name);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        return toolboxText;&#13;
    }&#13;
&#13;
    function generateXMLFromCategories(categories) {&#13;
        var xml = "";&#13;
        var variables_editor_xml = "";&#13;
        for (var categoryName in categories) {&#13;
            var category = "";&#13;
            var categoryIsNotEmpty = false;&#13;
            if (categories.hasOwnProperty(categoryName)) {&#13;
                category += "&lt;category name='" + categoryName + "' &gt;";&#13;
                for (var key in categories[categoryName]) {&#13;
                    if (categories[categoryName].hasOwnProperty(key)) {&#13;
                        var block = categories[categoryName][key];&#13;
                        if (block.name === 'variables_editor') {&#13;
                            variables_editor_xml = "&lt;category name='" + categoryName + "' custom='VARIABLE'&gt;&lt;/category&gt;";&#13;
                            continue;&#13;
                        }&#13;
                        if (!block.isCategory) {&#13;
                            continue;&#13;
                        }&#13;
                        categoryIsNotEmpty = true;&#13;
                        category += "&lt;block type='" + block.name + "'&gt;&lt;/block&gt;";&#13;
                    }&#13;
                }&#13;
            }&#13;
            category += "&lt;/category&gt;";&#13;
            if (categoryIsNotEmpty) {&#13;
                xml += category;&#13;
            }&#13;
        }&#13;
        xml += variables_editor_xml;&#13;
        return xml;&#13;
    }&#13;
&#13;
    presenter.onEventReceived = function Blockly_onEventReceived_function (eventName, eventData) {&#13;
        if (eventName == "PageLoaded") {&#13;
            if (presenter.configuration.pageLoaded ) {&#13;
                return;&#13;
            }&#13;
            presenter.addBlocksTranslations();&#13;
            presenter.getSceneModuleOnPageLoaded();&#13;
            var sceneData = presenter.getSceneData();&#13;
            if (sceneData !== undefined) {&#13;
                if (presenter.configuration.addSceneToolbox) {&#13;
                    presenter.scenesInitialization[sceneData.type](sceneData);&#13;
                    presenter.updateToolbox();&#13;
                }&#13;
            }&#13;
&#13;
            presenter.configuration.pageLoaded = true;&#13;
        } else if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        } else if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    presenter.getSceneData = function Blockly_getSceneData () {&#13;
        if ((presenter.configuration.sceneModule !== null &amp;&amp; presenter.configuration.sceneModule !== undefined)) {&#13;
            if (presenter.configuration.sceneModule.getBlocklyData !== undefined &amp;&amp; presenter.configuration.sceneModule.getBlocklyData !== null) {&#13;
                return presenter.configuration.sceneModule.getBlocklyData();&#13;
            }&#13;
        }&#13;
&#13;
        return undefined;&#13;
    };&#13;
&#13;
    presenter.getSceneModuleOnPageLoaded = function Blockly_getSceneModuleOnPageLoaded_function () {&#13;
        if (presenter.configuration.sceneModule === null || presenter.configuration.sceneModule === undefined) {&#13;
            presenter.configuration.sceneModule = presenter.playerController.getModule(presenter.configuration.sceneID);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.updateToolbox = function Blockly_updateToolbox_function () {&#13;
        presenter.configuration.workspace.updateToolbox(presenter.getToolboxXML());&#13;
        var transformValueWidth = $(".blocklyToolboxDiv").width();&#13;
&#13;
        presenter.$view.find('.blocklyFlyout').css({&#13;
            '-webkit-transform' : StringUtils.format("translate({0}px, 0)", transformValueWidth),&#13;
            '-moz-transform'    : StringUtils.format("translate({0}px, 0)", transformValueWidth),&#13;
            '-ms-transform'     : StringUtils.format("translate({0}px, 0)", transformValueWidth),&#13;
            '-o-transform'      : StringUtils.format("translate({0}px, 0)", transformValueWidth),&#13;
            'transform'         : StringUtils.format("translate({0}px, 0)", transformValueWidth)&#13;
        });&#13;
    };&#13;
&#13;
    presenter.getState = function Blockly_Code_Edtior_get_state () {&#13;
        var xml = Blockly.Xml.workspaceToDom(presenter.configuration.workspace);&#13;
        var value = {&#13;
            code: Blockly.Xml.domToText(xml),&#13;
            isVisible: presenter.configuration.isVisible&#13;
        };&#13;
        return JSON.stringify(value);&#13;
    };&#13;
&#13;
    presenter.setState = function Blockly_Code_Editor_set_state (state) {&#13;
        var value = JSON.parse(state);&#13;
        var xml = Blockly.Xml.textToDom(value.code);&#13;
        Blockly.Xml.domToWorkspace(xml, presenter.configuration.workspace);&#13;
        presenter.setVisibility(value.isVisible);&#13;
    };&#13;
&#13;
    presenter.reset = function Blockly_reset_function () {&#13;
        presenter.setWorkMode();&#13;
        presenter.configuration.workspace.clear();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function Blockly_setShowErrorsMode_function () {&#13;
        presenter.setWorkMode();&#13;
        presenter.coverToolbox();&#13;
        presenter.coverAddon();&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function Blockly_setWorkMode_function () {&#13;
        presenter.removeToolboxCover();&#13;
        presenter.removeAddonCover();&#13;
    };&#13;
&#13;
    presenter.showAnswers = function Blockly_showAnswers_function () {&#13;
        presenter.setShowErrorsMode();&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function Blockly_hideAnswers_function () {&#13;
        presenter.setWorkMode();&#13;
    };&#13;
&#13;
    presenter.coverAddon = function Blockly_coverAddon_function () {&#13;
        var cover = $("&lt;div&gt;");&#13;
        cover.addClass("blockly-cover");&#13;
        presenter.$view.append(cover);&#13;
    };&#13;
&#13;
    presenter.removeAddonCover = function Blockly_removeAddonCover_function () {&#13;
        var element = presenter.$view.find('.blockly-cover');&#13;
        element.remove();&#13;
    };&#13;
&#13;
    presenter.coverToolbox = function Blockly_coverToolbox_function () {&#13;
        var toolbox = presenter.view.getElementsByClassName('blocklyToolboxDiv');&#13;
        if (toolbox.length != 0) {&#13;
            var cover = document.createElement('div');&#13;
            cover.className = 'toolboxCover blockly-cover';&#13;
            toolbox[0].appendChild(cover);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.removeToolboxCover = function Blockly_removeToolboxCover_function () {&#13;
        var toolboxCover = presenter.view.getElementsByClassName('toolboxCover blockly-cover');&#13;
        if (toolboxCover !== null &amp;&amp; toolboxCover !== undefined) {&#13;
            if (toolboxCover.length &gt; 0) {&#13;
                toolboxCover[0].parentNode.removeChild(toolboxCover[0]);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.gridSceneInitialization = function (data) {&#13;
        for (var key in data.labels) {&#13;
            if (data.labels.hasOwnProperty(key) &amp;&amp; presenter.configuration.blocksTranslation.hasOwnProperty(key)) {&#13;
                data.labels[key] = presenter.configuration.blocksTranslation[key];&#13;
            }&#13;
        }&#13;
        BlocklyCustomBlocks.SceneGrid.addBlocks(data.labels);&#13;
&#13;
        if (presenter.configuration.addSceneToolbox) {&#13;
            for (var key in data.availableBlocks) {&#13;
                if (data.availableBlocks.hasOwnProperty(key)) {&#13;
                    presenter.configuration.toolboxXML[presenter.configuration.sceneToolboxName].push({&#13;
                        name: key,&#13;
                        isCategory: presenter.configuration.sceneToolboxIsCategory&#13;
                    });&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.scenesInitialization = {&#13;
        "GridScene" : presenter.gridSceneInitialization&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>