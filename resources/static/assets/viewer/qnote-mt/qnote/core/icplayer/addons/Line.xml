<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Line" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Rotation angle" nameLabel="Line_property_rotation_angle" type="string"/>
		<property name="Line width" nameLabel="Line_property_line_width" type="string"/>
		<property name="Line color" nameLabel="Line_property_line_color" type="string"/>
        <property name="Line opacity" nameLabel="Line_property_line_opacity" type="string"/>
		<property name="Left line ending" nameLabel="Line_property_left_line_ending" type="{None, Round, Circle, Square}"/>
        <property name="Right line ending" nameLabel="Line_property_right_line_ending" type="{None, Round, Circle, Square}"/>
	</model>
<css>.line-wrapper {&#13;
    border: 0 solid black;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    overflow: hidden;&#13;
}&#13;
</css><view>&lt;div class="line-wrapper"&gt;&#13;
&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="line-wrapper"&gt;&#13;
&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonLine_create() {&#13;
    var presenter = function () {&#13;
    };&#13;
&#13;
    presenter.LINE_ENDING = {&#13;
        NONE: 'None',&#13;
        CIRCLE: 'Circle',&#13;
        ROUND: 'Round',&#13;
        SQUARE: 'Square'&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'R01': "Rotation angle must be between 0 and 360 degrees!",&#13;
        'R02': "Rotation angle is not a number!",&#13;
        'ST1': "Line width must be a positive number",&#13;
        'ST2': "Line width is not a number!",&#13;
        'ST3': "Line color must be in RGB format (hexadecimal) and start with #",&#13;
        'ST4': "Line opacity must be a positive number between 0 and 1",&#13;
        'ST5': "Line opacity is not a number!",&#13;
        'F01': "Line color must be in RGB format (hexadecimal) and start with #",&#13;
        'RU1': "Addon dimensions are too small to draw line with endings (or line is too thick)!",&#13;
        'RU2': "Addon dimensions are too small to draw line with circle ending!",&#13;
        'RU3': "Addon dimensions are too small to draw line with square ending!"&#13;
    };&#13;
&#13;
    function convertToRadians(degrees) {&#13;
        return degrees * Math.PI / 180;&#13;
    }&#13;
&#13;
    function presenterLogic(view, model) {&#13;
        presenter.$view = $(view);&#13;
        var containerDimensions = DOMOperationsUtils.getOuterDimensions(presenter.$view);&#13;
        var containerDistances = DOMOperationsUtils.calculateOuterDistances(containerDimensions);&#13;
&#13;
        presenter.$view.css({&#13;
            width: (presenter.$view.width() - containerDistances.horizontal) + 'px',&#13;
            height: (presenter.$view.height() - containerDistances.vertical) + 'px'&#13;
        });&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        var canvasWrapper = presenter.$view.find('.line-wrapper:first')[0];&#13;
        var wrapperDimensions = DOMOperationsUtils.getOuterDimensions(canvasWrapper);&#13;
        var wrapperDistances = DOMOperationsUtils.calculateOuterDistances(wrapperDimensions);&#13;
&#13;
        var canvasWrapperWidth = presenter.$view.width() - wrapperDistances.horizontal;&#13;
        var canvasWrapperHeight = presenter.$view.height() - wrapperDistances.vertical;&#13;
        $(canvasWrapper).css({&#13;
            width: (canvasWrapperWidth &lt; 1 ? model.Width : canvasWrapperWidth) + 'px',&#13;
            height: (canvasWrapperHeight &lt; 1 ? model.Height : canvasWrapperHeight) + 'px'&#13;
        });&#13;
&#13;
        var angle = parseInt(presenter.configuration.rotation);&#13;
        presenter.drawLine(canvasWrapper, canvasWrapperWidth, canvasWrapperHeight, angle);&#13;
    }&#13;
&#13;
    presenter.applyStyles = function (element) {&#13;
        element.attr({&#13;
            'stroke-width': presenter.configuration.strokeWidth,&#13;
            'stroke': presenter.configuration.strokeColor,&#13;
            'opacity': presenter.configuration.strokeOpacity,&#13;
            'fill': presenter.configuration.strokeColor,&#13;
            'fill-rule': 'evenodd'&#13;
        });&#13;
&#13;
        if (presenter.configuration.cornersRoundings) {&#13;
            element.attr('stroke-linecap', 'round');&#13;
        }&#13;
    };&#13;
&#13;
    function transformShape(element, angle, width, height, axis) {&#13;
        // Calculate space needed for ending display&#13;
        var neededSpace = 0;&#13;
        if (angle % 90 != 0)  neededSpace = 1.7 * Math.abs(Math.cos(convertToRadians(angle))) * presenter.configuration.strokeWidth;&#13;
        //Line length after rotation&#13;
        var newLineLengh = Math.min((width - axis) / Math.abs(Math.cos(convertToRadians(angle))), (height - axis) / Math.abs(Math.cos(convertToRadians(90 - angle)))) - neededSpace;&#13;
        var roundedScale = Math.round(newLineLengh / (width) * 100) / 100; // Rounding scale to two decimal places&#13;
        var cx = parseInt(width / 2, 10);&#13;
        var cy = parseInt(height / 2, 10);&#13;
&#13;
        element.transform("r" + angle + "," + cx + "," + cy);&#13;
        element.transform("...s" + roundedScale + "," + roundedScale + "," + cx + "," + cy);&#13;
    }&#13;
&#13;
    function calculateSimpleLinePoints(width, height, lineWidth, lineEnding, leftLinePart) {&#13;
        //space needed for rounded endings&#13;
        var roundSpace = 0;&#13;
        if (lineEnding == presenter.LINE_ENDING.ROUND) roundSpace = lineWidth / 2;&#13;
&#13;
        var tmpY = parseInt((height) / 2, 10);&#13;
        var tmpX = parseInt((width) / 2, 10);&#13;
        if (leftLinePart) { //for left part of the line&#13;
            return [&#13;
                { x: tmpX, y: tmpY },&#13;
                { x: roundSpace, y: tmpY }&#13;
            ];&#13;
        } else {&#13;
            return [&#13;
                { x: tmpX, y: tmpY },&#13;
                { x: width - roundSpace, y: tmpY }&#13;
            ];&#13;
        }&#13;
    }&#13;
&#13;
    function calculateLinePoints(lineEnding, width, height, horizontalAxis, leftLinePart) {&#13;
        var points = {};&#13;
        switch (lineEnding) {&#13;
            case presenter.LINE_ENDING.CIRCLE:&#13;
                points.pointA = {&#13;
                    x: parseInt(width / 2, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                if (leftLinePart) {&#13;
                    points.pointB = {&#13;
                        x: 2 * horizontalAxis + (presenter.configuration.strokeWidth / 2) + 1.5,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                    points.pointC = {&#13;
                        x: 2 * horizontalAxis + (presenter.configuration.strokeWidth / 2) + 1.5,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                } else {&#13;
                    points.pointB = {&#13;
                        x: width - 2 * horizontalAxis - (presenter.configuration.strokeWidth / 2) - 1.5,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                    points.pointC = {&#13;
                        x: width - 2 * horizontalAxis - (presenter.configuration.strokeWidth / 2) - 1.5,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                }&#13;
                points.pointD = {&#13;
                    x: parseInt(width / 2, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
&#13;
                break;&#13;
            case presenter.LINE_ENDING.SQUARE:&#13;
                var widthSpace = width - (presenter.configuration.strokeWidth / 2);&#13;
                points.pointA = {&#13;
                    x: parseInt(width / 2, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
&#13;
                if (leftLinePart) {&#13;
                    points.pointB = {&#13;
                        x: (presenter.configuration.strokeWidth / 2) + 2 * horizontalAxis,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                    points.pointC = {&#13;
                        x: (presenter.configuration.strokeWidth / 2) + 2 * horizontalAxis,&#13;
                        y: parseInt((height) / 2, 10) + horizontalAxis&#13;
                    };&#13;
                    points.pointD = {&#13;
                        x: (presenter.configuration.strokeWidth / 2),&#13;
                        y: parseInt((height) / 2, 10) + horizontalAxis&#13;
                    };&#13;
                    points.pointE = {&#13;
                        x: (presenter.configuration.strokeWidth / 2),&#13;
                        y: parseInt((height) / 2, 10) - horizontalAxis&#13;
                    };&#13;
                    points.pointF = {&#13;
                        x: (presenter.configuration.strokeWidth / 2) + 2 * horizontalAxis,&#13;
                        y: parseInt((height) / 2, 10) - horizontalAxis&#13;
                    };&#13;
                    points.pointG = {&#13;
                        x: (presenter.configuration.strokeWidth / 2) + 2 * horizontalAxis,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                } else {&#13;
                    points.pointB = {&#13;
                        x: widthSpace - 2 * horizontalAxis,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
                    points.pointC = {&#13;
                        x: widthSpace - 2 * horizontalAxis,&#13;
                        y: parseInt((height) / 2, 10) + horizontalAxis&#13;
                    };&#13;
                    points.pointD = {&#13;
                        x: widthSpace,&#13;
                        y: parseInt((height) / 2, 10) + horizontalAxis&#13;
                    };&#13;
                    points.pointE = {&#13;
                        x: widthSpace,&#13;
                        y: parseInt((height) / 2, 10) - horizontalAxis&#13;
                    };&#13;
                    points.pointF = {&#13;
                        x: widthSpace - 2 * horizontalAxis,&#13;
                        y: parseInt((height) / 2, 10) - horizontalAxis&#13;
                    };&#13;
                    points.pointG = {&#13;
                        x: widthSpace - 2 * horizontalAxis,&#13;
                        y: parseInt(height / 2, 10)&#13;
                    };&#13;
&#13;
                }&#13;
                points.pointH = {&#13;
                    x: parseInt(width / 2, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
        }&#13;
        return points;&#13;
    }&#13;
&#13;
    function createLinePath(width, height, lineEnding, horizontalAxis, leftLinePart) {&#13;
        var points = [];&#13;
        var pathString;&#13;
        var verticalAxis = horizontalAxis + 0.5;&#13;
        presenter.configuration.cornersRoundings = false;&#13;
        switch (lineEnding) {&#13;
            case presenter.LINE_ENDING.NONE:&#13;
                points = calculateSimpleLinePoints(width, height, presenter.configuration.strokeWidth, lineEnding, leftLinePart);&#13;
                //fix for one round ending and second "none"&#13;
                pathString = points[0].x + "," + points[0].y;&#13;
                pathString += "L" + points[1].x + "," + points[1].y;&#13;
                pathString += "L" + points[0].x + "," + points[0].y;&#13;
                break;&#13;
            case presenter.LINE_ENDING.ROUND:&#13;
                points = calculateSimpleLinePoints(width, height, presenter.configuration.strokeWidth, lineEnding, leftLinePart);&#13;
                if (leftLinePart) {&#13;
                    pathString = points[0].x + "," + points[0].y;&#13;
                    pathString += "L" + points[1].x + "," + points[1].y;&#13;
                } else {&#13;
                    pathString = points[0].x + "," + points[0].y;&#13;
                    pathString += "L" + points[1].x + "," + points[1].y;&#13;
                }&#13;
                presenter.configuration.cornersRoundings = true;&#13;
                break;&#13;
            case presenter.LINE_ENDING.CIRCLE:&#13;
                points = calculateLinePoints(presenter.LINE_ENDING.CIRCLE, width, height, horizontalAxis, leftLinePart);&#13;
                pathString = points.pointA.x + "," + points.pointA.y + "L" + points.pointB.x + "," + points.pointB.y;&#13;
                if (leftLinePart) {&#13;
                    pathString += "A" + horizontalAxis + " " + verticalAxis + " 90 1 1 " + points.pointC.x + " " + (points.pointC.y - 1);&#13;
                } else {&#13;
                    pathString += "A" + horizontalAxis + " " + verticalAxis + " 90 1 0 " + points.pointC.x + " " + (points.pointC.y - 1);&#13;
                }&#13;
                pathString += "L" + points.pointC.x + "," + points.pointC.y;&#13;
                pathString += "L" + points.pointD.x + "," + points.pointD.y;&#13;
                break;&#13;
            case presenter.LINE_ENDING.SQUARE:&#13;
                points = calculateLinePoints(presenter.LINE_ENDING.SQUARE, width, height, horizontalAxis, leftLinePart);&#13;
                pathString = points.pointA.x + "," + points.pointA.y + "L" + points.pointB.x + "," + points.pointB.y;&#13;
                pathString += "L" + points.pointC.x + "," + points.pointC.y;&#13;
                pathString += "L" + points.pointD.x + "," + points.pointD.y;&#13;
                pathString += "L" + points.pointE.x + "," + points.pointE.y;&#13;
                pathString += "L" + points.pointF.x + "," + points.pointF.y;&#13;
                pathString += "L" + points.pointG.x + "," + points.pointG.y;&#13;
                pathString += "L" + points.pointH.x + "," + points.pointH.y;&#13;
                break;&#13;
        }&#13;
        return pathString;&#13;
    }&#13;
&#13;
&#13;
    presenter.drawLine = function (wrapper, width, height, angle) {&#13;
&#13;
        if ((presenter.configuration.rightLineEnding !== presenter.LINE_ENDING.NONE) || (presenter.configuration.leftLineEnding !== presenter.LINE_ENDING.NONE)) {&#13;
            if (2 * presenter.configuration.strokeWidth + 2 &gt; height) {&#13;
                DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, 'RU1');&#13;
                return;&#13;
            }&#13;
        }&#13;
&#13;
        var paper = new Raphael(wrapper, width &lt; 20 ? 20 : width, height &lt; 20 ? 20 : height);&#13;
        var radius = parseInt(presenter.configuration.strokeWidth / 2, 10) + 5;&#13;
        var horizontalAxis = radius - (presenter.configuration.strokeWidth) * 0.5 + 1.5;&#13;
&#13;
        var pathString;&#13;
        pathString = "M";&#13;
        if (presenter.configuration.rightLineEnding == presenter.LINE_ENDING.ROUND) {    //for rounded ending sequence of creating path does matter&#13;
            // case for simply line with two rounded endings&#13;
            if ((presenter.configuration.leftLineEnding == presenter.LINE_ENDING.ROUND)) {&#13;
                pathString += parseInt(presenter.configuration.strokeWidth / 2, 10) + "," + parseInt(height / 2, 10);&#13;
                pathString += "L" + (width - parseInt(presenter.configuration.strokeWidth / 2, 10)) + "," + parseInt(height / 2, 10);&#13;
                presenter.configuration.cornersRoundings = true;&#13;
            }&#13;
            else {&#13;
                pathString += createLinePath(width, height, presenter.configuration.leftLineEnding, horizontalAxis, true);&#13;
                pathString += "L";&#13;
                pathString += createLinePath(width, height, presenter.configuration.rightLineEnding, horizontalAxis, false);&#13;
            }&#13;
        }&#13;
        else {&#13;
            pathString += createLinePath(width, height, presenter.configuration.rightLineEnding, horizontalAxis, false);&#13;
            pathString += "L";&#13;
            pathString += createLinePath(width, height, presenter.configuration.leftLineEnding, horizontalAxis, true);&#13;
        }&#13;
&#13;
        var path = paper.path(pathString);&#13;
        presenter.applyStyles(path);&#13;
&#13;
        transformShape(path, angle, width, height, horizontalAxis);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenterLogic(view, model);&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenterLogic(view, model);&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
&#13;
        var rotation = model["Rotation angle"];&#13;
        if (!rotation) {&#13;
            rotation = 0;&#13;
        } else {&#13;
            rotation = parseFloat(rotation);&#13;
            if (isNaN(rotation)) {&#13;
                return { isError: true, errorCode: 'R02' };&#13;
            }&#13;
&#13;
            if (rotation &lt; 0 || rotation &gt; 360) {&#13;
                return { isError: true, errorCode: 'R01' };&#13;
            }&#13;
        }&#13;
&#13;
        var strokeWidth = model["Line width"];&#13;
        if (!strokeWidth) {&#13;
            strokeWidth = 1;&#13;
        } else {&#13;
            strokeWidth = parseFloat(strokeWidth);&#13;
            if (isNaN(strokeWidth)) {&#13;
                return { isError: true, errorCode: 'ST2' };&#13;
            }&#13;
&#13;
            if (strokeWidth &lt;= 0) {&#13;
                return { isError: true, errorCode: 'ST1' };&#13;
            }&#13;
        }&#13;
&#13;
        var strokeColor = model["Line color"];&#13;
        var regExp = new RegExp("#[0-9a-fA-F]+");&#13;
        var colorMatch;&#13;
&#13;
        if (!strokeColor) {&#13;
            strokeColor = "#000";&#13;
        } else {&#13;
            if (strokeColor.length &lt; 4 || strokeColor.length &gt; 7) {&#13;
                return { isError: true, errorCode: 'ST3' };&#13;
            }&#13;
&#13;
            colorMatch = strokeColor.match(regExp);&#13;
            if (!colorMatch || colorMatch === null || colorMatch.length &lt; 1) {&#13;
                return { isError: true, errorCode: 'ST3' };&#13;
            }&#13;
            if (colorMatch[0].length &lt; strokeColor.length) {&#13;
                return { isError: true, errorCode: 'ST3' };&#13;
            }&#13;
        }&#13;
&#13;
        var strokeOpacity = model["Line opacity"];&#13;
        if (!strokeOpacity) {&#13;
            strokeOpacity = 1;&#13;
        } else {&#13;
            strokeOpacity = parseFloat(strokeOpacity);&#13;
            if (isNaN(strokeOpacity)) {&#13;
                return { isError: true, errorCode: 'ST5' };&#13;
            }&#13;
&#13;
            if (strokeOpacity &lt; 0 || strokeOpacity &gt; 1) {&#13;
                return { isError: true, errorCode: 'ST4' };&#13;
            }&#13;
        }&#13;
&#13;
        var leftLineEnding = model["Left line ending"];&#13;
        if (!leftLineEnding) {&#13;
            leftLineEnding = presenter.LINE_ENDING.NONE;&#13;
        }&#13;
        var rightLineEnding = model["Right line ending"];&#13;
        if (!rightLineEnding) {&#13;
            rightLineEnding = presenter.LINE_ENDING.NONE;&#13;
        }&#13;
&#13;
        var isVisibleByDefault = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            rotation: rotation,&#13;
            strokeWidth: strokeWidth,&#13;
            strokeColor: strokeColor,&#13;
            strokeOpacity: strokeOpacity,&#13;
            rightLineEnding: rightLineEnding,&#13;
            leftLineEnding: leftLineEnding,&#13;
            isVisibleByDefault: isVisibleByDefault,&#13;
            isVisible: isVisibleByDefault,&#13;
            cornersRoundings: false&#13;
        };&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        var isVisible = JSON.parse(state).isVisible;&#13;
&#13;
        presenter.configuration.isVisible = isVisible;&#13;
        presenter.setVisibility(isVisible);&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>