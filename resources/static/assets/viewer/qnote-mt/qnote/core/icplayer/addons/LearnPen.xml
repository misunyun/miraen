<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="LearnPen" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
        <property displayName="LearnPen" name="SmartPen" nameLabel="LearnPen_property_smart_pen" type="boolean"/>
        <property name="Colors" nameLabel="LearnPen_property_colors" type="text"/>
        <property name="Thickness" nameLabel="LearnPen_property_thickness" type="text"/>
        <property name="Opacity" nameLabel="LearnPen_property_opacity" type="text"/>

        <property name="Squeeze limits" nameLabel="LearnPen_property_squeeze_limits" type="string"/>
        <property name="Squeeze limits interpretation" nameLabel="LearnPen_property_squeeze_limits_interpretation" type="{Separately, Together}"/>
        <property name="Pressure limits" nameLabel="LearnPen_property_pressure_limits" type="string"/>

        <property name="Events" nameLabel="LearnPen_property_events" type="list">
            <property name="Sensor" nameLabel="LearnPen_property_sensor" type="string"/>
            <property name="Reaction scope" nameLabel="LearnPen_property_reaction_scope" type="string"/>
            <property name="Item" nameLabel="LearnPen_property_item" type="string"/>
            <property name="Value" nameLabel="LearnPen_property_value" type="string"/>
            <property name="Score" nameLabel="LearnPen_property_score" type="string"/>
        </property>

        <property name="Mirror" nameLabel="LearnPen_property_mirror" type="boolean"/>
        <property name="Background color" nameLabel="LearnPen_property_background_color" type="string"/>
	</model>
<css>.addon_DrawingSmartPen .drawing .canvas {&#13;
    position: absolute;&#13;
    left: 0; right: 0;&#13;
    bottom: 0; top: 0;&#13;
&#13;
    cursor: crosshair;&#13;
}&#13;
&#13;
.addon_DrawingSmartPen .drawing .canvas:active {&#13;
    cursor: crosshair;&#13;
}&#13;
&#13;
/* https://code.google.com/p/android/issues/detail?id=35474 */&#13;
.addon_DrawingSmartPen .drawing {&#13;
    overflow: hidden;&#13;
    overflow-x: visible;&#13;
}&#13;
</css><view>&lt;div class="drawing"&gt;&lt;/div&gt;&#13;
</view><preview>&lt;div class="drawing"&gt;&lt;/div&gt;&#13;
</preview><presenter>function AddonLearnPen_create() {&#13;
    var presenter = function() {};&#13;
&#13;
    // work-around for double line in android browser&#13;
    function setOverflowWorkAround(turnOn) {&#13;
&#13;
        if (!MobileUtils.isAndroidWebBrowser(window.navigator.userAgent)) { return false; }&#13;
&#13;
        var android_ver = MobileUtils.getAndroidVersion(window.navigator.userAgent);&#13;
        if (["4.1.1", "4.1.2", "4.2.2", "4.3"].indexOf(android_ver) !== -1) {&#13;
&#13;
            presenter.$view.parents("*").each(function() {&#13;
                var overflow = null;&#13;
                if (turnOn) {&#13;
                    $(this).attr("data-overflow", $(this).css("overflow"));&#13;
                    $(this).css("overflow", "visible");&#13;
                } else {&#13;
                    overflow = $(this).attr("data-overflow");&#13;
                    if (overflow !== "") {&#13;
                        $(this)[0].removeAttribute("data-overflow");&#13;
                        $(this).css("overflow", overflow);&#13;
                    }&#13;
                }&#13;
            });&#13;
&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    // constant values&#13;
    var val = {&#13;
        maxThickness: 40,&#13;
        defaultThickness: 15,&#13;
        defaultColor: "rgba(0, 0, 0, 0)",&#13;
        sensors: ["SQUEEZE_A", "SQUEEZE_B", "SQUEEZE_C", "SQUEEZE_SUM", "SQUEEZE_MAX", "PRESSURE", "ALL"]&#13;
    };&#13;
&#13;
    presenter.position = {&#13;
        pre_x: 0,&#13;
        pre_y: 0,&#13;
        x: 0,&#13;
        y: 0&#13;
    };&#13;
&#13;
    presenter.drawingData = {&#13;
        isDrawingOn: true,&#13;
        pre_color: val.defaultColor,&#13;
        color: val.defaultColor,&#13;
        thickness: val.defaultThickness&#13;
    };&#13;
&#13;
    presenter.data = {&#13;
        canvas: null,&#13;
        context: null,&#13;
&#13;
        isStarted: false,&#13;
        isPencil: true,&#13;
        color: val.defaultColor,&#13;
        zoom: 1,&#13;
        lineCounter: 0,&#13;
        allPoints: [],&#13;
        pencilThickness: 0,&#13;
        eraserThickness: 0&#13;
    };&#13;
&#13;
    var eventBus;&#13;
&#13;
    function updateZoomMultiplier() {&#13;
        var zoom = $('#_icplayer').css('zoom');&#13;
        if (zoom === '' || zoom === undefined || zoom === "normal") {&#13;
            zoom = 1;&#13;
        }&#13;
        presenter.data.zoom = parseInt(zoom, 10);&#13;
    }&#13;
&#13;
    presenter.hexToRGBA = function(hex, opacity) {&#13;
        var r = parseInt(hex.substring(1,3), 16),&#13;
            g = parseInt(hex.substring(3,5), 16),&#13;
            b = parseInt(hex.substring(5,7), 16);&#13;
&#13;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';&#13;
    };&#13;
&#13;
    presenter.colourNameToHex = function(color) {&#13;
        var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff","beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887","cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff","darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f","darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1","darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff","firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff","gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f","honeydew":"#f0fff0","hotpink":"#ff69b4","indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c","lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2","lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de","lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6","magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee","mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5","navajowhite":"#ffdead","navy":"#000080","oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6","palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080","red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1","saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4","tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0","violet":"#ee82ee","wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5","yellow":"#ffff00","yellowgreen":"#9acd32"};&#13;
&#13;
        if (typeof colors[color.toLowerCase()] !== 'undefined') {&#13;
            return colors[color.toLowerCase()];&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    function eventCreator(a, b, c, p) {&#13;
        function sendSensorEvent(eventData, smartPenValue) {&#13;
            if (eventData.reactionScope[0] &lt;= smartPenValue &amp;&amp; smartPenValue &lt;= eventData.reactionScope[1]) {&#13;
                eventBus.sendEvent('ItemReturned', {&#13;
                    'source': presenter.configuration.id,&#13;
                    'item': eventData.item,&#13;
                    'value': eventData.value,&#13;
                    'score': eventData.score&#13;
                });&#13;
            }&#13;
        }&#13;
&#13;
        var eventsArray = presenter.configuration.events;&#13;
        for (var i=0; i&lt;eventsArray.length; i++) {&#13;
            switch(eventsArray[i].sensor) {&#13;
                case "SQUEEZE_A": sendSensorEvent(eventsArray[i], a); break;&#13;
                case "SQUEEZE_B": sendSensorEvent(eventsArray[i], b); break;&#13;
                case "SQUEEZE_C": sendSensorEvent(eventsArray[i], c); break;&#13;
                case "SQUEEZE_SUM": sendSensorEvent(eventsArray[i], ((a+b+c)/3)); break;&#13;
                case "SQUEEZE_MAX": sendSensorEvent(eventsArray[i], Math.max(a,b,c)); break;&#13;
                case "PRESSURE": sendSensorEvent(eventsArray[i], p); break;&#13;
                case "ALL": sendSensorEvent(eventsArray[i], ((a+b+c+p)/4)); break;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function areLimitsOk(a, b, c, p) {&#13;
        var isPressureOK = presenter.configuration.pressureLimits[0] &lt;= p &amp;&amp; p &lt;= presenter.configuration.pressureLimits[1];&#13;
&#13;
        if (presenter.configuration.squeezeLimitsInterpretation === "TOGETHER") {&#13;
            var sum = a + b + c;&#13;
            var isSqueezeOK = (presenter.configuration.squeezeLimits[0] * 3) &lt;= sum &amp;&amp; sum &lt;= (presenter.configuration.squeezeLimits[1] * 3);&#13;
&#13;
            return isPressureOK &amp;&amp; isSqueezeOK;&#13;
        } else if (presenter.configuration.squeezeLimitsInterpretation === "SEPARATELY") {&#13;
            var isSqueezeAOK = presenter.configuration.squeezeLimits[0] &lt;= a &amp;&amp; a &lt;= presenter.configuration.squeezeLimits[1];&#13;
            var isSqueezeBOK = presenter.configuration.squeezeLimits[0] &lt;= b &amp;&amp; b &lt;= presenter.configuration.squeezeLimits[1];&#13;
            var isSqueezeCOK = presenter.configuration.squeezeLimits[0] &lt;= c &amp;&amp; c &lt;= presenter.configuration.squeezeLimits[1];&#13;
&#13;
            return isSqueezeAOK &amp;&amp; isSqueezeBOK &amp;&amp; isSqueezeCOK &amp;&amp; isPressureOK;&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.calculateValue = function(v, collection, defaultVal) {&#13;
        var result = defaultVal;&#13;
        for (var i=0; i&lt;collection.length; i++) {&#13;
            if (collection[i][0] &gt;= v) {&#13;
                result = collection[i][1];&#13;
                break;&#13;
            }&#13;
        }&#13;
        return result;&#13;
    };&#13;
&#13;
    function getValue(a, b, c, p, collection, defaultValue) {&#13;
        switch(collection.sensor) {&#13;
            case "SQUEEZE_A": return presenter.calculateValue(a, collection.values, defaultValue);&#13;
            case "SQUEEZE_B": return presenter.calculateValue(b, collection.values, defaultValue);&#13;
            case "SQUEEZE_C": return presenter.calculateValue(c, collection.values, defaultValue);&#13;
            case "SQUEEZE_SUM": return presenter.calculateValue(parseInt((a + b + c) / 3, 10), collection.values, defaultValue);&#13;
            case "SQUEEZE_MAX": return presenter.calculateValue(Math.max(a, b, c), collection.values, defaultValue);&#13;
            case "PRESSURE": return presenter.calculateValue(p, collection.values, defaultValue);&#13;
            case "ALL": return presenter.calculateValue(parseInt((a + b + c + p)/ 3, 10), collection.values, defaultValue);&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function getColor(a, b, c, p) {&#13;
        return getValue(a, b, c, p, presenter.configuration.colors, "#000000");&#13;
    }&#13;
&#13;
    function getOpacity(a, b, c, p) {&#13;
        return getValue(a, b, c, p, presenter.configuration.opacity, 1);&#13;
    }&#13;
&#13;
    function getThickness(a, b, c, p) {&#13;
        return getValue(a, b, c, p, presenter.configuration.thickness, val.defaultThickness);&#13;
    }&#13;
&#13;
    function updateDrawingData(e) {&#13;
        var a, b, c, p;&#13;
        if (presenter.configuration.isSmartPen) {&#13;
            if (window.LearnPen === undefined) {&#13;
                presenter.drawingData.isDrawingOn = true;&#13;
                presenter.drawingData.pre_color = presenter.drawingData.color = "black";&#13;
                presenter.drawingData.thickness = 1;&#13;
            } else {&#13;
                a = parseInt(window.LearnPen.getA() / 10, 10);&#13;
                b = parseInt(window.LearnPen.getB() / 10, 10);&#13;
                c = parseInt(window.LearnPen.getC() / 10, 10);&#13;
                p = parseInt(window.LearnPen.getP() / 10, 10);&#13;
&#13;
                eventCreator(a, b, c, p);&#13;
&#13;
                if (areLimitsOk(a, b, c, p)) {&#13;
                    presenter.drawingData.isDrawingOn = true;&#13;
                    presenter.drawingData.pre_color = presenter.drawingData.color;&#13;
                    presenter.drawingData.color = presenter.hexToRGBA(getColor(a, b, c, p), getOpacity(a, b, c, p));&#13;
                    presenter.drawingData.thickness = getThickness(a, b, c, p);&#13;
                } else {&#13;
                    presenter.drawingData.isDrawingOn = false;&#13;
                    presenter.noDraw = true;&#13;
                }&#13;
            }&#13;
        } else {&#13;
            presenter.drawingData.pre_color = presenter.drawingData.color;&#13;
            if (presenter.data.isPencil) {&#13;
                presenter.drawingData.color = presenter.hexToRGBA(presenter.data.color, presenter.configuration.opacity);&#13;
            }&#13;
            presenter.drawingData.thickness = presenter.data.isPencil ? presenter.data.pencilThickness : presenter.data.eraserThickness;&#13;
        }&#13;
&#13;
        presenter.position.pre_x = presenter.position.x;&#13;
        presenter.position.pre_y = presenter.position.y;&#13;
&#13;
        if (MobileUtils.isEventSupported('touchstart')) {&#13;
            presenter.position.x = parseInt(event.changedTouches[0].pageX - $(presenter.data.canvas).offset().left, 10);&#13;
            presenter.position.y = parseInt(event.changedTouches[0].pageY - $(presenter.data.canvas).offset().top, 10);&#13;
        } else {&#13;
            presenter.position.x = parseInt((e.pageX - presenter.data.canvas.offset().left) / presenter.data.zoom, 10);&#13;
            presenter.position.y = parseInt((e.pageY - presenter.data.canvas.offset().top) / presenter.data.zoom, 10);&#13;
        }&#13;
    }&#13;
&#13;
    function resizeCanvas() {&#13;
        var con = presenter.$view.find('.drawing').parent();&#13;
        presenter.data.canvas[0].width = con.width() - 2;&#13;
        presenter.data.canvas[0].height = con.height();&#13;
    }&#13;
&#13;
    function fillCanvasWithColor() {&#13;
        if (presenter.configuration.backgroundColor !== "NO_BG") {&#13;
            presenter.data.context.fillStyle = presenter.configuration.backgroundColor;&#13;
            presenter.data.context.fillRect(0, 0, presenter.data.canvas[0].width, presenter.data.canvas[0].height);&#13;
        }&#13;
    }&#13;
&#13;
    function drawVerticalLineIfIsMirror() {&#13;
        if (presenter.configuration.isMirror) {&#13;
            var w = presenter.data.canvas[0].width;&#13;
&#13;
            presenter.data.context.beginPath();&#13;
            presenter.data.context.moveTo(w / 2, 0);&#13;
            presenter.data.context.lineTo(w / 2, presenter.data.canvas[0].height);&#13;
&#13;
            presenter.data.context.lineWidth = presenter.configuration.border;&#13;
            presenter.data.context.strokeStyle = 'black';&#13;
            presenter.data.context.stroke();&#13;
        }&#13;
    }&#13;
&#13;
    function createCanvas(isPreview) {&#13;
        presenter.data.isPencil = true;&#13;
        presenter.data.pencilThickness = presenter.configuration.thickness;&#13;
&#13;
        presenter.$view.find('.drawing').append("&lt;canvas class='canv'&gt;Canvas is not supported by your browser&lt;/canvas&gt;");&#13;
&#13;
        presenter.data.canvas = presenter.$view.find('canvas');&#13;
        presenter.data.context = presenter.data.canvas[0].getContext("2d");&#13;
&#13;
        presenter.$view.find('.drawing').css('opacity', presenter.configuration.opacity);&#13;
        resizeCanvas();&#13;
&#13;
        fillCanvasWithColor();&#13;
        drawVerticalLineIfIsMirror();&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.turnOnEventListeners();&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    }&#13;
&#13;
    function returnErrorObject(errorCode) {&#13;
        return { isValid: false, errorCode: errorCode };&#13;
    }&#13;
&#13;
    function returnCorrectObject(v) {&#13;
        return { isValid: true, value: v };&#13;
    }&#13;
&#13;
    presenter.SQ_LIMITS_INTERPRETATION = {&#13;
        'Separately': 'SEPARATELY',&#13;
        'Together': 'TOGETHER',&#13;
        DEFAULT: 'Separately'&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        F01: "Value range has to be between 0 and 100%",&#13;
        F02: "Range values has to be ascending",&#13;
&#13;
        S01: "Value sensor cannot be empty",&#13;
        S02: "Wrong sensor name",&#13;
&#13;
        C01: "Property colors cannot be empty",&#13;
        C02: "One of the value in property colors has wrong length in hex format, should be # and 6 digits [0 - F]",&#13;
        C03: "One of the value in property color has wrong color name",&#13;
&#13;
        T01: "Property thickness cannot be empty when SmartPen is on",&#13;
        T02: "Property thickness cannot be smaller than 1 and bigger then " + val.maxThickness,&#13;
&#13;
        O02: "Property opacity cannot be smaller than 0 and bigger than 1",&#13;
&#13;
        SQL01: "Wrong amount of values in property squeeze limits",&#13;
        SQL02: "Values in property squeeze limits must be numeric",&#13;
        SQL03: "2nd value in property squeeze limits cannot be smaller than 1st",&#13;
        SQL04: "Values in property squeeze limits cannot be smaller than 0",&#13;
        SQL05: "Values in property squeeze limits cannot be bigger than 100",&#13;
&#13;
        PL01: "Wrong amount of numbers in property pressure limits",&#13;
        PL02: "Values in Property pressure limits must be numeric",&#13;
        PL03: "2nd value in property pressure limits cannot be smaller than 1st",&#13;
        PL04: "Values in property pressure limits cannot be smaller than 0",&#13;
        PL05: "Values in property pressure limits cannot be bigger than 100",&#13;
&#13;
        E01: "Value in property Events cannot be different then 0 or 1",&#13;
        E02: "Score in property Events cannot be different then 0 or 1",&#13;
&#13;
        RS02: "Wrong amount of numbers in Reaction scope in Events property",&#13;
        RS03: "Values in Reaction scope in Events property must be numeric",&#13;
        RS04: "2nd value in Reaction scope in Events property cannot be smaller than 1st",&#13;
        RS05: "Values in Reaction scope in Events property cannot be smaller than 0",&#13;
        RS06: "Values in Reaction scope in Events property cannot be bigger than 100",&#13;
&#13;
        B02: "Property border cannot be smaller than 0",&#13;
        B03: "Property border cannot be bigger than 5"&#13;
    };&#13;
&#13;
    function addPointsToHistory(x, y) {&#13;
        presenter.data.allPoints.push({x: x, y: y});&#13;
    }&#13;
&#13;
    function sendEvent() {&#13;
        function round(num, x) {&#13;
            x = Math.pow(10, x);&#13;
            return Math.round(num * x) / x;&#13;
        }&#13;
&#13;
        var distance = 0;&#13;
&#13;
        for (var i = 0; i &lt; presenter.data.allPoints.length-1; i++) {&#13;
            distance += Math.sqrt(Math.pow(presenter.data.allPoints[i].x - presenter.data.allPoints[i+1].x, 2) + Math.pow(presenter.data.allPoints[i].y - presenter.data.allPoints[i+1].y, 2));&#13;
        }&#13;
&#13;
        if (presenter.data.allPoints.length !== 0) {&#13;
            eventBus.sendEvent('ItemReturned', {&#13;
                'source': presenter.configuration.id,&#13;
                'item': presenter.data.lineCounter++,&#13;
                'value': round(distance, 2),&#13;
                'score': presenter.mouseleave || presenter.noDraw ? '0' : '1'&#13;
            });&#13;
        }&#13;
&#13;
        presenter.data.allPoints = [];&#13;
    }&#13;
&#13;
    presenter.turnOnEventListeners = function() {&#13;
        var canvas = presenter.data.canvas,&#13;
            ctx = presenter.data.context,&#13;
            isDown = false;&#13;
&#13;
        ctx.lineJoin = 'round';&#13;
        ctx.lineCap = 'round';&#13;
&#13;
        // TOUCH events&#13;
        if (MobileUtils.isEventSupported('touchstart')) {&#13;
            canvas.on('touchend', function() {&#13;
                canvas.off('touchmove', presenter.onPainting);&#13;
                sendEvent();&#13;
                setOverflowWorkAround(false);&#13;
            });&#13;
&#13;
            canvas.on('touchstart', function(e) {&#13;
                presenter.data.isStarted = true;&#13;
                presenter.noDraw = false;&#13;
&#13;
                updateZoomMultiplier();&#13;
                presenter.drawPoint();&#13;
                canvas.on('touchmove', presenter.onPainting);&#13;
                setOverflowWorkAround(true);&#13;
            });&#13;
        } else { // MOUSE events&#13;
            canvas.on('mouseup', function() {&#13;
                canvas.off('mousemove', presenter.onPainting);&#13;
&#13;
                sendEvent();&#13;
                isDown = false;&#13;
                presenter.mouseleave = false;&#13;
                setOverflowWorkAround(false);&#13;
            });&#13;
&#13;
            canvas.on('mouseleave', function() {&#13;
                canvas.off('mousemove', presenter.onPainting);&#13;
&#13;
                if(isDown) {&#13;
                    sendEvent();&#13;
                    isDown = false;&#13;
                    presenter.mouseleave = true;&#13;
                }&#13;
                setOverflowWorkAround(false);&#13;
            });&#13;
&#13;
            canvas.on('mousedown', function(e) {&#13;
                //updateDrawingData(e);&#13;
                presenter.data.isStarted = true;&#13;
                presenter.noDraw = false;&#13;
                isDown = true;&#13;
&#13;
                updateZoomMultiplier();&#13;
                presenter.drawPoint(e);&#13;
&#13;
                canvas.on('mousemove', presenter.onPainting);&#13;
                setOverflowWorkAround(true);&#13;
            });&#13;
        }&#13;
&#13;
        function createGradient(pre_x, pre_y, x, y) {&#13;
            var grad = presenter.data.context.createLinearGradient(pre_x, pre_y, x, y);&#13;
&#13;
            grad.addColorStop(0, presenter.data.isPencil ? presenter.drawingData.pre_color : "rgba(0,0,0,1)");&#13;
            grad.addColorStop(1, presenter.data.isPencil ? presenter.drawingData.color : "rgba(0,0,0,1)");&#13;
&#13;
            return grad;&#13;
        }&#13;
&#13;
        presenter.onPainting = function(e) {&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
            updateDrawingData(e);&#13;
&#13;
            if (presenter.drawingData.isDrawingOn) {&#13;
                updateZoomMultiplier();&#13;
                addPointsToHistory(presenter.position.x, presenter.position.y);&#13;
                ctx.lineWidth = presenter.drawingData.thickness;&#13;
&#13;
                ctx.beginPath();&#13;
                ctx.moveTo(presenter.position.pre_x, presenter.position.pre_y);&#13;
                ctx.lineTo(presenter.position.x, presenter.position.y);&#13;
                ctx.strokeStyle = createGradient(presenter.position.pre_x, presenter.position.pre_y, presenter.position.x, presenter.position.y);&#13;
                ctx.stroke();&#13;
&#13;
                if (presenter.configuration.isMirror) {&#13;
                    var w = presenter.data.canvas[0].width - presenter.position.x;&#13;
                    var pre_w = presenter.data.canvas[0].width - presenter.position.pre_x;&#13;
&#13;
                    ctx.beginPath();&#13;
                    ctx.moveTo(pre_w, presenter.position.pre_y);&#13;
                    ctx.lineTo(w, presenter.position.y);&#13;
                    ctx.strokeStyle = createGradient(pre_w, presenter.position.pre_y, w, presenter.position.y);&#13;
                    ctx.stroke();&#13;
                }&#13;
            }&#13;
        };&#13;
&#13;
        presenter.drawPoint = function(e) {&#13;
            updateDrawingData(e);&#13;
&#13;
            if (presenter.drawingData.isDrawingOn) {&#13;
                ctx.lineWidth = presenter.drawingData.thickness;&#13;
&#13;
                ctx.beginPath();&#13;
                ctx.moveTo(presenter.position.x, presenter.position.y);&#13;
                ctx.lineTo(presenter.position.x+1, presenter.position.y);&#13;
                ctx.strokeStyle = createGradient(presenter.position.x, presenter.position.y, presenter.position.x+1, presenter.position.y);&#13;
                ctx.stroke();&#13;
&#13;
                if (presenter.configuration.isMirror) {&#13;
                    var w = presenter.data.canvas[0].width - presenter.position.x;&#13;
&#13;
                    ctx.beginPath();&#13;
                    ctx.moveTo(w, presenter.position.y);&#13;
                    ctx.lineTo(w, presenter.position.y+1);&#13;
                    ctx.strokeStyle = createGradient(w+1, presenter.position.y, w, presenter.position.y);&#13;
                    ctx.stroke();&#13;
                }&#13;
            }&#13;
        };&#13;
&#13;
        canvas.on("click", function() {&#13;
            event.stopPropagation();&#13;
        });&#13;
    };&#13;
&#13;
    function prepareFunctionsValues(fun) {&#13;
        fun = Helpers.splitLines(fun);&#13;
        var sensor = fun[0].toUpperCase();&#13;
        var parsedValues = [];&#13;
&#13;
        if (val.sensors.indexOf(sensor) === -1) {&#13;
            return returnErrorObject("S02");&#13;
        }&#13;
&#13;
        var values = fun.slice(1);&#13;
&#13;
        var previousNumber = 0;&#13;
        for (var i=0; i&lt;values.length; i++) {&#13;
            var tmp = values[i].split("%");&#13;
            var number = parseInt(tmp[0].trim(), 10);&#13;
&#13;
            if (number &lt; 0 || number &gt; 100) {&#13;
                return returnErrorObject("F01");&#13;
            }&#13;
&#13;
            if (previousNumber &gt;= number) {&#13;
                return returnErrorObject("F02")&#13;
            }&#13;
&#13;
            parsedValues.push([number, tmp[1].trim()]);&#13;
            previousNumber = number;&#13;
        }&#13;
&#13;
        return returnCorrectObject({&#13;
            sensor: sensor,&#13;
            values: parsedValues&#13;
        });&#13;
    }&#13;
&#13;
    presenter.parseColors = function(colors, isLearnPen) {&#13;
        function checkColor(colors) {&#13;
            if (colors[0] === '#' &amp;&amp; !(colors.length === 7 || colors.length === 4)) {&#13;
                return returnErrorObject("C02");&#13;
            }&#13;
&#13;
            if (colors[0] !== '#') {&#13;
                colors = presenter.colourNameToHex(colors);&#13;
&#13;
                if (!colors) {&#13;
                    return returnErrorObject("C03");&#13;
                }&#13;
            }&#13;
&#13;
            return returnCorrectObject(colors);&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(colors)) {&#13;
            return returnErrorObject("C01");&#13;
        }&#13;
&#13;
        if (isLearnPen) {&#13;
&#13;
            var parsedFunction = prepareFunctionsValues(colors);&#13;
            if (!parsedFunction.isValid) {&#13;
                return returnErrorObject(parsedFunction.errorCode);&#13;
            }&#13;
&#13;
            for (var i=0; i&lt;parsedFunction.value.values.length; i++) {&#13;
                var localColor = parsedFunction.value.values[i][1];&#13;
                var checked = checkColor(localColor);&#13;
                if (!checked.isValid) {&#13;
                    return returnErrorObject(checked.errorCode);&#13;
                }&#13;
                parsedFunction.value.values[i][1] = checked.value;&#13;
            }&#13;
&#13;
            return returnCorrectObject({&#13;
                sensor: parsedFunction.value.sensor,&#13;
                values: parsedFunction.value.values&#13;
            });&#13;
        } else {&#13;
            return checkColor(colors);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.parseThickness = function(thickness, isSmartPen) {&#13;
        if (ModelValidationUtils.isStringEmpty(thickness)) {&#13;
            return isSmartPen ? returnErrorObject("T01") : returnCorrectObject(val.defaultThickness);&#13;
        }&#13;
&#13;
        if (isSmartPen) {&#13;
            var parsedFunction = prepareFunctionsValues(thickness);&#13;
            if (!parsedFunction.isValid) {&#13;
                return returnErrorObject(parsedFunction.errorCode);&#13;
            }&#13;
&#13;
            for (var i=0; i&lt;parsedFunction.value.values.length; i++) {&#13;
                var localThickness = parsedFunction.value.values[i][1];&#13;
                if (1 &gt; localThickness || localThickness &gt; val.maxThickness) {&#13;
                    return returnErrorObject("T02");&#13;
                }&#13;
            }&#13;
&#13;
            return returnCorrectObject({&#13;
                sensor: parsedFunction.value.sensor,&#13;
                values: parsedFunction.value.values //.map(function(a) { return [a[0], parseInt(a[1], 10)]; }) // parse 2nd value to integer&#13;
            });&#13;
        } else {&#13;
            thickness = parseInt(thickness, 10);&#13;
            if (1 &gt; thickness || thickness &gt; val.maxThickness) {&#13;
                return returnErrorObject("T02");&#13;
            }&#13;
            return returnCorrectObject(thickness);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.parseOpacity = function(opacity, isSmartPen) {&#13;
        if (ModelValidationUtils.isStringEmpty(opacity)) {&#13;
            return returnCorrectObject(isSmartPen ? { sensor: "ALL", values: [[100, 1]] } : 1);&#13;
        }&#13;
&#13;
        if (isSmartPen) {&#13;
            var parsedFunction = prepareFunctionsValues(opacity);&#13;
            if (!parsedFunction.isValid) {&#13;
                return returnErrorObject(parsedFunction.errorCode);&#13;
            }&#13;
&#13;
            for (var i=0; i&lt;parsedFunction.value.values.length; i++) {&#13;
                var localOpacity = parsedFunction.value.values[i][1];&#13;
                if (0 &gt; localOpacity || localOpacity &gt; 1) {&#13;
                    return returnErrorObject("O02");&#13;
                }&#13;
            }&#13;
&#13;
            return returnCorrectObject({&#13;
                sensor: parsedFunction.value.sensor,&#13;
                values: parsedFunction.value.values.map(function(a) { return [a[0], parseFloat(a[1])]; }) // parse 2nd value to float&#13;
            });&#13;
        } else {&#13;
            if (0 &gt; opacity || opacity &gt; 1) {&#13;
                return returnErrorObject("O02");&#13;
            }&#13;
&#13;
            return returnCorrectObject(opacity);&#13;
        }&#13;
    };&#13;
&#13;
    function parseRange(range, code) {&#13;
        function isNumber(n) {&#13;
            return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n);&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(range)) {&#13;
            return returnCorrectObject([0, 100]);&#13;
        }&#13;
&#13;
        range = range.split(';').map($.trim).map(parseFloat);&#13;
        range = range.length === 1 ? [0].concat(range) : range;&#13;
&#13;
        if (range.length !== 2) {&#13;
            return returnErrorObject(code + '01');&#13;
        }&#13;
&#13;
        if (!isNumber(range[0]) || !isNumber(range[1])) {&#13;
            return returnErrorObject(code + '02');&#13;
        }&#13;
&#13;
        if (range[0] &gt;= range[1]) {&#13;
            return returnErrorObject(code + '03');&#13;
        }&#13;
&#13;
        if (range[0] &lt; 0 || range[1] &lt; 0) {&#13;
            return returnErrorObject(code + '04');&#13;
        }&#13;
&#13;
        if (range[0] &gt; 100 || range[1] &gt; 100) {&#13;
            return returnErrorObject(code + '05');&#13;
        }&#13;
&#13;
        return returnCorrectObject(range);&#13;
    }&#13;
&#13;
    presenter.parseSqueeze = function(crush) {&#13;
        return parseRange(crush, 'SQL');&#13;
    };&#13;
&#13;
    presenter.parsePressure = function(pressure) {&#13;
        return parseRange(pressure, 'PL');&#13;
    };&#13;
&#13;
    presenter.parseEvents = function(events) {&#13;
        function isEventEmpty(eventData) {&#13;
            return ModelValidationUtils.isStringEmpty(eventData["Sensor"]) &amp;&amp;&#13;
                ModelValidationUtils.isStringEmpty(eventData["Reaction scope"]) &amp;&amp;&#13;
                ModelValidationUtils.isStringEmpty(eventData["Item"]) &amp;&amp;&#13;
                ModelValidationUtils.isStringEmpty(eventData["Value"]) &amp;&amp;&#13;
                ModelValidationUtils.isStringEmpty(eventData["Score"]);&#13;
        }&#13;
&#13;
        if (isEventEmpty(events[0])) {&#13;
            return returnCorrectObject([]);&#13;
        }&#13;
&#13;
        var eventsArray = [];&#13;
&#13;
        for (var i=0; i&lt;events.length; i++) {&#13;
            var sensor = events[i]["Sensor"];&#13;
            if (ModelValidationUtils.isStringEmpty(sensor)) {&#13;
                return returnErrorObject("S01");&#13;
            }&#13;
            if (val.sensors.indexOf(sensor) === -1) {&#13;
                return returnErrorObject("S02");&#13;
            }&#13;
&#13;
            var reactionScope = events[i]["Reaction scope"];&#13;
            var parsedReactionScope = parseRange(reactionScope, "RS");&#13;
            if (!parsedReactionScope.isValid) {&#13;
                return returnErrorObject(parsedReactionScope.errorCode);&#13;
            }&#13;
&#13;
            var value = events[i]["Value"];&#13;
            if (value !== '1' &amp;&amp; value !== '0') {&#13;
                return returnErrorObject("E01");&#13;
            }&#13;
&#13;
            var score = events[i]["Score"];&#13;
            if (score !== '1' &amp;&amp; score !== '0') {&#13;
                return returnErrorObject("E02");&#13;
            }&#13;
&#13;
            eventsArray.push({&#13;
                sensor: sensor,&#13;
                reactionScope: parsedReactionScope.value,&#13;
                item: events[i]["Item"],&#13;
                value: value,&#13;
                score: score&#13;
            });&#13;
        }&#13;
&#13;
        return returnCorrectObject(eventsArray);&#13;
    };&#13;
&#13;
    presenter.parseBGColor = function(color) {&#13;
        if (ModelValidationUtils.isStringEmpty(color)) {&#13;
            return returnCorrectObject("NO_BG");&#13;
        }&#13;
&#13;
        if (color[0] === '#' &amp;&amp; !(color.length === 7)) {&#13;
            return returnErrorObject('C02');&#13;
        }&#13;
&#13;
        if (color[0] !== '#') {&#13;
            color = presenter.colourNameToHex(color);&#13;
&#13;
            if (!color) {&#13;
                return returnErrorObject('C03');&#13;
            }&#13;
        }&#13;
&#13;
        return returnCorrectObject(color);&#13;
    };&#13;
&#13;
    presenter.parseBorder = function(border) {&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(border)) {&#13;
            return returnCorrectObject(0);&#13;
        }&#13;
&#13;
        if (border &lt; 0) {&#13;
            return returnErrorObject('B02');&#13;
        }&#13;
&#13;
        if (border &gt; 5) {&#13;
            return returnErrorObject('B03');&#13;
        }&#13;
&#13;
        return returnCorrectObject(border);&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var isSmartPen = ModelValidationUtils.validateBoolean(model["SmartPen"]);&#13;
&#13;
        var parsedColors = presenter.parseColors(model["Colors"], isSmartPen);&#13;
        if (!parsedColors.isValid) {&#13;
            return returnErrorObject(parsedColors.errorCode);&#13;
        }&#13;
&#13;
        var parsedThickness = presenter.parseThickness(model["Thickness"], isSmartPen);&#13;
        if (!parsedThickness.isValid) {&#13;
            return returnErrorObject(parsedThickness.errorCode);&#13;
        }&#13;
&#13;
        var parsedOpacity = presenter.parseOpacity(model["Opacity"], isSmartPen);&#13;
        if (!parsedOpacity.isValid) {&#13;
            return returnErrorObject(parsedOpacity.errorCode);&#13;
        }&#13;
&#13;
        var parsedSqueeze = presenter.parseSqueeze(model["Squeeze limits"]);&#13;
        if (!parsedSqueeze.isValid) {&#13;
            return returnErrorObject(parsedSqueeze.errorCode);&#13;
        }&#13;
&#13;
        var parsedPressure = presenter.parsePressure(model["Pressure limits"]);&#13;
        if (!parsedPressure.isValid) {&#13;
            return returnErrorObject(parsedPressure.errorCode);&#13;
        }&#13;
&#13;
        var parsedEvent = presenter.parseEvents(model["Events"]);&#13;
        if (!parsedEvent.isValid) {&#13;
            return returnErrorObject(parsedEvent.errorCode);&#13;
        }&#13;
&#13;
        var parsedBGColor = presenter.parseBGColor(model["Background color"]);&#13;
        if (!parsedBGColor.isValid) {&#13;
            return returnErrorObject(parsedBGColor.errorCode);&#13;
        }&#13;
&#13;
        return {&#13;
            isSmartPen: isSmartPen,&#13;
            colors: parsedColors.value, // if (isSmartPen) {sensor: String, values: [Integer, Hex color] } else String (hex color)&#13;
            thickness: parsedThickness.value, // if (isSmartPen) {sensor: String, thicknesses: [Integer, Integer] } else Integer&#13;
            opacity: parsedOpacity.value, // if (isSmartPen) {sensor: String, opacity: [Integer, Float] } else Float&#13;
            squeezeLimits: parsedSqueeze.value,&#13;
            squeezeLimitsInterpretation: ModelValidationUtils.validateOption(presenter.SQ_LIMITS_INTERPRETATION, model["Squeeze limits interpretation"]),&#13;
            pressureLimits: parsedPressure.value,&#13;
            events: parsedEvent.value,&#13;
            isMirror: ModelValidationUtils.validateBoolean(model["Mirror"]),&#13;
            backgroundColor: parsedBGColor.value,&#13;
&#13;
            width: model["Width"],&#13;
            height: model["Height"],&#13;
            id: model["ID"],&#13;
            isValid: true,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model["Is Visible"])&#13;
        };&#13;
    };&#13;
&#13;
    presenter.presenterLogic = function(view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.model = model;&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return false;&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isSmartPen) presenter.data.color = presenter.configuration.colors;&#13;
        presenter.data.pencilThickness = presenter.configuration.thickness;&#13;
        presenter.data.eraserThickness = presenter.configuration.thickness;&#13;
&#13;
        createCanvas(isPreview);&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return false;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
//    presenter.setShowErrorsMode = function() {};&#13;
//    presenter.setWorkMode = function() {};&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    presenter.reset = function() {&#13;
        presenter.$view.find('.canv').remove();&#13;
        createCanvas(false);&#13;
&#13;
        presenter.data.isStarted = false;&#13;
        presenter.data.lineCounter = 0;&#13;
    };&#13;
&#13;
//     presenter.getErrorCount = function() {};&#13;
//     presenter.getMaxScore = function() {};&#13;
//     presenter.getScore = function() {};&#13;
&#13;
    presenter.getState = function() {&#13;
        if (!presenter.data.isStarted) {&#13;
            return;&#13;
        }&#13;
&#13;
        var c = presenter.$view.find("canvas")[0];&#13;
&#13;
        return JSON.stringify({&#13;
            isPencil: presenter.data.isPencil,&#13;
            color: presenter.data.color,&#13;
            pencilThickness: presenter.data.pencilThickness,&#13;
            eraserThickness: presenter.data.eraserThickness,&#13;
            data: c.toDataURL("image/png"),&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function(state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var savedImg = new Image();&#13;
&#13;
        savedImg.onload = function() {&#13;
            presenter.data.context.drawImage(savedImg, 0, 0);&#13;
&#13;
            presenter.data.pencilThickness = JSON.parse(state).pencilThickness;&#13;
            presenter.data.eraserThickness = JSON.parse(state).eraserThickness;&#13;
            presenter.configuration.isVisible = JSON.parse(state).isVisible;&#13;
            presenter.data.isPencil = JSON.parse(state).isPencil;&#13;
            presenter.data.isStarted = true;&#13;
&#13;
            if (!presenter.configuration.isSmartPen) {&#13;
                if (presenter.data.isPencil) {&#13;
                    presenter.setColor(JSON.parse(state).color);&#13;
                } else {&#13;
                    presenter.setEraserOn();&#13;
                }&#13;
            }&#13;
        };&#13;
        savedImg.src = JSON.parse(state).data;&#13;
    };&#13;
&#13;
    presenter.setColor = function(color) {&#13;
        if (!presenter.configuration.isSmartPen) {&#13;
            presenter.data.isPencil = true;&#13;
            presenter.data.context.globalCompositeOperation = "source-over";&#13;
            presenter.data.color = presenter.parseColors(color, false).value;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setThickness = function(thickness) {&#13;
        if (!presenter.configuration.isSmartPen) {&#13;
            if (presenter.data.isPencil) {&#13;
                presenter.data.pencilThickness = thickness;&#13;
            } else {&#13;
                presenter.data.eraserThickness = thickness;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setEraserOn = function() {&#13;
        if (!presenter.configuration.isSmartPen) {&#13;
            presenter.data.isPencil = false;&#13;
            presenter.data.context.globalCompositeOperation = "destination-out";&#13;
            presenter.configuration.color = "rgba(255, 255, 255, 1)";&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isLearnPenConnected = function() {&#13;
        return window.LearnPen !== undefined&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>