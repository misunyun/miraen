<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Table" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Rows" nameLabel="Table_property_rows" type="string"/>
		<property name="Columns" nameLabel="Table_property_columns" type="string"/>
		<property isDefault="true" name="Table cells" nameLabel="Table_property_table_cells" type="list">
			<property name="Row" nameLabel="Table_property_row" type="string"/>
			<property name="Column" nameLabel="Table_property_column" type="string"/>
			<property isLocalized="true" name="Content" nameLabel="Table_property_content" type="html"/>
            <property name="CSS Class" nameLabel="Table_property_css_class" type="string"/>
            <property name="CSS Style" nameLabel="Table_property_css_style" type="string"/>
		</property>
		<property name="Columns width" nameLabel="Table_property_columns_width" type="list">
			<property name="Width" nameLabel="Table_property_width" type="string"/>
		</property>
		<property name="Rows height" nameLabel="Table_property_rows_height" type="list">
			<property name="Height" nameLabel="Table_property_height" type="string"/>
		</property>
		<property name="Is not an activity" nameLabel="Table_property_is_not_an_activity" type="boolean"/>
		<property name="Is disabled" nameLabel="Table_property_is_disabled" type="boolean"/>
		<property name="Case sensitive" nameLabel="Table_property_case_sensitive" type="boolean"/>
		<property name="useNumericKeyboard" nameLabel="Table_property_use_numeric_keyboard" type="boolean"/>
		<property name="Ignore punctuation" nameLabel="Table_property_ignore_punctuation" type="boolean"/>
		<property name="Gap width" nameLabel="Table_property_gap_width" type="string"/>
        <property name="Gap Type" nameLabel="Table_property_gap_type" type="{editable, draggable, math}"/>
		<property displayName="Gap max length" name="GapMaxLength" nameLabel="Table_property_gap_max_length" type="string" value="0"/>
		<property name="newWidthCalculate" nameLabel="Table_property_new_width_calculate" type="boolean"/>
		<property displayName="Lang attribute" name="langAttribute" nameLabel="Table_property_lang_attribute" type="string"/>
		<property displayName="Speech texts" name="speechTexts" nameLabel="Hierarchical_Lesson_Report_property_speech_texts" type="staticlist">

            <property name="Correct" nameLabel="choice_item_correct" type="staticrow">
                <property name="Correct" nameLabel="choice_item_correct" type="string"/>
            </property>

			<property name="Wrong" nameLabel="choice_item_wrong" type="staticrow">
                <property name="Wrong" nameLabel="choice_item__wrong" type="string"/>
            </property>

			<property name="Empty" nameLabel="choice_item_empty" type="staticrow">
                <property name="Empty" nameLabel="choice_item_empty" type="string"/>
            </property>

			<property name="Gap" nameLabel="choice_item_gap" type="staticrow">
                <property name="Gap" nameLabel="choice_item_gap" type="string"/>
            </property>

			<property name="Dropdown" nameLabel="choice_item_dropdown" type="staticrow">
                <property name="Dropdown" nameLabel="choice_item_dropdown" type="string"/>
            </property>

			<property name="Inserted" nameLabel="text_insert" type="staticrow">
                <property name="Inserted" nameLabel="text_insert" type="string"/>
            </property>

			<property name="Removed" nameLabel="text_removed" type="staticrow">
                <property name="Removed" nameLabel="text_removed" type="string"/>
            </property>

			<property name="Cell" nameLabel="Table_cell" type="staticrow">
                <property name="Cell" nameLabel="Table_cell" type="string"/>
            </property>

			<property name="Row" nameLabel="Table_row_speech_text" type="staticrow">
				<property name="Row" nameLabel="Table_row_speech_text" type="string"/>
			</property>

			<property name="Column" nameLabel="Table_column_speech_text" type="staticrow">
				<property name="Column" nameLabel="Table_column_speech_text" type="string"/>
			</property>

			<property name="RowSpan" nameLabel="Table_row_span_speech_text" type="staticrow">
				<property name="RowSpan" nameLabel="Table_row_span_speech_text" type="string"/>
			</property>

			<property name="ColSpan" nameLabel="Table_column_span_speech_text" type="staticrow">
				<property name="ColSpan" nameLabel="Table_column_span_speech_text" type="string"/>
			</property>

		</property>
		<property name="printable" nameLabel="printable_name_label" type="{No, Don't randomize, Randomize}"/>
		<property name="keepOriginalOrder" nameLabel="Table_property_keep_order" type="boolean"/>
		<property name="isSplitInPrintBlocked" nameLabel="printable_block_split_label" type="boolean"/>
		<property name="isFirstRowHeader" nameLabel="Table_property_first_row_is_header" type="boolean"/>
		<property name="isFirstColumnHeader" nameLabel="Table_property_first_column_is_header" type="boolean"/>
	</model>
<css>.table-addon-wrapper {&#13;
    border: 0;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    direction: ltr;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    direction: ltr;&#13;
}&#13;
&#13;
.table-addon-wrapper table {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    border-collapse: collapse;&#13;
    vertical-align: middle;&#13;
}&#13;
&#13;
.table-addon-wrapper table td {&#13;
    padding-left: 10px;&#13;
    padding-right: 10px;&#13;
    text-align: center;&#13;
    vertical-align: middle;&#13;
}&#13;
&#13;
.table-addon-wrapper table tr td {&#13;
    border: 1px solid black;&#13;
}&#13;
&#13;
.table-addon-wrapper .gapFilled{&#13;
    cursor: pointer;&#13;
}&#13;
&#13;
.table-addon-wrapper .draggable-gap{&#13;
    height: 20px;&#13;
    width: 40px;&#13;
}&#13;
&#13;
.printable_addon_Table .table-addon-wrapper {&#13;
    height: fit-content;&#13;
}&#13;
&#13;
.printable_addon_Table tbody tr:first-child {&#13;
    column-break-inside: avoid;&#13;
	-webkit-column-break-inside: avoid;&#13;
    column-break-after: avoid;&#13;
	-webkit-column-break-after: avoid;&#13;
}&#13;
&#13;
.printable_addon_Table .table-addon-wrapper .printable_gap {&#13;
    border-bottom: 1px solid;&#13;
}&#13;
.printable_addon_Table .table-addon-wrapper .printable_math_gap {&#13;
    margin: 1px 5px;&#13;
    padding: 0 5px;&#13;
}&#13;
&#13;
.printable_addon_Table .table-addon-wrapper .printable_gap_correct::after {&#13;
    content: " \2714";&#13;
}&#13;
&#13;
.printable_addon_Table .table-addon-wrapper .printable_gap_wrong::after {&#13;
    content: " \2716";&#13;
}&#13;
&#13;
.printable_addon_Table.printable_addon_Table-show-answers .table-addon-wrapper table tbody tr td {&#13;
    border: 1px black dashed;&#13;
}&#13;
&#13;
</css><view>&lt;div class="table-addon-wrapper"&gt;&lt;/div&gt;&#13;
</view><preview>&lt;div class="table-addon-wrapper"&gt;&lt;/div&gt;&#13;
</preview><presenter>function AddonTable_create() {&#13;
&#13;
    /*&#13;
        INTEGRATION WITH MATH MODULE:&#13;
            Table supports integration with Math module. Table which is not activity, will show answers provided by&#13;
            Math module. Requires implementation of methods and variables listed below.&#13;
&#13;
            Attributes:&#13;
                @param isConnectedWith {boolean}  required by Math module, to detect if table is connected with Math&#13;
&#13;
            Methods:&#13;
                presenter.setGapAnswer (gapIndex, answer, answersLength) - method used by Math to set gap answer at&#13;
                    show answers when table is not activity. Gap index based by DOM occurence order. 1-n based&#13;
&#13;
                presenter.setUserValue (gapIndex, value) - method used by Math module to restore user answer at hide answers&#13;
&#13;
                presenter.getValue (gapIndex) - method used by Math module to get user value in gap by index&#13;
&#13;
                presenter.isActivity - method used by Math module to determine if addon is activity&#13;
     */&#13;
&#13;
&#13;
    var presenter = function () {&#13;
    };&#13;
&#13;
    var isConnectedWithMath = false;&#13;
    presenter.gapsSize = [];&#13;
    presenter.isSetShowErrorsMode = false;&#13;
    presenter.keyboardControllerObject = null;&#13;
    presenter.isWCAGOn = false;&#13;
    presenter.gapNavigation = false;&#13;
    presenter.addonKeyboardNavigationActive = false;&#13;
    presenter.gapIndex = 0;&#13;
    presenter.isGradualShowAnswersActive = false;&#13;
    presenter.printableState = null;&#13;
    presenter.printableStateMode = null;&#13;
    presenter.printableParserID = null;&#13;
    presenter.printableParserCallback = null;&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'RW_01': 'Number of rows must be a positive integer!',&#13;
        'CL_01': 'Number of columns must be a positive integer!',&#13;
        'CO_01': 'Row number must be a positive integer!',&#13;
        'CO_02': 'Column number must be a positive integer',&#13;
        'CO_03': 'Row number must be a number from 1 to rows count!',&#13;
        'CO_04': 'Column number must be a number from 1 to columns count',&#13;
        'CO_05': 'Each table cell can be defined only once!',&#13;
        'CO_06': 'Empty table cell definition must contain only one empty element!',&#13;
        'CR_00': 'Column and row numbers must be sequential within one table cell',&#13;
        'CW_01': "Number of items in 'Columns width' property cannot be higher than number of columns!",&#13;
        'RH_01': "Number of items in 'Rows height' property cannot be higher than number of rows!",&#13;
        'GW_01': "Gap width incorrect!"&#13;
    };&#13;
&#13;
    presenter.replaceGapID = function (gap, parsedText) {&#13;
        var gapID = presenter.configuration.addonID + gap.id;&#13;
        var patt = new RegExp("id=\"" + gap.id + "\"");&#13;
        var rep = "id=\"" + gapID + "\"";&#13;
        return  parsedText.replace(patt, rep);&#13;
    };&#13;
&#13;
    function getParsedHTMLView () {&#13;
        return presenter.textParser.parseGaps(presenter.$view.html(),&#13;
            {&#13;
                isCaseSensitive: presenter.configuration.isCaseSensitive,&#13;
                isKeepOriginalOrder: presenter.configuration.keepOriginalOrder&#13;
            }&#13;
        );&#13;
    }&#13;
&#13;
    presenter.parseGaps = function (isPreview) {&#13;
        if (presenter.configuration.gapType === "draggable") {&#13;
            return presenter.parseGapsWrapper(presenter.DraggableDroppableGap, isPreview);&#13;
        } else {&#13;
            return presenter.parseGapsWrapper(presenter.EditableInputGap, isPreview);&#13;
        }&#13;
    };&#13;
&#13;
    function changeInlineGapsIDs (inlineGaps, parsedText) {&#13;
        inlineGaps.forEach(function (gap) {&#13;
            parsedText = presenter.replaceGapID(gap, parsedText);&#13;
            var gapID = presenter.configuration.addonID + gap.id;&#13;
&#13;
            presenter.gapsContainer.addGap(new presenter.SelectGap(gapID, [gap.answer], gap.value));&#13;
        });&#13;
&#13;
        return parsedText;&#13;
    }&#13;
&#13;
    function changeSimpleGapsIDs (simpleGaps, parsedText, objectType) {&#13;
        simpleGaps.forEach(function (gap) {&#13;
            parsedText = presenter.replaceGapID(gap, parsedText);&#13;
            var gapID = presenter.configuration.addonID + gap.id;&#13;
            presenter.gapsContainer.addGap(new objectType(gapID, gap.answers, 1));&#13;
        });&#13;
&#13;
        return parsedText;&#13;
    }&#13;
&#13;
    presenter.parseGapsWrapper = function (objectType, isPreview) {&#13;
        var textParserResult = getParsedHTMLView();&#13;
&#13;
        var parsedText = textParserResult.parsedText;&#13;
        parsedText = changeSimpleGapsIDs(textParserResult.gaps, parsedText, objectType);&#13;
        parsedText = changeInlineGapsIDs(textParserResult.inLineGaps, parsedText, objectType);&#13;
&#13;
        presenter.$view.html(parsedText);&#13;
&#13;
        if(!isPreview){&#13;
            presenter.getInputsSize();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getInputsSize = function () {&#13;
        presenter.$view.find('input').each(function () {&#13;
            var inputID = $(this).attr('id'),&#13;
                inputSize = $(this).attr('size');&#13;
&#13;
            presenter.gapsSize.push({id : inputID, size: inputSize})&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setGapsClassAndWidth = function () {&#13;
        presenter.$view.find('.ic_inlineChoice').addClass('ic_gap');&#13;
        presenter.$view.find('.ic_inlineChoice').css('width', presenter.configuration.gapWidth.value+"px");&#13;
    };&#13;
&#13;
    presenter.initializeGaps = function (isPreview) {&#13;
        presenter.parseGaps(isPreview);&#13;
&#13;
        if (presenter.hasMathGaps()){&#13;
            presenter.gapsContainer.gaps = [];&#13;
            $(presenter.$view).find('input').each(function () {&#13;
                $(this).replaceWith(&#13;
                    generateMathGap(&#13;
                        window.xssUtils.sanitize($(this).attr('id')),&#13;
                        presenter.configuration.gapWidth.value&#13;
                    )&#13;
                );&#13;
            });&#13;
        }&#13;
&#13;
        presenter.gapsContainer.replaceDOMViewWithGap();&#13;
        presenter.gapsContainer.updateGapMaxLength();&#13;
        presenter.setGapsClassAndWidth();&#13;
        presenter.gapsContainer.addMaxLengthParamToGaps();&#13;
    };&#13;
&#13;
    /**&#13;
     * String generated by this function can be replaced by MathJax to input.&#13;
     * See media/js/forminput.js&#13;
     * @param id&#13;
     * @param width&#13;
     */&#13;
    function generateMathGap(id, width) {&#13;
        return `\\gap{${id}|1|${width}|{{value:${id}}}}`;&#13;
    }&#13;
&#13;
    function deleteCommands () {&#13;
        delete presenter.getScore;&#13;
        delete presenter.getMaxScore;&#13;
        delete presenter.getState;&#13;
        delete presenter.setState;&#13;
        delete presenter.getGapTextCommand;&#13;
        delete presenter.getGapTextCommand;&#13;
        delete presenter.setGapTextCommand;&#13;
        delete presenter.markGapAsEmptyCommand;&#13;
        delete presenter.markGapAsCorrectCommand;&#13;
        delete presenter.markGapAsWrongCommand;&#13;
        delete presenter.enableGapCommand;&#13;
        delete presenter.enableAllGaps;&#13;
        delete presenter.disableGapCommand;&#13;
        delete presenter.disableAllGaps;&#13;
        delete presenter.isAttempted;&#13;
    }&#13;
&#13;
    function replaceInputsInPreview () {&#13;
        if (presenter.configuration.gapType === "draggable") {&#13;
            var inputs = presenter.$wrapper.find("input");&#13;
&#13;
            for (var i = 0; i &lt; inputs.length; i++) {&#13;
                $(inputs[i]).replaceWith(presenter.DraggableDroppableGap.prototype.createView());&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.logic = function (view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.$wrapper = presenter.$view.find('.table-addon-wrapper');&#13;
        presenter.configuration = presenter.validateModel(presenter.upgradeModel(model));&#13;
        presenter.isPreview = isPreview;&#13;
&#13;
        if (presenter.hasMathGaps()){&#13;
            var mathJaxDeferred = new jQuery.Deferred();&#13;
            presenter.mathJaxProcessEndedDeferred = mathJaxDeferred;&#13;
            presenter.mathJaxProcessEnded = mathJaxDeferred.promise();&#13;
&#13;
            MathJax.Hub.Register.MessageHook("End Process", function (message) {&#13;
                if ($(message[1]).hasClass('ic_page')) {&#13;
                    presenter.mathJaxProcessEndedDeferred.resolve();&#13;
                }&#13;
            });&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            deleteCommands();&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.mainLogic(isPreview);&#13;
&#13;
        if (presenter.hasMathGaps()){&#13;
            presenter.mathJaxProcessEnded.then(function() {&#13;
                MathJax.CallBack.Queue().Push(function () {&#13;
                    if(!isPreview){&#13;
                        presenter.renderMathJax();&#13;
                        presenter.keyboardControllerObject.setElements(presenter.getElementsForKeyboardNavigation());&#13;
                        var checkSelector = setInterval(function () {&#13;
                            if ($(presenter.$view).find('input').length &gt; 0) {&#13;
                                presenter.gapsContainer.gaps = [];&#13;
                                $(presenter.$view).find('input').each(function (_, index) {&#13;
                                    for(var i = 0; i &lt; presenter.gapsAnswers.length; i++){&#13;
                                        if(presenter.gapsAnswers[i].id === $(this).attr('id')){&#13;
                                            var correctAnswers = presenter.gapsAnswers[i].answers;&#13;
                                        }&#13;
                                    }&#13;
                                    presenter.gapsContainer.addGap(new presenter.EditableInputGap($(this).attr('id'), correctAnswers, 1));&#13;
                                });&#13;
                                clearInterval(checkSelector);&#13;
                                presenter.eventBus.sendEvent('ValueChanged', []);&#13;
                            }&#13;
                        }, 100);&#13;
                    }&#13;
                });&#13;
            });&#13;
        }&#13;
&#13;
        if(isPreview) {&#13;
            presenter.setEditorGapWidth();&#13;
        } else {&#13;
            presenter.setInputsSize();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setInputsSize = function () {&#13;
        for (var i = 0; i &lt; presenter.gapsSize.length; i++) {&#13;
            var inputId = presenter.gapsSize[i].id,&#13;
                size = presenter.gapsSize[i].size;&#13;
&#13;
            presenter.$view.find('#'+inputId).attr('size', size);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setEditorGapWidth = function () {&#13;
        presenter.$view.find('input').css("width", presenter.configuration.gapWidth.value+"px");&#13;
        presenter.$view.find('span').css("width", presenter.configuration.gapWidth.value+"px");&#13;
    };&#13;
&#13;
    presenter.mainLogic = function (isPreview) {&#13;
        presenter.gapsContainer = new presenter.GapsContainerObject();&#13;
&#13;
        var $table = presenter.generateTable(presenter.configuration.contents, isPreview);&#13;
        presenter.setColumnWidth($table, presenter.configuration.columnsWidths, presenter.configuration.rowsHeights);&#13;
        presenter.setRowHeight($table, presenter.configuration.rowsHeights);&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        presenter.initializeGaps(isPreview);&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.parseDefinitionLinks();&#13;
        } else {&#13;
            replaceInputsInPreview();&#13;
            presenter.setGapsClassAndWidth();&#13;
            presenter.$view.find('input').attr("size", "auto");&#13;
            if (presenter.configuration.gapType === "draggable") {&#13;
                presenter.$view.find('input').addClass("draggable-gap");&#13;
            }&#13;
        }&#13;
&#13;
        presenter.gapsContainer.replaceGapsDOMWithView();&#13;
        presenter.lastDraggedItem = {};&#13;
&#13;
        if (presenter.configuration.isDisabledByDefault) {&#13;
            presenter.gapsContainer.lockAllGaps();&#13;
        }&#13;
&#13;
        presenter.buildKeyboardController();&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.textParser = new TextParserProxy(controller.getTextParser());&#13;
&#13;
    };&#13;
&#13;
    presenter.setEventBus = function (eventBus) {&#13;
        presenter.eventBus = eventBus;&#13;
&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
        presenter.eventBus.addEventListener('ItemSelected', this);&#13;
        presenter.eventBus.addEventListener('ItemConsumed', this);&#13;
        presenter.eventBus.addEventListener('GradualShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('GradualHideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.setTextParser = function (textParser) {&#13;
        presenter.textParser = new TextParserProxy(textParser());&#13;
    };&#13;
&#13;
    presenter.getSelectedItem = function () {&#13;
        var item = presenter.lastDraggedItem;&#13;
&#13;
        presenter.lastDraggedItem = {};&#13;
&#13;
        return item;&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.logic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.logic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.gapsContainer.reset();&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.isSetShowErrorsMode = false;&#13;
        presenter.attemptedGaps = [];&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        var spans;&#13;
        var gaps = presenter.gapsContainer.getGapsState();&#13;
&#13;
        if (presenter.configuration.gapType === "draggable") {&#13;
            spans = presenter.gapsContainer.getState();&#13;
        } else {&#13;
            spans = null;&#13;
        }&#13;
&#13;
        return JSON.stringify({&#13;
            gaps: gaps,&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            spans: spans&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (rawState) {&#13;
        var state = JSON.parse(rawState);&#13;
&#13;
        presenter.setVisibility(state.isVisible);&#13;
        presenter.configuration.isVisible = state.isVisible;&#13;
        presenter.attemptedGaps = state.attemptedGaps === undefined ? presenter.attemptedGaps : state.attemptedGaps;&#13;
&#13;
        if (presenter.hasMathGaps()) {&#13;
            var checkSelector = setInterval(&#13;
                function () {&#13;
                    if ($(presenter.$view).find('.mathGap').length === presenter.gapsAnswers.length) {&#13;
                        try{&#13;
                            presenter.gapsContainer.setGapsState(state.gaps);&#13;
                            presenter.gapsContainer.setSpansState(state.spans);&#13;
                            clearInterval(checkSelector);&#13;
                        } catch (e) { }&#13;
                    }&#13;
                }, 100);&#13;
        } else {&#13;
            presenter.gapsContainer.setGapsState(state.gaps);&#13;
            presenter.gapsContainer.setSpansState(state.spans);&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Generate table row (tr) element. Each cell has col_C and row_R classes where R is row number&#13;
     * (counted from 1 to rows count) and C is column number (from 1 to columns count).&#13;
     *&#13;
     * @param row row number counted from 0&#13;
     * @param content row content array&#13;
     * @param isPreview&#13;
     *&#13;
     * @return {jQuery} jQuery reference to new table row element&#13;
     */&#13;
    presenter.generateRow = function (row, content, isPreview) {&#13;
        var $rowElement = $(document.createElement('tr')), i, length;&#13;
&#13;
        for (i = 0, length = content.length; i &lt; length; i++) {&#13;
            if (!content[i]) continue;&#13;
&#13;
            var $element;&#13;
            if ((row === 0 &amp;&amp; presenter.configuration.isFirstRowHeader) ||&#13;
                (i === 0 &amp;&amp; presenter.configuration.isFirstColumnHeader)) {&#13;
                $element = $(document.createElement('th'));&#13;
            } else {&#13;
                $element = $(document.createElement('td'));&#13;
            }&#13;
&#13;
            $element.addClass('table_cell');&#13;
            $element.addClass('row_' + (row + 1));&#13;
            $element.addClass('col_' + (i + 1));&#13;
            $element.html(content[i].content);&#13;
            $element.attr({&#13;
                colspan: content[i].colSpan,&#13;
                rowspan: content[i].rowSpan&#13;
            });&#13;
&#13;
            if ( presenter.configuration.isTabindexEnabled) {&#13;
                $element.attr('tabindex', '0');&#13;
            }&#13;
&#13;
            if (content[i].class) {&#13;
                $element.addClass(content[i].class)&#13;
            }&#13;
            if (content[i].style) {&#13;
                $element.attr({style:content[i].style})&#13;
            }&#13;
&#13;
            $rowElement.append($element);&#13;
        }&#13;
&#13;
        return $rowElement;&#13;
    };&#13;
&#13;
    presenter.parseDefinitionLinks = function () {&#13;
        $.each(presenter.$view.find('.table_cell'), function (index, element) {&#13;
            const sanitizedLink = window.xssUtils.sanitize(presenter.textParser.parse($(element).html()));&#13;
            $(element).html(sanitizedLink);&#13;
        });&#13;
&#13;
        presenter.textParser.connectLinks(presenter.$view);&#13;
    };&#13;
&#13;
    /**&#13;
     * Generate table element with content based on provided array.&#13;
     *&#13;
     * @param content array with table cells contents&#13;
     * @param isPreview&#13;
     *&#13;
     * @return {jQuery} jQuery reference to new table element&#13;
     */&#13;
    presenter.generateTable = function (content, isPreview) {&#13;
        var $table = $(document.createElement('table'));&#13;
&#13;
        for (var i = 0, length = content.length; i &lt; length; i++) {&#13;
            var $row = presenter.generateRow(i, content[i], isPreview);&#13;
&#13;
            $table.append($row);&#13;
        }&#13;
&#13;
        presenter.$wrapper.html($table);&#13;
&#13;
        return $table;&#13;
    };&#13;
&#13;
    presenter.setColumnWidth = function ($table, columnWidth, rowsHeights) {&#13;
        var i = 0;&#13;
        if (presenter.configuration.newWidthCalculate) {&#13;
            var rowsNumber = rowsHeights.length;&#13;
            var columsNumber = columnWidth.length;&#13;
            for (var row = 1; row &lt;= rowsNumber; row++) {&#13;
                var foundedRow = $table.find('.row_' + row);&#13;
                for (i = 0; i &lt; columsNumber; i++) {&#13;
                    $(foundedRow[i]).css('width', columnWidth[i]);&#13;
                }&#13;
            }&#13;
        } else {&#13;
            var firstRow = $table.find('.row_1');&#13;
&#13;
            for (i = 0; i &lt; columnWidth.length; i++) {&#13;
                $(firstRow[i]).css('width', columnWidth[i]);&#13;
            }&#13;
        }&#13;
};&#13;
&#13;
&#13;
    presenter.setRowHeight = function ($table, rowHeight) {&#13;
        var i;&#13;
        for (i = 0; i &lt; rowHeight.length; i++) {&#13;
            $table.find('.row_' + (i + 1)).each(function () {&#13;
                $(this).css('height', rowHeight[i]);&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Validate content list and convert it into multidimensional {Array}. Not specified contents equals empty elements.&#13;
     *&#13;
     * @param content list of content definition (consist Row, Column and Content fields)&#13;
     * @param rowsCount number of rows&#13;
     * @param columnsCount number of columns&#13;
     *&#13;
     * @return {Object} validation result&#13;
     * @return {Boolean} isValid&#13;
     * @return {String} error code if any occurs&#13;
     * @return {Array} contents array of contents. Dimensions based on Rows and Columns properties&#13;
     */&#13;
    presenter.validateContent = function (content, rowsCount, columnsCount) {&#13;
        var validatedContent = [], controlArray = [], c, r;&#13;
&#13;
        for (r = 0; r &lt; rowsCount; r++) {&#13;
            validatedContent[r] = [];&#13;
            controlArray[r] = [];&#13;
&#13;
            for (c = 0; c &lt; columnsCount; c++) {&#13;
                validatedContent[r][c] = { content: "", rowSpan: 1, colSpan: 1 };&#13;
                controlArray[r][c] = false;&#13;
            }&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isArrayElementEmpty(content[0])) {&#13;
            if (content.length === 1) {&#13;
                return { isValid: true, content: validatedContent };&#13;
            } else {&#13;
                return { isValid: false, errorCode: 'CO_06' };&#13;
            }&#13;
        }&#13;
&#13;
        for (var i = 0, length = content.length; i &lt; length; i++) {&#13;
            var rows = presenter.validateSequence(content[i].Row, rowsCount, true);&#13;
            if (!rows.isValid)  return { isValid: false, errorCode: rows.errorCode };&#13;
&#13;
            var columns = presenter.validateSequence(content[i].Column, columnsCount, false);&#13;
            if (!columns.isValid)  return { isValid: false, errorCode: columns.errorCode };&#13;
&#13;
            for (r = 0; r &lt; rows.values.length; r++) {&#13;
                for (c = 0; c &lt; columns.values.length; c++) {&#13;
                    var row = rows.values[r] - 1;&#13;
                    var column = columns.values[c] - 1;&#13;
&#13;
                    if (controlArray[row][column]) return { isValid: false, errorCode: 'CO_05' };&#13;
                    controlArray[row][column] = true;&#13;
&#13;
                    if (r === 0 &amp;&amp; c === 0) {&#13;
                        validatedContent[row][column] = {&#13;
                            content: content[i].Content,&#13;
                            rowSpan: rows.values.length,&#13;
                            colSpan: columns.values.length,&#13;
                            class : content[i].hasOwnProperty("CSS Class") ? content[i]["CSS Class"] : "",&#13;
                            style: content[i].hasOwnProperty("CSS Style") ? content[i]["CSS Style"] : ""&#13;
                        };&#13;
                    } else {&#13;
                        validatedContent[row][column] = undefined;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return { isValid: true, content: validatedContent };&#13;
    };&#13;
&#13;
    presenter.validateSingleNumber = function (column, columnsCount, isRowValidated) {&#13;
        var validatedColumn = ModelValidationUtils.validatePositiveInteger(column);&#13;
&#13;
        if (!validatedColumn.isValid) return { isValid: false, errorCode: isRowValidated ? 'CO_01' : 'CO_02'};&#13;
        if (validatedColumn.value &gt; columnsCount) return { isValid: false, errorCode: isRowValidated ? 'CO_03' : 'CO_04' };&#13;
&#13;
        return {isValid: true, value: validatedColumn.value };&#13;
    };&#13;
&#13;
    presenter.validateSequence = function (columns, columnsCount, isRowValidated) {&#13;
        var values = [], validatedColumn, splittedColumns, i;&#13;
&#13;
        splittedColumns = columns.indexOf(',') === -1 ? [columns] : columns.split(',');&#13;
&#13;
        for (i = 0; i &lt; splittedColumns.length; i++) {&#13;
            validatedColumn = presenter.validateSingleNumber(splittedColumns[i], columnsCount, isRowValidated);&#13;
&#13;
            if (!validatedColumn.isValid) return { isValid: false, errorCode: validatedColumn.errorCode };&#13;
&#13;
            values.push(validatedColumn.value);&#13;
        }&#13;
&#13;
        if (values.length &gt; 1) {&#13;
            for (i = 1; i &lt; values.length; i++) {&#13;
                if (values[i - 1] + 1 !== values[i]) {&#13;
                    return { isValid: false, errorCode: 'CR_00' };&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return { values: values, isValid: true };&#13;
    };&#13;
&#13;
    presenter.convertDimensionsArray = function (columnWidth, columnsCount, propertyName) {&#13;
        if (columnWidth.length &gt; columnsCount) return { isValid: false };&#13;
&#13;
        var widths = [], value, i;&#13;
        for (i = 0; i &lt; columnWidth.length; i++) {&#13;
            if (ModelValidationUtils.isStringEmpty(columnWidth[i][propertyName])) {&#13;
                value = 'auto';&#13;
            } else {&#13;
                value = columnWidth[i][propertyName];&#13;
            }&#13;
&#13;
            widths.push(value);&#13;
        }&#13;
&#13;
        if (columnWidth.length &lt; columnsCount) {&#13;
            for (i = columnWidth.length; i &lt; columnsCount; i++) {&#13;
                widths.push('auto');&#13;
            }&#13;
        }&#13;
&#13;
        return { isValid: true, dimensions: widths };&#13;
    };&#13;
&#13;
    function getSpeechTextProperty (rawValue, defaultValue) {&#13;
        var value = rawValue.trim();&#13;
&#13;
        if (value === undefined || value === null || value === '') {&#13;
            return defaultValue;&#13;
        }&#13;
&#13;
        return value;&#13;
    }&#13;
&#13;
    presenter.setSpeechTexts = function(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            correct:  'correct',&#13;
            wrong: 'wrong',&#13;
            empty: 'empty',&#13;
            gap: 'gap',&#13;
            dropdown: 'dropdown',&#13;
            inserted: 'inserted',&#13;
            removed: 'removed',&#13;
            cell: 'cell',&#13;
            row: 'row',&#13;
            column: 'column',&#13;
            rowSpan: 'row span',&#13;
            colSpan: 'column span'&#13;
        };&#13;
&#13;
        if (!speechTexts) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            correct:    getSpeechTextProperty(speechTexts['Correct']['Correct'], presenter.speechTexts.correct),&#13;
            wrong: getSpeechTextProperty(speechTexts['Wrong']['Wrong'], presenter.speechTexts.wrong),&#13;
            empty:  getSpeechTextProperty(speechTexts['Empty']['Empty'], presenter.speechTexts.empty),&#13;
            gap:     getSpeechTextProperty(speechTexts['Gap']['Gap'], presenter.speechTexts.gap),&#13;
            dropdown:   getSpeechTextProperty(speechTexts['Dropdown']['Dropdown'], presenter.speechTexts.dropdown),&#13;
            inserted:      getSpeechTextProperty(speechTexts['Inserted']['Inserted'], presenter.speechTexts.inserted),&#13;
            removed:        getSpeechTextProperty(speechTexts['Removed']['Removed'], presenter.speechTexts.removed),&#13;
            cell:        getSpeechTextProperty(speechTexts['Cell']['Cell'], presenter.speechTexts.cell),&#13;
            row:        getSpeechTextProperty(speechTexts['Row']['Row'], presenter.speechTexts.row),&#13;
            column:        getSpeechTextProperty(speechTexts['Column']['Column'], presenter.speechTexts.column),&#13;
            rowSpan:        getSpeechTextProperty(speechTexts['RowSpan']['RowSpan'], presenter.speechTexts.rowSpan),&#13;
            colSpan:        getSpeechTextProperty(speechTexts['ColSpan']['ColSpan'], presenter.speechTexts.colSpan)&#13;
        };&#13;
    };&#13;
&#13;
    /**&#13;
     * Validate user input configuration.&#13;
     *&#13;
     * @param model {Array} of properties injected into Addon&#13;
     *&#13;
     * @return {Object} validation result&#13;
     * @return {Boolean} isValid&#13;
     * @return {String} error code if any occurs&#13;
     * @return {Object} contents array of contents. Dimensions based on Rows and Columns properties&#13;
     */&#13;
    presenter.validateModel = function (model) {&#13;
&#13;
        presenter.setSpeechTexts(model['speechTexts']);&#13;
&#13;
        if (model["newWidthCalculate"] === undefined) {&#13;
            model["newWidthCalculate"] = false;&#13;
        }&#13;
&#13;
        var validatedRows = ModelValidationUtils.validatePositiveInteger(model.Rows);&#13;
        if (!validatedRows.isValid) {&#13;
            return { isValid: false, errorCode: 'RW_01' };&#13;
        }&#13;
&#13;
        var validatedColumns = ModelValidationUtils.validatePositiveInteger(model.Columns);&#13;
        if (!validatedColumns.isValid) {&#13;
            return { isValid: false, errorCode: 'CL_01' };&#13;
        }&#13;
&#13;
        var validatedContents = presenter.validateContent(model["Table cells"], validatedRows.value, validatedColumns.value);&#13;
        if (!validatedContents.isValid) {&#13;
            return { isValid: false, errorCode: validatedContents.errorCode };&#13;
        }&#13;
&#13;
        var convertedColumnWidth = presenter.convertDimensionsArray(model["Columns width"], validatedColumns.value, 'Width');&#13;
        if (!convertedColumnWidth.isValid) {&#13;
            return { isValid: false, errorCode: 'CW_01' };&#13;
        }&#13;
&#13;
        var convertedRowWidths = presenter.convertDimensionsArray(model["Rows height"], validatedRows.value, 'Height');&#13;
        if (!convertedRowWidths.isValid) {&#13;
            return { isValid: false, errorCode: 'RH_01' };&#13;
        }&#13;
&#13;
        var gapWidth = { isSet: false, value: undefined };&#13;
        if (!ModelValidationUtils.isStringEmpty(model["Gap width"])) {&#13;
            var validatedGapWidth = ModelValidationUtils.validatePositiveInteger(model["Gap width"]);&#13;
            if (!validatedGapWidth.isValid) {&#13;
                return { isValid: false, errorCode: 'GW_01' };&#13;
            } else {&#13;
                gapWidth = { isSet: true, value: validatedGapWidth.value };&#13;
            }&#13;
        }&#13;
&#13;
        var isFirstRowHeader = ModelValidationUtils.validateBoolean(model["isFirstRowHeader"]);&#13;
        var isFirstColumnHeader = ModelValidationUtils.validateBoolean(model["isFirstColumnHeader"]);&#13;
&#13;
        var isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        var isTabindexEnabled = ModelValidationUtils.validateBoolean(model['Is Tabindex Enabled']);&#13;
&#13;
        const gapMaxLength = ModelValidationUtils.validatePositiveInteger(model["GapMaxLength"]);&#13;
&#13;
        return {&#13;
            addonID: model.ID,&#13;
            isValid: true,&#13;
            contents: validatedContents.content,&#13;
            columnsWidths: convertedColumnWidth.dimensions,&#13;
            rowsHeights: convertedRowWidths.dimensions,&#13;
            isVisible: isVisible,&#13;
            isVisibleByDefault: isVisible,&#13;
            isActivity: !ModelValidationUtils.validateBoolean(model["Is not an activity"]),&#13;
            isNotActivity: ModelValidationUtils.validateBoolean(model["Is not an activity"]),&#13;
            isDisabledByDefault: ModelValidationUtils.validateBoolean(model["Is disabled"]),&#13;
            isPunctuationIgnored: ModelValidationUtils.validateBoolean(model["Ignore punctuation"]),&#13;
            isCaseSensitive: ModelValidationUtils.validateBoolean(model["Case sensitive"]),&#13;
            newWidthCalculate: ModelValidationUtils.validateBoolean(model["newWidthCalculate"]),&#13;
            gapWidth: gapWidth,&#13;
            gapType: model["Gap Type"],&#13;
            gapMaxLength: gapMaxLength,&#13;
            isTabindexEnabled: isTabindexEnabled,&#13;
            columnsCount: validatedColumns.value,&#13;
            rowsCount: validatedRows.value,&#13;
            langTag: model["langAttribute"],&#13;
            useNumericKeyboard: ModelValidationUtils.validateBoolean(model["useNumericKeyboard"]),&#13;
            keepOriginalOrder: ModelValidationUtils.validateBoolean(model["keepOriginalOrder"]),&#13;
            isFirstRowHeader: isFirstRowHeader,&#13;
            isFirstColumnHeader: isFirstColumnHeader&#13;
        };&#13;
    };&#13;
&#13;
    presenter.addColumnsWidth = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model["Columns width"]) {&#13;
            upgradedModel["Columns width"] = [&#13;
                { Width: "" }&#13;
            ];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addRowHeights = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model["Rows height"]) {&#13;
            upgradedModel["Rows height"] = [&#13;
                { Height: "" }&#13;
            ];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addLangTag = function AddonTable_addLangTag(model) {&#13;
         var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model['langAttribute']) {&#13;
            upgradedModel['langAttribute'] =  '';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addSpeechTexts = function(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!model['speechTexts']) {&#13;
            upgradedModel['speechTexts'] = {&#13;
                Gap: {Gap: "Gap"},&#13;
                Dropdown: {Dropdown: "Dropdown"},&#13;
                Correct: {Correct: "Correct"},&#13;
                Wrong: {Wrong: "Wrong"},&#13;
                Empty: {Empty: "Empty"},&#13;
                Inserted: {Inserted: "Inserted"},&#13;
                Removed: {Removed: "Removed"},&#13;
                Cell: {Cell: "Cell"}&#13;
            }&#13;
        }&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addUseNumericKeyboard = function (model) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if(model.useNumericKeyboard === undefined) {&#13;
            upgradedModel["useNumericKeyboard"] = "False";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addKeepOriginalOrder = function(model) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if(model.keepOriginalOrder === undefined) {&#13;
            upgradedModel["keepOriginalOrder"] = "False";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addHeaders = function(model) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model);&#13;
&#13;
        if (model.isFirstRowHeader === undefined) {&#13;
            upgradedModel["isFirstRowHeader"] = "False";&#13;
        }&#13;
&#13;
        if (model.isFirstColumnHeader === undefined) {&#13;
            upgradedModel["isFirstColumnHeader"] = "False";&#13;
        }&#13;
&#13;
        if (model['speechTexts']["Row"] === undefined) {&#13;
            upgradedModel['speechTexts']["Row"] = {Row: "Row"};&#13;
        }&#13;
&#13;
        if (model['speechTexts']["Column"] === undefined) {&#13;
            upgradedModel['speechTexts']["Column"] = {Column: "Column"};&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addSpanSpeechTexts = function(model) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model);&#13;
&#13;
        if (model['speechTexts']["RowSpan"] === undefined) {&#13;
            upgradedModel['speechTexts']["RowSpan"] = {RowSpan: "Row span"};&#13;
        }&#13;
&#13;
        if (model['speechTexts']["ColSpan"] === undefined) {&#13;
            upgradedModel['speechTexts']["ColSpan"] = {ColSpan: "Column span"};&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.addGapMaxLength = function (model) {&#13;
        const upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model);&#13;
&#13;
        if (!upgradedModel.hasOwnProperty('GapMaxLength')) {&#13;
            upgradedModel['GapMaxLength'] = '0';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        var upgradedModel = presenter.addColumnsWidth(model);&#13;
        upgradedModel = presenter.addRowHeights(upgradedModel);&#13;
        upgradedModel = presenter.addLangTag(upgradedModel);&#13;
        upgradedModel = presenter.addSpeechTexts(upgradedModel);&#13;
        upgradedModel = presenter.addUseNumericKeyboard(upgradedModel);&#13;
        upgradedModel = presenter.addKeepOriginalOrder(upgradedModel);&#13;
        upgradedModel = presenter.addHeaders(upgradedModel);&#13;
        upgradedModel = presenter.addSpanSpeechTexts(upgradedModel);&#13;
        upgradedModel = presenter.addGapMaxLength(upgradedModel);&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
        presenter.enableAllGaps();&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
        presenter.disableAllGaps();&#13;
    };&#13;
&#13;
    presenter.getGapText = function (gapIndex) {&#13;
        return executeFunctionOnGap(gapIndex, "getGapValueByIndex");&#13;
    };&#13;
&#13;
    presenter.getGapValue = function (gapIndex) {&#13;
        return presenter.getGapText(gapIndex);&#13;
    };&#13;
&#13;
    presenter.getGapTextCommand = function (params) {&#13;
        return presenter.getGapText(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.setGapText = function (gapIndex, text) {&#13;
        if (["draggable", "math"].includes(presenter.configuration.gapType)) {&#13;
            return;&#13;
        }&#13;
&#13;
        const validatedGapIndex = presenter.validateGapIndex(gapIndex);&#13;
        if (validatedGapIndex.isValid) {&#13;
            presenter.gapsContainer.setGapTextByIndex(validatedGapIndex.index, text);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setGapTextCommand = function (params) {&#13;
        presenter.setGapText(parseInt(params[0], 10), params[1]);&#13;
    };&#13;
&#13;
    function executeFunctionOnGap(gapIndex, functionToCall) {&#13;
        var validatedGapIndex = presenter.validateGapIndex(gapIndex);&#13;
&#13;
        if (validatedGapIndex.isValid) {&#13;
            return presenter.gapsContainer[functionToCall](validatedGapIndex.index);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.validateGapIndex = function (gapIndex) {&#13;
        if (isNaN(gapIndex) || gapIndex &lt; 1 || gapIndex &gt; presenter.gapsContainer.getLength()) {&#13;
            return {isValid: false};&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            index: parseInt(gapIndex, 10) - 1&#13;
        };&#13;
    };&#13;
&#13;
&#13;
    presenter.markGapAsCorrect = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "markGapByIndexAsCorrect");&#13;
    };&#13;
&#13;
    presenter.markGapAsCorrectCommand = function (params) {&#13;
        presenter.markGapAsCorrect(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.markGapAsWrong = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "markGapByIndexAsWrong");&#13;
    };&#13;
&#13;
    presenter.markGapAsWrongCommand = function (params) {&#13;
        presenter.markGapAsWrong(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.markGapAsEmpty = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "markGapByIndexAsEmpty");&#13;
    };&#13;
&#13;
    presenter.markGapAsEmptyCommand = function (params) {&#13;
        presenter.markGapAsEmpty(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.enableGap = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "unlockGapByIndex");&#13;
    };&#13;
&#13;
    presenter.enableGapCommand = function (params) {&#13;
        presenter.enableGap(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.enableAllGaps = function () {&#13;
        presenter.gapsContainer.unlockAllGaps();&#13;
    };&#13;
&#13;
    presenter.disableGap = function (gapIndex) {&#13;
        executeFunctionOnGap(gapIndex, "lockGapByIndex");&#13;
    };&#13;
&#13;
    presenter.disableGapCommand = function (params) {&#13;
        presenter.disableGap(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.disableAllGaps = function () {&#13;
        presenter.gapsContainer.lockAllGaps();&#13;
    };&#13;
&#13;
    presenter.getView = function() {&#13;
        return presenter.$view;&#13;
    };&#13;
&#13;
    presenter.isAllOK = function() {&#13;
        var score = presenter.getScore();&#13;
        return score === presenter.getMaxScore() &amp;&amp; score !== 0;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        var commands = {&#13;
            'disableAllGaps': presenter.disableAllGaps,&#13;
            'disableGap': presenter.disableGapCommand,&#13;
            'enableAllGaps': presenter.enableAllGaps,&#13;
            'enableGap': presenter.enableGapCommand,&#13;
            'getGapText': presenter.getGapTextCommand,&#13;
            'getGapValue': presenter.getGapTextCommand,&#13;
            'setGapText': presenter.setGapTextCommand,&#13;
            'getView': presenter.getView,&#13;
            'hide': presenter.hide,&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'isAttempted': presenter.isAttempted,&#13;
            'markGapAsCorrect': presenter.markGapAsCorrectCommand,&#13;
            'markGapAsEmpty': presenter.markGapAsEmptyCommand,&#13;
            'markGapAsWrong': presenter.markGapAsWrongCommand,&#13;
            'show': presenter.show&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.sendAllOKEvent = function () {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.gapsContainer === undefined) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getMaxScore();&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.gapsContainer === undefined) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getScore();&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.gapsContainer === undefined) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getErrorCount();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        if (!presenter.isSetShowErrorsMode) {&#13;
            presenter.gapsContainer.check();&#13;
            presenter.isSetShowErrorsMode = true;&#13;
        }&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            if(presenter.isShowAnswersActive) {&#13;
                presenter.gapsContainer.gaps.forEach(function(gap) {&#13;
                    gap.onHideAnswers();&#13;
                })&#13;
            }&#13;
            presenter.gapsContainer.unlockAllGaps();&#13;
            presenter.gapsContainer.lockAllNotEmptyGaps();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        if (presenter.isSetShowErrorsMode) {&#13;
            presenter.gapsContainer.check();&#13;
            presenter.isSetShowErrorsMode = false;&#13;
        }&#13;
&#13;
        presenter.gapsContainer.removeAllGapsClasses();&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            presenter.gapsContainer.unlockAllGaps();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createEventData = function (item, value, score) {&#13;
        return {&#13;
            source: presenter.configuration.addonID,&#13;
            item: "" + item,&#13;
            value: "" + value,&#13;
            score: "" + score&#13;
        };&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, eventData) {&#13;
        switch (eventName) {&#13;
            case "ShowAnswers":&#13;
                presenter.showAnswers();&#13;
                break;&#13;
            case "HideAnswers":&#13;
                presenter.hideAnswers();&#13;
                break;&#13;
            case "GradualShowAnswers":&#13;
                if (!presenter.isGradualShowAnswersActive) {&#13;
                    presenter.isGradualShowAnswersActive = true;&#13;
                }&#13;
                if (eventData.moduleID === presenter.configuration.addonID) {&#13;
                    presenter.gradualShowAnswers(parseInt(eventData.item, 10));&#13;
                }&#13;
                break;&#13;
            case "GradualHideAnswers":&#13;
                presenter.gradualHideAnswers();&#13;
                break;&#13;
            case "ItemSelected":&#13;
                if(presenter.configuration.isVisible) {&#13;
                    presenter.lastDraggedItem = eventData;&#13;
                }&#13;
                break;&#13;
            case "ItemConsumed":&#13;
                const isEqualToDraggedValue = presenter.lastDraggedItem.value &amp;&amp; eventData.value === presenter.lastDraggedItem.value&#13;
                const isEqualToDraggedItem = presenter.lastDraggedItem.item &amp;&amp; eventData.item === presenter.lastDraggedItem.item&#13;
&#13;
                if (isEqualToDraggedValue  &amp;&amp; isEqualToDraggedItem &amp;&amp; presenter.configuration.isVisible) {&#13;
                    presenter.lastDraggedItem = {};&#13;
                }&#13;
                break;&#13;
            default:&#13;
                break;&#13;
            &#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (presenter.configuration.isActivity) {&#13;
            presenter.gapsContainer.showAnswers();&#13;
            presenter.isShowAnswersActive = true;&#13;
            presenter.isSetShowErrorsMode = false;&#13;
            presenter.renderMathJax();&#13;
        } else {&#13;
            if (presenter.isSetShowErrorsMode) {&#13;
                presenter.setWorkMode();&#13;
&#13;
                if (isConnectedWithMath) {&#13;
                    presenter.disableAllGaps();&#13;
                }&#13;
            }&#13;
            if (isConnectedWithMath) {&#13;
                presenter.isShowAnswersActive = true;&#13;
                presenter.isSetShowErrorsMode = false;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            presenter.gapsContainer.hideAnswers();&#13;
            if (isConnectedWithMath){&#13;
                presenter.gapsContainer.unlockAllGaps();&#13;
            }&#13;
            presenter.isShowAnswersActive = false;&#13;
            presenter.isSetShowErrorsMode = false;&#13;
            presenter.renderMathJax();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getCSSConfiguration = function () {&#13;
        return {&#13;
            correct: "ic_gap-correct",&#13;
            wrong: "ic_gap-wrong",&#13;
            showAnswers: "ic_gap-show-answers",&#13;
            block: "ic_gap-empty",&#13;
            droppableHover: "table-addon-gap-highlight"&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils = function (configuration) {&#13;
        if(!presenter.isPreview){&#13;
            DraggableDroppableObject.call(this, configuration, presenter.getCSSConfiguration());&#13;
        }&#13;
&#13;
        this.gapScore = configuration.gapScore;&#13;
        this.gapType = presenter.GapUtils.GAP_TYPE.NORMAL;&#13;
        this.isDisabled = false;&#13;
        this.isEnabled = true;&#13;
        this.mathShowAnswersValue = "";&#13;
        this.mathCSSClass = "math-answer";&#13;
        this.valueChangeObserver = new presenter.ValueChangeObserver();&#13;
        this.isAttempted = false;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype = Object.create(DraggableDroppableObject.prototype);&#13;
    presenter.GapUtils.parent = DraggableDroppableObject.prototype;&#13;
&#13;
    presenter.GapUtils.GAP_TYPE = {&#13;
        NORMAL: 0,&#13;
        SELECT: 1&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getParsedCorrectAnswers = function () {&#13;
        return this.showAnswersValue.map(function (value) {&#13;
            return this.parseValue(value);&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getParsedValue = function () {&#13;
        return this.parseValue(this.getValue());&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.isCorrect = function () {&#13;
        var correctAnswers = this.getParsedCorrectAnswers();&#13;
        var value = this.getParsedValue();&#13;
&#13;
        return (correctAnswers.indexOf(value) !== -1);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.parseValue = function (value) {&#13;
        if(presenter.hasMathGaps()) {&#13;
            return value;&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isCaseSensitive) {&#13;
            value = value.toLowerCase();&#13;
        }&#13;
&#13;
        if (presenter.configuration.isPunctuationIgnored) {&#13;
            value = value.replace(/\W/g, '');&#13;
        }&#13;
&#13;
        return value.trim();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.isValueEmpty = function () {&#13;
        var value = this.getValue().trim();&#13;
        return value.length === 0 || (this.gapType===1 &amp;&amp; 0 === value.localeCompare("---")); //gapType===1 is the dropdown gap&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnCorrect = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return true;&#13;
        }&#13;
&#13;
        DraggableDroppableObject.prototype.setCssOnCorrect.call(this);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnUnCorrect = function () {&#13;
        this.removeAllClasses();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onBlock = function () {&#13;
        if (!this.isDisabled) {&#13;
            this.lock();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onUnblock = function () {&#13;
        if (this.isDisabled &amp;&amp; this.isEnabled) {&#13;
            this.unlock();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onCorrect = function () {&#13;
        this.onBlock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onUnCorrect = function () {&#13;
        this.onUnblock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onWrong = function () {&#13;
        this.onBlock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onUnWrong = function () {&#13;
        this.onUnblock();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnWrong = function () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return true;&#13;
        }&#13;
&#13;
        if (this.isValueEmpty()) {&#13;
            this.addCssClass('ic_gap-empty');&#13;
            return;&#13;
        }&#13;
&#13;
        DraggableDroppableObject.prototype.setCssOnWrong.call(this);&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnUnWrong = function () {&#13;
        this.removeAllClasses();&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnShowAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            DraggableDroppableObject.prototype.setCssOnShowAnswers.call(this);&#13;
        }&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            this.addCssClass(this.mathCSSClass);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setCssOnHideAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            DraggableDroppableObject.prototype.setCssOnHideAnswers.call(this);&#13;
    	}&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            this.removeCssClass(this.mathCSSClass);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onShowAnswers = function () {&#13;
        if (presenter.configuration.isActivity) {&#13;
            this.onBlock();&#13;
            this.setViewValue(this.showAnswersValue[0]);&#13;
        }&#13;
&#13;
        if (isConnectedWithMath) {&#13;
            this.onBlock();&#13;
            this.setViewValue(this.mathShowAnswersValue);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onHideAnswers = function () {&#13;
        if (presenter.configuration.isActivity || isConnectedWithMath) {&#13;
            this.setViewValue(this.value);&#13;
            this.onUnblock();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setGapWidth = function () {&#13;
        if (presenter.configuration.gapWidth.isSet &amp;&amp; !presenter.isPreview) {&#13;
            this.$view.width(presenter.configuration.gapWidth.value + 'px');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.removeAllClasses = function () {&#13;
        this.removeCssClass('ic_gap-correct');&#13;
        this.removeCssClass('ic_gap-wrong');&#13;
        this.removeCssClass('ic_gap-empty');&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getScore = function () {&#13;
        return this.isCorrect() ? this.gapScore : 0;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getErrorCount = function () {&#13;
        if (this.getValue().trim() === "") {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return this.isCorrect() ? 0 : 1;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.notify = function () {&#13;
        if (this.isValueEmpty()) {&#13;
            this.isAttempted = false;&#13;
        } else {&#13;
            this.isAttempted = true;&#13;
        }&#13;
&#13;
        this.valueChangeObserver.notify(this.getValueChangeEventData());&#13;
    };&#13;
&#13;
    /**&#13;
     *&#13;
     * @returns {{objectID: (string|*), isCorrect: boolean, value: string}}&#13;
     */&#13;
    presenter.GapUtils.prototype.getValueChangeEventData = function () {&#13;
        return {&#13;
            objectID: this.getObjectID(),&#13;
            isCorrect: this.isCorrect(),&#13;
            value: this.getValue()&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setIsEnabled = function (isEnabled) {&#13;
        if (this.isDisabled &amp;&amp; isEnabled) {&#13;
            this.unlock();&#13;
        }&#13;
&#13;
        if (!this.isDisabled &amp;&amp; !isEnabled) {&#13;
            this.lock();&#13;
        }&#13;
&#13;
        this.isEnabled = isEnabled;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setMathShowAnswersValue = function (value) {&#13;
        this.mathShowAnswersValue = value;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getGapState = function () {&#13;
        return {&#13;
            isAttempted: this.isAttempted,&#13;
            isEnabled: this.isEnabled,&#13;
            value: this.getValue()&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.getState = function () {&#13;
        return {&#13;
            droppedElement: this.getDroppedElement(),&#13;
            isAttempted: this.isAttempted,&#13;
            item: this.getSource(),&#13;
            value: this.getValue()&#13;
        };&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setState = function (configuration) {&#13;
        var value = configuration.value;&#13;
        var source = configuration.source;&#13;
        var isEnabled = configuration.isEnabled;&#13;
        var droppedElement = configuration.droppedElement;&#13;
        this.isAttempted = configuration.isAttempted === undefined ? false : configuration.isAttempted;&#13;
&#13;
        if (presenter.configuration.gapType === "draggable") {&#13;
            DraggableDroppableObject.prototype.setState.call(this, value, source, droppedElement);&#13;
        } else {&#13;
            this.value = value;&#13;
            this.source = source;&#13;
            this.setViewValue(value);&#13;
        }&#13;
&#13;
        if (isEnabled !== undefined) {&#13;
            this.setIsEnabled(isEnabled);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.onReset = function () {&#13;
        DraggableDroppableObject.prototype.onReset.call(this);&#13;
&#13;
        if (presenter.configuration.isDisabledByDefault) {&#13;
            this.setIsEnabled(false);&#13;
        } else {&#13;
            this.setIsEnabled(true);&#13;
        }&#13;
&#13;
        this.removeAllClasses();&#13;
        this.removeCssClass("gapFilled");&#13;
        this.isAttempted = false;&#13;
    };&#13;
&#13;
    presenter.GapUtils.prototype.setAttempted = function (value) {&#13;
        this.isAttempted = value;&#13;
    };&#13;
&#13;
&#13;
    presenter.SelectGap = function (htmlID, correctAnswer, gapScore) {&#13;
        var configuration = {&#13;
            addonID: presenter.configuration.addonID,&#13;
            objectID: htmlID,&#13;
            eventBus: presenter.eventBus,&#13;
            getSelectedItem: presenter.getSelectedItem,&#13;
&#13;
            showAnswersValue: correctAnswer,&#13;
&#13;
            connectEvents: presenter.SelectGap.prototype.connectEvents,&#13;
            setViewValue: presenter.SelectGap.prototype.setViewValue,&#13;
&#13;
            gapScore: gapScore,&#13;
            maxLength: presenter.getMaxLength(correctAnswer)&#13;
        };&#13;
&#13;
        presenter.GapUtils.call(this, configuration);&#13;
&#13;
        this.gapType = presenter.GapUtils.GAP_TYPE.SELECT;&#13;
        this.setGapWidth();&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype = Object.create(presenter.GapUtils.prototype);&#13;
    presenter.SelectGap.constructor = presenter.SelectGap;&#13;
&#13;
    presenter.SelectGap.prototype.connectEvents = function () {&#13;
        this.$view.off('change').bind('change', this.onEdit.bind(this));&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.onEdit = function (event) {&#13;
        this.notifyEdit();&#13;
        this.value = this.$view.find(":selected").text();&#13;
        this.notify();&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.setViewValue = function (value) {&#13;
        var escaped = presenter.textParser.escapeXMLEntities(value);&#13;
        this.$view.val(escaped);&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.lock = function () {&#13;
        this.isDisabled = true;&#13;
        this.$view.attr('disabled','disabled');&#13;
    };&#13;
&#13;
    presenter.SelectGap.prototype.unlock = function () {&#13;
        this.isDisabled = false;&#13;
        this.$view.removeAttr('disabled');&#13;
    };&#13;
&#13;
    presenter.gapsAnswers = [];&#13;
&#13;
    function addGapAnswers(htmlID, correctAnswer) {&#13;
        var isInTable = false;&#13;
        for (var i = 0; i &lt; presenter.gapsAnswers.length; i++){&#13;
            if(presenter.gapsAnswers[i].id === htmlID){&#13;
                isInTable = true;&#13;
            }&#13;
        }&#13;
&#13;
        if(!isInTable){&#13;
            presenter.gapsAnswers.push({id: htmlID, answers: correctAnswer});&#13;
        }&#13;
    }&#13;
&#13;
    presenter.EditableInputGap = function (htmlID, correctAnswer, gapScore) {&#13;
        addGapAnswers(htmlID, correctAnswer);&#13;
        var configuration = {&#13;
            addonID: presenter.configuration.addonID,&#13;
            objectID: htmlID,&#13;
            eventBus: presenter.eventBus,&#13;
            getSelectedItem: presenter.getSelectedItem,&#13;
&#13;
            showAnswersValue: correctAnswer,&#13;
&#13;
            createView: presenter.EditableInputGap.prototype.createView,&#13;
            connectEvents: this.connectEvents,&#13;
            setViewValue: presenter.EditableInputGap.prototype.setViewValue,&#13;
&#13;
            gapScore: gapScore,&#13;
            maxLength: presenter.getMaxLength(correctAnswer)&#13;
        };&#13;
&#13;
        presenter.GapUtils.call(this, configuration);&#13;
        this.setGapWidth();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype = Object.create(presenter.GapUtils.prototype);&#13;
    presenter.EditableInputGap.constructor = presenter.EditableInputGap;&#13;
&#13;
    presenter.EditableInputGap.prototype.connectEvents = function () {&#13;
        this.$view.on("input", this.onEdit.bind(this));&#13;
        this.$view.on("blur", this.blurHandler.bind(this));&#13;
        this.$view.on('keyup', this.onKeyUp.bind(this));&#13;
        this.$view.on("keypress", this.onKeyPress.bind(this));&#13;
        this.$view.off('change').bind('change', this.onEdit.bind(this));&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.createView = function () {&#13;
        if (presenter.hasMathGaps()) {&#13;
            return $(presenter.$view).find("input[id='"+this.objectID+"']");&#13;
        }else{&#13;
            var inputType = "text";&#13;
            if (presenter.configuration.useNumericKeyboard) {&#13;
                inputType = "tel";&#13;
            }&#13;
            var $inputGap = $('&lt;input type="' + inputType + '" value="" id="' + this.objectID + '" /&gt;');&#13;
            $inputGap.css({&#13;
                width: presenter.configuration.gapWidth + "px"&#13;
            });&#13;
&#13;
            $inputGap.addClass("ic_gap");&#13;
            if (presenter.configuration.useNumericKeyboard) {&#13;
                $inputGap.attr("step", "any");&#13;
            }&#13;
&#13;
            return $inputGap;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.onKeyUp = function(event) {&#13;
        event.stopPropagation();&#13;
        if (presenter.configuration.useNumericKeyboard) {&#13;
            var newText = String(event.target.value);&#13;
            var pattern = StringUtils.getNumericPattern();&#13;
            if (newText.length &gt; 0 &amp;&amp; !newText.match(pattern)) {&#13;
                var patternWithoutLastCharacter = pattern.slice(0, -1);&#13;
                var regExp = RegExp(patternWithoutLastCharacter);&#13;
                var match = regExp.exec(newText);&#13;
&#13;
                if (match) {&#13;
                    this.setViewValue(match[0]);&#13;
                } else {&#13;
                    this.setViewValue("");&#13;
                }&#13;
                this.value = this.getViewValue();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.onKeyPress = function(event) {&#13;
        event.stopPropagation();&#13;
        if (presenter.configuration.useNumericKeyboard) {&#13;
            var key = String.fromCharCode(!event.charCode ? event.which : event.charCode);&#13;
            var selectionStartIdx = event.target.selectionStart;&#13;
            var selectionEndIdx = event.target.selectionEnd;&#13;
            var oldText = String(event.target.value);&#13;
            var newText = oldText.substring(0, selectionStartIdx)&#13;
                            + key&#13;
                            + oldText.substring(selectionEndIdx);&#13;
            var pattern = StringUtils.getNumericPattern();&#13;
            if (!newText.match(pattern)) {&#13;
                event.preventDefault();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.onEdit = function (event) {&#13;
        this.notifyEdit();&#13;
        this.value = this.getViewValue();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.blurHandler = function (event) {&#13;
        this.notify();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.getViewValue = function () {&#13;
        return this.$view.val();&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.lock = function () {&#13;
        this.isDisabled = true;&#13;
        this.$view.attr('disabled','disabled');&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.unlock = function () {&#13;
        this.isDisabled = false;&#13;
        this.$view.removeAttr('disabled');&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.getValue = function () {&#13;
        return this.value;&#13;
    };&#13;
&#13;
    presenter.EditableInputGap.prototype.setViewValue = function (value) {&#13;
        return this.$view.val(value);&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap = function (htmlID, correctAnswers, gapScore) {&#13;
        var configuration = {&#13;
            addonID: presenter.configuration.addonID,&#13;
            objectID: htmlID,&#13;
            eventBus: presenter.eventBus,&#13;
            getSelectedItem: presenter.getSelectedItem,&#13;
            createView: presenter.DraggableDroppableGap.prototype.createView,&#13;
&#13;
            showAnswersValue: correctAnswers,&#13;
            fillGap: presenter.DraggableDroppableGap.prototype.fillGap,&#13;
            makeGapEmpty: presenter.DraggableDroppableGap.prototype.makeGapEmpty,&#13;
&#13;
            gapScore: gapScore,&#13;
            maxLength: presenter.getMaxLength(correctAnswers)&#13;
        };&#13;
&#13;
        presenter.GapUtils.call(this, configuration);&#13;
        this.setGapWidth();&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype = Object.create(presenter.GapUtils.prototype);&#13;
    presenter.DraggableDroppableGap.parent = presenter.GapUtils.prototype;&#13;
    presenter.DraggableDroppableGap.constructor = presenter.DraggableDroppableGap;&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.createView = function () {&#13;
        var $view = DraggableDroppableObject.prototype.createView.call(this);&#13;
&#13;
        $view.css({&#13;
            width: presenter.configuration.gapWidth + "px",&#13;
            display: 'inline-block'&#13;
        });&#13;
&#13;
        $view.addClass("draggable-gap");&#13;
        $view.addClass("ic_gap");&#13;
&#13;
        return $view;&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.lock = function () {&#13;
        this.isDisabled = true;&#13;
        DraggableDroppableObject.prototype.lock.call(this);&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.unlock = function () {&#13;
        this.isDisabled = false;&#13;
        DraggableDroppableObject.prototype.unlock.call(this);&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.fillGap = function (selectedItem) {&#13;
        DraggableDroppableObject.prototype.fillGap.call(this, selectedItem);&#13;
        this.addCssClass("gapFilled");&#13;
        this.notify();&#13;
&#13;
        presenter.renderMathJax();&#13;
        presenter.rerenderMathJax();&#13;
    };&#13;
&#13;
    presenter.DraggableDroppableGap.prototype.makeGapEmpty = function () {&#13;
        DraggableDroppableObject.prototype.makeGapEmpty.call(this);&#13;
        this.removeCssClass("gapFilled");&#13;
        this.notify();&#13;
    };&#13;
&#13;
    presenter.getMaxLength = function (correctAnswers) {&#13;
        let maxLength = presenter.configuration.gapMaxLength.value;&#13;
&#13;
        correctAnswers.forEach(answers =&gt; {&#13;
            if (answers.length &gt; maxLength) {&#13;
                maxLength = answers.length;&#13;
            }&#13;
        });&#13;
&#13;
        return maxLength;&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject = function () {&#13;
        this.gaps = [];&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.addGap = function (gap) {&#13;
        this.gaps.push(gap);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.replaceDOMViewWithGap = function () {&#13;
        this.gaps.filter(function (gap) {&#13;
            return gap.gapType === presenter.GapUtils.GAP_TYPE.NORMAL;&#13;
        }).forEach(function (gap) {&#13;
            var gapID = "#" + gap.getObjectID(),&#13;
                element = presenter.$view.find(gapID),&#13;
                placeholder = element.attr("placeholder");&#13;
&#13;
            element.replaceWith(gap.getView());&#13;
            element = presenter.$view.find(gapID);&#13;
            if(placeholder) {&#13;
                element.attr("placeholder", placeholder);&#13;
                element.removeClass("ic_gap").addClass("ic_filled_gap");&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.updateGapMaxLength = function () {&#13;
        this.gaps.filter(function (gap) {&#13;
            return gap.gapType === presenter.GapUtils.GAP_TYPE.NORMAL;&#13;
        }).forEach(gap =&gt; {&#13;
            const gapMaxLength = gap.getGapMaxLength();&#13;
            const element = presenter.$view.find(`#${gap.getObjectID()}`);&#13;
            const placeholder = element.attr('placeholder');&#13;
            const placeholderLength = placeholder ? placeholder.length : 0;&#13;
&#13;
            gap.setGapMaxLength(Math.max(gapMaxLength, placeholderLength));&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.addMaxLengthParamToGaps = function () {&#13;
        this.gaps.filter(gap =&gt; {&#13;
            return gap.gapType === presenter.GapUtils.GAP_TYPE.NORMAL;&#13;
        }).forEach(gap =&gt; {&#13;
            const gapMaxLength = gap.getGapMaxLength();&#13;
            const element = presenter.$view.find(`#${gap.getObjectID()}`);&#13;
            $(element).attr('maxlength', gapMaxLength);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.replaceGapsDOMWithView = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.$view = presenter.$view.find("#" + gap.getObjectID());&#13;
            if(!presenter.isPreview){&#13;
                gap.connectEvents();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.removeAllGapsClasses = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.removeAllClasses();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.check = function (isSetShow) {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.check(isSetShow);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.showAnswers = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.showAnswers();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.showAnswer = function (item) {&#13;
        this.gaps[item].showAnswers();&#13;
    }&#13;
&#13;
    presenter.GapsContainerObject.prototype.showAnswersMath = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            if(gap.mathShowAnswersValue !== ""){&#13;
                gap.showAnswers();&#13;
            }else{&#13;
                gap.lock();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.hideAnswers = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.hideAnswers();&#13;
            gap.removeAllClasses();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.reset = function () {&#13;
        this.gaps.forEach(function (gap) {&#13;
            gap.reset();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getErrorCount = function () {&#13;
        return this.gaps.reduce(function (errorCount, gap) {&#13;
            return errorCount += gap.getErrorCount();&#13;
        }, 0);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getScore = function () {&#13;
        return this.gaps.reduce(function (score, gap) {&#13;
            return score += gap.getScore();&#13;
        }, 0);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getMaxScore = function () {&#13;
        return this.gaps.reduce(function (maxScore, gap) {&#13;
            return maxScore += gap.gapScore;&#13;
        }, 0);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexWithClass = function (index, cssClass) {&#13;
        this.gaps[index].removeAllClasses();&#13;
        this.gaps[index].addCssClass(cssClass);&#13;
        this.gaps[index].notifyEdit();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexAsCorrect = function (index) {&#13;
        this.markGapByIndexWithClass(index, this.gaps[index].correctCSS);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexAsWrong = function (index) {&#13;
        this.markGapByIndexWithClass(index, this.gaps[index].wrongCSS);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.markGapByIndexAsEmpty = function (index) {&#13;
        this.markGapByIndexWithClass(index, 'ic_gap-empty');&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getLength = function () {&#13;
        return this.gaps.length;&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getGapValueByIndex = function (index) {&#13;
        return this.gaps[index].getValue();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setGapTextByIndex = function (index, text) {&#13;
        this.gaps[index].setValue(text);&#13;
        this.gaps[index].setViewValue(text);&#13;
        this.gaps[index].notifyEdit();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setLockGapByIndex = function (index, lock) {&#13;
        this.gaps[index].setIsEnabled(lock);&#13;
        this.gaps[index].notifyEdit();&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.lockGapByIndex = function (index) {&#13;
        this.setLockGapByIndex(index, false);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.unlockGapByIndex = function (index) {&#13;
        this.setLockGapByIndex(index, true);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.unlockAllGaps = function () {&#13;
        this.gaps.map(function (gap, index) {&#13;
            this.unlockGapByIndex(index);&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.lockAllGaps = function () {&#13;
        this.gaps.map(function (gap, index) {&#13;
            this.lockGapByIndex(index);&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.lockAllNotEmptyGaps = function () {&#13;
        this.gaps.map(function (gap, index) {&#13;
            if(!gap.isValueEmpty()){&#13;
                this.lockGapByIndex(index);&#13;
            }&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getGapIndexByObjectID = function (objectID) {&#13;
        for (var index = 0; index &lt; this.gaps.length; index++) {&#13;
            if (this.gaps[index].getObjectID() === objectID) {&#13;
                return (index + 1);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getGapsState = function () {&#13;
        return this.gaps.map(function (gap) {&#13;
            return gap.getGapState();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.getState = function () {&#13;
        return this.gaps.map(function (gap) {&#13;
            return gap.getState();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setGapsState = function (state) {&#13;
        state.map(function (stateData, index) {&#13;
            var configuration = {&#13;
                droppedElement: undefined,&#13;
                isAttempted: stateData.isAttempted === undefined ? false : stateData.isAttempted,&#13;
                isEnabled: stateData.isEnabled,&#13;
                source: "",&#13;
                value: stateData.value&#13;
            };&#13;
&#13;
            this.gaps[index].setState(configuration);&#13;
            this.gaps[index].$view.trigger('change');&#13;
        }, this);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setSpansState = function (state, undefinedAttr) {&#13;
        if ((state !== undefinedAttr) &amp;&amp; (state !== null)) {&#13;
            state.map(function (stateData, index) {&#13;
                var configuration = {&#13;
                    value: stateData.value,&#13;
                    source: stateData.item,&#13;
                    isEnabled: undefined,&#13;
                    droppedElement: stateData.droppedElement&#13;
                };&#13;
&#13;
                this.gaps[index].setState(configuration);&#13;
&#13;
                if (stateData.value === "") {&#13;
                    this.gaps[index].destroyDraggableProperty();&#13;
                }else{&#13;
                    this.gaps[index].addCssClass("gapFilled");&#13;
                }&#13;
&#13;
            }, this);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setMathShowAnswersValueByGapIndex = function (index, value) {&#13;
        this.gaps[index].setMathShowAnswersValue(value);&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.isGapAttempted = function (index) {&#13;
        return this.gaps[index].isAttempted;&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.isAnyGapAttempted = function () {&#13;
        return this.gaps.some(function (gap) {&#13;
            return gap.isAttempted;&#13;
        });&#13;
    };&#13;
&#13;
    presenter.GapsContainerObject.prototype.setIsAttemptedByGapId = function(objectID, value) {&#13;
        for (var index = 0; index &lt; this.gaps.length; index++) {&#13;
            if (this.gaps[index].getObjectID() === objectID) {&#13;
                this.gaps[index].setAttempted(value);&#13;
                break;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    presenter.ValueChangeObserver = function () {};&#13;
&#13;
    presenter.ValueChangeObserver.prototype.notify = function (data) {&#13;
        presenter.eventBus.sendEvent('ValueChanged', this.getEventData(data));&#13;
&#13;
        if (presenter.isAllOK()) presenter.sendAllOKEvent();&#13;
    };&#13;
&#13;
    presenter.ValueChangeObserver.prototype.getEventData = function (data) {&#13;
        return {&#13;
            score: data.isCorrect ? "1" : "0",&#13;
            value: data.value,&#13;
            source: presenter.configuration.addonID,&#13;
            item: presenter.gapsContainer.getGapIndexByObjectID(data.objectID)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.isActivity = function () {&#13;
        return presenter.configuration.isActivity;&#13;
    };&#13;
&#13;
    presenter.setMathShowAnswersCounter = function (counter) {&#13;
        presenter.configuration.mathShowAnswersCounter = counter;&#13;
    };&#13;
&#13;
    presenter.tickMathCounter = function () {&#13;
        if (presenter.configuration.mathShowAnswersCounter) {&#13;
            presenter.configuration.mathShowAnswersCounter = presenter.configuration.mathShowAnswersCounter - 1;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.shouldTriggerMathShowAnswers = function () {&#13;
        return presenter.configuration.mathShowAnswersCounter === 0;&#13;
    };&#13;
&#13;
    //showAnswers from Math&#13;
    presenter.setGapAnswer = function (gapIndex, answer, counter) {&#13;
        if (presenter.configuration.mathShowAnswersCounter === undefined) {&#13;
            presenter.setMathShowAnswersCounter(counter);&#13;
        }&#13;
&#13;
        presenter.gapsContainer.setMathShowAnswersValueByGapIndex((gapIndex - 1), answer);&#13;
&#13;
        presenter.tickMathCounter();&#13;
&#13;
        if (presenter.shouldTriggerMathShowAnswers()) {&#13;
            presenter.gapsContainer.removeAllGapsClasses();&#13;
            presenter.gapsContainer.showAnswersMath();&#13;
            presenter.setMathShowAnswersCounter(counter);&#13;
        }&#13;
    };&#13;
&#13;
    //hideAnswers from Math&#13;
    //hideAnswers is called anyway so just void function&#13;
    presenter.setUserValue = function () {};&#13;
&#13;
    presenter.markConnectionWithMath = function() {&#13;
        isConnectedWithMath = true;&#13;
        presenter.isConnectedWithMath = true;&#13;
    };&#13;
&#13;
    presenter.getValue = function (index) {&#13;
        return presenter.gapsContainer.getGapValueByIndex((index-1))&#13;
    };&#13;
&#13;
    presenter.renderMathJax = function () {&#13;
        MathJax.CallBack.Queue().Push(function () {&#13;
            MathJax.Hub.Typeset(presenter.$view.find(".table-addon-wrapper")[0]);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.rerenderMathJax = function () {&#13;
        MathJax.CallBack.Queue().Push(function () {&#13;
            MathJax.Hub.Rerender(presenter.$view.find(".table-addon-wrapper")[0]);&#13;
        });&#13;
    };&#13;
&#13;
    function TableKeyboardController (elements, columnsCount, rowsCount) {&#13;
        var newElements = accountForMergedCells(elements, columnsCount, rowsCount);&#13;
        KeyboardController.call(this, newElements, columnsCount);&#13;
        this.rowsCount = rowsCount;&#13;
    }&#13;
&#13;
    function accountForMergedCells(elements, columnsCount, rowsCount) {&#13;
        if (columnsCount === undefined || rowsCount === undefined ||&#13;
            elements.length === 0 || elements[0].getAttribute === undefined) return elements;&#13;
        var elementsArray = Array.from(Array(rowsCount), () =&gt; new Array(columnsCount));&#13;
        var i = 0;&#13;
        for (var ri = 0; ri &lt; rowsCount; ri++) {&#13;
            for (var ci = 0; ci &lt; columnsCount; ci++) {&#13;
                if (elementsArray[ri][ci] === undefined &amp;&amp; i &lt; elements.length) {&#13;
                    var element = elements[i];&#13;
                    i++;&#13;
                    var colNumber = getColspan(element);&#13;
                    var rowNumber = getRowspan(element);&#13;
                    for (var rj = 0; rj &lt; rowNumber; rj++) {&#13;
                        for (var cj = 0; cj &lt; colNumber; cj++) {&#13;
                            var newColIndex = ci + cj;&#13;
                            var newRowIndex = ri + rj;&#13;
                            if (newRowIndex &lt; rowsCount &amp;&amp; newColIndex &lt; columnsCount) {&#13;
                                elementsArray[newRowIndex][newColIndex] = element;&#13;
                            }&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        var newElements = [];&#13;
        for (var i = 0; i &lt; rowsCount; i++) newElements = newElements.concat(elementsArray[i]);&#13;
        return newElements;&#13;
    }&#13;
&#13;
    function getColspan(element) {&#13;
        return getAttributeNumberValue(element, "colspan", 1);&#13;
    }&#13;
&#13;
    function getRowspan(element) {&#13;
        return getAttributeNumberValue(element, "rowspan", 1);&#13;
    }&#13;
&#13;
    function getAttributeNumberValue(element, attributeName, defaultValue) {&#13;
        if (element.getAttribute(attributeName)!= null &amp;&amp; !isNaN(element.getAttribute(attributeName))) {&#13;
            return new Number(element.getAttribute(attributeName));&#13;
        } else {&#13;
            return defaultValue;&#13;
        }&#13;
    }&#13;
&#13;
    TableKeyboardController.prototype.reload = function (elements, columnsCount, rowsCount) {&#13;
        var newElements = accountForMergedCells(elements, columnsCount, rowsCount);&#13;
        KeyboardController.prototype.reload.call(this, newElements, columnsCount);&#13;
    }&#13;
&#13;
    TableKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    TableKeyboardController.prototype.constructor = TableKeyboardController;&#13;
&#13;
    TableKeyboardController.prototype.select = function (event) {&#13;
        event.preventDefault();&#13;
        presenter.addWhiteSpaceToValue();&#13;
        if (presenter.gapNavigation &amp;&amp; presenter.configuration.gapType === 'draggable' &amp;&amp; presenter.getCurrentGapsNumber() &gt; 0) {&#13;
            var $gap = presenter.getGap(presenter.gapIndex);&#13;
&#13;
            if (!$gap || !$gap.is('span')) return;&#13;
&#13;
            var oldVal = $gap.text();&#13;
            $gap.click();&#13;
            var value = $gap.text();&#13;
&#13;
            if (0 !== oldVal.localeCompare(value)) {&#13;
                var data = [];&#13;
                if (value) {&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(value, presenter.configuration.langTag));&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.inserted));&#13;
                } else {&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(oldVal, presenter.configuration.langTag));&#13;
                    data.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.removed));&#13;
                }&#13;
                presenter.speak(data);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.addWhiteSpaceToValue = function () {&#13;
        if (!presenter.getGap(presenter.gapIndex)) return;&#13;
&#13;
        var gap = presenter.getGap(presenter.gapIndex)[0];&#13;
        var classNames = ['ic_filled_gap', 'ic_gap'];&#13;
        var isInputTypeGap = classNames.some(className =&gt; gap.classList.contains(className));&#13;
        if (!gap || !isInputTypeGap) return;&#13;
&#13;
        var oldValue = gap.value;&#13;
        $(gap).val(`${oldValue} `);&#13;
    }&#13;
&#13;
    TableKeyboardController.prototype.mark =  function (element) {&#13;
        KeyboardController.prototype.mark.call(this, element);&#13;
        this.getTarget(element, false).focus();&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.unmark = function (element) {&#13;
        KeyboardController.prototype.unmark.call(this, element);&#13;
        this.getTarget(element, false).blur();&#13;
    };&#13;
&#13;
    presenter.buildKeyboardController = function () {&#13;
        presenter.keyboardControllerObject = new TableKeyboardController(presenter.getElementsForKeyboardNavigation(), presenter.configuration.columnsCount, presenter.configuration.rowsCount);&#13;
    };&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        return presenter.$view.find('.table_cell');&#13;
    };&#13;
&#13;
    presenter.keyboardController = function(keycode, isShiftKeyDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.getTarget = function (element, willBeClicked){&#13;
        return $(element);&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.escape = function (event) {&#13;
        if (presenter.gapNavigation) {&#13;
            if (event) {&#13;
                event.stopPropagation();&#13;
                event.preventDefault();&#13;
            }&#13;
            presenter.gapNavigation = false;&#13;
            presenter.clearCurrentCell();&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            // must be set to false, otherwise module won't exit navigation&#13;
            presenter.addonKeyboardNavigationActive = false;&#13;
            KeyboardController.prototype.escape.call(this, event);&#13;
        }&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.enter = function (event){&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
&#13;
        if (presenter.addonKeyboardNavigationActive &amp;&amp; !presenter.gapNavigation) {&#13;
            presenter.gapNavigation = true;&#13;
            presenter.selectGap(0);&#13;
        }&#13;
        if (!presenter.addonKeyboardNavigationActive){&#13;
            presenter.addonKeyboardNavigationActive = true;&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            presenter.readCurrentNavigationElement();&#13;
        }&#13;
    }&#13;
&#13;
    KeyboardController.prototype.switchElement = function (move) {&#13;
        var new_position_index = this.keyboardNavigationCurrentElementIndex + move;&#13;
        if (new_position_index &gt;= this.keyboardNavigationElementsLen) {&#13;
            new_position_index = new_position_index - this.keyboardNavigationElementsLen;&#13;
        } else if (new_position_index &lt; 0) {&#13;
            new_position_index = this.keyboardNavigationElementsLen + new_position_index;&#13;
        }&#13;
        if (this.keyboardNavigationCurrentElement === this.keyboardNavigationElements[new_position_index]&#13;
            &amp;&amp; this.keyboardNavigationCurrentElementIndex != new_position_index) {&#13;
                this.keyboardNavigationCurrentElementIndex = new_position_index;&#13;
                if (move == this.columnsCount || move == -1 * this.columnsCount) {&#13;
                    if (new_position_index + move &gt;=0 &amp;&amp; new_position_index + move &lt; this.keyboardNavigationElementsLen) {&#13;
                        this.switchElement(move);&#13;
                    } else {&#13;
                        this.markCurrentElement(new_position_index);&#13;
                    }&#13;
                } else {&#13;
                if (move &lt; 0) {&#13;
                    if (new_position_index % this.columnsCount != 0) {&#13;
                        this.switchElement(-1);&#13;
                    } else {&#13;
                        this.markCurrentElement(new_position_index);&#13;
                    }&#13;
                } else {&#13;
                    if (new_position_index % this.columnsCount != this.columnsCount - 1) {&#13;
                        this.switchElement(1);&#13;
                    } else {&#13;
                        this.markCurrentElement(new_position_index);&#13;
                    }&#13;
                }&#13;
            }&#13;
        } else {&#13;
            this.markCurrentElement(new_position_index);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.readCurrentNavigationElement = function() {&#13;
        var html = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
        var data = window.TTSUtils.getTextVoiceArrayFromElementWithGaps(html, presenter.configuration.langTag, presenter.speechTexts);&#13;
        presenter.speak(data);&#13;
    };&#13;
&#13;
    presenter.readCurrentCellTitle = function() {&#13;
        var row = Math.floor(presenter.keyboardControllerObject.keyboardNavigationCurrentElementIndex / presenter.configuration.columnsCount);&#13;
        var column = presenter.keyboardControllerObject.keyboardNavigationCurrentElementIndex % presenter.configuration.columnsCount;&#13;
        var element = presenter.keyboardControllerObject.keyboardNavigationCurrentElement;&#13;
        var rowSpan = getRowspan(element);&#13;
        var colSpan = getColspan(element);&#13;
&#13;
        if (rowSpan != 1 || colSpan != 1) {&#13;
            var classNames = element.className.split(' ');&#13;
            for (var i = 0; i &lt; classNames.length; i++) {&#13;
                var className = classNames[i];&#13;
                if (className.startsWith('col_')) {&#13;
                    var numberString = className.replace('col_', '').trim();&#13;
                    if (numberString.length &gt; 0 &amp;&amp; !isNaN(numberString)) column = new Number(numberString) - 1;&#13;
                }&#13;
                if (className.startsWith('row_')) {&#13;
                    var numberString = className.replace('row_', '').trim();&#13;
                    if (numberString.length &gt; 0 &amp;&amp; !isNaN(numberString)) row = new Number(numberString) - 1;&#13;
                }&#13;
            }&#13;
        }&#13;
        var alphabet = "ABCDEFGHIJKLMNOPRSTUWXYZ";&#13;
        var content = presenter.speechTexts.cell + " " + alphabet[column % alphabet.length] + " " + (row+1);&#13;
        var data = [window.TTSUtils.getTextVoiceObject(content)];&#13;
        if (rowSpan &gt; 1) {&#13;
            data.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.rowSpan+" "+rowSpan));&#13;
        }&#13;
        if (colSpan &gt; 1) {&#13;
            data.push(window.TTSUtils.getTextVoiceObject(presenter.speechTexts.colSpan+" "+colSpan));&#13;
        }&#13;
        if (presenter.configuration.isFirstRowHeader) {&#13;
            data = data.concat(getCellHeaderUtterances('.row_1.col_'+(column+1), presenter.speechTexts.column));&#13;
        }&#13;
        if (presenter.configuration.isFirstColumnHeader) {&#13;
            data = data.concat(getCellHeaderUtterances('.col_1.row_'+(row+1), presenter.speechTexts.row));&#13;
        }&#13;
        presenter.speak(data);&#13;
    };&#13;
&#13;
    function getCellHeaderUtterances(headerSelector, headerTypeSpeechText) {&#13;
        var data = [];&#13;
        var html = presenter.$view.find(headerSelector);&#13;
        if (html.length &gt; 0) {&#13;
            var headerContent = window.TTSUtils.getTextVoiceArrayFromElementWithGaps(html, presenter.configuration.langTag, presenter.speechTexts);&#13;
            if (headerContent.length &gt; 0) {&#13;
                data.push(window.TTSUtils.getTextVoiceObject(headerTypeSpeechText));&#13;
                data = data.concat(headerContent);&#13;
            }&#13;
        }&#13;
        return data;&#13;
    }&#13;
&#13;
    // TAB or Right Arrow&#13;
    TableKeyboardController.prototype.nextElement = function (event) {&#13;
        if(event.keyCode === 9) { //TAB&#13;
            this.handleTab(event);&#13;
            event.preventDefault();&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.gapNavigation){&#13;
            presenter.switchSelectedValue(1);&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        if (this.keyboardNavigationCurrentElementIndex % this.columnsCount === this.columnsCount - 1) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(1);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    // SHIFT+TAB or Left Arrow&#13;
    TableKeyboardController.prototype.previousElement = function (event) {&#13;
        if(event.keyCode === 9) { //TAB&#13;
            this.handleTab(event);&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.gapNavigation){&#13;
            presenter.switchSelectedValue(-1);&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        if (this.keyboardNavigationCurrentElementIndex % this.columnsCount === 0) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(-1);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    TableKeyboardController.prototype.handleTab = function (event) {&#13;
        if (presenter.getCurrentGapsNumber() &gt; 0) {&#13;
            if (!presenter.gapNavigation) {&#13;
                presenter.gapNavigation = true;&#13;
                presenter.selectGap(0);&#13;
            } else {&#13;
                if ( !event.shiftKey ) {&#13;
                    presenter.selectGap(presenter.gapIndex + 1);&#13;
                } else {&#13;
                    presenter.selectGap(presenter.gapIndex - 1);&#13;
                }&#13;
            }&#13;
&#13;
            var $gap = presenter.getGap(presenter.gapIndex);&#13;
            var $cell = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
            var data = window.TTSUtils.getTextVoiceArrayFromGap($gap, $cell, presenter.configuration.langTag, presenter.speechTexts);&#13;
            presenter.speak(data);&#13;
&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    // UP Arrow&#13;
    TableKeyboardController.prototype.previousRow = function (event) {&#13;
        if (presenter.gapNavigation) {&#13;
            presenter.switchSelectedValue(-1);&#13;
            return;&#13;
        }&#13;
&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
&#13;
        if (Math.floor(this.keyboardNavigationCurrentElementIndex / this.columnsCount) === 0) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(-this.columnsCount);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    // DOWN Arrow&#13;
    TableKeyboardController.prototype.nextRow = function (event) {&#13;
        if (presenter.gapNavigation) {&#13;
            presenter.switchSelectedValue(1);&#13;
            return;&#13;
        }&#13;
&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
&#13;
        if (Math.floor(this.keyboardNavigationCurrentElementIndex / this.columnsCount) === this.rowsCount - 1) {&#13;
            presenter.readCurrentCellTitle();&#13;
        } else {&#13;
            this.switchElement(this.columnsCount);&#13;
            presenter.readCurrentCellTitle();&#13;
        }&#13;
    };&#13;
&#13;
    function getTableKeyboardController() {&#13;
        return TableKeyboardController;&#13;
    }&#13;
&#13;
    getTableKeyboardController().prototype.exitWCAGMode = function () {&#13;
        presenter.gapNavigation = false;&#13;
        presenter.clearCurrentCell();&#13;
        presenter.addonKeyboardNavigationActive = false;&#13;
        KeyboardController.prototype.exitWCAGMode.call(this);&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function AddonTable_getTextToSpeechOrNull(playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function AddonTable_setWCAGStatus(isOn) {&#13;
        presenter.isWCAGOn = isOn;&#13;
    };&#13;
&#13;
    presenter.speak = function AddonTable_speak(data) {&#13;
        var tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isDeactivationBlocked = function() {&#13;
        return presenter.addonKeyboardNavigationActive || presenter.gapNavigation;&#13;
    };&#13;
&#13;
    presenter.getCurrentGapsNumber = function() {&#13;
        return $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement).find('.ic_gap, ic_inlineChoice, .ic_filled_gap').length;&#13;
    };&#13;
&#13;
    presenter.clearCurrentCell = function() {&#13;
        var $cell = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
        $cell.find('.keyboard_navigation_active_element').removeClass('keyboard_navigation_active_element');&#13;
        if ($cell.find('input:focus').length &gt; 0) {&#13;
            $cell.find('input:focus').blur();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getGap = function (index) {&#13;
        var $gaps = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement).find('.ic_gap, ic_inlineChoice, .ic_filled_gap');&#13;
        if ($gaps.length === 0) return;&#13;
        if (index &lt; 0) index = 0;&#13;
        if (index &gt;= $gaps.length) index = $gaps.length-1;&#13;
        return $gaps.eq(index);&#13;
    };&#13;
&#13;
    presenter.selectGap = function(index) {&#13;
        var $gaps = $(presenter.keyboardControllerObject.keyboardNavigationCurrentElement).find('.ic_gap, ic_inlineChoice, .ic_filled_gap');&#13;
        if ($gaps.length === 0) return;&#13;
        if(index &lt; 0) index = 0;&#13;
        if(index &gt;= $gaps.length) index = $gaps.length - 1;&#13;
        var $gap = $gaps.eq(index);&#13;
&#13;
        presenter.clearCurrentCell();&#13;
        $gap.addClass('keyboard_navigation_active_element');&#13;
&#13;
        presenter.gapIndex = index;&#13;
        if ($gap.is('input')) {&#13;
            $gap.focus();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.switchSelectedValue = function(move) {&#13;
        if(presenter.isShowAnswersActive || presenter.isSetShowErrorsMode) return;&#13;
        var $gap = presenter.getGap(presenter.gapIndex);&#13;
&#13;
        if (!$gap || !$gap.is('select')) return;&#13;
&#13;
        var index = $gap.prop("selectedIndex");&#13;
        var optionSize = $gap.find('option').size();&#13;
        index = index + move;&#13;
&#13;
        if (0 &lt;= index &amp;&amp; index &lt; optionSize) {&#13;
            $gap.prop("selectedIndex", index);&#13;
            $gap.change();&#13;
            var value = $gap.val();&#13;
            if (value.length === 0 || value === '-' || value === '---') {&#13;
                var data = [window.TTSUtils.getTextVoiceObject(presenter.speechTexts.empty)];&#13;
            } else {&#13;
                var data = [window.TTSUtils.getTextVoiceObject($gap.val(), presenter.configuration.langTag)];&#13;
            }&#13;
            presenter.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
    * @method isAttempted method returning if user has interacted with addon&#13;
    * @return boolean&#13;
    */&#13;
    presenter.isAttempted = function AddonTable_isAttempted () {&#13;
        if (presenter.configuration.isNotActivity) {&#13;
            return true;&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.getLength() === 0 ? true : presenter.gapsContainer.isAnyGapAttempted();&#13;
    };&#13;
&#13;
&#13;
    /**&#13;
     * @param gapIndex - index of gap to check&#13;
     * @returns boolean&#13;
     */&#13;
    presenter.isGapAttempted = function AddonTableisGapAttempted (gapIndex) {&#13;
        if (gapIndex &gt; 0) {&#13;
            gapIndex = gapIndex - 1;&#13;
        }&#13;
&#13;
        return presenter.gapsContainer.isGapAttempted(gapIndex);&#13;
    };&#13;
&#13;
    presenter.PRINTABLE_STATE_MODE = {&#13;
        EMPTY: 0,&#13;
        SHOW_ANSWERS: 1,&#13;
        SHOW_USER_ANSWERS: 2,&#13;
        CHECK_ANSWERS: 3&#13;
    };&#13;
&#13;
    function isPrintableShowAnswersStateMode() {&#13;
        return presenter.printableStateMode === presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS;&#13;
    }&#13;
    function isPrintableShowUserAnswersStateMode() {&#13;
        return presenter.printableStateMode === presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS;&#13;
    }&#13;
    function isPrintableCheckAnswersStateMode() {&#13;
        return presenter.printableStateMode === presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS;&#13;
    }&#13;
    function isPrintableStateMode() {&#13;
        return isPrintableShowUserAnswersStateMode() || isPrintableCheckAnswersStateMode();&#13;
    }&#13;
&#13;
    presenter.setPrintableState = function(state) {&#13;
        if (state === null || ModelValidationUtils.isStringEmpty(state))&#13;
            return;&#13;
        presenter.printableState = JSON.parse(state);&#13;
    }&#13;
&#13;
    presenter.setPrintableController = function(controller) {&#13;
        presenter.textParser = new TextParserProxy(controller.getTextParser());&#13;
    }&#13;
&#13;
    function chosePrintableStateMode(showAnswers) {&#13;
        if (presenter.printableState) {&#13;
            if (showAnswers)&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS;&#13;
            else&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS;&#13;
        } else {&#13;
            if (showAnswers)&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS;&#13;
            else&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.EMPTY;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setPrintableAsyncCallback = function(id, callback) {&#13;
        presenter.printableParserID = id;&#13;
        presenter.printableParserCallback = callback;&#13;
    }&#13;
&#13;
    presenter.isPrintableAsync = function() {&#13;
        return true;&#13;
    }&#13;
&#13;
    presenter.hasMathGaps = function() {&#13;
        return presenter.configuration.gapType === 'math';&#13;
    }&#13;
&#13;
    presenter.getPrintableHTML = function(model, showAnswers) {&#13;
        presenter.configuration = presenter.validateModel(presenter.upgradeModel(model));&#13;
        chosePrintableStateMode(showAnswers);&#13;
        createPrintableHTMLStructure(model);&#13;
&#13;
        presenter.$view.addClass("printable_module");&#13;
        const clone = presenter.$view.clone();&#13;
        clone.attr('id', presenter.printableParserID);&#13;
&#13;
        if (presenter.hasMathGaps()) {&#13;
            presenter.transformMathGaps();&#13;
        } else {&#13;
            // normal gaps don't need additional parsing like math gaps, this just notifies callback asynchronusly&#13;
            setTimeout(function() {&#13;
                const result = parsePrintableGaps(presenter.$view[0].outerHTML);&#13;
&#13;
                presenter.notifyParserCallback(result);&#13;
            }, 0);&#13;
        }&#13;
&#13;
        return clone[0].outerHTML;&#13;
&#13;
    };&#13;
&#13;
    function createPrintableHTMLStructure(model) {&#13;
        createPrintableHTMLWrapper(model);&#13;
        var $table = presenter.generateTable(presenter.configuration.contents, false);&#13;
        presenter.$wrapper.append($table);&#13;
    }&#13;
&#13;
    function createPrintableHTMLWrapper(model) {&#13;
        presenter.$view = $('&lt;div&gt;&lt;/div&gt;');&#13;
        presenter.$view.attr("id", model.ID);&#13;
        presenter.$view.addClass('printable_addon_Table');&#13;
        presenter.$view.css('max-width', model.Width + 'px');&#13;
        presenter.$wrapper = $('&lt;div&gt;&lt;/div&gt;');&#13;
        presenter.$wrapper.addClass('table-addon-wrapper');&#13;
        presenter.$view.append(presenter.$wrapper);&#13;
&#13;
        presenter.$view.addClass(getViewClassesBasedOnMode());&#13;
    }&#13;
&#13;
    function getViewClassesBasedOnMode() {&#13;
        switch(presenter.printableStateMode) {&#13;
            case presenter.PRINTABLE_STATE_MODE.EMPTY: {&#13;
                return "printable_addon_Table-empty-mode";&#13;
            }&#13;
            case presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS: {&#13;
                return "printable_addon_Table-show-answers";&#13;
            }&#13;
            case presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS: {&#13;
                return "printable_addon_Table-show-user-answers";&#13;
            }&#13;
            case presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS: {&#13;
                return "printable_addon_Table-check-answers";&#13;
            }&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    function matchGap(gapRegex, textToSearch, closingSignGapSize) {&#13;
        let closingBracketIndex = 0;&#13;
&#13;
        let gapMatch = textToSearch.match(gapRegex);&#13;
        if (gapMatch == null)&#13;
            return [];&#13;
&#13;
        const gapsMatches = [];&#13;
        while (gapMatch != null) {&#13;
            const textWithoutFoundGapBeginning = textToSearch.substring(gapMatch.index + gapMatch[0].length);&#13;
&#13;
            closingBracketIndex = presenter.textParser.findClosingBracket(textWithoutFoundGapBeginning);&#13;
            if (closingBracketIndex &gt; 0) {&#13;
                const gapEndIndex = gapMatch.index + gapMatch[0].length + closingBracketIndex + closingSignGapSize;&#13;
                const wholeGapTextToTheEndingBracket = textToSearch.substring(gapMatch.index, gapEndIndex);&#13;
                // ex: \gap{lorem|ispum|\(\frac{1}{4}\)}&#13;
                gapsMatches.push(wholeGapTextToTheEndingBracket);&#13;
                textToSearch = textToSearch.substring(gapEndIndex);&#13;
            } else {&#13;
                // gap has no ending bracket, so syntax is broken and in fact it doesn't contain gap, ex:&#13;
                // \gap{lorem|ispum|\(\frac{1}{4}\)&#13;
                break;&#13;
            }&#13;
&#13;
            gapMatch = textToSearch.match(gapRegex);&#13;
        }&#13;
&#13;
        return gapsMatches;&#13;
    }&#13;
&#13;
    function matchGapAndFilledGap(html) {&#13;
        const gapsRegex = /\\gap{|\\filledGap{/;&#13;
        return matchGap(gapsRegex, html, "}".length);&#13;
    }&#13;
&#13;
    function matchDropdownGap(html) {&#13;
        // match last {{ ex. \frac{1}{{{gap_definition}}} will match last two "{{" from "{{{"&#13;
        const gapRegex = /{{(?!{)/;&#13;
        return matchGap(gapRegex, html, "}}".length);&#13;
    }&#13;
&#13;
    function parsePrintableGaps (html) {&#13;
        let gapsMatches = matchGapAndFilledGap(html);&#13;
        gapsMatches = gapsMatches.concat(matchDropdownGap(html));&#13;
&#13;
        const tablePrintableOptions = indexRegexMatchesBaseOnGapsTypes(gapsMatches);&#13;
        for (let i = 0; i &lt; tablePrintableOptions.length; i++) {&#13;
            const tablePrintableOption = tablePrintableOptions[i];&#13;
            const optionHTML = tablePrintableOption.getPrintableHTML();&#13;
            html = html.replace(tablePrintableOption.text, optionHTML);&#13;
        }&#13;
        return html;&#13;
    }&#13;
&#13;
    /**&#13;
     To properly parse math gaps, gaps need to be transformed to special syntax \gap{id|width|size|{{value:value}}&#13;
     and it needs to be passed into mathjax processor.&#13;
     Then gaps will be changed to html inputs which can be transformed into proper printable gap html&#13;
     */&#13;
    presenter.transformMathGaps = function() {&#13;
        let result = parsePrintableMathGaps(presenter.$view[0].outerHTML);&#13;
        presenter.$view.html(result.html);&#13;
&#13;
        function mathJaxTypesetEnd() {&#13;
            // replace each input with its corresponding gap html&#13;
            presenter.$view.find('input').each(function (index, element) {&#13;
                let html = result.printableOptions[index].getPrintableHTML();&#13;
                $(this).replaceWith(html);&#13;
            });&#13;
&#13;
            presenter.notifyParserCallback(presenter.$view[0].outerHTML);&#13;
        }&#13;
&#13;
        const args = [];&#13;
        args.push("Typeset", MathJax.Hub, presenter.$view[0]);&#13;
        args.push(mathJaxTypesetEnd);&#13;
        MathJax.Hub.Queue(args);&#13;
    }&#13;
&#13;
    presenter.notifyParserCallback = function (outerHTML) {&#13;
        presenter.printableStateMode = null;&#13;
&#13;
        presenter.printableParserCallback(&#13;
            presenter.textParser.parseAltTexts(outerHTML)&#13;
        );&#13;
    }&#13;
&#13;
    function parsePrintableMathGaps(html) {&#13;
        const gapsMatches = matchGapAndFilledGap(html);&#13;
        const tablePrintableOptions = indexRegexMatchesBaseOnGapsTypes(gapsMatches);&#13;
&#13;
        // replace normal gap syntax with math gap syntax&#13;
        for (let i = 0; i &lt; gapsMatches.length; i++) {&#13;
            const match = gapsMatches[i];&#13;
            const gapId = `${presenter.configuration.addonID}-${i}`;&#13;
            html = html.replace(match, generateMathGap(gapId, presenter.configuration.gapWidth.value));&#13;
        }&#13;
&#13;
        return {&#13;
            printableOptions: tablePrintableOptions,&#13;
            html: html&#13;
        }&#13;
    }&#13;
&#13;
    function indexRegexMatchesBaseOnGapsTypes(gapsMatches) {&#13;
        const normalGapRegex = /\\gap{.*?}/g,&#13;
            filledGapRegex = /\\filledGap{.*?}/g,&#13;
            dropdownGapRegex = /{{.*?}}/g;&#13;
        var tablePrintableOptions = [],&#13;
            stateIndex = 0,&#13;
            isMatchesGapType,&#13;
            gapMatch,&#13;
            gapMatchIndex;&#13;
&#13;
        for (gapMatchIndex = 0; gapMatchIndex &lt; gapsMatches.length; gapMatchIndex++) {&#13;
            gapMatch = gapsMatches[gapMatchIndex];&#13;
&#13;
            isMatchesGapType = gapMatch.match(normalGapRegex);&#13;
            if (isMatchesGapType != null) {&#13;
                tablePrintableOptions.push(&#13;
                    new TablePrintableNormalGapOption(&#13;
                        gapMatch,&#13;
                        stateIndex&#13;
                    )&#13;
                )&#13;
                stateIndex += 1;&#13;
                continue;&#13;
            }&#13;
&#13;
            isMatchesGapType = gapMatch.match(filledGapRegex);&#13;
            if (isMatchesGapType != null) {&#13;
                tablePrintableOptions.push(&#13;
                    new TablePrintableFilledGapOption(&#13;
                        gapMatch,&#13;
                        stateIndex&#13;
                    )&#13;
                )&#13;
                stateIndex += 1;&#13;
            }&#13;
        }&#13;
        for (gapMatchIndex = 0; gapMatchIndex &lt; gapsMatches.length; gapMatchIndex++) {&#13;
            gapMatch = gapsMatches[gapMatchIndex];&#13;
&#13;
            isMatchesGapType = gapMatch.match(dropdownGapRegex);&#13;
            if (isMatchesGapType != null) {&#13;
                tablePrintableOptions.push(&#13;
                    new TablePrintableDropdownGapOption(&#13;
                        gapMatch,&#13;
                        stateIndex&#13;
                    )&#13;
                );&#13;
                stateIndex += 1;&#13;
            }&#13;
        }&#13;
        return tablePrintableOptions;&#13;
    }&#13;
&#13;
    function getTextWidthInPixels(html) {&#13;
        var $outerLessonWrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $outerLessonWrapper.css("position", "absolute");&#13;
        $outerLessonWrapper.css("visibility", "hidden");&#13;
        $outerLessonWrapper.addClass("printable_lesson");&#13;
&#13;
        var $outerPageWrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $outerPageWrapper.addClass("printable_page");&#13;
        $outerLessonWrapper.append($outerPageWrapper);&#13;
&#13;
        var $outerModuleWrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $outerModuleWrapper.addClass("printable_module");&#13;
        $outerModuleWrapper.addClass("printable_addon_Table");&#13;
        $outerPageWrapper.append($outerModuleWrapper);&#13;
&#13;
        var $wrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
		$wrapper.css("margin", "0px");&#13;
		$wrapper.css("padding", "0px");&#13;
		$wrapper.addClass("printable_gap");&#13;
		$outerModuleWrapper.append($wrapper);&#13;
&#13;
		$wrapper.html(html);&#13;
		$("body").append($outerLessonWrapper);&#13;
		var width = $wrapper[0].getBoundingClientRect().width;&#13;
		$outerLessonWrapper.detach();&#13;
		return width;&#13;
    }&#13;
&#13;
    presenter.gradualShowAnswers = function(item) {&#13;
        presenter.gapsContainer.showAnswer(item);&#13;
        presenter.renderMathJax();&#13;
    }&#13;
&#13;
    presenter.gradualHideAnswers = function() {&#13;
         presenter.gapsContainer.hideAnswers();&#13;
         presenter.renderMathJax();&#13;
         presenter.isGradualShowAnswersActive = false;&#13;
    }&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        return presenter.gapsContainer.getLength();&#13;
    }&#13;
&#13;
    /**&#13;
    * TablePrintableOption&#13;
    * */&#13;
    function TablePrintableOption (text, stateID) {&#13;
        this.text = text;&#13;
        this.stateID = stateID;&#13;
        this.options = [];&#13;
    }&#13;
&#13;
    TablePrintableOption.prototype = Object.create(Object.prototype);&#13;
    TablePrintableOption.prototype.constructor = TablePrintableOption;&#13;
&#13;
    TablePrintableOption.prototype.getPrintableGapSignHTML = function() {&#13;
        var $signSpan = $("&lt;span&gt;&lt;/span&gt;");&#13;
        if (this.hasCorrectAnswer()) {&#13;
            $signSpan.addClass("printable_gap_correct");&#13;
        } else {&#13;
            $signSpan.addClass("printable_gap_wrong");&#13;
        }&#13;
        return $signSpan[0].outerHTML;&#13;
    }&#13;
&#13;
    /**&#13;
     * TablePrintableEditableGapOption&#13;
     */&#13;
&#13;
    /**&#13;
     * @param text&#13;
     * @param stateID&#13;
     * @constructor&#13;
     */&#13;
    function TablePrintableEditableGapOption (text, stateID) {&#13;
        TablePrintableOption.call(this, text, stateID)&#13;
        this.initialValue = "";&#13;
        this.correctAnswer = "";&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype = Object.create(TablePrintableOption.prototype);&#13;
    TablePrintableEditableGapOption.prototype.constructor = TablePrintableEditableGapOption;&#13;
&#13;
    TablePrintableEditableGapOption.prototype.getPrintableHTML = function () {&#13;
        this.getGapTextData();&#13;
        var gapInnerText = this.generateInnerText();&#13;
        var gapHTML = this.generateGapHTML(gapInnerText);&#13;
        if (isPrintableCheckAnswersStateMode() &amp;&amp; this.hasAnswer()) {&#13;
            gapHTML += this.getPrintableGapSignHTML();&#13;
        }&#13;
        return gapHTML;&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype.getAnswer = function () {&#13;
        const gapState = presenter.printableState.gaps[this.stateID];&#13;
        return gapState === undefined ? null : gapState.value;&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype.hasCorrectAnswer = function () {&#13;
        return this.correctAnswer === this.getAnswer();&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype.hasAnswer = function () {&#13;
        return this.getAnswer() !== "" &amp;&amp; this.getAnswer() !== null;&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype.generateInnerText = function() {&#13;
        switch(presenter.printableStateMode) {&#13;
            case presenter.PRINTABLE_STATE_MODE.EMPTY: {&#13;
                return this.generateInnerTextForEmptyStateMode();&#13;
            }&#13;
            case presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS: {&#13;
                return this.correctAnswer;&#13;
            }&#13;
            case presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS:&#13;
            case presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS: {&#13;
                return this.hasAnswer() ? this.getAnswer() : this.generateInnerTextForEmptyStateMode();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype.generateInnerTextForEmptyStateMode = function(){&#13;
        var longestAnswer = "";&#13;
        for (var i = 0; i &lt; this.options.length; i++) {&#13;
            if (this.options[i].length &gt; longestAnswer.length) {&#13;
                longestAnswer = this.options[i];&#13;
            }&#13;
        }&#13;
        if (longestAnswer.length === 0)&#13;
            longestAnswer = "&amp;nbsp;&amp;nbsp;&amp;nbsp;";&#13;
&#13;
        var gapWidth = 0;&#13;
        if (presenter.configuration.gapWidth.isSet) {&#13;
            gapWidth = presenter.configuration.gapWidth.value;&#13;
        } else {&#13;
            gapWidth = getTextWidthInPixels(longestAnswer);&#13;
        }&#13;
&#13;
        var value = this.initialValue;&#13;
        var initialValueLength = 0;&#13;
        if (this.initialValue.length &gt; 0) {&#13;
            initialValueLength = getTextWidthInPixels(this.initialValue);&#13;
        }&#13;
&#13;
        var spaceWidth = getTextWidthInPixels('&amp;nbsp;');&#13;
        var spaceCount = Math.ceil((gapWidth - initialValueLength) / spaceWidth);&#13;
        var maxSplitFreeWidth = 50; //must be at least minSplitSize * 2&#13;
        var minSplitSize = 20;&#13;
&#13;
        if (spaceCount &gt; maxSplitFreeWidth) {&#13;
            for (i = 0; i &lt; minSplitSize; i++) {&#13;
                value += "&amp;nbsp;";&#13;
            }&#13;
&#13;
            var nextNbsp = false;&#13;
            for (i = 0; i &lt; spaceCount - 2 * minSplitSize; i++) {&#13;
                if (nextNbsp) {&#13;
                    value += "&amp;nbsp;";&#13;
                } else {&#13;
                    value += " ";&#13;
                }&#13;
                nextNbsp = !nextNbsp;&#13;
            }&#13;
&#13;
            for (i = 0; i &lt; minSplitSize; i++) {&#13;
                value += "&amp;nbsp;";&#13;
            }&#13;
        } else {&#13;
            for (i = 0; i &lt; spaceCount; i++) {&#13;
                value += "&amp;nbsp;";&#13;
            }&#13;
        }&#13;
        return value;&#13;
    }&#13;
&#13;
    TablePrintableEditableGapOption.prototype.generateGapHTML = function(gapInnerText) {&#13;
        const $span = $("&lt;span&gt;&lt;/span&gt;");&#13;
        const classes = presenter.hasMathGaps() ? "printable_gap printable_math_gap" : "printable_gap";&#13;
        $span.addClass(classes);&#13;
        $span.html(gapInnerText);&#13;
        return $span[0].outerHTML;&#13;
    }&#13;
&#13;
    /**&#13;
     * TablePrintableNormalGapOption&#13;
     */&#13;
&#13;
    function TablePrintableNormalGapOption (text, stateID) {&#13;
        TablePrintableEditableGapOption.call(this, text, stateID)&#13;
    }&#13;
&#13;
    TablePrintableNormalGapOption.prototype = Object.create(TablePrintableEditableGapOption.prototype);&#13;
    TablePrintableNormalGapOption.prototype.constructor = TablePrintableNormalGapOption;&#13;
&#13;
    TablePrintableNormalGapOption.prototype.getGapTextData = function() {&#13;
        // remove "\\gap{" and last "}"&#13;
        this.options = this.text.replace("\\gap{", "").replace(/}$/, "").split("|");&#13;
        this.correctAnswer = this.options[0];&#13;
    }&#13;
&#13;
&#13;
    /**&#13;
     * TablePrintableFilledGapOption&#13;
     */&#13;
&#13;
    function TablePrintableFilledGapOption (text, stateID) {&#13;
        TablePrintableEditableGapOption.call(this, text, stateID)&#13;
    }&#13;
&#13;
    TablePrintableFilledGapOption.prototype = Object.create(TablePrintableEditableGapOption.prototype);&#13;
    TablePrintableFilledGapOption.prototype.constructor = TablePrintableFilledGapOption;&#13;
&#13;
    TablePrintableFilledGapOption.prototype.getGapTextData = function() {&#13;
        this.options = this.text.replace("\\filledGap{", "").replace(/}$/, "").split("|");&#13;
        this.correctAnswer = this.options[1];&#13;
        this.initialValue = this.options.splice(0, 1)[0];&#13;
    }&#13;
&#13;
    /**&#13;
    * TablePrintableDropdownGapOption&#13;
    * */&#13;
&#13;
    function TablePrintableDropdownGapOption (text, stateID) {&#13;
        TablePrintableOption.call(this, text, stateID);&#13;
        this.correctOptionRegex = /[0-9]*?:/;&#13;
        this.correctOptionIndex = null;&#13;
        this.chosenOptionIndex = null;&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype = Object.create(TablePrintableOption.prototype);&#13;
    TablePrintableDropdownGapOption.prototype.constructor = TablePrintableDropdownGapOption;&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.getPrintableHTML = function() {&#13;
        this.getGapTextData();&#13;
        if (!presenter.configuration.keepOriginalOrder)&#13;
            this.sortOptions();&#13;
        this.findCorrectOptionIndex();&#13;
        this.removeScoreInformationFromCorrectOption();&#13;
&#13;
        if (isPrintableStateMode())&#13;
            this.findChosenOptionIndex();&#13;
&#13;
        var gapHTML = this.generateGapHTML();&#13;
        if (isPrintableCheckAnswersStateMode() &amp;&amp; this.hasAnswer()){&#13;
            gapHTML += this.getPrintableGapSignHTML();&#13;
        }&#13;
        return gapHTML;&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.getAnswer = function () {&#13;
        return this.chosenOptionIndex;&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.hasAnswer = function () {&#13;
        return this.chosenOptionIndex !== null;&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.hasCorrectAnswer = function () {&#13;
        return this.chosenOptionIndex === this.correctOptionIndex;&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.getGapTextData = function() {&#13;
        this.options = this.text.replace("{{","").replace("}}","").split("|");&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.sortOptions = function() {&#13;
        this.options.sort(function(a,b){&#13;
            return a.replace(this.correctOptionRegex, "").localeCompare(b.replace(this.correctOptionRegex, ""));&#13;
        }.bind(this));&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.findCorrectOptionIndex = function() {&#13;
        for (var i = 0; i &lt; this.options.length; i++) {&#13;
            if (this.correctOptionRegex.test(this.options[i])) {&#13;
                this.correctOptionIndex = i;&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.removeScoreInformationFromCorrectOption = function() {&#13;
        this.options[this.correctOptionIndex]&#13;
            = this.options[this.correctOptionIndex].replace(this.correctOptionRegex, "");&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.findChosenOptionIndex = function() {&#13;
        const gapState = presenter.printableState.gaps[this.stateID];&#13;
        const gapValue = gapState === undefined ? null : gapState.value;&#13;
        for (var i = 0; i &lt; this.options.length; i++) {&#13;
            if (this.options[i] === gapValue) {&#13;
                this.chosenOptionIndex = i;&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    TablePrintableDropdownGapOption.prototype.generateGapHTML = function() {&#13;
        var $span = $("&lt;span&gt;&lt;/span&gt;");&#13;
        $span.addClass("printable_gap");&#13;
&#13;
        if (isPrintableShowAnswersStateMode()) {&#13;
            $span.html(this.options[this.correctOptionIndex]);&#13;
            this.options[this.correctOptionIndex] = $span[0].outerHTML;&#13;
        } else if (isPrintableStateMode()) {&#13;
            $span.html(this.options[this.chosenOptionIndex]);&#13;
            this.options[this.chosenOptionIndex] = $span[0].outerHTML;&#13;
        }&#13;
        return this.options.join(" / ");&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>