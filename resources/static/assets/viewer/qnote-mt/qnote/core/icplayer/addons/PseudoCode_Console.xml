<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="PseudoCode_Console" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property isDefault="true" name="functionsList" nameLabel="PseudoCode_Console_property_functions_list" type="list">
            <property name="name" nameLabel="PseudoCode_Console_property_functions_name" type="string"/>
            <property name="body" nameLabel="PseudoCode_Console_property_functions_body" type="text"/>
        </property>
        <property name="methodsList" nameLabel="PseudoCode_Console_property_methods_list" type="list">
            <property name="objectName" nameLabel="PseudoCode_Console_property_object_name" type="{Number,String,Array}"/>
            <property name="methodName" nameLabel="PseudoCode_Console_property_method_name" type="string"/>
            <property name="methodBody" nameLabel="PseudoCode_Console_property_method_body" type="text"/>
        </property>
        <property name="default_aliases" nameLabel="PseudoCode_Code_property_default_aliases" type="staticlist">
            <property displayName="Begin" name="begin" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="End" name="end" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Variable" name="variable" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="For" name="for" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="While" name="while" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="From" name="from" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="To" name="to" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Do" name="do" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Program" name="program" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Or" name="or" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="And" name="and" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="If" name="if" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Then" name="then" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Else" name="else" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Case" name="case" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Option" name="option" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Function" name="function" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Return" name="return" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Array" name="array_block" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="Downto" name="down_to" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
            <property displayName="By" name="by" type="staticrow">
                <property name="name" nameLabel="Pseudo_Console_property_functions_name" type="string"/>
            </property>
        </property>
        <property name="exceptionsTranslation" nameLabel="PseudoCode_Code_property_exception_translations_list" type="staticlist">
            <property displayName="The instruction '{0}' has already been defined" name="InstructionIsDefinedException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Cast exception '{0}' to type: '{1}'" name="CastErrorException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Exception ({0}): Value at index {1} is not defined" name="GetErrorException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Exception ({0}): index {1} is out of bounds" name="IndexOutOfBoundsException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="To few arguments for function '{0}' (expected at least: {1} arguments)" name="ToFewArgumentsException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Undefined method '{0}'" name="MethodNotFoundException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Usage of undefined variable '{0}' in function '{1}'" name="UndefinedVariableNameException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Usage of undefined function '{0}' in function '{1}'" name="UndefinedFunctionNameException" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
            <property displayName="Unexpected identifier" name="UnexpectedIdentifier" type="staticrow">
                <property name="translation" nameLabel="Pseudo_Console_property_translation_name" type="string"/>
            </property>
        </property>
        <property name="isNotActivity" nameLabel="PseudoCode_Console_property_is_not_activity" type="boolean"/>
        <property name="runUserCode" nameLabel="PseudoCode_Console_property_run_user_code" type="boolean"/>
        <property name="runParameters" nameLabel="PseudoCode_Console_property_run_parameters" type="list">
            <property name="value" nameLabel="PseudoCode_Console_property_parameters_value" type="string"/>
        </property>
        <property name="maxTimeForAnswer" nameLabel="PseudoCode_Console_property_answer_max_timeout" type="string"/>
        <property name="answerCode" nameLabel="PseudoCode_Console_property_answer_code" type="text"/>
        <property name="mathRound" nameLabel="PseudoCode_Console_property_math_round" type="string"/>
        <property name="consoleAvailableInput" nameLabel="PseudoCode_Console_property_console_available_input" type="{All,Natural numbers,Real numbers,Letters only}"/>

    </model>
<css>.pseudoConsole-console-cursor {&#13;
    background-color: #666;&#13;
}&#13;
&#13;
.addon-PseudoCode_Console-console {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.pseudoConsole-console-right-element {&#13;
    position: relative;&#13;
}&#13;
&#13;
.pseudoConsole-console-textarea {&#13;
    width: 1px;&#13;
    height: 1px;&#13;
    color: transparent;&#13;
    background-color: transparent;&#13;
    border: none;&#13;
    position: absolute;&#13;
    opacity: 0.000001;&#13;
}&#13;
&#13;
.addon-PseudoCode_Console-wrapper {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    overflow: auto;&#13;
}&#13;
&#13;
.pseudoConsole-console-cursor-active {&#13;
    margin-right: -0.5em;&#13;
}&#13;
</css><view>&lt;div class="addon-PseudoCode_Console-wrapper"&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="addon-PseudoCode_Console-wrapper"&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>/******/ (function(modules) { // webpackBootstrap&#13;
/******/ 	// The module cache&#13;
/******/ 	var installedModules = {};&#13;
/******/&#13;
/******/ 	// The require function&#13;
/******/ 	function __webpack_require__(moduleId) {&#13;
/******/&#13;
/******/ 		// Check if module is in cache&#13;
/******/ 		if(installedModules[moduleId]) {&#13;
/******/ 			return installedModules[moduleId].exports;&#13;
/******/ 		}&#13;
/******/ 		// Create a new module (and put it into the cache)&#13;
/******/ 		var module = installedModules[moduleId] = {&#13;
/******/ 			i: moduleId,&#13;
/******/ 			l: false,&#13;
/******/ 			exports: {}&#13;
/******/ 		};&#13;
/******/&#13;
/******/ 		// Execute the module function&#13;
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);&#13;
/******/&#13;
/******/ 		// Flag the module as loaded&#13;
/******/ 		module.l = true;&#13;
/******/&#13;
/******/ 		// Return the exports of the module&#13;
/******/ 		return module.exports;&#13;
/******/ 	}&#13;
/******/&#13;
/******/&#13;
/******/ 	// expose the modules object (__webpack_modules__)&#13;
/******/ 	__webpack_require__.m = modules;&#13;
/******/&#13;
/******/ 	// expose the module cache&#13;
/******/ 	__webpack_require__.c = installedModules;&#13;
/******/&#13;
/******/ 	// define getter function for harmony exports&#13;
/******/ 	__webpack_require__.d = function(exports, name, getter) {&#13;
/******/ 		if(!__webpack_require__.o(exports, name)) {&#13;
/******/ 			Object.defineProperty(exports, name, {&#13;
/******/ 				configurable: false,&#13;
/******/ 				enumerable: true,&#13;
/******/ 				get: getter&#13;
/******/ 			});&#13;
/******/ 		}&#13;
/******/ 	};&#13;
/******/&#13;
/******/ 	// getDefaultExport function for compatibility with non-harmony modules&#13;
/******/ 	__webpack_require__.n = function(module) {&#13;
/******/ 		var getter = module &amp;&amp; module.__esModule ?&#13;
/******/ 			function getDefault() { return module['default']; } :&#13;
/******/ 			function getModuleExports() { return module; };&#13;
/******/ 		__webpack_require__.d(getter, 'a', getter);&#13;
/******/ 		return getter;&#13;
/******/ 	};&#13;
/******/&#13;
/******/ 	// Object.prototype.hasOwnProperty.call&#13;
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };&#13;
/******/&#13;
/******/ 	// __webpack_public_path__&#13;
/******/ 	__webpack_require__.p = "";&#13;
/******/&#13;
/******/ 	// Load entry module and return exports&#13;
/******/ 	return __webpack_require__(__webpack_require__.s = 7);&#13;
/******/ })&#13;
/************************************************************************/&#13;
/******/ ([&#13;
/* 0 */,&#13;
/* 1 */,&#13;
/* 2 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.generateExecuteObject = generateExecuteObject;&#13;
exports.generateJumpInstruction = generateJumpInstruction;&#13;
var TYPES = exports.TYPES = {&#13;
    EXECUTE: 1,&#13;
    JUMP: 2&#13;
};&#13;
&#13;
/**&#13;
 * Generate code executed by addon.&#13;
 * @param  {String} code&#13;
 * @param  {String} label set label for goto instruction&#13;
 * @param  {Boolean} [isAsync] async instructions cant be merged and is optional&#13;
 */&#13;
function generateExecuteObject(code, label, isAsync) {&#13;
    return {&#13;
        code: code,&#13;
        type: TYPES.EXECUTE,&#13;
        label: label,&#13;
        isAsync: isAsync || false&#13;
    };&#13;
}&#13;
&#13;
function generateJumpInstruction(code, toLabel) {&#13;
    return {&#13;
        code: code,&#13;
        toLabel: toLabel,&#13;
        type: TYPES.JUMP&#13;
    };&#13;
}&#13;
&#13;
/***/ }),&#13;
/* 3 */,&#13;
/* 4 */,&#13;
/* 5 */,&#13;
/* 6 */,&#13;
/* 7 */&#13;
/***/ (function(module, exports, __webpack_require__) {&#13;
&#13;
var _languageDefinition = __webpack_require__(8);&#13;
&#13;
var _definedObjects = __webpack_require__(9);&#13;
&#13;
var _definedExceptions = __webpack_require__(10);&#13;
&#13;
var _languageCodeGenerators = __webpack_require__(11);&#13;
&#13;
var _console = __webpack_require__(12);&#13;
&#13;
var _machine = __webpack_require__(13);&#13;
&#13;
var _validation = __webpack_require__(14);&#13;
&#13;
var _utils = __webpack_require__(15);&#13;
&#13;
/**&#13;
 * Teoria:&#13;
 * http://wazniak.mimuw.edu.pl/index.php?title=Podstawy_kompilator%C3%B3w&#13;
 * Check comments if you want to add OOP to language.&#13;
 */&#13;
function AddonPseudoCode_Console_create() {&#13;
    var presenter = function presenter() {};&#13;
&#13;
    /**&#13;
     * Each object in pseudocode console must be created by this mock.&#13;
     */&#13;
    presenter.objectMocks = {};&#13;
    presenter.bnf = _languageCodeGenerators.CODE_GENERATORS;&#13;
    presenter.exceptions = null;&#13;
    presenter.console = _console.UserConsole;&#13;
    presenter.codeExecutor = _machine.codeExecutor;&#13;
    presenter.validateModel = _validation.validateModel;&#13;
    presenter.validateFunction = _validation.validateFunction;&#13;
    presenter.validateAnswer = _validation.validateAnswer;&#13;
    presenter.validateFunctions = _validation.validateFunctions;&#13;
    presenter.validateAliases = _validation.validateAliases;&#13;
    presenter.validateMethod = _validation.validateMethod;&#13;
&#13;
    //This object will be passed to instruction as scope&#13;
    presenter.objectForInstructions = {&#13;
        calledInstructions: {&#13;
            for: 0,&#13;
            while: 0,&#13;
            doWhile: 0,&#13;
            if: 0,&#13;
            case: 0&#13;
        }, //Object with calculated each built in instruction call e.g. for, while,&#13;
        data: {}&#13;
    };&#13;
&#13;
    presenter.state = {&#13;
        console: null,&#13;
        functions: {}, //Functions defined by user&#13;
        codeGenerator: null, //Generator code to execute from string.&#13;
        wasChanged: false, //If code was changed and addon must recalculate score&#13;
        lastScore: 0, //Last score, we dont need to recalculate score if user dont run code&#13;
        lastUsedCode: [], //Compiled code which was last used,&#13;
        definedByUserFunctions: [], //Functions defined by user&#13;
        variablesAndFunctionsUsage: {}, //Functions and variables used by user each element contains: {defined: [], args: [], vars: [], fn: []},&#13;
        addonWrapper: null,&#13;
        _disabled: false,&#13;
        _wasExecuted: false&#13;
    };&#13;
&#13;
    presenter.configuration = {&#13;
        aliases: {&#13;
            "begin": "begin",&#13;
            "do": "do",&#13;
            "end": "end",&#13;
            "for": "for",&#13;
            "from": "from",&#13;
            "to": "to",&#13;
            "variable": "variable",&#13;
            "program": "program",&#13;
            "while": "while",&#13;
            "or": "or",&#13;
            "and": "and",&#13;
            "if": "if",&#13;
            "then": "then",&#13;
            "else": "else",&#13;
            "case": "case",&#13;
            "option": "option",&#13;
            "function": "function",&#13;
            "return": "return",&#13;
            "array_block": "array",&#13;
            "down_to": "downto",&#13;
            "by": "by"&#13;
        },&#13;
        isValid: false,&#13;
        addonID: null,&#13;
        isActivity: false,&#13;
        isVisibleByDefault: false,&#13;
        functions: [],&#13;
        answer: null,&#13;
        methods: [],&#13;
        round: 20,&#13;
        availableConsoleInput: "All",&#13;
        exceptionTranslations: {}&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        "FN01": "Defined function name must match to ^[A-Za-z_][a-zA-Z0-9_]*$",&#13;
        "FN02": "Defined function must have unique name",&#13;
        "FN03": "Defined function overrides built in alias",&#13;
        "AN01": "Defined alias name must match to ^[A-Za-z_][a-zA-Z0-9_]*$",&#13;
        "AN02": "Multiple aliases got the same name",&#13;
        "JS01": "Java Script code in mdefined ethod is not valid.",&#13;
        "JS02": "Java Script code in defined function is not valid",&#13;
        "ER01": "Math precision value must be an integer",&#13;
        "ER02": "Math precision value must be bigger than 0",&#13;
        "ER03": "Math precision value cannot be greater than 20",&#13;
        "IP01": "Max time for answer must be float number in range 0 to 10 excluding 0",&#13;
        "IP02": "Answer code must be valid JS code"&#13;
    };&#13;
&#13;
    presenter.availableInputsInConsole = {&#13;
        "All": function All() {&#13;
            return true;&#13;
        },&#13;
        "Natural numbers": function NaturalNumbers(value, wholeValue) {&#13;
            return (0, _utils.isDigit)(value);&#13;
        },&#13;
        "Letters only": function LettersOnly(value, wholeValue) {&#13;
            return (0, _utils.isLetter)(value);&#13;
        },&#13;
        "Real numbers": function RealNumbers(value, wholeValue) {&#13;
            return (/^-?[0-9]*\.?[0-9]*$/g.test(wholeValue)&#13;
            );&#13;
        }&#13;
    };&#13;
&#13;
    presenter.CLASS_LIST = {&#13;
        "correct": "pseudo-code-console-correct",&#13;
        "wrong": "pseudo-code-console-wrong"&#13;
    };&#13;
&#13;
    presenter.originalDisplay = 'block';&#13;
&#13;
    presenter.setPlayerController = function presenter_setPlayerController(controller) {&#13;
        presenter.state.playerController = controller;&#13;
        presenter.state.eventBus = presenter.state.playerController.getEventBus();&#13;
        presenter.state.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.state.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.killMachine = {}; // Object which contains all machines with kill machine function&#13;
&#13;
    presenter.killAllMachines = function presenter_killAllMachines() {&#13;
        var id = void 0;&#13;
&#13;
        for (id in presenter.killMachine) {&#13;
            if (presenter.killMachine.hasOwnProperty(id)) {&#13;
                presenter.killMachine[id]();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.run = function presenter_run(view, model) {&#13;
        presenter.initialize(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function presenter_createPreview(view, model) {&#13;
        presenter.initialize(view, model, true);&#13;
    };&#13;
&#13;
    presenter.initializeGrammar = function presenter_initializeGrammar() {&#13;
        presenter.state.codeGenerator = (0, _languageDefinition.getLanguageParser)({&#13;
            presenter: presenter,&#13;
            aliases: presenter.configuration.aliases&#13;
        });&#13;
    };&#13;
&#13;
    /**&#13;
     * Before each user code call, this object should be initialized&#13;
     * @param  {Object} [consoleMock] optional argument for console&#13;
     */&#13;
    presenter.initializeObjectForCode = function presenter_initializeObjectForCode(consoleMock) {&#13;
        presenter.objectForInstructions = {&#13;
            calledInstructions: {&#13;
                for: 0,&#13;
                while: 0,&#13;
                doWhile: 0,&#13;
                if: 0,&#13;
                case: 0&#13;
            },&#13;
            data: {}&#13;
        };&#13;
        presenter.objectForInstructions.console = consoleMock || presenter.state.console;&#13;
        presenter.state.definedByUserFunctions = [];&#13;
    };&#13;
&#13;
    presenter.getInputChecker = function () {&#13;
        return presenter.availableInputsInConsole[presenter.configuration.availableConsoleInput];&#13;
    };&#13;
&#13;
    presenter.initializeConsole = function presenter_initializeConsole() {&#13;
        presenter.state.console = new presenter.console(presenter.state.$view.find(".addon-PseudoCode_Console-wrapper"), {&#13;
            inputChecker: presenter.getInputChecker()&#13;
        });&#13;
&#13;
        var originalReadLine = presenter.state.console.ReadLine,&#13;
            originalReadChar = presenter.state.console.ReadChar;&#13;
&#13;
        /**&#13;
         * Because console is asynchronous but pseudocode console is synchronous we must wrap user callback in console.&#13;
         * Before executing original console function we must stop machine which is executing this code and when user enters input then we resume machine&#13;
         * pauseIns and nextIns are set while executing each command (see dispatchForBuiltInFunctions which is calling wrapMethodOrFunctionWithBuiltInCode code)&#13;
         * @param callback {Function}&#13;
         */&#13;
        presenter.state.console.ReadLine = function console_read_line_override(callback) {&#13;
            presenter.state.console.pauseIns();&#13;
            originalReadLine.call(presenter.state.console, function (input) {&#13;
                callback.call(this, input);&#13;
                presenter.state.console.nextIns();&#13;
            });&#13;
        };&#13;
&#13;
        /**&#13;
         * Like ReadLine&#13;
         * @param callback {Function}&#13;
         */&#13;
        presenter.state.console.ReadChar = function console_read_char_override(callback) {&#13;
            presenter.state.console.pauseIns();&#13;
            originalReadChar.call(presenter.state.console, function (input) {&#13;
                callback.call(this, input);&#13;
                presenter.state.console.nextIns();&#13;
            });&#13;
        };&#13;
    };&#13;
&#13;
    presenter.completeObjectsMethods = function presenter_completeObjectsMethods() {&#13;
        presenter.objectMocks = (0, _definedObjects.getDefinedObjects)({&#13;
            round: presenter.configuration.round,&#13;
            exceptions: presenter.exceptions&#13;
        });&#13;
&#13;
        presenter.configuration.methods.forEach(function (method) {&#13;
            if (method.objectName !== "" &amp;&amp; method.methodName !== "") {&#13;
                presenter.objectMocks[method.objectName].__methods__[method.methodName] = {&#13;
                    native: true,&#13;
                    jsCode: method.function&#13;
                };&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.initialize = function presenter_initialize(view, model, isPreview) {&#13;
        presenter.configuration = presenter.validateModel(model, presenter.configuration.aliases);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
        presenter.state.$view = $(view);&#13;
        presenter.state.view = view;&#13;
&#13;
        var display = presenter.state.$view.css('display');&#13;
        if (display != null &amp;&amp; display.length &gt; 0) {&#13;
            presenter.originalDisplay = display;&#13;
        }&#13;
&#13;
        presenter.state.addonWrapper = presenter.state.$view.find(".addon-PseudoCode_Console-wrapper");&#13;
        if (!isPreview) {&#13;
            presenter.initializeExceptions();&#13;
            presenter.initializeConsole();&#13;
            presenter.initializeObjectForCode();&#13;
            presenter.initializeGrammar();&#13;
            presenter.completeObjectsMethods();&#13;
        }&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        view.addEventListener('DOMNodeRemoved', presenter.destroy);&#13;
    };&#13;
&#13;
    presenter.initializeExceptions = function () {&#13;
        presenter.exceptions = new _definedExceptions.EXCEPTIONS(presenter.configuration.exceptionTranslations);&#13;
    };&#13;
&#13;
    presenter.stop = function presenter_stop() {&#13;
        presenter.state.console.Reset();&#13;
        presenter.killAllMachines();&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function presenter_onEventReceived(eventName) {&#13;
        if (eventName === "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName === "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.executeCommand = function presenter_executeCommand(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'stop': presenter.stop,&#13;
            'showAnswers': presenter.showAnswers,&#13;
            'hideAnswers': presenter.hideAnswers&#13;
        };&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.showAnswers = function presenter_showAnswers() {&#13;
        presenter.setWorkMode();&#13;
        presenter.state._disabled = true;&#13;
        presenter.state.console.disable();&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function presenter_hideAnswers() {&#13;
        presenter.state._disabled = false;&#13;
        presenter.state.console.enable();&#13;
    };&#13;
&#13;
    presenter.destroy = function presenter_destroy(event) {&#13;
        if (event.target !== this) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.state.view.removeEventListener("DOMNodeRemoved", presenter.destroy);&#13;
        if (presenter.state.console) {&#13;
            presenter.state.console.destroy();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setVisibility = function presenter_setVisibility(isVisible) {&#13;
        presenter.state.$view.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
        presenter.state.$view.css('display', isVisible ? presenter.originalDisplay : 'none');&#13;
&#13;
        presenter.state.isVisible = isVisible;&#13;
    };&#13;
&#13;
    presenter.show = function presenter_show() {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function presenter_hide() {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.reset = function presenter_reset() {&#13;
        presenter.state._wasExecuted = false;&#13;
        presenter.setWorkMode();&#13;
        presenter.hideAnswers();&#13;
        presenter.killAllMachines();&#13;
        presenter.state.console.Reset();&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.state.console.enable();&#13;
        presenter.state.lastUsedCode = [];&#13;
        presenter.state.wasChanged = true;&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function presenter_setShowErrorsMode() {&#13;
        presenter.hideAnswers();&#13;
        presenter.state._disabled = true;&#13;
&#13;
        if (!presenter.state._wasExecuted) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity) {&#13;
            if (presenter.getScore() === 1) {&#13;
                presenter.state.addonWrapper[0].classList.add(presenter.CLASS_LIST.correct);&#13;
            } else {&#13;
                presenter.state.addonWrapper[0].classList.add(presenter.CLASS_LIST.wrong);&#13;
            }&#13;
        }&#13;
        presenter.state.console.disable();&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function presenter_setWorkMode() {&#13;
        presenter.state._disabled = false;&#13;
&#13;
        presenter.state.addonWrapper[0].classList.remove(presenter.CLASS_LIST.correct);&#13;
        presenter.state.addonWrapper[0].classList.remove(presenter.CLASS_LIST.wrong);&#13;
        presenter.state.console.enable();&#13;
    };&#13;
&#13;
    presenter.setState = function presenter_setState(stateString) {&#13;
        var state = JSON.parse(stateString);&#13;
&#13;
        presenter.setVisibility(state.isVisible);&#13;
        presenter.state.lastScore = state.score;&#13;
        presenter.state._wasExecuted = state._wasExecuted;&#13;
    };&#13;
&#13;
    presenter.getState = function presenter_getState() {&#13;
        var state = {&#13;
            isVisible: presenter.state.isVisible,&#13;
            score: presenter.state.lastScore,&#13;
            _wasExecuted: presenter.state._wasExecuted //Added later and can be false&#13;
        };&#13;
&#13;
        return JSON.stringify(state);&#13;
    };&#13;
&#13;
    presenter.evaluateScoreFromLastOutput = function presenter_evaluateScoreFromLastOutput() {&#13;
        try {&#13;
            if (presenter.configuration.answer.answerCode.call(presenter.objectForInstructions)) {&#13;
                return 1;&#13;
            }&#13;
&#13;
            return 0;&#13;
        } catch (e) {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.generateConsoleMock = function presenter_generateConsoleMock(input) {&#13;
        var actualInputIndex = 0;&#13;
        return {&#13;
            Reset: function Reset() {},&#13;
&#13;
            ReadLine: function ReadLine(callback) {&#13;
                var actualInput = input[actualInputIndex];&#13;
                if (actualInput !== null) {&#13;
                    callback.call(presenter.state.console, actualInput);&#13;
                    actualInputIndex += 1;&#13;
                }&#13;
            },&#13;
&#13;
            ReadChar: function ReadChar(callback) {&#13;
                var actualInput = input[actualInputIndex];&#13;
                if (actualInput !== null) {&#13;
                    callback.call(presenter.state.console, actualInput);&#13;
                    actualInputIndex += 1;&#13;
                }&#13;
            },&#13;
            Write: function Write() {}&#13;
        };&#13;
    };&#13;
&#13;
    presenter.evaluateScoreFromUserCode = function presenter_evaluateScoreFromUserCode() {&#13;
        var code = presenter.state.lastUsedCode,&#13;
            objectForInstructionsSaved = presenter.objectForInstructions,&#13;
            score = void 0;&#13;
&#13;
        presenter.initializeObjectForCode(presenter.generateConsoleMock(presenter.configuration.answer.parameters));&#13;
        presenter.codeExecutor(code, true, presenter);&#13;
        score = presenter.evaluateScoreFromLastOutput();&#13;
&#13;
        presenter.objectForInstructions = objectForInstructionsSaved;&#13;
&#13;
        return score;&#13;
    };&#13;
&#13;
    presenter.evaluateScore = function presenter_evaluateScore() {&#13;
        if (presenter.configuration.answer.runUserCode) {&#13;
            return presenter.evaluateScoreFromUserCode();&#13;
        }&#13;
&#13;
        return presenter.evaluateScoreFromLastOutput();&#13;
    };&#13;
&#13;
    function sendValueChangedEvent(eventData) {&#13;
        if (presenter.state.eventBus !== null) {&#13;
            presenter.state.eventBus.sendEvent('ValueChanged', eventData);&#13;
        }&#13;
    }&#13;
&#13;
    function sendScoreChangedEvent(score) {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': score&#13;
        };&#13;
        sendValueChangedEvent(eventData);&#13;
    }&#13;
&#13;
    presenter.getScore = function presenter_getScore() {&#13;
        if (!presenter.state.wasChanged) {&#13;
            return presenter.state.lastScore;&#13;
        }&#13;
&#13;
        var score = 0;&#13;
        if (presenter.configuration.isActivity) {&#13;
            score = presenter.evaluateScore();&#13;
&#13;
            presenter.state.lastScore = score;&#13;
            presenter.state.wasChanged = false;&#13;
&#13;
            sendScoreChangedEvent(score);&#13;
        }&#13;
&#13;
        return score;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function presenter_getMaxScore() {&#13;
        if (presenter.configuration.isActivity) {&#13;
            return 1;&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function presenter_getErrorCount() {&#13;
        if (presenter.configuration.isActivity) {&#13;
            return 1 - presenter.getScore();&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getExcludedNames = function presenter_getExcludedNames() {&#13;
        var i = void 0,&#13;
            excludedNames = {};&#13;
&#13;
        for (i in presenter.configuration.aliases) {&#13;
            if (presenter.configuration.aliases.hasOwnProperty(i)) {&#13;
                excludedNames[presenter.configuration.aliases[i]] = true;&#13;
            }&#13;
        }&#13;
&#13;
        for (i in presenter.configuration.functions) {&#13;
            if (presenter.configuration.functions.hasOwnProperty(i)) {&#13;
                excludedNames[i] = true;&#13;
            }&#13;
        }&#13;
&#13;
        return excludedNames;&#13;
    };&#13;
&#13;
    /**&#13;
     * If user defined function which was defined then throw error&#13;
     */&#13;
    presenter.multiDefineInstructionChecker = function presenter_multiDefineInstructionChecker() {&#13;
        var i = void 0,&#13;
            userFunctionName = "",&#13;
            excludedNames = presenter.getExcludedNames();&#13;
&#13;
        for (i = 0; i &lt; presenter.state.definedByUserFunctions.length; i += 1) {&#13;
            userFunctionName = presenter.state.definedByUserFunctions[i];&#13;
            if (!excludedNames[userFunctionName]) {&#13;
                excludedNames[userFunctionName] = true;&#13;
            } else {&#13;
                throw presenter.exceptions.InstructionIsDefinedException(userFunctionName);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * User calls undefined function&#13;
     * @param  {{defined: String[], args: String[], vars:String [], fn: String[]}} functionData&#13;
     * @param  {String} functionName&#13;
     */&#13;
    presenter.undefinedUsageForFunctionChecker = function presenter_undefinedUsageForFunctionChecker(functionData, functionName) {&#13;
        var usedVariableName = "",&#13;
            usedFunctionName = "",&#13;
            i = void 0,&#13;
            excludedNames = presenter.getExcludedNames();&#13;
&#13;
        for (i = 0; i &lt; functionData.vars.length; i += 1) {&#13;
            usedVariableName = functionData.vars[i];&#13;
            if ($.inArray(usedVariableName, functionData.defined) === -1 &amp;&amp; $.inArray(usedVariableName, functionData.args) === -1) {&#13;
                throw presenter.exceptions.UndefinedVariableNameException(usedVariableName, functionName);&#13;
            }&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; functionData.fn.length; i += 1) {&#13;
            usedFunctionName = functionData.fn[i];&#13;
            if (!excludedNames[usedFunctionName] &amp;&amp; $.inArray(usedFunctionName, presenter.state.definedByUserFunctions) === -1) {&#13;
                throw presenter.exceptions.UndefinedFunctionNameException(usedFunctionName, functionName);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Check if user uses not defined variable or instruction&#13;
     */&#13;
    presenter.undefinedInstructionOrVariableChecker = function presenter_undefinedInstructionOrVariableChecker() {&#13;
        var i = void 0,&#13;
            usedVariablesAndFunctions = {};&#13;
&#13;
        for (i in presenter.state.variablesAndFunctionsUsage) {&#13;
            if (presenter.state.variablesAndFunctionsUsage.hasOwnProperty(i)) {&#13;
                usedVariablesAndFunctions = presenter.state.variablesAndFunctionsUsage[i];&#13;
                presenter.undefinedUsageForFunctionChecker(usedVariablesAndFunctions, i);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.checkCode = function presenter_checkCode() {&#13;
        presenter.multiDefineInstructionChecker();&#13;
        presenter.undefinedInstructionOrVariableChecker();&#13;
    };&#13;
&#13;
    presenter.executeCode = function presenter_executeCode(code) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.state._disabled) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.state.variablesAndFunctionsUsage = {};&#13;
        presenter.state.wasChanged = true;&#13;
        presenter.state._wasExecuted = true;&#13;
        presenter.state.lastUsedCode = [];&#13;
        presenter.initializeObjectForCode();&#13;
        try {&#13;
            presenter.state.console.Reset();&#13;
            var executableCode = presenter.state.codeGenerator.parse(code);&#13;
            presenter.checkCode();&#13;
&#13;
            presenter.state.lastUsedCode = executableCode;&#13;
            presenter.stop();&#13;
&#13;
            presenter.codeExecutor(executableCode, false, presenter);&#13;
        } catch (e) {&#13;
            if (e.name !== "Error") {&#13;
                presenter.state.console.Write(e.message + "\n", 'program-error-output');&#13;
            } else {&#13;
                presenter.state.console.Write(presenter.configuration.exceptionTranslations.UnexpectedIdentifier || "Unexpected identifier\n", 'program-error-output');&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
&#13;
window.AddonPseudoCode_Console_create = AddonPseudoCode_Console_create;&#13;
&#13;
/***/ }),&#13;
/* 8 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.getLanguageParser = getLanguageParser;&#13;
/**&#13;
 * OOP:&#13;
 *      Each variable is object, with struct as:&#13;
 *      {&#13;
 *          value: valueOfObject,&#13;
 *          methods: {&#13;
 *              methodName: {isBuiltIn: true|false, labelToJump: string|null, jsCode: string|null}&#13;
 *          },&#13;
 *          type: typeNameAsString,&#13;
 *          parent: object to parent or null&#13;
 *      }&#13;
 *      New object is created by function which will returns empty object.&#13;
 *      Each object can contains class methods, which name will start with __. (Concept: user can override this methods by built prefix.)&#13;
 *&#13;
 *      Calling built in methods:&#13;
 *          Check Object call manager for more information&#13;
 *&#13;
 *      Defined by user (concept):&#13;
 *          Set as actual context object value, and jump to labelToJump&#13;
 *&#13;
 *          Example class:&#13;
 *          class A&#13;
 *               field zmienna&#13;
 *&#13;
 *               method getName (tekst)&#13;
 *               begin&#13;
 *                   print()&#13;
 *               end&#13;
 *&#13;
 *               built method add ()    %As override class method in add%&#13;
 *               begin&#13;
 *                   return "A"&#13;
 *               end&#13;
 *&#13;
 *&#13;
 *           endClass&#13;
 *&#13;
 *          check object call manager for more information&#13;
 *&#13;
 */&#13;
&#13;
function getJISONGrammar() {&#13;
    return {&#13;
        "lex": {&#13;
            "options": {&#13;
                flex: true&#13;
            },&#13;
            "rules": [&#13;
            //String section, if lexer will catch " without string condition, then start condition string. While this condition, only rules with ["string"] will be in use&#13;
            //and this condition will be turned off if " will be catch with start condition&#13;
            ["[\"]", "this.begin('string'); return 'START_STRING'"], [["string"], "[^\"\\\\]", "return 'STRING';"], [["string"], "[\\n]", "return 'NEWLINE_IN_STRING';"], [["string"], "\\\\.", "return 'STRING'"], // match \. &lt;- escaped characters"&#13;
            [["string"], "$", "return 'EOF_IN_STRING';"], [["string"], "[\"]", "this.popState(); return 'END_STRING';"],&#13;
            //Words between |&lt;name&gt;| will be replaced by values from configuration&#13;
            ["|begin|", "return 'BEGIN_BLOCK';"], ["|end|", "return 'END_BLOCK';"], ["|program|", "return 'PROGRAM';"], ["|variable|", "return 'VARIABLE_DEF';"], ["|for|", "return 'FOR';"], ["|from|", "return 'FROM';"], ["|to|", "return 'TO';"], ["|do|", "return 'DO';"], ["|or|", "return 'OR';"], ["|and|", "return 'AND';"], ["|while|", "return 'WHILE';"], ["|if|", "return 'IF';"], ["|then|", "return 'THEN';"], ["|else|", "return 'ELSE';"], ["|case|", "return 'CASE';"], ["|option|", "return 'OPTION';"], ["|function|", "return 'FUNCTION';"], ["|return|", "return 'RETURN';"], ["|array_block|", "return 'ARRAY_DEF';"], ["|down_to|", "return 'DOWNTO';"], ["|by|", "return 'BY';"], ["\\n+", "return 'NEW_LINE';"], ["$", "return 'EOF';"], ["[0-9]+(?:\\.[0-9]+)?\\b", "return 'NUMBER';"], ["&lt;=", "return '&lt;=';"], ["&gt;=", "return '&gt;=';"], ["!=", "return '!=';"], ["==", "return '==';"], ["&lt;", "return '&lt;';"], ["&gt;", "return '&gt;';"], ["\\*", "return '*';"], ["\\/_", "return 'DIV_FLOOR';"], ["\\/", "return '/';"], ["-", "return '-';"], ["\\+", "return '+';"], ["%", "return '%';"], ["\\(", "return '(';"], ["\\)", "return ')';"], ["[A-Za-z][a-zA-Z0-9_]*", "return 'STATIC_VALUE';"], ["\\[", "return '[';"], ["\\]", "return ']';"], [",", "return 'COMMA';"], ["\\.", "return 'DOT';"], ["=", "return '=';"], ["[ \f\r\t\x0B\u200B\xA0\u1680\u200B\u180E\u2000\u200B\u2001\u2002\u200B\u2003\u2004\u200B\u2005\u2006\u200B\u2007\u2008\u200B\u2009\u200A\u200B\u2028\u2029\u200B\u2028\u2029\u200B\u202F\u205F\u200B\u3000]", "/* IGNORE SPACES */"], [".", "return 'NOT_MATCH';"]],&#13;
&#13;
            //Each conditions used by lexer must be defined there&#13;
            "startConditions": {&#13;
                string: 1&#13;
            }&#13;
        },&#13;
&#13;
        //Operators order&#13;
        "operators": [//Be sure, you added operators here to avoid problems with conflicts&#13;
        ["left", "OR", "AND"], ["left", "&lt;=", "&gt;=", "&lt;", "&gt;", "!=", "=="], ["left", "+", "-"], ["left", "*", "/", "DIV_FLOOR", "%"], ["left", "(", ")"], ["lefr", "DOT"], ["left", "[", "]"], ["left", "UMINUS"], ["right", "IF", "ELSE", "THEN"], ["right", "CASE", "OPTION"]],&#13;
        "bnf": {&#13;
            //entry point&#13;
            "expressions": [&#13;
            //Code executor will stop when will receive undefined to execute.&#13;
            ["functions program_name section_list code_block", "return {sections: '', code: ($3 || []).concat($4).concat(undefined).concat($1).concat(undefined).concat(yy.presenterContext.bnf['getObjectCallManager']())};($2 || '') + ($3 || '');"]],&#13;
&#13;
            "functions": ["", ["functions_list", "$$ = $1;"]],&#13;
&#13;
            "functions_list": [["function", "$$ = $1;"], ["functions_list function", "$$ = $1.concat($2);"]],&#13;
&#13;
            "function": [["function_declaration ( function_arguments ) end_line section_list code_block", "$$ = yy.presenterContext.bnf['function'](yy, $1, $3 || [], $6, $7);"]],&#13;
&#13;
            "function_declaration": [["FUNCTION STATIC_VALUE", "$$ = yy.presenterContext.bnf['function_declaration'](yy, $2);"]],&#13;
&#13;
            "function_arguments": ["", ["function_arguments_list", "$$ = $1 || [];"]],&#13;
&#13;
            "function_arguments_list": [["STATIC_VALUE", "$$ = [$1];"], ["function_arguments_list COMMA STATIC_VALUE", "$1.push($3); $$ = $1;"]],&#13;
&#13;
            "program_name": [["program_const STATIC_VALUE end_line", "$$ = yy.presenterContext.bnf['program_name'](yy, $2); "]],&#13;
&#13;
            "program_const": [["PROGRAM", "$$ = '';"]],&#13;
&#13;
            "section_list": ["", ["section_list section", "$$ = ($1 || []).concat($2);"]],&#13;
&#13;
            "section": [["var_section", "$$ = $1;"], ["array_section", "$$ = $1;"]],&#13;
&#13;
            "array_section": [["ARRAY_DEF array_list NEW_LINE", "$$ = $2 || []"]],&#13;
&#13;
            "array_list": [["array_definition", "$$ = $1"], ["array_list COMMA array_definition", "$$ = $1"]],&#13;
&#13;
            "array_definition": [["STATIC_VALUE [ NUMBER ] array_start_value", "$$ = yy.presenterContext.bnf['array'](yy, $1, $3, $5);"]],&#13;
&#13;
            "array_start_value": ["", [" = [ array_start_entries ]", "$$ = $3"]],&#13;
&#13;
            "array_start_entries": [["array_start_entry", "$$ = [$1]"], ["array_start_entries COMMA array_start_entry", "$1.push($3); $$ = $1;"]],&#13;
&#13;
            "array_start_entry": [["operation", "$$ = $1"]],&#13;
&#13;
            "var_section": [["variable_def_const var_list end_line", "$$ = $2;"]],&#13;
&#13;
            "variable_def_const": [["VARIABLE_DEF", "$$ = '';"]],&#13;
&#13;
            "var_list": [["var", "$$ = $1;"], ["var_list comma_separator var", "$$ = $1.concat($3);"]],&#13;
&#13;
            "comma_separator": [["COMMA", "$$ = '';"]],&#13;
&#13;
            "var": [["STATIC_VALUE", "$$ = [yy.presenterContext.bnf['var'](yy, yytext)];"], ["STATIC_VALUE = operation", "$$ = yy.presenterContext.bnf['var_start_value'](yy, $1, $3);"]],&#13;
&#13;
            "code_block": [["begin_block instructions end_block", "$$ = $2 || [];"]],&#13;
&#13;
            "code_block_or_instruction": [["code_block", "$$ = $1 || [];"], ["instruction", "$$ = $1 || [];"]],&#13;
&#13;
            "begin_block": [["BEGIN_BLOCK end_line", "$$ = '';"]],&#13;
&#13;
            "end_block": [["END_BLOCK end_line", "$$ = '';"]],&#13;
&#13;
            "instructions": ["", ["instruction_list", "$$ = $1;"]],&#13;
&#13;
            "instruction_list": [["instruction", "$$ = $1;"], ["instruction_list instruction", "$$ = $1.concat($2);"]],&#13;
&#13;
            "instruction": [['for_instruction', '$$ = $1;'], ['while_instruction', '$$ = $1;'], ['do_while_instruction', '$$ = $1;'], ["assign_value", "$$ = $1;"], ["if_instruction", "$$ = $1"], ["case_instruction", "$$ = $1;"], ["RETURN operation end_line", "$$ = yy.presenterContext.bnf['return_value'](yy, $2);"]],&#13;
&#13;
            "case_instruction": [["CASE variable_get end_line case_options", "$$ = yy.presenterContext.bnf['case']($2, $4);"]],&#13;
&#13;
            "case_options": [["case_option", "$$ = $1;"], ["case_options case_option", "$$ = $1.concat($2);"]],&#13;
&#13;
            "case_option": [["OPTION case_operations THEN end_line code_block_or_instruction", "$$ = yy.presenterContext.bnf['case_option']($2, $5);"]],&#13;
&#13;
            "case_operations": [["operation", "$$ = [$1]"], ["case_operations COMMA operation", "$1.push($3); $$ = $1"]],&#13;
&#13;
            "number_with_minus": [["number_value", "$$ = $1"], ["- number_value", "$$ = ($2 * -1);"]],&#13;
&#13;
            "if_instruction": [["IF operation THEN end_line code_block_or_instruction", "$$ = yy.presenterContext.bnf['if_instruction']($2, $5);"], ["IF operation THEN end_line code_block_or_instruction ELSE end_line code_block_or_instruction", "$$ = yy.presenterContext.bnf['if_else_instruction']($2, $5, $8);"]],&#13;
&#13;
            "assign_value": [['operation [ operation ] = operation end_line', "$$ = yy.presenterContext.bnf['assign_array_value']($1, $3, $6);"], ['STATIC_VALUE = operation end_line', "$$ = yy.presenterContext.bnf['assign_value_1'](yy, $1, $3);"], ['operation end_line', "$$ = yy.presenterContext.bnf['assign_value_2']($1);"]],&#13;
&#13;
            "do_while_instruction": [["do_while_header end_line code_block_or_instruction do_while_checker", "$$ = $1.concat($3).concat($4);"]],&#13;
&#13;
            "do_while_header": [["DO", "$$ = yy.presenterContext.bnf['do_while_header'](yy);"]],&#13;
&#13;
            "do_while_checker": [["WHILE operation end_line", "$$ = yy.presenterContext.bnf['do_while_exiter'](yy, $2);"]],&#13;
&#13;
            "while_instruction": [["while_header end_line code_block_or_instruction", "var endBlock = yy.presenterContext.bnf['while_exiter'](yy); $$ = $1.concat($3).concat(endBlock);"]],&#13;
&#13;
            "while_header": [["WHILE operation DO", "$$ = $$ = yy.presenterContext.bnf['while_header'](yy, $2);"]],&#13;
&#13;
            "for_instruction": [["for_value_header end_line code_block_or_instruction", "$$ = $1.concat($3).concat(yy.presenterContext.bnf['for_exiter'](yy));"]],&#13;
&#13;
            "for_value_header": [["FOR STATIC_VALUE FROM operation TO operation BY NUMBER DO", "$$ = yy.presenterContext.bnf['for_value_header'](yy, $2, $4, $6, $8, '&lt;=');"], ["FOR STATIC_VALUE FROM operation TO operation DO", "$$ = yy.presenterContext.bnf['for_value_header'](yy, $2, $4, $6, 1, '&lt;=');"], ["FOR STATIC_VALUE FROM operation DOWNTO operation DO", "$$ = yy.presenterContext.bnf['for_value_header'](yy, $2, $4, $6, -1, '&gt;=');"], ["FOR STATIC_VALUE FROM operation DOWNTO operation BY NUMBER DO", "$$ = yy.presenterContext.bnf['for_value_header'](yy, $2, $4, $6, $8 * -1, '&gt;=');"]],&#13;
&#13;
            "static_value_or_number": [["STATIC_VALUE", "$$ = yy.presenterContext.bnf['for_argument'](yy, yytext);"], ["NUMBER", "$$ = Number(yytext);"]],&#13;
&#13;
            "arguments": ["", ["arguments_list", "$$ = $1;"]],&#13;
&#13;
            "arguments_list": [["argument", "$$ = [$1];"], ["arguments_list COMMA argument", "$1.push($3); $$ = $1;"]],&#13;
&#13;
            "argument": [["operation", "$$ = $1;"]],&#13;
&#13;
            "string_value": [["START_STRING string_chars END_STRING", "$$ = yy.presenterContext.bnf['string_value'](yy, $2);"]],&#13;
&#13;
            "string_chars": ["", ["string_char", "$$ = $1"]],&#13;
&#13;
            "string_char": [["STRING", "$$ = $1;"], ["string_char STRING", "$$ = $1 + $2"]],&#13;
&#13;
            "end_line": [["new_line_list", "$$='';"]],&#13;
&#13;
            "new_line_list": [["EOF", "$$='';"], ["NEW_LINE", "$$='';"], ["new_line_list NEW_LINE", "$$='';"], ["new_line_list EOF", "$$ = '';"]],&#13;
&#13;
            "operation": [["STATIC_VALUE ( arguments )", "$$ = yy.presenterContext.bnf['function_call'](yy, $1, $3);"], ["operation + operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__add__');"], ["operation - operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__sub__');"], ["operation * operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__mul__');"], ["operation DIV_FLOOR operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__div_full__');"], ["operation / operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__div__');"], ["operation % operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__mod__');"], ["operation &lt;= operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__le__');"], ["operation &gt;= operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__ge__');"], ["operation &gt; operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__gt__');"], ["operation &lt; operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__lt__');"], ["operation != operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__neq__');"], ["operation == operation", "$$ = yy.presenterContext.bnf['generateOperationCode'](yy, $1, $3, '__eq__');"], ["operation OR operation", "$$ = yy.presenterContext.bnf['generateOptimizedOrOperationCode'](yy, $1, $3);"], ["operation AND operation", "$$ = yy.presenterContext.bnf['generateOptimizedAndOperationCode'](yy, $1, $3);"], ["( operation )", "$$ = $2"], ["- operation", "$$ = yy.presenterContext.bnf['generateMinusOperation']($2);", { "prec": "UMINUS" }], ["operation DOT STATIC_VALUE ( arguments )", "$$ = yy.presenterContext.bnf['method_call']($3, $5 || [], $1);"], ["number_value", "$$ = $1"], ["variable_get", "$$ = $1"], ["string_value", "$$ = $1"]],&#13;
&#13;
            "variable_get": [["STATIC_VALUE", "$$ = yy.presenterContext.bnf['argument'](yy, yytext);"], ["operation [ operation ]", "$$ = yy.presenterContext.bnf['array_get']($1, $3);"]],&#13;
&#13;
            "number_value": [["NUMBER", "$$ = yy.presenterContext.bnf['number_value'](yy, yytext);"]]&#13;
        }&#13;
    };&#13;
}&#13;
&#13;
function getWordBetweenHorizontalLine(word) {&#13;
    if (word.indexOf("|") &gt; -1 &amp;&amp; word.lastIndexOf("|") !== word.indexOf("|")) {&#13;
        return word.substring(1, word.length - 1);&#13;
    }&#13;
    return null;&#13;
}&#13;
&#13;
/**&#13;
 * @param {{presenter: Object, aliases: {}}}config&#13;
 */&#13;
function getLanguageParser(config) {&#13;
    var grammar = getJISONGrammar(),&#13;
        rules = grammar.lex.rules,&#13;
        aliases = config.aliases;&#13;
&#13;
    for (var i = 0; i &lt; rules.length; i += 1) {&#13;
        var rule = rules[i][0];&#13;
        var word = getWordBetweenHorizontalLine(rule);&#13;
        if (word !== null) {&#13;
            //We want to find words between "$" and replace them with aliases&#13;
            if (aliases.hasOwnProperty(word)) {&#13;
                rules[i][0] = aliases[word];&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    var parser = new Jison.Parser(grammar);&#13;
    parser.yy.presenterContext = config.presenter;&#13;
    parser.yy.labelsStack = [];&#13;
    parser.yy.functionNames = [];&#13;
    return parser;&#13;
}&#13;
&#13;
/***/ }),&#13;
/* 9 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.objectMocksMethodArgumentsDispatcherDecorator = objectMocksMethodArgumentsDispatcherDecorator;&#13;
exports.getDefinedObjects = getDefinedObjects;&#13;
/**&#13;
 * Arguments dispatcher for methods. Before calling method get object and arguments from stack and convert it to js call with arguments&#13;
 * @param fn {Function}&#13;
 * @returns {Function}&#13;
 */&#13;
function objectMocksMethodArgumentsDispatcherDecorator(fn) {&#13;
    return function () {&#13;
        var builtIn = {&#13;
            console: arguments[0].console,&#13;
            data: arguments[0].data,&#13;
            objects: arguments[1],&#13;
            retVal: arguments[4]&#13;
        };&#13;
        builtIn.console.nextIns = arguments[2];&#13;
        builtIn.console.pauseIns = arguments[3];&#13;
        var args = Array.prototype.slice.call(arguments, 5);&#13;
&#13;
        args.push(builtIn);&#13;
&#13;
        builtIn.retVal.value = fn.apply(this, args);&#13;
    };&#13;
}&#13;
&#13;
/**&#13;
 *&#13;
 * @param {{round: Number, exceptions: EXCEPTIONS}} config&#13;
 */&#13;
function getDefinedObjects(config) {&#13;
    var DEFINED_OBJECTS = {&#13;
        Object: {&#13;
            __constructor__: function object__constructor__() {&#13;
                return {&#13;
                    value: null,&#13;
                    type: "Object",&#13;
                    methods: DEFINED_OBJECTS.Object['__methods__'],&#13;
                    parent: null&#13;
                };&#13;
            },&#13;
            __methods__: {&#13;
                __ge__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function object_ge__method(toValue) {&#13;
                        if (this.value &gt;= toValue.value) {&#13;
                            return DEFINED_OBJECTS.Boolean.__constructor__(true);&#13;
                        }&#13;
&#13;
                        return DEFINED_OBJECTS.Boolean.__constructor__(false);&#13;
                    })&#13;
                },&#13;
                __le__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function object__le__method(toValue) {&#13;
                        if (this.value &lt;= toValue.value) {&#13;
                            return DEFINED_OBJECTS.Boolean.__constructor__(true);&#13;
                        }&#13;
&#13;
                        return DEFINED_OBJECTS.Boolean.__constructor__(false);&#13;
                    })&#13;
                },&#13;
&#13;
                __gt__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function object__gt__method(toValue) {&#13;
                        if (this.value &gt; toValue.value) {&#13;
                            return DEFINED_OBJECTS.Boolean.__constructor__(true);&#13;
                        }&#13;
&#13;
                        return DEFINED_OBJECTS.Boolean.__constructor__(false);&#13;
                    })&#13;
                },&#13;
&#13;
                __lt__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function object__lt__method(toValue) {&#13;
                        if (this.value &lt; toValue.value) {&#13;
                            return DEFINED_OBJECTS.Boolean.__constructor__(true);&#13;
                        }&#13;
&#13;
                        return DEFINED_OBJECTS.Boolean.__constructor__(false);&#13;
                    })&#13;
                },&#13;
&#13;
                __neq__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function object__neq__method(toValue) {&#13;
                        if (this.value !== toValue.value) {&#13;
                            return DEFINED_OBJECTS.Boolean.__constructor__(true);&#13;
                        }&#13;
&#13;
                        return DEFINED_OBJECTS.Boolean.__constructor__(false);&#13;
                    })&#13;
                },&#13;
&#13;
                __eq__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function object__eq__method(toValue) {&#13;
                        if (this.value === toValue.value) {&#13;
                            return DEFINED_OBJECTS.Boolean.__constructor__(true);&#13;
                        }&#13;
&#13;
                        return DEFINED_OBJECTS.Boolean.__constructor__(false);&#13;
                    })&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        Array: {&#13;
            __constructor__: function array__constructor__(count, values) {&#13;
                values = values || [];&#13;
&#13;
                var value = [];&#13;
                var i = 0;&#13;
&#13;
                for (i; i &lt; values.length; i += 1) {&#13;
                    value[i] = values[i];&#13;
                }&#13;
&#13;
                for (; i &lt; count; i += 1) {&#13;
                    value.push(DEFINED_OBJECTS.Number.__constructor__(0));&#13;
                }&#13;
&#13;
                return {&#13;
                    value: value,&#13;
                    type: "Array",&#13;
                    methods: DEFINED_OBJECTS.Array['__methods__'],&#13;
                    parent: DEFINED_OBJECTS.Object&#13;
                };&#13;
            },&#13;
&#13;
            __methods__: {&#13;
                __get__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function array__get__code(index) {&#13;
                        if (index.type !== "Number") {&#13;
                            throw config.exceptions.CastErrorException(index.type, "Number");&#13;
                        }&#13;
&#13;
                        if (this.value[index.value] === undefined) {&#13;
                            throw config.exceptions.IndexOutOfBoundsException(this.type, index.value, this.value.length);&#13;
                        }&#13;
&#13;
                        return this.value[index.value];&#13;
                    })&#13;
                },&#13;
                __set__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function array__set__code(index, value) {&#13;
                        if (index.type !== "Number") {&#13;
                            throw config.exceptions.CastErrorException("String", "Number");&#13;
                        }&#13;
&#13;
                        if (this.value[index.value] === undefined) {&#13;
                            throw config.exceptions.IndexOutOfBoundsException(this.type, index.value, this.value.length);&#13;
                        }&#13;
&#13;
                        this.value[index.value] = value;&#13;
&#13;
                        return this;&#13;
                    })&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        Boolean: {&#13;
            __constructor__: function boolean__constructor__(val) {&#13;
                return {&#13;
                    value: Boolean(val) || false,&#13;
                    type: "Boolean",&#13;
                    methods: DEFINED_OBJECTS.Boolean['__methods__'],&#13;
                    parent: DEFINED_OBJECTS.Object&#13;
                };&#13;
            },&#13;
&#13;
            __methods__: {}&#13;
        },&#13;
&#13;
        String: {&#13;
            __constructor__: function string__constructor__(val) {&#13;
                return {&#13;
                    value: String(val) || '',&#13;
                    type: "String",&#13;
                    methods: DEFINED_OBJECTS.String['__methods__'],&#13;
                    parent: DEFINED_OBJECTS.Object&#13;
                };&#13;
            },&#13;
&#13;
            __methods__: {&#13;
                __add__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function string__add__method__(toValue) {&#13;
                        if (toValue.type === "Number" || toValue.type === "String") {&#13;
                            return DEFINED_OBJECTS.String.__constructor__(this.value + toValue.value);&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        Number: {&#13;
            __constructor__: function number__constructor__(value) {&#13;
                return {&#13;
                    constructor: DEFINED_OBJECTS.Number['__constructor__'],&#13;
                    value: Number(value) || 0,&#13;
                    type: "Number",&#13;
                    methods: DEFINED_OBJECTS.Number['__methods__'],&#13;
                    parent: DEFINED_OBJECTS.Object&#13;
                };&#13;
            },&#13;
            __methods__: {&#13;
                __add__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__add__method(toValue) {&#13;
                        if (toValue.type === "Number") {&#13;
                            return DEFINED_OBJECTS.Number.__constructor__(this.value + toValue.value);&#13;
                        } else if (toValue.type === "String") {&#13;
                            return DEFINED_OBJECTS.String.__constructor__(this.value + toValue.value);&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                },&#13;
                __sub__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__sub__method(toValue) {&#13;
                        if (toValue.type === "Number") {&#13;
                            return DEFINED_OBJECTS.Number.__constructor__(this.value - toValue.value);&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                },&#13;
&#13;
                __mul__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__mul__method(toValue) {&#13;
                        if (toValue.type === "Number") {&#13;
                            var value = this.value * toValue.value;&#13;
                            value = value.toFixed(config.round);&#13;
&#13;
                            return DEFINED_OBJECTS.Number.__constructor__(parseFloat(value));&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                },&#13;
&#13;
                __div__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__div__method(toValue) {&#13;
                        if (toValue.type === "Number") {&#13;
                            var value = this.value / toValue.value;&#13;
                            value = value.toFixed(config.round);&#13;
&#13;
                            return DEFINED_OBJECTS.Number.__constructor__(parseFloat(value));&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                },&#13;
                __div_full__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__div_full__method(toValue) {&#13;
                        if (toValue.type === "Number") {&#13;
                            return DEFINED_OBJECTS.Number.__constructor__(~~(this.value / toValue.value));&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                },&#13;
                __mod__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__mod__method(toValue) {&#13;
                        if (toValue.type === "Number") {&#13;
                            return DEFINED_OBJECTS.Number.__constructor__(this.value % toValue.value);&#13;
                        }&#13;
&#13;
                        throw config.exceptions.CastErrorException(this.type, toValue.type);&#13;
                    })&#13;
                },&#13;
                __minus__: {&#13;
                    native: true,&#13;
                    jsCode: objectMocksMethodArgumentsDispatcherDecorator(function number__minus__method() {&#13;
                        return DEFINED_OBJECTS.Number.__constructor__(this.value * -1);&#13;
                    })&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    return DEFINED_OBJECTS;&#13;
}&#13;
&#13;
/***/ }),&#13;
/* 10 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
&#13;
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();&#13;
&#13;
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }&#13;
&#13;
var EXCEPTIONS = exports.EXCEPTIONS = function () {&#13;
    function EXCEPTIONS(translations) {&#13;
        _classCallCheck(this, EXCEPTIONS);&#13;
&#13;
        this.translations = {};&#13;
&#13;
        this.translations = translations;&#13;
    }&#13;
&#13;
    _createClass(EXCEPTIONS, [{&#13;
        key: "InstructionIsDefinedException",&#13;
        value: function InstructionIsDefinedException(instrName) {&#13;
            var defaultTranslation = "The instruction '{0}' has already been defined";&#13;
            this.name = "InstructionIsDefinedException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, instrName);&#13;
&#13;
            return this;&#13;
        }&#13;
    }, {&#13;
        key: "CastErrorException",&#13;
        value: function CastErrorException(type, toType) {&#13;
            var defaultTranslation = "Cast exception '{0}' to type: '{1}'";&#13;
            this.name = "CastErrorException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, type, toType);&#13;
            return this;&#13;
        }&#13;
    }, {&#13;
        key: "IndexOutOfBoundsException",&#13;
        value: function IndexOutOfBoundsException(type, index, length) {&#13;
            var defaultTranslation = "Exception ({0}): index {1} is out of bounds";&#13;
            this.name = "IndexOutOfBoundsException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, type, index);&#13;
&#13;
            return this;&#13;
        }&#13;
    }, {&#13;
        key: "ToFewArgumentsException",&#13;
        value: function ToFewArgumentsException(functionName, expected) {&#13;
            var defaultTranslation = "To few arguments for function '{0}' (expected at least: {1} arguments)";&#13;
            this.name = "ToFewArgumentsException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, functionName, expected);&#13;
&#13;
            return this;&#13;
        }&#13;
    }, {&#13;
        key: "MethodNotFoundException",&#13;
        value: function MethodNotFoundException(instrName) {&#13;
            var defaultTranslation = "Undefined method '{0}'";&#13;
            this.name = "MethodNotFoundException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, instrName);&#13;
&#13;
            return this;&#13;
        }&#13;
    }, {&#13;
        key: "UndefinedVariableNameException",&#13;
        value: function UndefinedVariableNameException(varName, functionName) {&#13;
            var defaultTranslation = "Usage of undefined variable '{0}' in function '{1}'";&#13;
            this.name = "UndefinedVariableNameException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, varName, functionName);&#13;
&#13;
            return this;&#13;
        }&#13;
    }, {&#13;
        key: "UndefinedFunctionNameException",&#13;
        value: function UndefinedFunctionNameException(varName, functionName) {&#13;
            var defaultTranslation = "Usage of undefined function '{0}' in function '{1}'";&#13;
            this.name = "UndefinedFunctionNameException";&#13;
            this.message = window.StringUtils.format(this.translations[this.name] || defaultTranslation, varName, functionName);&#13;
&#13;
            return this;&#13;
        }&#13;
    }]);&#13;
&#13;
    return EXCEPTIONS;&#13;
}();&#13;
&#13;
/***/ }),&#13;
/* 11 */&#13;
/***/ (function(module, exports, __webpack_require__) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.CODE_GENERATORS = undefined;&#13;
&#13;
var _languageUtils = __webpack_require__(2);&#13;
&#13;
function uidDecorator(fn) {&#13;
    return function () {&#13;
        CODE_GENERATORS.uid += 1;&#13;
        return fn.apply(this, arguments);&#13;
    };&#13;
}&#13;
&#13;
function getuid() {&#13;
    CODE_GENERATORS.uid += 1;&#13;
    return CODE_GENERATORS.uid;&#13;
}&#13;
&#13;
var CODE_GENERATORS = exports.CODE_GENERATORS = {&#13;
    uid: 0,&#13;
&#13;
    case: uidDecorator(&#13;
    /**&#13;
     * @param  {Object[]} variableDef&#13;
     * @param  {{option:String[], code:Object[]}[]} options&#13;
     */&#13;
    function bnf_case(variableDef, options) {&#13;
        var i = void 0,&#13;
            exitLabel = CODE_GENERATORS.uid + "_case_end",&#13;
            execCode = [(0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.case++;', '')];&#13;
&#13;
        execCode = execCode.concat(variableDef); //On stack is variable value&#13;
&#13;
        for (i = 0; i &lt; options.length; i += 1) {&#13;
            options[i].option.forEach(function (option) {&#13;
                execCode = execCode.concat(option); //Now on stack we have option to compare&#13;
                execCode.push((0, _languageUtils.generateJumpInstruction)('stack[stack.length - 2].value === stack.pop().value', CODE_GENERATORS.uid + '_case_option_' + i));&#13;
            });&#13;
        }&#13;
        execCode.push((0, _languageUtils.generateJumpInstruction)('true', exitLabel));&#13;
&#13;
        for (i = 0; i &lt; options.length; i += 1) {&#13;
            execCode.push((0, _languageUtils.generateExecuteObject)('', CODE_GENERATORS.uid + '_case_option_' + i));&#13;
            execCode = execCode.concat(options[i].code);&#13;
            execCode.push((0, _languageUtils.generateJumpInstruction)('true', exitLabel));&#13;
        }&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)('', exitLabel));&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)('stack.pop();', ''));&#13;
        return execCode;&#13;
    }),&#13;
&#13;
    /**&#13;
     * Try to find method in object. If object doesn't contains method then check his parent.&#13;
     * @param object {Object}&#13;
     * @param methodName {String}&#13;
     * @returns {Function}&#13;
     */&#13;
    getMethodFromObject: function bnf_getMethodFromObject(machineManager, object, methodName) {&#13;
        var methods = object.methods;&#13;
        while (true) {&#13;
            if (methods.hasOwnProperty(methodName)) {&#13;
                return methods[methodName];&#13;
            }&#13;
&#13;
            if (object.parent == null) {&#13;
                throw machineManager.exceptions.MethodNotFoundException(methodName);&#13;
            }&#13;
&#13;
            object = object.parent;&#13;
            methods = object.__methods__;&#13;
        }&#13;
    },&#13;
&#13;
    /**&#13;
     * Manager should be added to each program. If method is called then this manager will find correct function.&#13;
     *  Built in methods:&#13;
     *  -get method from object. Call this object method as js call function with passed object and stack and builtIn arguments.&#13;
     *  -get retVal value and add it to stack&#13;
     *&#13;
     *&#13;
     * Objects and inheritance in pseudocode (Concept):&#13;
     *  -Add to machine new instruction evaluateJumpLabelAndJump which will execute code in label and will jump to generated label.&#13;
     *  -Add new object to machineManager.objectMocks&#13;
     *  -Use it in object call manager, if getMethodFromObject(a,b).native is True, then execute original code, if false then use evaluateJumpLabelAndJump to getMethodFromObject(a,b).labelCode where will be code to jump.&#13;
     *  -Each class should be saved in precessor code, each method should contains own label to jump, for example MyClass.myMethod should contains MyClass.myMethod label for jump&#13;
     *  -Before jump, set scope for this class and jump to method.&#13;
     *&#13;
     */&#13;
    getObjectCallManager: function bnf_getObjectCallManager() {&#13;
        var execCode = [];&#13;
&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)('', '1_get_object_call_manager'));&#13;
&#13;
        var code = "";&#13;
        code += "machineManager.bnf.builtInMethodCall(machineManager, stack, machineManager.objectForInstructions, machineManager.objectMocks, next, pause, retVal);;";&#13;
&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)(code, ''));&#13;
&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)("actualIndex = functionsCallPositionStack.pop() + 1;", ""));&#13;
&#13;
        return execCode;&#13;
    },&#13;
&#13;
    case_option: function bnf_case_option(option, code) {&#13;
        return [{&#13;
            option: option,&#13;
            code: code&#13;
        }];&#13;
    },&#13;
&#13;
    array: function bnf_array(yy, arrayName, arraySize, startValues) {&#13;
        var execCode = [];&#13;
&#13;
        var code = 'var buff1 = [];';&#13;
&#13;
        startValues = startValues || [];&#13;
&#13;
        startValues.forEach(function (el) {&#13;
            code += ';buff1.push(stack.pop());';&#13;
            execCode = execCode.concat(el);&#13;
        });&#13;
&#13;
        code += 'stack.push(buff1.reverse());';&#13;
&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].defined.push(arrayName);&#13;
        code = code + 'actualScope.' + arrayName + '= machineManager.objectMocks.Array.__constructor__.call({},' + arraySize + ', stack.pop());';&#13;
&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)(code, ''));&#13;
&#13;
        return execCode;&#13;
    },&#13;
&#13;
    var: function bnf_var(yy, varName) {&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].defined.push(varName);&#13;
        return (0, _languageUtils.generateExecuteObject)('actualScope.' + varName + ' = machineManager.objectMocks.Number.__constructor__.call({}, 0);');&#13;
    },&#13;
&#13;
    var_start_value: function var_start_value(yy, varName, operation) {&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].defined.push(varName);&#13;
&#13;
        operation.push((0, _languageUtils.generateExecuteObject)('actualScope.' + varName + ' = stack.pop();'));&#13;
&#13;
        return operation;&#13;
    },&#13;
&#13;
    function_call: function bnf_function_call(yy, functionName, args) {&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].fn.push(functionName);&#13;
&#13;
        return CODE_GENERATORS.dispatchFunction(yy, functionName, args || []);&#13;
    },&#13;
&#13;
    method_call: function bnf_method_call(methodName, args, operations) {&#13;
        var execObjects = [];&#13;
&#13;
        //Call args code in reverse order to save it on stack&#13;
        for (var i = args.length - 1; i &gt;= 0; i--) {&#13;
            execObjects = execObjects.concat(args[i]);&#13;
        }&#13;
&#13;
        execObjects = execObjects.concat(operations);&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)("stack.push('" + methodName + "');", ''));&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)("stack.push(" + args.length + ");", ''));&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)("functionsCallPositionStack.push(actualIndex);", ""));&#13;
        execObjects.push((0, _languageUtils.generateJumpInstruction)('true', '1_get_object_call_manager'));&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)("stack.push(retVal.value);", ''));&#13;
&#13;
        return execObjects;&#13;
    },&#13;
&#13;
    array_get: function bnf_array_get(variableName, operations) {&#13;
        return CODE_GENERATORS.method_call("__get__", [operations], variableName);&#13;
    },&#13;
&#13;
    function: function bnf_function(yy, functionName, functionArgs, sectionsBlock, codeBlock) {&#13;
        var sections = sectionsBlock || [];&#13;
&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].args = functionArgs;&#13;
        yy.functionNames.pop();&#13;
&#13;
        return CODE_GENERATORS.generateFunctionStart(functionArgs, functionName).concat(sections).concat(codeBlock).concat(CODE_GENERATORS.generateFunctionEnd(functionName));&#13;
    },&#13;
&#13;
    function_declaration: function bnf_function_declaration(yy, functionName) {&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[functionName] = { defined: [], args: [], vars: [], fn: [] };&#13;
        yy.actualFunctionName = functionName;&#13;
        yy.presenterContext.state.definedByUserFunctions.push(functionName);&#13;
        yy.functionNames.push(functionName);&#13;
&#13;
        return functionName;&#13;
    },&#13;
&#13;
    assign_value_1: function bnf_assign_value_1(yy, variableName, operations) {&#13;
        operations.push((0, _languageUtils.generateExecuteObject)('actualScope.' + variableName + ' = stack.pop();', ''));&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].vars.push(variableName);&#13;
&#13;
        return operations;&#13;
    },&#13;
&#13;
    assign_value_2: function bnf_assign_value_2(operations) {&#13;
        operations.push((0, _languageUtils.generateExecuteObject)('stack.pop()'));&#13;
&#13;
        return operations;&#13;
    },&#13;
&#13;
    assign_array_value: function bnf_assign_array_value(variableName, operations, value) {&#13;
        return CODE_GENERATORS.method_call("__set__", [operations, value], variableName);&#13;
    },&#13;
&#13;
    program_name: function bnf_program_name(yy, programName) {&#13;
        yy.actualFunctionName = '1_main';&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage['1_main'] = { defined: [], args: [], vars: [], fn: [] };&#13;
        return programName;&#13;
    },&#13;
&#13;
    argument: function bnf_argument(yy, argName) {&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].vars.push(argName);&#13;
&#13;
        return [(0, _languageUtils.generateExecuteObject)('stack.push(actualScope.' + argName + ');', '')];&#13;
    },&#13;
&#13;
    for_argument: function bnf_for_argument(yy, argName) {&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].vars.push(argName);&#13;
&#13;
        return 'actualScope.' + argName + '.value';&#13;
    },&#13;
&#13;
    for_value_header: uidDecorator(function bnf_for_value_header(yy, variableName, from, to, by, comparator) {&#13;
        var execElements = [];&#13;
&#13;
        yy.presenterContext.state.variablesAndFunctionsUsage[yy.actualFunctionName].vars.push(variableName);&#13;
&#13;
        yy.labelsStack.push(CODE_GENERATORS.uid + '_for');&#13;
        yy.labelsStack.push(CODE_GENERATORS.uid + '_for_end');&#13;
&#13;
        execElements = execElements.concat(from);&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)("actualScope." + variableName + ' = machineManager.objectMocks.Number.__constructor__(stack.pop().value - ' + by + ');'));&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)('', CODE_GENERATORS.uid + '_for'));&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.for++', ''));&#13;
        execElements = execElements.concat(to);&#13;
        execElements.push((0, _languageUtils.generateJumpInstruction)('!((Boolean(actualScope.' + variableName + ' = machineManager.objectMocks.Number.__constructor__(actualScope.' + variableName + '.value + ' + by + ')) || true) &amp;&amp; actualScope.' + variableName + ".value " + comparator + " stack.pop().value )", CODE_GENERATORS.uid + '_for_end'));&#13;
        return execElements;&#13;
    }),&#13;
&#13;
    for_exiter: function bnf_for_exiter(yy) {&#13;
        var execElements = [],&#13;
            exitLabel = yy.labelsStack.pop(),&#13;
            checkerLabel = yy.labelsStack.pop();&#13;
&#13;
        execElements.push((0, _languageUtils.generateJumpInstruction)('true', checkerLabel));&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.for--', exitLabel));&#13;
        return execElements;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param  {Object[]} expression&#13;
     * @param  {Object[]} code&#13;
     */&#13;
    if_instruction: uidDecorator(function bnf_if_instruction(expression, code) {&#13;
        var executableCode = [(0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.if++;')],&#13;
            if_end = CODE_GENERATORS.uid + "_end_if";&#13;
&#13;
        executableCode = executableCode.concat(expression);&#13;
        executableCode.push((0, _languageUtils.generateJumpInstruction)('!Boolean(stack.pop().value);', if_end));&#13;
        executableCode = executableCode.concat(code);&#13;
        executableCode.push((0, _languageUtils.generateExecuteObject)('', if_end));&#13;
&#13;
        return executableCode;&#13;
    }),&#13;
&#13;
    /**&#13;
     * @param  {Object[]} expression&#13;
     * @param  {Object[]} ifCode&#13;
     * @param  {Object[]} elseCode&#13;
     */&#13;
    if_else_instruction: uidDecorator(function bnf_if_else_instruction(expression, ifCode, elseCode) {&#13;
        var executableCode = [(0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.if++;')],&#13;
            else_start = CODE_GENERATORS.uid + "_else_if",&#13;
            if_end = CODE_GENERATORS.uid + "_end_if";&#13;
&#13;
        executableCode = executableCode.concat(expression);&#13;
        executableCode.push((0, _languageUtils.generateJumpInstruction)('!Boolean(stack.pop().value);', else_start));&#13;
        executableCode = executableCode.concat(ifCode);&#13;
        executableCode.push((0, _languageUtils.generateJumpInstruction)('true', if_end));&#13;
        executableCode.push((0, _languageUtils.generateExecuteObject)('', else_start));&#13;
        executableCode = executableCode.concat(elseCode);&#13;
        executableCode.push((0, _languageUtils.generateExecuteObject)('', if_end));&#13;
&#13;
        return executableCode;&#13;
    }),&#13;
&#13;
    while_header: uidDecorator(function bnf_while_header(yy, expression) {&#13;
        yy.labelsStack.push(CODE_GENERATORS.uid + "_while");&#13;
        yy.labelsStack.push(CODE_GENERATORS.uid + "_while_end");&#13;
&#13;
        var execElements = [];&#13;
&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.while++', CODE_GENERATORS.uid + "_while"));&#13;
        execElements = execElements.concat(expression);&#13;
        execElements.push((0, _languageUtils.generateJumpInstruction)('!Boolean(stack.pop().value)', CODE_GENERATORS.uid + "_while_end"));&#13;
&#13;
        return execElements;&#13;
    }),&#13;
&#13;
    while_exiter: function bnf_while_exiter(yy) {&#13;
        var exitLabel = yy.labelsStack.pop(),&#13;
            startWhileLabel = yy.labelsStack.pop(),&#13;
            execElements = [];&#13;
&#13;
        execElements.push((0, _languageUtils.generateJumpInstruction)('true', startWhileLabel));&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.while--', exitLabel));&#13;
&#13;
        return execElements;&#13;
    },&#13;
&#13;
    return_value: function bnf_return_value(yy, returnCode) {&#13;
        var actualFunctionName = yy.functionNames[yy.functionNames.length - 1],&#13;
            execCommands = returnCode;&#13;
&#13;
        execCommands.push((0, _languageUtils.generateExecuteObject)("retVal = {value: stack.pop()};", ""));&#13;
        execCommands.push((0, _languageUtils.generateJumpInstruction)('true', "1_" + actualFunctionName));&#13;
&#13;
        return execCommands;&#13;
    },&#13;
&#13;
    do_while_header: uidDecorator(function bnf_do_while_header(yy) {&#13;
        var execElements = [],&#13;
            enterLabel = CODE_GENERATORS.uid + "_do_while_enter";&#13;
&#13;
        execElements.push((0, _languageUtils.generateExecuteObject)('machineManager.objectForInstructions.calledInstructions.doWhile++;', enterLabel));&#13;
        yy.labelsStack.push(enterLabel);&#13;
&#13;
        return execElements;&#13;
    }),&#13;
&#13;
    do_while_exiter: function bnf_do_while_exiter(yy, expression) {&#13;
        var execElements = [],&#13;
            enterLabel = yy.labelsStack.pop();&#13;
&#13;
        execElements = execElements.concat(expression);&#13;
        execElements.push((0, _languageUtils.generateJumpInstruction)('Boolean(stack.pop().value)', enterLabel));&#13;
&#13;
        return execElements;&#13;
    },&#13;
&#13;
    generateFunctionStart: function presenter_generateFunctionStart(argsList, functionName) {&#13;
        var execObjects = [],&#13;
            i = void 0,&#13;
            initialCommand = "";&#13;
&#13;
        // Set start label&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)('', functionName));&#13;
&#13;
        initialCommand += "eax = stack.pop();\n"; //Size of args array&#13;
        initialCommand += "ebx = Math.abs(eax - " + argsList.length + ");\n";&#13;
&#13;
        initialCommand += "if (eax &lt; " + argsList.length + ") throw machineManager.exceptions.ToFewArgumentsException('" + functionName + "'," + argsList.length + ");\n";&#13;
&#13;
        initialCommand += "stack.push(actualScope);\n"; //Save actualScope on stack&#13;
        initialCommand += "actualScope = {};\n"; //Reset scope to default&#13;
&#13;
        // Add to actualScope variables passed in stack, but in stack is actualScope saved! (while function call)&#13;
        for (i = argsList.length - 1; i &gt;= 0; i -= 1) {&#13;
            initialCommand += "actualScope['" + argsList[Math.abs(i - (argsList.length - 1))] + "'] = stack[stack.length - (2 + " + i + " + ebx)];\n";&#13;
        }&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)(initialCommand, '')); //Call it as code&#13;
&#13;
        return execObjects;&#13;
    },&#13;
&#13;
    generateFunctionEnd: function presenter_generateFunctionEnd(functionName) {&#13;
        var execCommands = [],&#13;
            exitCommand = "";&#13;
&#13;
        execCommands.push((0, _languageUtils.generateExecuteObject)('retVal.value = machineManager.objectMocks.Number.__constructor__(0);', '')); //If code goes there without return, then add to stack default value&#13;
&#13;
        execCommands.push((0, _languageUtils.generateExecuteObject)('', '1_' + functionName)); //Here return will jump. Define as 1_&lt;function_name&gt;.&#13;
&#13;
        exitCommand += "actualScope = {};"; // Clear scope&#13;
        exitCommand += "actualScope = stack.pop();"; //Get saved scope&#13;
&#13;
        execCommands.push((0, _languageUtils.generateExecuteObject)(exitCommand, ''));&#13;
&#13;
        execCommands.push((0, _languageUtils.generateExecuteObject)("actualIndex = functionsCallPositionStack.pop() + 1;", ""));&#13;
&#13;
        return execCommands;&#13;
    },&#13;
&#13;
    /**&#13;
     * @param stack {Object[]}&#13;
     * @param consoleObj {UserConsole}&#13;
     * @param objects {Object[]} List of objects from objectMocks&#13;
     * @param next {Function}&#13;
     * @param pause {Function}&#13;
     * @param retVal {{value: Object}}&#13;
     * @returns {*|void}&#13;
     */&#13;
    builtInMethodCall: function presenter_builtInMethodCall(machineManager, stack, consoleObj, objects, next, pause, retVal) {&#13;
        var argsCount = stack.pop();&#13;
        var methName = stack.pop();&#13;
        var obj = stack.pop();&#13;
        var args = [consoleObj, objects, next, pause, retVal];&#13;
&#13;
        var method = CODE_GENERATORS.getMethodFromObject(machineManager, obj, methName).jsCode;&#13;
&#13;
        for (var i = 0; i &lt; argsCount; i++) {&#13;
            args.push(stack.pop());&#13;
        }&#13;
&#13;
        return method.apply(obj, args);&#13;
    },&#13;
&#13;
    /**&#13;
     * @param  {Object} yy&#13;
     * @param  {Object[]} firstVal array with calculations first value&#13;
     * @param  {Object[]} secVal array with calculations second value&#13;
     * @param  {('__add__'|'__sub__'|'__div__'|'__mul__'|'__div_full__'|'__mod__'|'__ge__'|'__le__'|'__gt__'|'__lt__'|'__neq__'|'__eq__')} operationType&#13;
     * @return {Object[]}&#13;
     */&#13;
    generateOperationCode: function presenter_generateOperationCode(yy, firstVal, secVal, operationType) {&#13;
        var execObjects = firstVal.concat(secVal),&#13;
            code = "",&#13;
            exitCode = "",&#13;
            preCode = "";&#13;
&#13;
        code += "ebx = stack.pop();";&#13;
        code += "eax = stack.pop();";&#13;
        code += "stack.push(ebx);";&#13;
        code += "stack.push(eax);";&#13;
        code += "stack.push('" + operationType + "');";&#13;
        code += "stack.push(1);";&#13;
        code += "functionsCallPositionStack.push(actualIndex);";&#13;
&#13;
        exitCode += "stack.push(retVal.value);";&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)(code, ""));&#13;
        execObjects.push((0, _languageUtils.generateJumpInstruction)('true', '1_get_object_call_manager'));&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)(exitCode, ''));&#13;
        return execObjects;&#13;
    },&#13;
&#13;
    /**&#13;
     *&#13;
     * @param yy&#13;
     * @param {Object[]} firstVal&#13;
     * @param {Object[]} secVal&#13;
     */&#13;
    generateOptimizedAndOperationCode: function presenter_generateOptimizedAndOperationCode(yy, firstVal, secVal) {&#13;
        var execObjects = firstVal;&#13;
        var code = "";&#13;
        var exitLabel = getuid() + "_optimized_and_exiter";&#13;
&#13;
        code += "eax = stack.pop();";&#13;
        code += "if (!eax.value) stack.push(eax);";&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)(code, ''));&#13;
        execObjects.push((0, _languageUtils.generateJumpInstruction)('!eax.value', exitLabel));&#13;
&#13;
        execObjects = execObjects.concat(secVal);&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)('', exitLabel));&#13;
&#13;
        return execObjects;&#13;
    },&#13;
&#13;
    /**&#13;
     *&#13;
     * @param yy&#13;
     * @param {Object[]} firstVal&#13;
     * @param {Object[]} secVal&#13;
     */&#13;
    generateOptimizedOrOperationCode: function presenter_generateOptimizedAndOperationCode(yy, firstVal, secVal) {&#13;
        var execObjects = firstVal;&#13;
        var code = "";&#13;
        var exitLabel = getuid() + "_optimized_or_exiter";&#13;
&#13;
        code += "eax = stack.pop();";&#13;
        code += "if (eax.value) stack.push(eax);";&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)(code, ''));&#13;
        execObjects.push((0, _languageUtils.generateJumpInstruction)('eax.value', exitLabel));&#13;
&#13;
        execObjects = execObjects.concat(secVal);&#13;
&#13;
        execObjects.push((0, _languageUtils.generateExecuteObject)('', exitLabel));&#13;
&#13;
        return execObjects;&#13;
    },&#13;
&#13;
    generateMinusOperation: function presenter_generateMinusOperation(execObjects) {&#13;
        var retVal = [].concat(execObjects);&#13;
        var code = "";&#13;
        var exitCode = "";&#13;
&#13;
        code += "stack.push('__minus__');";&#13;
        code += "stack.push(0);";&#13;
        code += "functionsCallPositionStack.push(actualIndex);";&#13;
&#13;
        exitCode += "stack.push(retVal.value);";&#13;
&#13;
        retVal.push((0, _languageUtils.generateExecuteObject)(code, ""));&#13;
        retVal.push((0, _languageUtils.generateJumpInstruction)('true', '1_get_object_call_manager'));&#13;
        retVal.push((0, _languageUtils.generateExecuteObject)(exitCode, ''));&#13;
        return retVal;&#13;
    },&#13;
&#13;
    dispatchFunction: function presenter_dispatchFunction(yy, functionName, args) {&#13;
        var execCode = [],&#13;
            clearStackCode = '',&#13;
            i = void 0;&#13;
&#13;
        for (i = 1; i &lt;= args.length; i += 1) {&#13;
            execCode = execCode.concat(args[i - 1]);&#13;
            clearStackCode += 'stack.pop();';&#13;
        }&#13;
&#13;
        if (yy.presenterContext.configuration.functions.hasOwnProperty(functionName)) {&#13;
            execCode = execCode.concat(CODE_GENERATORS.dispatchForBuiltInFunctions(functionName, args));&#13;
        } else {&#13;
            execCode.push((0, _languageUtils.generateExecuteObject)("stack.push(" + args.length + ");", ''));&#13;
            execCode.push((0, _languageUtils.generateExecuteObject)("functionsCallPositionStack.push(actualIndex);", "")); //Push actual index of code, function before end will return to that index&#13;
            execCode = execCode.concat(CODE_GENERATORS.dispatchUserFunction(functionName));&#13;
        }&#13;
&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)(clearStackCode, ''));&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)('stack.push(retVal.value);', ''));&#13;
        return execCode;&#13;
    },&#13;
&#13;
    dispatchUserFunction: function presenter_dispatchUserFunction(functionName) {&#13;
        var execCode = [];&#13;
&#13;
        execCode.push((0, _languageUtils.generateJumpInstruction)('true', functionName));&#13;
&#13;
        return execCode;&#13;
    },&#13;
&#13;
    /**&#13;
     * Dispatch for build in function (function declared in properties)&#13;
     * Returned value is executed in machine scope, so next, pause, retVal are locally variable for each machine (function machineManager.codeExecutor is scope for this code (eval))&#13;
     * @param  {String} functionName&#13;
     * @param  {Array[]} args contains how to resolve each argument&#13;
     */&#13;
    dispatchForBuiltInFunctions: function presenter_dispatchForBuiltInFunctions(functionName, args) {&#13;
        var parsedArgs = [],&#13;
            i = void 0,&#13;
            code = void 0,&#13;
            execCode = [];&#13;
&#13;
        // That must be there, because, we don't know how many args receive built in function, so we send all args to this function&#13;
        for (i = 1; i &lt;= args.length; i += 1) {&#13;
            parsedArgs.unshift("stack[stack.length - " + i + "]");&#13;
        }&#13;
&#13;
        if (parsedArgs.length &gt; 0) {&#13;
            code = "machineManager.configuration.functions." + functionName + ".call({}, machineManager.objectForInstructions, machineManager.objectMocks, next, pause, retVal," + parsedArgs.join(",") + ");";&#13;
        } else {&#13;
            code = "machineManager.configuration.functions." + functionName + ".call({}, machineManager.objectForInstructions, machineManager.objectMocks, next, pause, retVal);";&#13;
        }&#13;
&#13;
        execCode.push((0, _languageUtils.generateExecuteObject)(code, '', true));&#13;
&#13;
        return execCode;&#13;
    },&#13;
&#13;
    number_value: function presenter_number_value(yy, yytext) {&#13;
        return [(0, _languageUtils.generateExecuteObject)('stack.push(machineManager.objectMocks.Number.__constructor__.call({}, Number(' + yytext + ')))', '')];&#13;
    },&#13;
&#13;
    string_value: function string_value(yy, chars) {&#13;
        return [(0, _languageUtils.generateExecuteObject)('stack.push(machineManager.objectMocks.String.__constructor__.call({},"' + (chars || '') + '"))', '')];&#13;
    }&#13;
};&#13;
&#13;
/***/ }),&#13;
/* 12 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.UserConsole = UserConsole;&#13;
var consoleClasses = {&#13;
    "LINES_CONTAINER": "pseudoConsole-console-container",&#13;
    "CURSOR": "pseudoConsole-console-cursor",&#13;
    "ACTIVE_CURSOR": "pseudoConsole-console-cursor-active",&#13;
    "RIGHT_ELEMENT": "pseudoConsole-console-right-element",&#13;
    "LEFT_ELEMENT": "pseudoConsole-console-left-element",&#13;
    "TEXT_AREA": "pseudoConsole-console-textarea"&#13;
};&#13;
&#13;
/**&#13;
 *&#13;
 * @param {jQuery} $element&#13;
 * @param {{inputChecker: Function}}config&#13;
 * @constructor&#13;
 */&#13;
function UserConsole($element, config) {&#13;
    this.container = $("&lt;pre&gt;&lt;/pre&gt;");&#13;
    this.$textArea = $("&lt;textarea class='pseudoConsole-console-textarea'&gt;&lt;/textarea&gt;");&#13;
    this.linesContainer = $("&lt;div class='" + consoleClasses.LINES_CONTAINER + "'&gt;&lt;/div&gt;");&#13;
    this.$parentElement = $element;&#13;
    this.lines = [];&#13;
    this.activeLineIndex = -1;&#13;
    this.isReadMode = false; //Console is waiting for user input&#13;
    this.isDisabled = false;&#13;
    this.config = config;&#13;
    this.characterWidth = 0;&#13;
&#13;
    $element.append(this.container);&#13;
    $element.append(this.$textArea);&#13;
&#13;
    this.container.append(this.linesContainer);&#13;
&#13;
    this.addNewLine(true);&#13;
}&#13;
&#13;
UserConsole.prototype = {&#13;
    generateLine: function generateLine(className) {&#13;
        if (!className) {&#13;
            className = '';&#13;
        }&#13;
&#13;
        var $htmlObject = $("&lt;span&gt;&lt;/span&gt;"),&#13;
            $left = $("&lt;span class='" + className + " " + consoleClasses.LEFT_ELEMENT + "'&gt;&lt;/span&gt;"),&#13;
            $right = $("&lt;span class='" + className + " " + consoleClasses.RIGHT_ELEMENT + "'&gt;&lt;/span&gt;"),&#13;
            $cursor = $("&lt;span class='" + consoleClasses.CURSOR + "'&gt;&lt;/span&gt;");&#13;
&#13;
        $htmlObject.append($left);&#13;
        $htmlObject.append($cursor);&#13;
        $htmlObject.append($right);&#13;
&#13;
        return {&#13;
            $htmlObject: $htmlObject,&#13;
            elements: {&#13;
                $left: $left,&#13;
                $cursor: $cursor,&#13;
                $right: $right&#13;
            }&#13;
        };&#13;
    },&#13;
&#13;
    /**&#13;
     * @param  {Boolean} isActive Activate this line automatically&#13;
     * @param  {String} [className] set class for that line&#13;
     */&#13;
    addNewLine: function addNewLine(isActive, className) {&#13;
        if (!className) {&#13;
            className = '';&#13;
        }&#13;
&#13;
        var line = this.generateLine(className);&#13;
        this.lines.push(line);&#13;
        this.linesContainer.append(line.$htmlObject);&#13;
&#13;
        if (isActive) {&#13;
            this.selectLineAsActive(this.lines.length - 1);&#13;
        }&#13;
&#13;
        this.$parentElement[0].scrollTop = this.$parentElement[0].scrollHeight;&#13;
    },&#13;
&#13;
    selectLineAsActive: function selectLineAsActive(index) {&#13;
        var activeLine = null;&#13;
        if (this.activeLineIndex &gt; -1) {&#13;
            activeLine = this.getActiveLine();&#13;
            activeLine.elements.$left.text(activeLine.elements.$left.text() + activeLine.elements.$right.text());&#13;
            activeLine.elements.$right.text('');&#13;
            activeLine.elements.$cursor.html('');&#13;
            activeLine.elements.$cursor.removeClass(consoleClasses.ACTIVE_CURSOR);&#13;
        }&#13;
&#13;
        this.activeLineIndex = index;&#13;
        activeLine = this.lines[index];&#13;
        activeLine.elements.$cursor.html('&amp;nbsp;');&#13;
        activeLine.elements.$cursor.addClass(consoleClasses.ACTIVE_CURSOR);&#13;
    },&#13;
    /**&#13;
     * @returns {{$htmlObject: jQuery, elements: {$left: jQuery, $right: jQuery, $cursor: jQuery}}}&#13;
     */&#13;
    getActiveLine: function getActiveLine() {&#13;
        return this.lines[this.activeLineIndex];&#13;
    },&#13;
&#13;
    /**&#13;
     * @param  {String} text&#13;
     * @param  {String} className&#13;
     */&#13;
    Write: function Write(text, className) {&#13;
        if (this.isReadMode) {&#13;
            //Dont write to console if is in read mode.&#13;
            return;&#13;
        }&#13;
&#13;
        text = String(text);&#13;
&#13;
        this.addNewLine(true, className);&#13;
&#13;
        var lines = text.split('\n'),&#13;
            line = void 0,&#13;
            activeLine = this.getActiveLine(),&#13;
            i = void 0;&#13;
&#13;
        for (i = 0; i &lt; lines.length - 1; i += 1) {&#13;
            line = lines[i];&#13;
            activeLine.elements.$left.text(activeLine.elements.$left.text() + line);&#13;
            this.addNewLine(true, className);&#13;
            activeLine = this.getActiveLine();&#13;
            activeLine.elements.$left.text("\n");&#13;
        }&#13;
&#13;
        activeLine = this.getActiveLine();&#13;
        line = lines[i];&#13;
        activeLine.elements.$left.text(activeLine.elements.$left.text() + line);&#13;
        this.scrollRight();&#13;
    },&#13;
&#13;
    ReadLine: function ReadLine(callback) {&#13;
        if (this.isReadMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        this.isReadMode = true;&#13;
        var self = this;&#13;
&#13;
        this.readLineFunction(function (data) {&#13;
            self.isReadMode = false;&#13;
            callback(data);&#13;
        });&#13;
    },&#13;
&#13;
    readLineFunction: function readLineFunction(onExitCallback) {&#13;
        if (!this.isReadMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        this.addNewLine(true);&#13;
&#13;
        var textAreaElement = this.$textArea,&#13;
            parentElement = this.$parentElement,&#13;
            self = this;&#13;
&#13;
        $(parentElement).on('click', function () {&#13;
            textAreaElement.off();&#13;
            textAreaElement.focus();&#13;
&#13;
            textAreaElement.on('input', function () {&#13;
                return self.onInputCallback();&#13;
            });&#13;
&#13;
            textAreaElement.on('keydown', function (event) {&#13;
                return self.onKeyDownCallback(event, onExitCallback);&#13;
            });&#13;
        });&#13;
&#13;
        $(parentElement).click();&#13;
    },&#13;
&#13;
    onInputCallback: function onInputCallback() {&#13;
        if (this.isDisabled) {&#13;
            return;&#13;
        }&#13;
&#13;
        var textAreaElement = this.$textArea,&#13;
            activeLine = this.getActiveLine(),&#13;
            data = textAreaElement.val(),&#13;
            leftText = activeLine.elements.$left.text(),&#13;
            rightText = activeLine.elements.$right.text();&#13;
&#13;
        textAreaElement.val('');&#13;
&#13;
        if (!this.config.inputChecker(data, leftText + data + rightText)) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (data.length &gt; 0) {&#13;
            if (data[data.length - 1] !== '\n') {&#13;
                leftText = leftText + data;&#13;
            }&#13;
        }&#13;
&#13;
        activeLine.elements.$left.text(leftText);&#13;
        activeLine.elements.$right.text(rightText);&#13;
&#13;
        this.scrollRight();&#13;
&#13;
        return false;&#13;
    },&#13;
&#13;
    onKeyDownCallback: function onKeyDownCallback(event, onExitCallback) {&#13;
        if (this.isDisabled) {&#13;
            return;&#13;
        }&#13;
&#13;
        var textAreaElement = this.$textArea,&#13;
            activeLine = this.getActiveLine(),&#13;
            keycode = event.which || event.keycode,&#13;
            leftText = activeLine.elements.$left.text(),&#13;
            rightText = activeLine.elements.$right.text(),&#13;
            parentElement = this.$parentElement;&#13;
&#13;
        if (keycode === 39 || keycode === 37 || keycode === 8 || keycode === 13) {&#13;
            if (keycode === 39) {&#13;
                //Left arrow&#13;
                if (rightText.length &gt; 0) {&#13;
                    leftText += rightText[0];&#13;
                    rightText = rightText.substring(1);&#13;
                }&#13;
            } else if (keycode === 37) {&#13;
                //Right arrow&#13;
                if (leftText.length &gt; 0) {&#13;
                    rightText = leftText[leftText.length - 1] + rightText;&#13;
                    leftText = leftText.substring(0, leftText.length - 1);&#13;
                }&#13;
            } else if (keycode === 8) {&#13;
                //Backspace&#13;
                leftText = leftText.substring(0, leftText.length - 1);&#13;
            } else if (keycode === 13) {&#13;
                if ((leftText + rightText).length &gt; 0) {&#13;
                    $(parentElement).off();&#13;
                    textAreaElement.off();&#13;
                    onExitCallback(leftText + rightText);&#13;
                }&#13;
            }&#13;
&#13;
            activeLine.elements.$left.text(leftText);&#13;
            activeLine.elements.$right.text(rightText);&#13;
            textAreaElement.val('');&#13;
&#13;
            this.scrollRight();&#13;
            return false;&#13;
        }&#13;
    },&#13;
&#13;
    ReadChar: function ReadChar(callback) {&#13;
        if (this.isReadMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        this.isReadMode = true;&#13;
&#13;
        this.addNewLine(true);&#13;
&#13;
        var activeLine = this.getActiveLine(),&#13;
            textAreaElement = this.$textArea,&#13;
            parentElement = this.$parentElement,&#13;
            data = void 0,&#13;
            leftText = void 0,&#13;
            self = this;&#13;
&#13;
        $(parentElement).on('click', function () {&#13;
            textAreaElement.off();&#13;
            textAreaElement.focus();&#13;
&#13;
            textAreaElement.on('input', function () {&#13;
                if (self.isDisabled) {&#13;
                    return;&#13;
                }&#13;
&#13;
                leftText = activeLine.elements.$left.text();&#13;
                data = textAreaElement.val();&#13;
&#13;
                if (!self.config.inputChecker(data, data)) {&#13;
                    return;&#13;
                }&#13;
&#13;
                if (data[data.length - 1] !== "\n") {&#13;
                    $(parentElement).off();&#13;
                    textAreaElement.off();&#13;
                    activeLine.elements.$left.text(leftText + data[data.length - 1]); //Get only last char&#13;
                    self.isReadMode = false;&#13;
                    textAreaElement.val('');&#13;
                    callback(data[data.length - 1]);&#13;
                }&#13;
&#13;
                self.scrollRight();&#13;
            });&#13;
        });&#13;
&#13;
        $(parentElement).click();&#13;
    },&#13;
&#13;
    Reset: function Reset() {&#13;
        var textAreaElement = this.$textArea,&#13;
            parentElement = this.$parentElement;&#13;
&#13;
        parentElement.off();&#13;
        textAreaElement.off();&#13;
&#13;
        this.isReadMode = false;&#13;
&#13;
        this.linesContainer.find('span').remove();&#13;
        this.lines = [];&#13;
&#13;
        this.activeLineIndex = -1;&#13;
&#13;
        this.addNewLine(true);&#13;
&#13;
        this.$textArea.val('');&#13;
    },&#13;
&#13;
    destroy: function destroy() {&#13;
        this.Reset();&#13;
    },&#13;
&#13;
    disable: function disable() {&#13;
        this.isDisabled = true;&#13;
    },&#13;
&#13;
    enable: function enable() {&#13;
        this.isDisabled = false;&#13;
    },&#13;
&#13;
    scrollRight: function scrollRight() {&#13;
        var actualLine = this.getActiveLine();&#13;
        var cursorLeftPosition = actualLine.elements.$cursor.position().left;&#13;
        var actualScroll = this.$parentElement.scrollLeft();&#13;
        var parentWidth = this.$parentElement.width();&#13;
&#13;
        this.$parentElement.scrollLeft(actualScroll + cursorLeftPosition - parentWidth / 2);&#13;
    }&#13;
};&#13;
&#13;
/***/ }),&#13;
/* 13 */&#13;
/***/ (function(module, exports, __webpack_require__) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.codeExecutor = codeExecutor;&#13;
&#13;
var _languageUtils = __webpack_require__(2);&#13;
&#13;
/**&#13;
 * @param  {Object} parsedData parsed code by jison&#13;
 * @param  {Boolean} getScore if function will be called to get score&#13;
 * @param  {Object} machineManager&#13;
 */&#13;
function codeExecutor(parsedData, getScore, machineManager) {&#13;
    var actualIndex = 0,&#13;
        code = parsedData.code,&#13;
        timeoutId = 0,&#13;
        isEnded = false,&#13;
        startTime = new Date().getTime() / 1000,&#13;
        actualScope = {},&#13;
        // There will be saved actual variables&#13;
    stack = [],&#13;
        // Stack contains saved scopes&#13;
    functionsCallPositionStack = [],&#13;
        //Stack which contains information about actual executed code position.&#13;
    retVal = { value: 0 },&#13;
        // value returned by function,&#13;
    eax = { value: 0 },&#13;
        // Helper register used in generated code (used for saving temporary data while executing code)&#13;
    ebx = { value: 0 },&#13;
        // Helper register used in generated code (used for saving temporary data while executing code)&#13;
    id = window.Helpers.uuidv4(); // Each machine contains own unique id which will be saved in presenter&#13;
&#13;
    function getIndexByLabel(label) {&#13;
        var i = void 0;&#13;
        for (i = 0; i &lt; code.length; i += 1) {&#13;
            if (code[i] &amp;&amp; code[i].label === label) {&#13;
                return i;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     *  Execute each line of code generated by JISON&#13;
     * @returns {Boolean} false - if code was executed, true if program is ended&#13;
     */&#13;
    function executeLine() {&#13;
        var actualEntry = code[actualIndex];&#13;
        if (actualEntry) {&#13;
            if (actualEntry.type === _languageUtils.TYPES.EXECUTE) {&#13;
                eval(actualEntry.code);&#13;
                actualIndex += 1;&#13;
            } else if (actualEntry.type === _languageUtils.TYPES.JUMP) {&#13;
                if (eval(actualEntry.code)) {&#13;
                    actualIndex = getIndexByLabel(actualEntry.toLabel);&#13;
                } else {&#13;
                    actualIndex += 1;&#13;
                }&#13;
            }&#13;
            return false;&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    function pause() {&#13;
        clearTimeout(timeoutId);&#13;
    }&#13;
&#13;
    function next() {&#13;
        if (!isEnded) {&#13;
            timeoutId = setTimeout(executeAsync, 1);&#13;
        }&#13;
    }&#13;
&#13;
    function executeAsync() {&#13;
        next();&#13;
        try {&#13;
            isEnded = executeLine();&#13;
            if (isEnded) {&#13;
                pause();&#13;
            }&#13;
        } catch (e) {&#13;
            if (!e.message) {&#13;
                machineManager.state.console.Write(e + "\n", 'program-error-output');&#13;
            } else {&#13;
                machineManager.state.console.Write(e.message + "\n", 'program-error-output');&#13;
            }&#13;
            killMachine();&#13;
        }&#13;
    }&#13;
&#13;
    function killMachine() {&#13;
        pause();&#13;
        delete machineManager.killMachine[id];&#13;
        actualScope = null;&#13;
        stack = null;&#13;
        functionsCallPositionStack = null;&#13;
        eax = null;&#13;
        ebx = null;&#13;
        isEnded = true;&#13;
        return true;&#13;
    }&#13;
&#13;
    function executeCodeSyncWithMaxTime() {&#13;
        var actualTime = void 0;&#13;
        while (true) {&#13;
            actualTime = new Date().getTime() / 1000;&#13;
            if (actualTime - startTime &gt; machineManager.configuration.answer.maxTimeForAnswer.parsedValue) {&#13;
                killMachine();&#13;
                return;&#13;
            }&#13;
            try {&#13;
                isEnded = executeLine();&#13;
                if (isEnded) {&#13;
                    killMachine();&#13;
                    return;&#13;
                }&#13;
            } catch (e) {&#13;
                killMachine();&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    machineManager.killMachine[id] = killMachine;&#13;
&#13;
    eval(parsedData.sections);&#13;
&#13;
    if (getScore) {&#13;
        executeCodeSyncWithMaxTime();&#13;
    } else {&#13;
        executeAsync();&#13;
    }&#13;
}&#13;
&#13;
/***/ }),&#13;
/* 14 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.validateFunction = validateFunction;&#13;
exports.validateFunctions = validateFunctions;&#13;
exports.validateAliases = validateAliases;&#13;
exports.validateAnswer = validateAnswer;&#13;
exports.validateMethod = validateMethod;&#13;
exports.validateModel = validateModel;&#13;
/**&#13;
 * Wrap each function or method defined by user by this code. It will set default values for function and initialize console for call&#13;
 * Functions pause and next will stop or resume machine which actually executes this code.&#13;
 * @param {String} userCode&#13;
 * @returns {string}&#13;
 */&#13;
function wrapMethodOrFunctionWithBuiltInCode(userCode) {&#13;
    var code = "var builtIn = {\n";&#13;
    code += "   console: arguments[0].console,\n";&#13;
    code += "   data: arguments[0].data,";&#13;
    code += "   objects: arguments[1],\n";&#13;
    code += "   retVal: arguments[4]\n";&#13;
    code += "};";&#13;
    code += "builtIn.console.nextIns = arguments[2];\n";&#13;
    code += "builtIn.console.pauseIns = arguments[3];\n";&#13;
    code += "arguments = Array.prototype.slice.call(arguments, 5)\n";&#13;
&#13;
    code += userCode;&#13;
&#13;
    return code;&#13;
}&#13;
&#13;
function generateValidationError(errorCode) {&#13;
    return {&#13;
        isValid: false,&#13;
        errorCode: errorCode&#13;
    };&#13;
}&#13;
&#13;
function validateFunction(functionToValidate) {&#13;
    var validatedFunction = void 0;&#13;
&#13;
    if (!/^[A-Za-z_][a-zA-Z0-9_]*$/g.exec(functionToValidate.name)) {&#13;
        return generateValidationError("FN01");&#13;
    }&#13;
&#13;
    try {&#13;
        validatedFunction = new Function(wrapMethodOrFunctionWithBuiltInCode(functionToValidate.body));&#13;
    } catch (e) {&#13;
        return generateValidationError("JS02");&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: {&#13;
            name: functionToValidate.name,&#13;
            body: validatedFunction&#13;
        }&#13;
    };&#13;
}&#13;
&#13;
function validateFunctions(functions) {&#13;
    var validatedFunctions = {},&#13;
        i = void 0,&#13;
        validatedFunction = void 0;&#13;
&#13;
    for (i = 0; i &lt; functions.length; i += 1) {&#13;
        if (functions[i].name.trim().length === 0) {&#13;
            continue;&#13;
        }&#13;
&#13;
        validatedFunction = validateFunction(functions[i]);&#13;
        if (!validatedFunction.isValid) {&#13;
            return validatedFunction;&#13;
        }&#13;
&#13;
        if (validatedFunctions[validatedFunction.value.name]) {&#13;
            return generateValidationError("FN02");&#13;
        }&#13;
&#13;
        validatedFunctions[validatedFunction.value.name] = validatedFunction.value.body;&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: validatedFunctions&#13;
    };&#13;
}&#13;
&#13;
function validateAliases(aliases) {&#13;
    var definedAliases = {},&#13;
        aliasKey = void 0,&#13;
        aliasName = void 0,&#13;
        exists = {};&#13;
&#13;
    for (aliasKey in aliases) {&#13;
        if (aliases.hasOwnProperty(aliasKey)) {&#13;
            if (aliases[aliasKey].name &amp;&amp; !ModelValidationUtils.isStringEmpty(aliases[aliasKey].name.trim())) {&#13;
                aliasName = aliases[aliasKey].name.trim();&#13;
&#13;
                if (!/^[A-Za-z_][a-zA-Z0-9_]*$/g.exec(aliasName)) {&#13;
                    return generateValidationError("AN01");&#13;
                }&#13;
&#13;
                definedAliases[aliasKey] = aliases[aliasKey].name.trim();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    for (aliasKey in definedAliases) {&#13;
        if (definedAliases.hasOwnProperty(aliasKey)) {&#13;
            if (exists[definedAliases[aliasKey]]) {&#13;
                return generateValidationError("AN02");&#13;
            }&#13;
&#13;
            exists[definedAliases[aliasKey]] = true;&#13;
        }&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: definedAliases&#13;
    };&#13;
}&#13;
&#13;
function validateParameters(params) {&#13;
    var parameters = [],&#13;
        i = void 0;&#13;
    for (i = 0; i &lt; params.length; i += 1) {&#13;
        parameters.push(params[i].value);&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: parameters&#13;
    };&#13;
}&#13;
&#13;
function validateAnswer(model) {&#13;
    var runUserCode = ModelValidationUtils.validateBoolean(model.runUserCode),&#13;
        answerCode = model.answerCode,&#13;
        maxTimeForAnswer = ModelValidationUtils.validateFloatInRange(model.maxTimeForAnswer, 10, 0),&#13;
        validatedParameters = void 0,&#13;
        answerCodeFunction = void 0;&#13;
&#13;
    if (runUserCode &amp;&amp; (!maxTimeForAnswer.isValid || maxTimeForAnswer.parsedValue === 0)) {&#13;
        return generateValidationError("IP01");&#13;
    }&#13;
&#13;
    validatedParameters = validateParameters(model.runParameters);&#13;
&#13;
    try {&#13;
        answerCodeFunction = new Function(answerCode);&#13;
    } catch (e) {&#13;
        return generateValidationError("IP02");&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        runUserCode: runUserCode,&#13;
        answerCode: answerCodeFunction,&#13;
        maxTimeForAnswer: maxTimeForAnswer,&#13;
        parameters: validatedParameters.value&#13;
    };&#13;
}&#13;
&#13;
function validateUniquenessAliasesNamesAndFunctions(aliases, functions) {&#13;
    var aliasKey = void 0;&#13;
&#13;
    for (aliasKey in aliases) {&#13;
        if (aliases.hasOwnProperty(aliasKey)) {&#13;
            if (functions[aliases[aliasKey]]) {&#13;
                return generateValidationError("FN03");&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true&#13;
    };&#13;
}&#13;
&#13;
/**&#13;
 * @param {{objectName: (Array|Number|String), methodName: String, methodBody: String}} method&#13;
 */&#13;
function validateMethod(method) {&#13;
    var validatedMethod = {};&#13;
&#13;
    try {&#13;
        validatedMethod = {&#13;
            objectName: method.objectName,&#13;
            methodName: method.methodName,&#13;
            function: new Function(wrapMethodOrFunctionWithBuiltInCode(method.methodBody))&#13;
        };&#13;
    } catch (e) {&#13;
        return generateValidationError("JS01");&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        method: validatedMethod&#13;
    };&#13;
}&#13;
&#13;
/**&#13;
 * @param {{objectName: (Array|Number|String), methodName: String, methodBody: String}[]} methods&#13;
 */&#13;
function validateMethods(methods) {&#13;
    var validatedMethods = [];&#13;
&#13;
    methods.forEach(function (method) {&#13;
        var validatedMethod = validateMethod(method);&#13;
&#13;
        if (!validatedMethod.isValid) {&#13;
            return validatedMethod;&#13;
        }&#13;
&#13;
        validatedMethods.push(validatedMethod.method);&#13;
    });&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        methods: validatedMethods&#13;
    };&#13;
}&#13;
&#13;
function validateRound(model) {&#13;
    var round = model['mathRound'];&#13;
&#13;
    if (round.trim() === '') {&#13;
        return {&#13;
            isValid: true,&#13;
            value: 20&#13;
        };&#13;
    }&#13;
&#13;
    var parsedRound = parseInt(round, 10);&#13;
&#13;
    if (isNaN(parsedRound)) {&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: "ER01"&#13;
        };&#13;
    }&#13;
&#13;
    if (parsedRound &lt; 1) {&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: "ER02"&#13;
        };&#13;
    }&#13;
&#13;
    if (parsedRound &gt; 20) {&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: "ER03"&#13;
        };&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: parsedRound&#13;
    };&#13;
}&#13;
&#13;
function validateConsoleAvailableInput(model) {&#13;
    var consoleAvailableInput = model.consoleAvailableInput;&#13;
&#13;
    if (consoleAvailableInput === "") {&#13;
        consoleAvailableInput = "All";&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: consoleAvailableInput&#13;
    };&#13;
}&#13;
&#13;
/**&#13;
 *&#13;
 * @param {{translation: String}} translation&#13;
 */&#13;
function validateExceptionTranslation(translation) {&#13;
    if (translation.translation.trim() === "") {&#13;
        return {&#13;
            isValid: true,&#13;
            value: null&#13;
        };&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: translation.translation.trim()&#13;
    };&#13;
}&#13;
&#13;
function validateExceptionsTranslation(model) {&#13;
    var translations = model.exceptionsTranslation;&#13;
    var validatedTranslations = {};&#13;
&#13;
    for (var exceptionName in translations) {&#13;
        if (translations.hasOwnProperty(exceptionName)) {&#13;
            var validatedTranslation = validateExceptionTranslation(translations[exceptionName]);&#13;
            if (!validatedTranslation.isValid) {&#13;
                return validatedTranslation;&#13;
            }&#13;
&#13;
            validatedTranslations[exceptionName] = validatedTranslation.value;&#13;
        }&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        value: validatedTranslations&#13;
    };&#13;
}&#13;
&#13;
function validateModel(model, aliases) {&#13;
    var validatedAliases = void 0,&#13;
        validatedFunctions = void 0,&#13;
        validatedAnswer = void 0,&#13;
        isUniqueInAliasesAndFunctions = void 0,&#13;
        validatedMethods = void 0;&#13;
&#13;
    validatedAliases = validateAliases(model.default_aliases);&#13;
    if (!validatedAliases.isValid) {&#13;
        return validatedAliases;&#13;
    }&#13;
&#13;
    validatedFunctions = validateFunctions(model.functionsList);&#13;
    if (!validatedFunctions.isValid) {&#13;
        return validatedFunctions;&#13;
    }&#13;
&#13;
    if (validatedAliases.isValid &amp;&amp; validatedFunctions.isValid) {&#13;
        isUniqueInAliasesAndFunctions = validateUniquenessAliasesNamesAndFunctions(validatedAliases.value, validatedFunctions.value);&#13;
        if (!isUniqueInAliasesAndFunctions.isValid) {&#13;
            return isUniqueInAliasesAndFunctions;&#13;
        }&#13;
    }&#13;
&#13;
    validatedAnswer = validateAnswer(model);&#13;
    if (!validatedAnswer.isValid) {&#13;
        return validatedAnswer;&#13;
    }&#13;
&#13;
    validatedMethods = validateMethods(model.methodsList);&#13;
    if (!validatedMethods.isValid) {&#13;
        return validatedMethods;&#13;
    }&#13;
&#13;
    var validatedRound = validateRound(model);&#13;
    if (!validatedRound.isValid) {&#13;
        return validatedRound;&#13;
    }&#13;
&#13;
    var validatedAvailableConsoleInput = validateConsoleAvailableInput(model);&#13;
    if (!validatedAvailableConsoleInput.isValid) {&#13;
        return validatedAvailableConsoleInput;&#13;
    }&#13;
&#13;
    var validatedExceptionsTranslation = validateExceptionsTranslation(model);&#13;
    if (!validatedExceptionsTranslation.isValid) {&#13;
        return validatedExceptionsTranslation;&#13;
    }&#13;
&#13;
    return {&#13;
        isValid: true,&#13;
        addonID: model.ID,&#13;
        isActivity: !ModelValidationUtils.validateBoolean(model.isNotActivity),&#13;
        isVisibleByDefault: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
        functions: validatedFunctions.value,&#13;
        aliases: $.extend(aliases, validatedAliases.value),&#13;
        answer: validatedAnswer,&#13;
        methods: validatedMethods.methods,&#13;
        round: validatedRound.value,&#13;
        availableConsoleInput: validatedAvailableConsoleInput.value,&#13;
        exceptionTranslations: validatedExceptionsTranslation.value&#13;
    };&#13;
}&#13;
&#13;
/***/ }),&#13;
/* 15 */&#13;
/***/ (function(module, exports) {&#13;
&#13;
Object.defineProperty(exports, "__esModule", {&#13;
    value: true&#13;
});&#13;
exports.isLetter = isLetter;&#13;
exports.isDigit = isDigit;&#13;
function inRange(value, min, max) {&#13;
    return value &lt;= max &amp; value &gt;= min;&#13;
}&#13;
&#13;
/**&#13;
 * Check if string contains only letters&#13;
 * @param {String} c&#13;
 * @returns {boolean}&#13;
 */&#13;
function isLetter(c) {&#13;
    for (var i = 0; i &lt; c.length; i++) {&#13;
        if (!_isLetter(c.charCodeAt(i))) {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    return true;&#13;
}&#13;
&#13;
/**&#13;
 * Check if string contains only digits&#13;
 * @param {String} c&#13;
 * @returns {boolean}&#13;
 */&#13;
function isDigit(c) {&#13;
    for (var i = 0; i &lt; c.length; i++) {&#13;
        if (!_isDigit(c.charCodeAt(i))) {&#13;
            return false;&#13;
        }&#13;
    }&#13;
&#13;
    return true;&#13;
}&#13;
&#13;
function _isLetter(character) {&#13;
    return inRange(character, 65, 90) || inRange(character, 97, 122) || inRange(character, 192, 687) || inRange(character, 900, 1159) || // latin letters&#13;
    inRange(character, 1162, 1315) || inRange(character, 1329, 1366) || inRange(character, 1377, 1415) || // cyrillic letters&#13;
    inRange(character, 1425, 1536) || inRange(character, 1569, 1610) || // arabic letters&#13;
    inRange(character, 0x3400, 0x9FFF) || inRange(character, 0x0620, 0x063F) || inRange(character, 0x0641, 0x064A); //chinese and japanese letters&#13;
}&#13;
&#13;
function _isDigit(d) {&#13;
    return inRange(d, 0x0030, 0x0039) //standard european digits&#13;
    || inRange(d, 0x0660, 0x0669) || inRange(d, 0x06F0, 0x06F9) // arabic digits&#13;
    || inRange(d, 0x1040, 0x108F) || inRange(d, 0x5344, 0x5345) // chinese and japanese digits&#13;
    || d === 0x3007 || d === 0x5341 || d === 0x4E00 || d === 0x4E8C || d === 0x4E09 || d === 0x56DB || d === 0x4E94 || d === 0x0516D || d === 0x4E03 || d === 0x516B || d === 0x4E5D || d === 0x5341 || d === 0x767E || d === 0x5343 || d === 0x4E07 || d === 0x842C || d === 0x5104 || d === 0x4EBF || d === 0x5146;&#13;
}&#13;
&#13;
/***/ })&#13;
/******/ ]);&#13;
</presenter></addon>