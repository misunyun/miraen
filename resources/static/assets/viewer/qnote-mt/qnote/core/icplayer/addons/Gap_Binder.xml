<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Gap_Binder" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
        <property name="Items" nameLabel="Gap_Binder_property_items" type="list">
            <property name="Modules" nameLabel="Gap_Binder_property_modules" type="string"/>
            <property isLocalized="true" name="Answers" nameLabel="Gap_Binder_property_answers" type="text"/>
        </property>
    </model>
<css/><view>&lt;p&gt;&lt;/p&gt;&#13;
</view><preview>&lt;p&gt;Addon Gap_Binder&lt;/p&gt;&#13;
</preview><presenter>function AddonGap_Binder_create() {&#13;
&#13;
    var presenter = function () { }&#13;
&#13;
    // addon's parsed configuration data&#13;
    presenter.modulesIDs = [];&#13;
    presenter.answers = [];&#13;
&#13;
    // addon's modes&#13;
    presenter.isErrorMode = false;&#13;
    presenter.isShowAnswersActive = false;&#13;
    presenter.isGradualShowAnswersActive = false;&#13;
    presenter.GSACounter = 0;&#13;
&#13;
    const SUPPORTED_MODULES_TYPES = ["Text", "table"];&#13;
&#13;
    let scoreData = {&#13;
        emptyElementsNumber: 0,&#13;
        correctElementsNumber: 0,&#13;
        maxCorrectElementsNumber: 0,&#13;
        usedAnswersIndex: [],&#13;
        gapsIDsWithCorrectAnswer: [],&#13;
    }&#13;
    let savedGapsValues = [];&#13;
&#13;
    presenter.validatedPages = [];&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        INVALID_ID: "Provided module ID is incorrect.",&#13;
        INVALID_NUMBER_GAP: "The number of answers provided is incorrect.",&#13;
        INVALID_NUMBER_ITEMS: "Addon supports only one item in the configuration.",&#13;
        INVALID_NULL: "Value cannot be null."&#13;
    };&#13;
&#13;
    presenter.CSS_CLASSES = {&#13;
        INVALID_CONFIGURATION: "gap_binder_invalid",&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
&#13;
        setTimeout(() =&gt; {&#13;
            presenter.configuration = presenter.validateModel(model);&#13;
            $(view).removeClass(presenter.CSS_CLASSES.INVALID_CONFIGURATION);&#13;
            if (presenter.configuration.isError) {&#13;
                DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
                $(view).addClass(presenter.CSS_CLASSES.INVALID_CONFIGURATION);&#13;
            }&#13;
        }, 1250);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
&#13;
        presenter.view.addEventListener("DOMNodeRemoved", presenter.destroy);&#13;
    };&#13;
&#13;
    presenter.presenterLogic = function (view, model, isPreview) {&#13;
        presenter.addonID = model.ID;&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
        presenter.readModelItems(model.Items);&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        return presenter.getGapsNumber();&#13;
    }&#13;
&#13;
    presenter.getGapsNumber = function () {&#13;
        let gapsCounter = 0;&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const moduleGaps = findModuleGaps(moduleID);&#13;
            gapsCounter += moduleGaps.length ? moduleGaps.length : 0;&#13;
        });&#13;
        return gapsCounter;&#13;
    }&#13;
&#13;
    presenter.readModelItems = function (items) {&#13;
        setModulesIDs(items);&#13;
        setAnswers(items);&#13;
    };&#13;
&#13;
    function setModulesIDs(items) {&#13;
        presenter.modulesIDs.length = 0;&#13;
        let newModules = [];&#13;
&#13;
        items.forEach(item =&gt; {&#13;
            const modulesIDs = item.Modules.split(",");&#13;
            modulesIDs.forEach(moduleID =&gt; {&#13;
                moduleID = moduleID.trim();&#13;
                newModules.push(moduleID);&#13;
            })&#13;
        });&#13;
&#13;
        presenter.modulesIDs = [...new Set(newModules)];&#13;
    }&#13;
&#13;
    function setAnswers(items) {&#13;
        presenter.answers.length = 0;&#13;
&#13;
        items.forEach(item =&gt; {&#13;
            let answers = item.Answers.split('\n');&#13;
            presenter.answers.push(...answers);&#13;
        });&#13;
    }&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        const oneItemInConfiguration = isOneItemInConfiguration(model);&#13;
        if (!oneItemInConfiguration) {&#13;
            return { isError: true, errorCode: 'INVALID_NUMBER_ITEMS' };&#13;
        }&#13;
&#13;
        const someItemEmpty = isSomeItemFieldEmpty(model);&#13;
        if (someItemEmpty) {&#13;
            return { isError: true, errorCode: 'INVALID_NULL' };&#13;
        }&#13;
&#13;
        const eachModuleOnCurrentPage = isEachModuleOnCurrentPage()&#13;
        if (!eachModuleOnCurrentPage) {&#13;
            return { isError: true, errorCode: 'INVALID_ID' };&#13;
        }&#13;
&#13;
        const numberOfProvidedAnswersCorrect = isNumberOfProvidedAnswersCorrect();&#13;
        if (!numberOfProvidedAnswersCorrect) {&#13;
            return { isError: true, errorCode: 'INVALID_NUMBER_GAP' };&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
        }&#13;
    };&#13;
&#13;
    function isOneItemInConfiguration(model) {&#13;
        return model.Items.length === 1;&#13;
    }&#13;
&#13;
    function isSomeItemFieldEmpty(model) {&#13;
        return model.Items.some(item =&gt; {&#13;
            return ((!item.Modules || item.Modules.trim() == "")&#13;
                || !item.Answers || item.Answers.trim() == "");&#13;
        });&#13;
    }&#13;
&#13;
    function isEachModuleOnCurrentPage() {&#13;
        const $pageGaps = findCurrentPageGaps();&#13;
        const pageModulesIDs = getGapsModulesIDs($pageGaps);&#13;
&#13;
        let foundModulesNumber = 0;&#13;
        presenter.modulesIDs.forEach(configurationModuleID =&gt; {&#13;
            if (pageModulesIDs.includes(configurationModuleID)) {&#13;
                foundModulesNumber++;&#13;
            }&#13;
        });&#13;
&#13;
        return foundModulesNumber === presenter.modulesIDs.length;&#13;
    }&#13;
&#13;
    function getGapsModulesIDs($gaps) {&#13;
        let modulesIDs = [];&#13;
&#13;
        for (let i = 0; i &lt; $gaps.length; i++) {&#13;
            let parent = $gaps[i].closest('.ice_module');&#13;
            if (parent == null) {&#13;
                parent = $gaps[i].closest('.ic_text');&#13;
            }&#13;
&#13;
            if (parent == null) {&#13;
                parent = $gaps[i].closest('.addon_Table');&#13;
            }&#13;
&#13;
            if (parent != null &amp;&amp; $(parent).attr('id').length &gt; 0) {&#13;
                modulesIDs.push($(parent).attr('id'));&#13;
            }&#13;
        }&#13;
        return [...new Set(modulesIDs)];&#13;
    }&#13;
&#13;
    function isNumberOfProvidedAnswersCorrect() {&#13;
        let count = 0;&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const $element = $('body').find(`#${moduleID}`);&#13;
            const $elementGaps = findGaps($element);&#13;
            const elementGaps = $elementGaps.toArray();&#13;
            count += elementGaps.length;&#13;
        });&#13;
&#13;
        return count === presenter.answers.length;&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.currentPageIndex = controller.getCurrentPageIndex();&#13;
    };&#13;
&#13;
    presenter.setEventBus = function(eventBus) {&#13;
        const eventsName = ['ValueChanged', 'PageLoaded', 'ShowAnswers', 'HideAnswers', 'GradualShowAnswers', 'GradualHideAnswers'];&#13;
        presenter.eventBus = eventBus;&#13;
&#13;
        eventsName.forEach(eventName =&gt; {&#13;
            presenter.eventBus.addEventListener(eventName, this);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, eventData) {&#13;
        switch (eventName) {&#13;
            case 'ShowAnswers':&#13;
                presenter.showAnswers();&#13;
                break;&#13;
&#13;
            case 'HideAnswers':&#13;
                presenter.hideAnswers();&#13;
                break;&#13;
&#13;
            case 'ValueChanged':&#13;
                if (!presenter.isShowAnswersActive) handleValueChangedEvent(eventData);&#13;
                break;&#13;
&#13;
            case 'GradualShowAnswers':&#13;
                presenter.gradualShowAnswers(eventData);&#13;
                break;&#13;
&#13;
            case 'GradualHideAnswers':&#13;
                presenter.gradualHideAnswers();&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = () =&gt; {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.isErrorMode) {&#13;
            handleWorkMode();&#13;
        }&#13;
&#13;
        checkCorrectnessOfAnswers();&#13;
        handleShowAnswers();&#13;
    };&#13;
&#13;
    function handleShowAnswers() {&#13;
        presenter.isShowAnswersActive = true;&#13;
&#13;
        savedGapsValues.length = 0;&#13;
        let answerIndex = 0;&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const moduleGaps = findModuleGaps(moduleID);&#13;
            const module = getModule(moduleID);&#13;
&#13;
            for (let gapIndex = 0; gapIndex &lt; moduleGaps.length; gapIndex++) {&#13;
                const gap = moduleGaps[gapIndex];&#13;
                saveNextGapValue(gap);&#13;
                loadCorrectAnswer(gap, answerIndex);&#13;
                answerIndex++;&#13;
&#13;
                module.disableGap(gapIndex + 1);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.hideAnswers = () =&gt; {&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.isErrorMode) {&#13;
            handleWorkMode();&#13;
        }&#13;
&#13;
        handleHideAnswers();&#13;
    };&#13;
&#13;
    function handleHideAnswers() {&#13;
        presenter.isShowAnswersActive = false;&#13;
&#13;
        let answerIndex = 0;&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const moduleGaps = findModuleGaps(moduleID);&#13;
            const module = getModule(moduleID);&#13;
&#13;
            for (let gapIndex = 0; gapIndex &lt; moduleGaps.length; gapIndex++) {&#13;
                const gap = moduleGaps[gapIndex];&#13;
                loadSavedGapValue(gap, answerIndex);&#13;
                answerIndex++;&#13;
&#13;
                module.enableGap(gapIndex + 1);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.gradualShowAnswers = function (eventData) {&#13;
        if (eventData.moduleID !== presenter.addonID) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.isErrorMode) {&#13;
            handleWorkMode();&#13;
        }&#13;
&#13;
        if (!presenter.isGradualShowAnswersActive) {&#13;
            checkCorrectnessOfAnswers();&#13;
            presenter.isGradualShowAnswersActive = true;&#13;
        }&#13;
&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const moduleGaps = findModuleGaps(moduleID);&#13;
            const module = getModule(moduleID);&#13;
&#13;
            for (let gapIndex = 0; gapIndex &lt; moduleGaps.length; gapIndex++) {&#13;
                if (gapIndex === presenter.GSACounter) {&#13;
                    const gap = moduleGaps[gapIndex];&#13;
                    saveNextGapValue(gap);&#13;
                    loadCorrectAnswer(gap, gapIndex);&#13;
                    module.disableGap(gapIndex + 1);&#13;
                }&#13;
            }&#13;
        });&#13;
        presenter.updateGSACounter(eventData);&#13;
    }&#13;
&#13;
    presenter.gradualHideAnswers = function () {&#13;
        if (!presenter.isGradualShowAnswersActive) return;&#13;
&#13;
        presenter.isGradualShowAnswersActive = false;&#13;
        presenter.GSACounter = 0;&#13;
        handleHideAnswers();&#13;
    }&#13;
&#13;
    presenter.updateGSACounter = function (eventData) {&#13;
        let itemIndex = parseInt(eventData.item, 10)&#13;
        while (itemIndex &lt; presenter.GSAcounter) {&#13;
            itemIndex++;&#13;
        }&#13;
        presenter.GSACounter = itemIndex + 1;&#13;
    }&#13;
&#13;
    function saveNextGapValue(gap) {&#13;
        const valueToSave = {&#13;
            innerHTML: gap.innerHTML,&#13;
            value: gap.value,&#13;
            id: gap.id,&#13;
        };&#13;
        savedGapsValues.push(valueToSave);&#13;
    }&#13;
&#13;
    function loadCorrectAnswer(gap, index) {&#13;
        const answer = presenter.answers[index];&#13;
        gap.innerHTML = answer;&#13;
        gap.value = answer;&#13;
    }&#13;
&#13;
    function loadSavedGapValue(gap, index) {&#13;
        if (index &gt;= savedGapsValues.length) {&#13;
            return;&#13;
        }&#13;
        const valueToLoad = savedGapsValues[index];&#13;
        gap.innerHTML = valueToLoad.innerHTML;&#13;
        gap.value = valueToLoad.value;&#13;
    }&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        if (presenter.isErrorMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        handleShownAnswers();&#13;
&#13;
        handleShowErrorsMode();&#13;
    };&#13;
&#13;
    function handleShownAnswers() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            handleHideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.isGradualShowAnswersActive) {&#13;
            presenter.isGradualShowAnswersActive = false;&#13;
            handleHideAnswers();&#13;
        }&#13;
    }&#13;
&#13;
    function handleShowErrorsMode() {&#13;
        presenter.isErrorMode = true;&#13;
&#13;
        presenter.validatedPages[presenter.currentPageIndex] = true;&#13;
&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const moduleGaps = findModuleGaps(moduleID);&#13;
            const module = getModule(moduleID);&#13;
&#13;
            for (let gapIndex = 0; gapIndex &lt; moduleGaps.length; gapIndex++) {&#13;
                const gapIndexInModule = gapIndex + 1;&#13;
                const gap = moduleGaps[gapIndex];&#13;
&#13;
                if (isCorrectAnswerInGap(gap.id)) {&#13;
                    module.markGapAsCorrect(gapIndexInModule);&#13;
                } else if (!isGapEmpty(gap)) {&#13;
                    module.markGapAsWrong(gapIndexInModule);&#13;
                } else {&#13;
                    module.markGapAsEmpty(gapIndexInModule);&#13;
                }&#13;
            }&#13;
        })&#13;
    }&#13;
&#13;
    function isGapEmpty(gap) {&#13;
        return ((!gap.innerHTML &amp;&amp; !gap.value)&#13;
            || (gap.innerHTML === "&amp;nbsp;" &amp;&amp; !gap.value)&#13;
            || (gap.innerHTML === "" &amp;&amp; !gap.value)&#13;
        );&#13;
    }&#13;
&#13;
    presenter.reset = function () {&#13;
        resetScoreData();&#13;
        presenter.hideAnswers();&#13;
        presenter.gradualHideAnswers();&#13;
        presenter.setWorkMode();&#13;
        presenter.GSACounter = 0;&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        if (!presenter.isErrorMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        handleShownAnswers();&#13;
&#13;
        handleWorkMode();&#13;
    };&#13;
&#13;
    function handleWorkMode() {&#13;
        presenter.isErrorMode = false;&#13;
        enableAllGapsOfConnectedModules();&#13;
    }&#13;
&#13;
    function enableAllGapsOfConnectedModules() {&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const module = getModule(moduleID);&#13;
            module.enableAllGaps();&#13;
        });&#13;
    }&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive) {&#13;
            return getErrorCountFromScoreData();&#13;
        }&#13;
&#13;
        handleShownAnswers();&#13;
        checkCorrectnessOfAnswers();&#13;
        if (scoreData.correctElementsNumber === scoreData.maxCorrectElementsNumber) {&#13;
            return 0;&#13;
        }&#13;
        return getErrorCountFromScoreData();&#13;
    };&#13;
&#13;
    function getErrorCountFromScoreData() {&#13;
        return scoreData.maxCorrectElementsNumber - scoreData.correctElementsNumber - scoreData.emptyElementsNumber;&#13;
    }&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (!presenter.playerController) {&#13;
            return presenter.answers.length;&#13;
        }&#13;
&#13;
        if (presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive) {&#13;
            return getMaxScoreFromScoreData();&#13;
        }&#13;
&#13;
        checkCorrectnessOfAnswers();&#13;
        return getMaxScoreFromScoreData();&#13;
    }&#13;
&#13;
    function getMaxScoreFromScoreData() {&#13;
        return scoreData.maxCorrectElementsNumber;&#13;
    }&#13;
&#13;
    presenter.getScore = function () {&#13;
        if (presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive) {&#13;
            return getScoreFromScoreData();&#13;
        }&#13;
&#13;
        handleShownAnswers();&#13;
        checkCorrectnessOfAnswers();&#13;
        return getScoreFromScoreData();&#13;
    };&#13;
&#13;
    function getScoreFromScoreData() {&#13;
        return scoreData.correctElementsNumber;&#13;
    }&#13;
&#13;
    function checkCorrectnessOfAnswers() {&#13;
        if (!presenter.answers || !presenter.modulesIDs) {&#13;
            return;&#13;
        }&#13;
&#13;
        resetScoreData();&#13;
&#13;
        hideMathJaxElements();&#13;
        presenter.modulesIDs.forEach(checkCorrectnessOfAnswersInModule);&#13;
    }&#13;
&#13;
    function checkCorrectnessOfAnswersInModule(moduleID) {&#13;
        const moduleGaps = findModuleGaps(moduleID);&#13;
        if (!moduleGaps) {&#13;
            return;&#13;
        }&#13;
&#13;
        scoreData.maxCorrectElementsNumber += moduleGaps.length;&#13;
        moduleGaps.forEach(gap =&gt; {&#13;
            if (isGapEmpty(gap)) {&#13;
                scoreData.emptyElementsNumber++;&#13;
                return;&#13;
            }&#13;
&#13;
            for (let answerIndex = 0; answerIndex &lt; presenter.answers.length; answerIndex++) {&#13;
                if (isAnswerUsed(answerIndex)) {&#13;
                    continue;&#13;
                }&#13;
&#13;
                const correctAnswer = presenter.answers[answerIndex];&#13;
                if (gap.innerHTML == correctAnswer || gap.value == correctAnswer) {&#13;
                    scoreData.correctElementsNumber++;&#13;
                    scoreData.usedAnswersIndex.push(answerIndex);&#13;
                    scoreData.gapsIDsWithCorrectAnswer.push(gap.id);&#13;
                }&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    function resetScoreData() {&#13;
        scoreData.emptyElementsNumber = 0;&#13;
        scoreData.correctElementsNumber = 0;&#13;
        scoreData.maxCorrectElementsNumber = 0;&#13;
        scoreData.usedAnswersIndex.length = 0;&#13;
        scoreData.gapsIDsWithCorrectAnswer.length = 0;&#13;
    }&#13;
&#13;
    function hideMathJaxElements() {&#13;
        $('body').find(".MathJax_Preview").each(() =&gt; $(this).style.display = "none");&#13;
    }&#13;
&#13;
    function isAnswerUsed(answerIndex) {&#13;
        return scoreData.usedAnswersIndex.includes(answerIndex);&#13;
    }&#13;
&#13;
    function isCorrectAnswerInGap(gapID) {&#13;
        return scoreData.gapsIDsWithCorrectAnswer.includes(gapID);&#13;
    }&#13;
&#13;
    presenter.createEventData = function (item, value, score) {&#13;
        return {&#13;
            'source': "" + presenter.addonID,&#13;
            'item': "" + item,&#13;
            'value': "" + value,&#13;
            'score': "" + score&#13;
        };&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore();&#13;
    };&#13;
&#13;
    presenter.isOK = function (moduleIndex, gapIndex) {&#13;
        const trueModuleIndex = moduleIndex - 1;&#13;
        const trueGapIndex = gapIndex - 1;&#13;
&#13;
        handleShownAnswers();&#13;
&#13;
        checkCorrectnessOfAnswers();&#13;
        if (presenter.modulesIDs[trueModuleIndex]) {&#13;
            const moduleGaps = findModuleGaps(presenter.modulesIDs[trueModuleIndex]);&#13;
            if (moduleGaps) {&#13;
                const elementID = moduleGaps[trueGapIndex].id;&#13;
                if (isCorrectAnswerInGap(elementID)) {&#13;
                    return true;&#13;
                }&#13;
            }&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.isAttempted = function () {&#13;
        handleShownAnswers();&#13;
&#13;
        return countFilledInItems() &gt; 0;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        var commands = {&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'isOK': presenter.isOK,&#13;
            'isAttempted': presenter.isAttempted&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.sendAllOKEvent = function () {&#13;
        const eventData = presenter.createEventData("all", "", "");&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    }&#13;
&#13;
    function countEmptyItems() {&#13;
        return countItems(true);&#13;
    }&#13;
&#13;
    function countFilledInItems() {&#13;
        return countItems(false);&#13;
    }&#13;
&#13;
    function countItems(forEmptyGaps) {&#13;
        let count = 0;&#13;
        presenter.modulesIDs.forEach(moduleID =&gt; {&#13;
            const moduleGaps = findModuleGaps(moduleID);&#13;
            moduleGaps.forEach(gap =&gt; {&#13;
                const gapEmpty = isGapEmpty(gap);&#13;
                if ((forEmptyGaps &amp;&amp; gapEmpty) || (!forEmptyGaps &amp;&amp; !gapEmpty)) {&#13;
                    count++;&#13;
                }&#13;
            });&#13;
        });&#13;
        return count;&#13;
    }&#13;
&#13;
    function handleValueChangedEvent (eventData) {&#13;
        const moduleType = eventData.moduleType;&#13;
        if (moduleType &amp;&amp; SUPPORTED_MODULES_TYPES.includes(moduleType)) {&#13;
            checkCorrectnessOfAnswers();&#13;
&#13;
            const gapData = findGapThatSentValueChangedEvent(eventData);&#13;
            if (!gapData.gap || gapData.relativeIndex === -1) {&#13;
                return;&#13;
            }&#13;
&#13;
            const item = gapData.relativeIndex !== -1 ? gapData.relativeIndex : '';&#13;
            const score = isCorrectAnswerInGap(gapData.gap.id) ? 1 : 0;&#13;
            const value = eventData.value ? eventData.value : '';&#13;
&#13;
            const newEventData = presenter.createEventData(item, value, score);&#13;
            presenter.eventBus.sendEvent('ValueChanged', newEventData);&#13;
&#13;
            if (presenter.isAllOK()) {&#13;
                presenter.sendAllOKEvent();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function findGapThatSentValueChangedEvent(eventData) {&#13;
        const notFoundResponse = {&#13;
            gap: undefined,&#13;
            relativeIndex: -1,&#13;
        }&#13;
&#13;
        if (eventData.source === undefined || eventData.item === undefined) {&#13;
            return notFoundResponse;&#13;
        }&#13;
&#13;
        const moduleIndex = presenter.modulesIDs.findIndex(moduleID =&gt; moduleID === eventData.source);&#13;
        if (moduleIndex === -1) {&#13;
            return notFoundResponse;&#13;
        }&#13;
&#13;
        const foundGaps = findModuleGaps(eventData.source);&#13;
        const itemIndex = parseInt(eventData.item, 10) - 1;&#13;
        if (itemIndex &lt; 0 || itemIndex &gt;= foundGaps.length) {&#13;
            return notFoundResponse;&#13;
        }&#13;
&#13;
        let relativeIndex = 1;&#13;
        for (let i = 0, moduleGaps; i &lt; moduleIndex; i++) {&#13;
            moduleGaps = findModuleGaps(presenter.modulesIDs[i]);&#13;
            relativeIndex += moduleGaps.length;&#13;
        }&#13;
        relativeIndex += itemIndex;&#13;
&#13;
        return {&#13;
            gap: foundGaps[itemIndex],&#13;
            relativeIndex,&#13;
        };&#13;
    }&#13;
&#13;
    function findModuleGaps(moduleID, toArray = true) {&#13;
        const module = getModule(moduleID);&#13;
        const $moduleView = $(module.getView());&#13;
        const $foundGaps = findGaps($moduleView);&#13;
        if (toArray) {&#13;
            return $foundGaps.toArray();&#13;
        }&#13;
        return $foundGaps;&#13;
    }&#13;
&#13;
    function getModule(moduleID) {&#13;
        return presenter.playerController.getModule(moduleID);&#13;
    }&#13;
&#13;
    function findCurrentPageGaps() {&#13;
        const $pageView = $('html');&#13;
        return findGaps($pageView);&#13;
    }&#13;
&#13;
    function findGaps($view) {&#13;
        return $view.find('.ic_gap, .gapFilled, .ic_gap-empty, .ic_filled_gap,  .ic_draggableGapFilled, .ic_draggableGapEmpty');&#13;
    }&#13;
&#13;
    presenter.destroy = function (event) {&#13;
        if (event.target !== presenter.view) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.view.removeEventListener("DOMNodeRemoved", presenter.destroy);&#13;
        presenter.hideAnswers();&#13;
        presenter.setWorkMode();&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        handleShownAnswers();&#13;
        checkCorrectnessOfAnswers();&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>