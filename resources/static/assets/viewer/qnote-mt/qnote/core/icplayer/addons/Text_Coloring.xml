<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Text_Coloring" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property displayName="Colors" name="colors" nameLabel="Text_Coloring_property_colors" type="list">
			<property displayName="Color ID" name="id" nameLabel="Text_Coloring_property_color_id" type="string"/>
			<property displayName="Color" name="color" nameLabel="Text_Coloring_property_color" type="string"/>
			<property displayName="Description" isLocalized="true" name="description" nameLabel="Text_Coloring_property_description" type="string"/>
		</property>
		<property displayName="Text" isDefault="true" isLocalized="true" name="text" nameLabel="Text_Coloring_property_text" type="text"/>
		<property displayName="Buttons position" name="buttonsPosition" nameLabel="Text_Coloring_property_buttons_position" type="{left, top, bottom, right}"/>
		<property displayName="Hide Color Buttons" name="hideColorsButtons" nameLabel="Text_Coloring_property_hide_color_buttons" type="boolean"/>
		<property displayName="Show all answers in gradual show answers mode" name="showAllAnswersInGradualShowAnswersMode" nameLabel="Text_Coloring_property_show_all_answers_in_gradual_show_answers_mode" type="boolean"/>
		<property displayName="Show set eraser mode button" name="showSetEraserModeButton" nameLabel="Text_Coloring_property_show_set_eraser_mode_button" type="boolean"/>
		<property displayName="Eraser button text" isLocalized="true" name="eraserButtonText" nameLabel="Text_Coloring_property_eraser_button_text" type="string"/>
		<property name="Mode" nameLabel="Text_Selection_property_mode" type="{All selectable, Mark phrases to select}"/>
		<property displayName="Count Errors" name="countErrors" nameLabel="Text_Coloring_property_count_errors" type="boolean"/>
		<property name="printable" nameLabel="printable_name_label" type="{No, Don't randomize, Randomize}"/>
		<property name="Legend title" nameLabel="legend_title" type="string"/>
		<property displayName="Speech texts" name="speechTexts" nameLabel="Text_Coloring_property_speech_texts" type="staticlist">
			<property name="Selected" nameLabel="Text_Coloring_property_selected" type="staticrow">
				<property name="Selected" nameLabel="Text_Coloring_property_selected" type="string"/>
			</property>
			<property name="Deselected" nameLabel="Text_Coloring_property_deselected" type="staticrow">
				<property name="Deselected" nameLabel="Text_Coloring_property_deselected" type="string"/>
			</property>
			<property name="TextContent" nameLabel="Text_Coloring_property_TextContent" type="staticrow">
				<property name="TextContent" nameLabel="Text_Coloring_property_TextContent" type="string"/>
			</property>
			<property name="Correct" nameLabel="Text_Coloring_property_correct" type="staticrow">
				<property name="Correct" nameLabel="Text_Coloring_property_correct" type="string"/>
			</property>
			<property name="Incorrect" nameLabel="Text_Coloring_property_Incorrect" type="staticrow">
				<property name="Incorrect" nameLabel="Text_Coloring_property_Incorrect" type="string"/>
			</property>
		</property>
		<property displayName="Lang attribute" name="langAttribute" nameLabel="Text_Coloring_property_lang_attribute" type="string"/>
	</model>
<css>.text-coloring-hover-class {&#13;
	background-color: orange;&#13;
}&#13;
&#13;
.text-coloring-pointer-class {&#13;
	cursor: pointer;&#13;
}&#13;
&#13;
.text-coloring-active-button {&#13;
	background-color: orange;&#13;
}&#13;
&#13;
/*TOP POSITION*/&#13;
.text-coloring-eraser-button-container-top-position {&#13;
	display: inline-block;&#13;
	margin-right: 20px;&#13;
}&#13;
&#13;
.text-coloring-colors-buttons-container-top-position {&#13;
	display: inline-block;&#13;
}&#13;
&#13;
.text-coloring-colors-buttons-container-top-position &gt; .text-coloring-color-button {&#13;
	display: inline-block;&#13;
	margin-right: 10px;&#13;
}&#13;
&#13;
.text-coloring-buttons-container-top-position {&#13;
	margin-bottom: 10px;&#13;
}&#13;
&#13;
/*LEFT POSITION*/&#13;
.text-coloring-main-container-left-position {&#13;
	display: table-row;&#13;
}&#13;
&#13;
.text-coloring-buttons-container-left-position {&#13;
	display: table-cell;&#13;
}&#13;
&#13;
.text-coloring-tokens-container-left-position {&#13;
	display: table-cell;&#13;
}&#13;
&#13;
.text-coloring-eraser-button-container-left-position {&#13;
	margin-top: 10px;&#13;
}&#13;
&#13;
.text-coloring-colors-buttons-container-left-position &gt; .text-coloring-color-button{&#13;
	margin-bottom: 10px;&#13;
}&#13;
/*BOTTOM POSITION*/&#13;
.text-coloring-colors-buttons-container-bottom-position {&#13;
	display: inline-block;&#13;
}&#13;
&#13;
.text-coloring-colors-buttons-container-bottom-position &gt; .text-coloring-color-button{&#13;
	margin-right: 10px;&#13;
	display: inline-block;&#13;
}&#13;
&#13;
.text-coloring-eraser-button-container-bottom-position {&#13;
	display: inline-block;&#13;
}&#13;
&#13;
.text-coloring-buttons-container-bottom-position {&#13;
	margin-top: 10px;&#13;
}&#13;
&#13;
/*RIGHT POSITION*/&#13;
.text-coloring-main-container-right-position {&#13;
	display: table-row;&#13;
}&#13;
&#13;
.text-coloring-tokens-container-right-position {&#13;
	display: table-cell;&#13;
}&#13;
&#13;
.text-coloring-buttons-container-right-position {&#13;
	display: table-cell;&#13;
}&#13;
&#13;
.text-coloring-buttons-container-right-position &gt; .text-coloring-color-button {&#13;
	margin-bottom: 10px;&#13;
}&#13;
&#13;
.text-coloring-eraser-button-container-right-position {&#13;
	margin-top: 10px;&#13;
}&#13;
&#13;
.text-coloring-token-correct-marking {&#13;
	background-color: green;&#13;
}&#13;
&#13;
.text-coloring-token-wrong-marking {&#13;
	background-color: red;&#13;
}&#13;
</css><view/><preview/><presenter>/*&#13;
 KNOWN ISSUES&#13;
    Text parsing:&#13;
        Do not change the space special character (&amp;nbsp;) support due to backward compatibility #6613&#13;
        Do not add html escape support due to backward compatibility #6902&#13;
*/&#13;
&#13;
function AddonText_Coloring_create() {&#13;
    var presenter = function () {};&#13;
    presenter.printableState = null;&#13;
    presenter.initialVisibility = null;&#13;
    presenter.isFirstEnter = true;&#13;
&#13;
    function markAsValidValues(value) {&#13;
        value.isValid = true;&#13;
        return value;&#13;
    }&#13;
&#13;
    function filterInvalid(definition) {&#13;
        return !definition.isValid;&#13;
    }&#13;
&#13;
    function removeIsValidFlag(colorDefinition) {&#13;
        delete colorDefinition.isValid;&#13;
        return colorDefinition;&#13;
    }&#13;
&#13;
    function filterSelectablesTokens(token) {&#13;
        return token.type == presenter.TOKENS_TYPES.SELECTABLE;&#13;
    }&#13;
&#13;
    function filterSelectedTokens(token) {&#13;
        return token.isSelected;&#13;
    }&#13;
&#13;
    function filterWrongTokens(token) {&#13;
        if (token.color == undefined) {&#13;
            return true;&#13;
        }&#13;
&#13;
        return token.selectionColorID != token.color;&#13;
    }&#13;
&#13;
    function flattenArrays(result, array) {&#13;
        array.forEach(function (element) {&#13;
            if (element)&#13;
                result.push(element);&#13;
        });&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    presenter.MODE = {&#13;
        'Mark phrases to select': 'MARK_PHRASES',&#13;
        'All selectable': 'ALL_SELECTABLE',&#13;
        DEFAULT: 'All selectable'&#13;
    };&#13;
&#13;
    presenter.DEFAULT_TTS_PHRASES = {&#13;
        selected: "selected",&#13;
        deselected: "deselected",&#13;
        textContent: "text content",&#13;
        correct: "correct",&#13;
        incorrect: "wrong"&#13;
    };&#13;
&#13;
    function parseIDs(colorDefinition) {&#13;
        var trimmedColorID = colorDefinition.id.trim();&#13;
        if (ModelValidationUtils.isStringEmpty(trimmedColorID)) {&#13;
            colorDefinition.isValid = false;&#13;
            colorDefinition.errorCode = presenter.ERROR_CODES_KEYS.TC_COLORS_COLOR_MUST_HAVE_ID;&#13;
            return colorDefinition;&#13;
        }&#13;
&#13;
        colorDefinition.id = trimmedColorID;&#13;
&#13;
        return colorDefinition;&#13;
    }&#13;
&#13;
    function parseRGBHex(colorDefinition) {&#13;
        var parsedColor = ModelValidationUtils.validateColor(colorDefinition.color.trim());&#13;
&#13;
        colorDefinition.color = parsedColor.color;&#13;
&#13;
        if (!parsedColor.isValid) {&#13;
            colorDefinition.errorCode = presenter.ERROR_CODES_KEYS.TC_COLORS_COLOR_DEFINITION_HAVE_TO_BE_RGB_HEX;&#13;
            colorDefinition.isValid = false;&#13;
        }&#13;
&#13;
        return colorDefinition;&#13;
    }&#13;
&#13;
    function parseDescriptions(colorDefinition) {&#13;
        colorDefinition.description = colorDefinition.description.trim();&#13;
&#13;
        return colorDefinition;&#13;
    }&#13;
&#13;
    function getWordToken(value) {&#13;
        return {&#13;
            "value": value,&#13;
            "type": presenter.TOKENS_TYPES.WORD&#13;
        };&#13;
    }&#13;
&#13;
    function getNewLineToken() {&#13;
        return {&#13;
            "type": presenter.TOKENS_TYPES.NEW_LINE&#13;
        };&#13;
    }&#13;
&#13;
    function getSelectableToken(value, colorID) {&#13;
        return {&#13;
            "type": presenter.TOKENS_TYPES.SELECTABLE,&#13;
            "value": value,&#13;
            "color": colorID&#13;
        };&#13;
    }&#13;
&#13;
    function getSpaceToken() {&#13;
        return {&#13;
            type: presenter.TOKENS_TYPES.SPACE&#13;
        };&#13;
    }&#13;
&#13;
    function deleteActiveClass() {&#13;
        var $buttons = presenter.$view.find(StringUtils.format(".{0}", presenter.defaults.css.activeButton));&#13;
        $buttons.removeClass(presenter.defaults.css.activeButton);&#13;
    }&#13;
&#13;
    function TextColoringStateMachine(cssConfiguration) {&#13;
        StatefullAddonObject.call(this, cssConfiguration);&#13;
        this.blocked = false;&#13;
        this.currentShowingAnswerId = 0;&#13;
        this.notifyEdit();&#13;
        this.previousActiveColorID = null;&#13;
        this.previousActiveColor = null;&#13;
        this.previousEraserMode = null;&#13;
    }&#13;
&#13;
    TextColoringStateMachine.prototype = Object.create(StatefullAddonObject.prototype);&#13;
    TextColoringStateMachine.constructor = TextColoringStateMachine;&#13;
&#13;
    TextColoringStateMachine.prototype.onBlock = function () {&#13;
        presenter.disconnectHandlers();&#13;
        this.blocked = true;&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onUnblock = function () {&#13;
        presenter.connectHandlers();&#13;
        if (presenter.configuration.activeColorID != null || presenter.configuration.eraserMode != null) {&#13;
            presenter.connectWordTokensHandlers();&#13;
        }&#13;
        this.blocked = false;&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onShowAnswers = function () {&#13;
        this.onBlockAnswers();&#13;
        presenter.configuration.filteredTokens.filter(filterSelectablesTokens).forEach(function (token) {&#13;
            var colorDefinition = presenter.getColorDefinitionById(token.color);&#13;
            if (colorDefinition !== undefined) {&#13;
                var $tokenElement = presenter.getWordTokenByIndex(token.index);&#13;
                presenter.addShowAnswerClass($tokenElement, colorDefinition.id);&#13;
                presenter.markToken($tokenElement, colorDefinition.color);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onShowSingleAnswer = function () {&#13;
        if (!presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            var currentShowingAnswerId = this.currentShowingAnswerId;&#13;
            var id = 0;&#13;
&#13;
            if (!this.blocked) {&#13;
                this.savePreviousState();&#13;
                this.onBlock();&#13;
            }&#13;
&#13;
            try {&#13;
                presenter.configuration.filteredTokens.filter(filterSelectablesTokens).forEach(function (token) {&#13;
                    var colorDefinition = presenter.getColorDefinitionById(token.color);&#13;
                    if (colorDefinition !== undefined) {&#13;
                        if (id === currentShowingAnswerId) {&#13;
                            var $tokenElement = presenter.getWordTokenByIndex(token.index);&#13;
                            presenter.addShowAnswerClass($tokenElement, colorDefinition.id);&#13;
                            presenter.markToken($tokenElement, colorDefinition.color);&#13;
                            throw BreakException;&#13;
                        }&#13;
                        id++;&#13;
                    }&#13;
                });&#13;
            } catch (e) {}&#13;
&#13;
            this.currentShowingAnswerId++;&#13;
        } else {&#13;
            this.onShowAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onBlockAnswers = function () {&#13;
        if (!this.blocked) {&#13;
            this.savePreviousState();&#13;
            this.onBlock();&#13;
            presenter.unmarkToken(presenter.$wordTokens);&#13;
            presenter.hideTokenClasses(presenter.$wordTokens);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.addShowAnswerClass = function ($element, colorName) {&#13;
        var className = StringUtils.format(presenter.defaults.css.showAnswer, colorName);&#13;
        $element.addClass(className);&#13;
    };&#13;
&#13;
    presenter.removeShowAnswerClass = function ($element, colorName) {&#13;
        var className = StringUtils.format(presenter.defaults.css.showAnswer, colorName);&#13;
        $element.removeClass(className);&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onHideAnswers = function () {&#13;
        this.currentShowingAnswerId = 0;&#13;
        this.blocked = false;&#13;
        this.restorePreviousState();&#13;
        this.onUnblock();&#13;
        presenter.unmarkToken(presenter.$wordTokens);&#13;
&#13;
        presenter.configuration.filteredTokens.filter(filterSelectablesTokens).forEach(function (token) {&#13;
            var $tokenElement = presenter.getWordTokenByIndex(token.index);&#13;
            presenter.removeShowAnswerClass($tokenElement, token.color);&#13;
        });&#13;
&#13;
        presenter.configuration.filteredTokens.filter(function (token) {&#13;
            return token.isSelected == true;&#13;
        }).forEach(function (token) {&#13;
            var colorDefinition = presenter.getColorDefinitionById(token.selectionColorID);&#13;
            var $tokenElement = presenter.getWordTokenByIndex(token.index);&#13;
            presenter.markToken($tokenElement, colorDefinition.color);&#13;
        });&#13;
&#13;
&#13;
        if (this.previousActiveColor != null) {&#13;
            presenter.setColorButtonAsActive(this.previousActiveColorID);&#13;
        }&#13;
&#13;
        if (this.previousEraserMode) {&#13;
            presenter.setEraserButtonAsActive();&#13;
        }&#13;
&#13;
        presenter.showTokenClasses(presenter.$wordTokens);&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.gradualShowAnswers = function () {&#13;
        switch (this._actualState) {&#13;
            case StatefullAddonObject._internal.STATE.WORK:&#13;
                this.onShowSingleAnswer();&#13;
                this.setCssOnShowAnswers();&#13;
                break;&#13;
            default:&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.gradualBlockAnswers = function () {&#13;
        switch (this._actualState) {&#13;
            case StatefullAddonObject._internal.STATE.WORK:&#13;
                this.onBlockAnswers();&#13;
                this.setCssOnShowAnswers();&#13;
                break;&#13;
            default:&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.gradualHideAnswers = function () {&#13;
        switch (this._actualState) {&#13;
            case StatefullAddonObject._internal.STATE.WORK:&#13;
                StatefullAddonObject._internal.hideAnswersShowAnswersState.call(this);&#13;
                break;&#13;
            default:&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.isCorrect = function () {&#13;
        return true;&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onCorrect = function () {&#13;
        this.savePreviousState();&#13;
        this.onBlock();&#13;
        presenter.configuration.filteredTokens.filter(filterSelectedTokens).forEach(function (token) {&#13;
            if (presenter.getScoreForWordMarking(token.index, token.selectionColorID)) {&#13;
                presenter.addCorrectClass(token.index);&#13;
            } else {&#13;
                presenter.addWrongClass(token.index);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onUnCorrect = function () {&#13;
        this.restorePreviousState();&#13;
        this.onUnblock();&#13;
        presenter.removeAllCheckAnswersClasses();&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.savePreviousState = function () {&#13;
        this.previousActiveColorID = presenter.configuration.activeColorID;&#13;
        this.previousActiveColor = presenter.configuration.activeColor;&#13;
        this.previousEraserMode = presenter.configuration.eraserMode;&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.restorePreviousState = function () {&#13;
        presenter.configuration.activeColorID = this.previousActiveColorID;&#13;
        presenter.configuration.activeColor = this.previousActiveColor;&#13;
        presenter.configuration.eraserMode = this.previousEraserMode;&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.setCssOnCorrect = function () {&#13;
        presenter.unsetColorButtonsAsActive();&#13;
        presenter.unsetEraserButtonAsActive();&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.setCssOnUnCorrect = function () {&#13;
        if (this.previousActiveColor != null) {&#13;
            presenter.setColorButtonAsActive(this.previousActiveColorID);&#13;
        }&#13;
&#13;
        if (this.previousEraserMode) {&#13;
            presenter.setEraserButtonAsActive();&#13;
        }&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.addCssClass = function () {&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.removeCssClass = function () {&#13;
    };&#13;
&#13;
    TextColoringStateMachine.prototype.onReset = function () {&#13;
        presenter.unmarkToken(presenter.$wordTokens);&#13;
&#13;
        presenter.resetColoredWords();&#13;
&#13;
        $.makeArray(presenter.$wordTokens).forEach(function (tokenHTML) {&#13;
            presenter.removeColorData($(tokenHTML));&#13;
        });&#13;
&#13;
        deleteActiveClass();&#13;
        if (presenter.configuration.eraserMode) {&#13;
            presenter.toggleEraserMode();&#13;
        }&#13;
&#13;
        if (presenter.configuration.activeColorID !== null) {&#13;
            presenter.configuration.activeColorID = null;&#13;
            presenter.configuration.activeColor = null;&#13;
        }&#13;
        presenter.disconnectWordTokensHandlers();&#13;
        presenter.setColor(presenter.configuration.colors[0].id);&#13;
    };&#13;
&#13;
    presenter.defaults = {&#13;
        eraserButtonDefaultText: "Eraser Mode",&#13;
        dataHolders: {&#13;
            colorID: "colorid"&#13;
        },&#13;
        css: {&#13;
            selectableWord: "text-coloring-selectable-word",&#13;
            colorButton: "text-coloring-color-button",&#13;
            pointer: "text-coloring-pointer-class",&#13;
            hover: "text-coloring-hover-class",&#13;
            eraserButton: "text-coloring-eraser-button",&#13;
            mainContainer: {&#13;
                top: 'text-coloring-main-container-top-position',&#13;
                left: 'text-coloring-main-container-left-position',&#13;
                bottom: 'text-coloring-main-container-bottom-position',&#13;
                right: 'text-coloring-main-container-right-position'&#13;
            },&#13;
            colorButtonsContainer: {&#13;
                top: 'text-coloring-colors-buttons-container-top-position',&#13;
                left: 'text-coloring-colors-buttons-container-left-position',&#13;
                bottom: 'text-coloring-colors-buttons-container-bottom-position',&#13;
                right: 'text-coloring-colors-buttons-container-right-position'&#13;
            },&#13;
            eraserButtonContainer: {&#13;
                top: 'text-coloring-eraser-button-container-top-position',&#13;
                left: 'text-coloring-eraser-button-container-left-position',&#13;
                bottom: 'text-coloring-eraser-button-container-bottom-position',&#13;
                right: 'text-coloring-eraser-button-container-right-position'&#13;
            },&#13;
            buttonsContainer: {&#13;
                top: 'text-coloring-buttons-container-top-position',&#13;
                left: 'text-coloring-buttons-container-left-position',&#13;
                bottom: 'text-coloring-buttons-container-bottom-position',&#13;
                right: 'text-coloring-buttons-container-right-position'&#13;
            },&#13;
            tokensContainer: {&#13;
                top: 'text-coloring-tokens-container-top-position',&#13;
                left: 'text-coloring-tokens-container-left-position',&#13;
                bottom: 'text-coloring-tokens-container-bottom-position',&#13;
                right: 'text-coloring-tokens-container-right-position'&#13;
            },&#13;
            markings: {&#13;
                correct: 'text-coloring-token-correct-marking',&#13;
                wrong: 'text-coloring-token-wrong-marking'&#13;
            },&#13;
            activeButton: 'text-coloring-active-button',&#13;
            coloredWord: 'text-coloring-colored-with-{0}',&#13;
            showAnswer: 'text-coloring-show-answers-{0}'&#13;
        }&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        "TC_COLORS_COLOR_DEFINITION_HAVE_TO_BE_RGB_HEX": "Color definitions in colors property have to be proper rgb hex e.g #FF0000 (red)",&#13;
        "TC_COLORS_COLOR_MUST_HAVE_ID": "Color definitions in colors property must have id",&#13;
        "TC_TEXT_COLOR_DEFINITION_WRONG_ID": "Text Coloring has to use defined color id"&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES_KEYS = {&#13;
        "TC_COLORS_COLOR_DEFINITION_HAVE_TO_BE_RGB_HEX": "TC_COLORS_COLOR_DEFINITION_HAVE_TO_BE_RGB_HEX",&#13;
        "TC_COLORS_COLOR_MUST_HAVE_ID": "TC_COLORS_COLOR_MUST_HAVE_ID",&#13;
        "TC_TEXT_COLOR_DEFINITION_WRONG_ID": "TC_TEXT_COLOR_DEFINITION_WRONG_ID"&#13;
    };&#13;
&#13;
    presenter.TOKENS_TYPES = {&#13;
        WORD: "word",&#13;
        SELECTABLE: "selectable",&#13;
        NEW_LINE: "new_line",&#13;
        SPACE: "space"&#13;
    };&#13;
&#13;
    presenter.POSITIONS = {&#13;
        LEFT: "left",&#13;
        RIGHT: "right",&#13;
        TOP: "top",&#13;
        BOTTOM: "bottom"&#13;
    };&#13;
&#13;
    presenter.EVENT_TYPES = {&#13;
        SELECTING: 1,&#13;
        DESELECTING: 0&#13;
    };&#13;
&#13;
    presenter.eventBus = null;&#13;
    presenter.view = null;&#13;
    presenter.stateMachine = null;&#13;
    presenter.$colorButtons = null;&#13;
    presenter.$eraserButton = null;&#13;
    presenter.$wordTokens = null;&#13;
&#13;
    presenter.configuration = {&#13;
        ID: "id",&#13;
        isValid: true,&#13;
        isError: false,&#13;
        textTokens: [],&#13;
        filteredTokens: [],&#13;
        colors: [],&#13;
        buttonsPosition: "left",&#13;
        showAllAnswersInGradualShowAnswersMode: false,&#13;
        showSetEraserButtonMode: false,&#13;
        hideColorsButtons: false,&#13;
        activeColor: null,&#13;
        activeColorID: null,&#13;
        eraserMode: false,&#13;
        eraserButtonText: "Eraser Mode",&#13;
        isVisible: true&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = controller.getEventBus();&#13;
        var events = ['ShowAnswers', 'HideAnswers', 'GradualShowAnswers', 'GradualHideAnswers'];&#13;
        for (var i = 0; i &lt; events.length; i++) {&#13;
            presenter.eventBus.addEventListener(events[i], this);&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.runLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.runLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.destroy = function (event) {&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        presenter.disconnectWordTokensHandlers();&#13;
        presenter.disconnectHandlers();&#13;
    };&#13;
&#13;
    presenter.runLogic = function (view, model, isPreview) {&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.configuration = $.extend({}, presenter.configuration, presenter.validateModel(model));&#13;
        presenter.initialVisibility = presenter.configuration.isVisible;&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
        if (presenter.configuration.isError) {&#13;
            ModelErrorUtils.showErrorMessage(presenter.view, presenter.ERROR_CODES[presenter.configuration.errorCode]);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved(event) {&#13;
            if (event.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
&#13;
        presenter.createStateMachine();&#13;
        presenter.setFilteredTokensData();&#13;
        presenter.setView(presenter.createView());&#13;
&#13;
        if (!presenter.configuration.isVisible &amp;&amp; !isPreview) {&#13;
            presenter.hide();&#13;
        }&#13;
&#13;
        if (isPreview) {&#13;
            presenter.colorTokensInPreview();&#13;
        } else {&#13;
            presenter.connectHandlers();&#13;
            presenter.setColor(presenter.configuration.colors[0].id);&#13;
            presenter.stateMachine.notifyEdit();&#13;
            presenter.buildKeyboardController();&#13;
            presenter.setSpeechTexts(model["speechTexts"]);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createStateMachine = function() {&#13;
        presenter.stateMachine = new TextColoringStateMachine({});&#13;
    };&#13;
&#13;
    presenter.colorTokensInPreview = function () {&#13;
        presenter.configuration.filteredTokens.filter(filterSelectablesTokens).forEach(function (token) {&#13;
            var $token = presenter.getWordTokenByIndex(token.index);&#13;
            presenter.markToken($token, token.color);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setFilteredTokensData = function () {&#13;
        presenter.configuration.filteredTokens = presenter.configuration.textTokens.filter(function (token) {&#13;
            return token.type == presenter.TOKENS_TYPES.WORD || token.type == presenter.TOKENS_TYPES.SELECTABLE;&#13;
        }).map(function (token, index) {&#13;
            token.isSelected = false;&#13;
            token.selectionColorID = null;&#13;
            token.index = index;&#13;
            return token;&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setView = function (view) {&#13;
        presenter.$view.html(StringUtils.format("&lt;div class='text_coloring'&gt;{0}&lt;/div&gt;", view));&#13;
        presenter.$wordTokens = presenter.$view.find(StringUtils.format(".{0}", presenter.defaults.css.selectableWord));&#13;
        presenter.$colorButtons = presenter.$view.find(StringUtils.format(".{0}", presenter.defaults.css.colorButton));&#13;
        presenter.$eraserButton = presenter.$view.find(StringUtils.format(".{0}", presenter.defaults.css.eraserButton));&#13;
&#13;
        if (!presenter.configuration.showSetEraserButtonMode) {&#13;
            presenter.hideEraserButtonMode();&#13;
        }&#13;
&#13;
        if (presenter.configuration.hideColorsButtons) {&#13;
            presenter.hideColorsButtons();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideEraserButtonMode = function () {&#13;
        presenter.$eraserButton.parent().hide();&#13;
    };&#13;
&#13;
    presenter.hideColorsButtons = function () {&#13;
        presenter.$colorButtons.parent().hide();&#13;
    };&#13;
&#13;
    presenter.createView = function () {&#13;
        var buttonsContainerHTML;&#13;
        var textHTML;&#13;
        var css;&#13;
&#13;
        var mainContainer = "&lt;div class='{0}'&gt;";&#13;
&#13;
        switch (presenter.configuration.buttonsPosition) {&#13;
            case presenter.POSITIONS.LEFT:&#13;
                css = presenter.getContainerCssByPosition(presenter.configuration.buttonsPosition);&#13;
                buttonsContainerHTML = presenter.getButtonsContainerHTML(css);&#13;
                textHTML = presenter.getTextHTML(presenter.configuration.textTokens, css.tokensContainer, presenter.configuration.mode);&#13;
                mainContainer = StringUtils.format(mainContainer, css.mainContainer);&#13;
                mainContainer += buttonsContainerHTML + textHTML;&#13;
                break;&#13;
            case presenter.POSITIONS.RIGHT:&#13;
                css = presenter.getContainerCssByPosition(presenter.configuration.buttonsPosition);&#13;
                textHTML = presenter.getTextHTML(presenter.configuration.textTokens, css.tokensContainer, presenter.configuration.mode);&#13;
                buttonsContainerHTML = presenter.getButtonsContainerHTML(css);&#13;
                mainContainer = StringUtils.format(mainContainer, css.mainContainer);&#13;
                mainContainer += textHTML + buttonsContainerHTML;&#13;
                break;&#13;
            case presenter.POSITIONS.TOP:&#13;
                css = presenter.getContainerCssByPosition(presenter.configuration.buttonsPosition);&#13;
                textHTML = presenter.getTextHTML(presenter.configuration.textTokens, css.tokensContainer, presenter.configuration.mode);&#13;
                buttonsContainerHTML = presenter.getButtonsContainerHTML(css);&#13;
                mainContainer = StringUtils.format(mainContainer, css.mainContainer);&#13;
                mainContainer += buttonsContainerHTML + textHTML;&#13;
                break;&#13;
            case presenter.POSITIONS.BOTTOM:&#13;
                css = presenter.getContainerCssByPosition(presenter.configuration.buttonsPosition);&#13;
                textHTML = presenter.getTextHTML(presenter.configuration.textTokens, css.tokensContainer, presenter.configuration.mode);&#13;
                buttonsContainerHTML = presenter.getButtonsContainerHTML(css);&#13;
                mainContainer = StringUtils.format(mainContainer, css.mainContainer);&#13;
                mainContainer += textHTML + buttonsContainerHTML;&#13;
                break;&#13;
        }&#13;
&#13;
        mainContainer += "&lt;/div&gt;";&#13;
        return mainContainer;&#13;
    };&#13;
&#13;
    presenter.getContainerCssByPosition = function (position) {&#13;
        var result = {&#13;
            eraserContainer: "",&#13;
            colorsContainer: "",&#13;
            mainContainer: "",&#13;
            buttonContainer: "",&#13;
            tokensContainer: ""&#13;
        };&#13;
&#13;
        switch (position) {&#13;
            case presenter.POSITIONS.LEFT:&#13;
                result.eraserContainer = presenter.defaults.css.eraserButtonContainer.left;&#13;
                result.colorsContainer = presenter.defaults.css.colorButtonsContainer.left;&#13;
                result.mainContainer = presenter.defaults.css.mainContainer.left;&#13;
                result.buttonContainer = presenter.defaults.css.buttonsContainer.left;&#13;
                result.tokensContainer = presenter.defaults.css.tokensContainer.left;&#13;
                break;&#13;
            case presenter.POSITIONS.RIGHT:&#13;
                result.eraserContainer = presenter.defaults.css.eraserButtonContainer.right;&#13;
                result.colorsContainer = presenter.defaults.css.colorButtonsContainer.right;&#13;
                result.mainContainer = presenter.defaults.css.mainContainer.right;&#13;
                result.buttonContainer = presenter.defaults.css.buttonsContainer.right;&#13;
                result.tokensContainer = presenter.defaults.css.tokensContainer.right;&#13;
                break;&#13;
            case presenter.POSITIONS.TOP:&#13;
                result.eraserContainer = presenter.defaults.css.eraserButtonContainer.top;&#13;
                result.colorsContainer = presenter.defaults.css.colorButtonsContainer.top;&#13;
                result.mainContainer = presenter.defaults.css.mainContainer.top;&#13;
                result.buttonContainer = presenter.defaults.css.buttonsContainer.top;&#13;
                result.tokensContainer = presenter.defaults.css.tokensContainer.top;&#13;
                break;&#13;
            case presenter.POSITIONS.BOTTOM:&#13;
                result.eraserContainer = presenter.defaults.css.eraserButtonContainer.bottom;&#13;
                result.colorsContainer = presenter.defaults.css.colorButtonsContainer.bottom;&#13;
                result.mainContainer = presenter.defaults.css.mainContainer.bottom;&#13;
                result.buttonContainer = presenter.defaults.css.buttonsContainer.bottom;&#13;
                result.tokensContainer = presenter.defaults.css.tokensContainer.bottom;&#13;
                break&#13;
        }&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.getButtonsContainerHTML = function (css) {&#13;
        var colorsButtons = presenter.getColorsButtonsHTML(presenter.configuration.colors, css.colorsContainer);&#13;
        var eraserButtons = presenter.getEraserModeButtonHTML(css.eraserContainer);&#13;
        return StringUtils.format("&lt;div class='{0}'&gt;{1} {2}&lt;/div&gt;", css.buttonContainer, colorsButtons, eraserButtons);&#13;
    };&#13;
&#13;
    presenter.getColorsButtonsHTML = function (colorsDefinitions, containerCssClass) {&#13;
        var result = StringUtils.format("&lt;div class='{0}'&gt;", containerCssClass);&#13;
&#13;
        var colorsLen = colorsDefinitions.length;&#13;
        for (var i = 0; i &lt; colorsLen; i++) {&#13;
            result = StringUtils.format("{0}{1}", result, presenter.getColorHTMLText(colorsDefinitions[i]));&#13;
        }&#13;
&#13;
        result += "&lt;/div&gt;";&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.getEraserModeButtonHTML = function (containerCssClass) {&#13;
        var result = StringUtils.format("&lt;div class='{0}'&gt;", containerCssClass);&#13;
        result += StringUtils.format("&lt;div class='{0}'&gt;{1}&lt;/div&gt;", presenter.defaults.css.eraserButton, presenter.configuration.eraserButtonText);&#13;
        result += "&lt;/div&gt;";&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.getColorHTMLText = function (colorDefinition) {&#13;
        return StringUtils.format("&lt;div class='{0}' data-{1}='{2}'&gt;{3}&lt;/div&gt;", presenter.defaults.css.colorButton, presenter.defaults.dataHolders.colorID, colorDefinition.id, colorDefinition.description);&#13;
    };&#13;
&#13;
    presenter.getTextHTML = function (tokens, containerCssClass, mode) {&#13;
        var tokensLen = tokens.length;&#13;
        var result = StringUtils.format("&lt;div class='{0}'&gt;", containerCssClass);&#13;
&#13;
        for (var i = 0, wordIndex = 0; i &lt; tokensLen; i++) {&#13;
            if (tokens[i].type == presenter.TOKENS_TYPES.NEW_LINE) {&#13;
                result = StringUtils.format("{0}{1}", result, presenter.getNewLineHTML());&#13;
            } else if (tokens[i].type == presenter.TOKENS_TYPES.SPACE) {&#13;
                result = StringUtils.format("{0}{1}", result, presenter.getSpaceHTML());&#13;
            } else if (tokens[i].type == presenter.TOKENS_TYPES.SELECTABLE) {&#13;
                result = StringUtils.format("{0}{1}", result, presenter.getWordHTML(tokens[i], wordIndex));&#13;
                wordIndex++;&#13;
            } else {&#13;
                if (mode == "ALL_SELECTABLE") {&#13;
                    result = StringUtils.format("{0}{1}", result, presenter.getWordHTML(tokens[i], wordIndex));&#13;
                } else {&#13;
                    result = StringUtils.format("{0}{1}", result, tokens[i].value);&#13;
                }&#13;
                wordIndex++;&#13;
            }&#13;
        }&#13;
&#13;
        result += "&lt;/div&gt;";&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.getNewLineHTML = function () {&#13;
        return "&lt;br&gt;";&#13;
    };&#13;
&#13;
    presenter.getSpaceHTML = function () {&#13;
        return "&lt;span&gt; &lt;/span&gt;";&#13;
    };&#13;
&#13;
    presenter.getWordHTML = function (token, index) {&#13;
        return StringUtils.format("&lt;span class='{0}' data-word-index='{1}' &gt;{2}&lt;/span&gt;",&#13;
            presenter.defaults.css.selectableWord, index, token.value);&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function(model) {&#13;
        var upgradedModel = upgradeModelAddProperties(model);&#13;
        upgradedModel = presenter.upgradeSpeechTexts(upgradedModel);&#13;
        upgradedModel = presenter.upgradeLangTag(upgradedModel);&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    function upgradeModelAddProperties(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if(!upgradedModel['Mode']){&#13;
            upgradedModel['Mode'] = presenter.MODE.DEFAULT;&#13;
        }&#13;
        if(!upgradedModel['countErrors']) {&#13;
            upgradedModel['countErrors'] = false;&#13;
        }&#13;
        if(!upgradedModel['showAllAnswersInGradualShowAnswersMode']) {&#13;
            upgradedModel['showAllAnswersInGradualShowAnswersMode'] = false;&#13;
        }&#13;
        if(!upgradedModel['Legend title']) {&#13;
            upgradedModel['Legend title'] = 'Legend';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeSpeechTexts = function AddonText_Coloring_upgradeSpeechTexts (model) {&#13;
         let defaultValue = {&#13;
             Selected: {Selected: ""},&#13;
             Deselected: {Deselected: ""},&#13;
             TextContent: {TextContent: ""},&#13;
             Correct: {Correct: ""},&#13;
             Incorrect: {Incorrect: ""}&#13;
        };&#13;
&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
        if (model["speechTexts"] == undefined) {&#13;
            upgradedModel["speechTexts"] = defaultValue;&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeLangTag = function AddonText_Coloring_upgradeLangTag (model) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model);&#13;
        if (model["langAttribute"] == undefined) {&#13;
            upgradedModel["langAttribute"] = "";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.setSpeechTexts = function AddonText_Coloring_setSpeechTexts (speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            selected: presenter.DEFAULT_TTS_PHRASES.selected,&#13;
            deselected: presenter.DEFAULT_TTS_PHRASES.deselected,&#13;
            textContent: presenter.DEFAULT_TTS_PHRASES.textContent,&#13;
            correct: presenter.DEFAULT_TTS_PHRASES.correct,&#13;
            incorrect: presenter.DEFAULT_TTS_PHRASES.incorrect&#13;
        };&#13;
&#13;
        if (!speechTexts || $.isEmptyObject(speechTexts)) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            selected: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Selected.Selected,&#13;
                presenter.speechTexts.selected),&#13;
            deselected: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Deselected.Deselected,&#13;
                presenter.speechTexts.deselected),&#13;
            textContent: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.TextContent.TextContent,&#13;
                presenter.speechTexts.textContent),&#13;
            correct: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Correct.Correct,&#13;
                presenter.speechTexts.correct),&#13;
            incorrect: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Incorrect.Incorrect,&#13;
                presenter.speechTexts.incorrect)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var validatedColors = presenter.validateColors(model.colors);&#13;
        if (validatedColors.isError) {&#13;
            return validatedColors;&#13;
        }&#13;
&#13;
        var mode = ModelValidationUtils.validateOption(presenter.MODE, model.Mode);&#13;
&#13;
        var parsedText = presenter.parseText(model.text, mode);&#13;
        var validatedText = presenter.validateUsingOnlyDefinedColors(parsedText, validatedColors.value);&#13;
        var modelText = model.text ? model.text.split(' ') : '';&#13;
        var height = model.Height ? model.Height / 2 : 0;&#13;
        var legendTitle = model['Legend title'] ?  model['Legend title'] : 'Legend';&#13;
&#13;
        if (validatedText.isError) {&#13;
            return validatedText;&#13;
        }&#13;
&#13;
        return {&#13;
            ID: model["ID"],&#13;
            isValid: true,&#13;
            isError: false,&#13;
            textTokens: parsedText,&#13;
            colors: validatedColors.value,&#13;
            buttonsPosition: presenter.parseButtonsPosition(model.buttonsPosition),&#13;
            showAllAnswersInGradualShowAnswersMode: ModelValidationUtils.validateBoolean(model.showAllAnswersInGradualShowAnswersMode),&#13;
            showSetEraserButtonMode: ModelValidationUtils.validateBoolean(model.showSetEraserModeButton),&#13;
            hideColorsButtons: ModelValidationUtils.validateBoolean(model.hideColorsButtons),&#13;
            eraserButtonText: presenter.parseEraserButtonText(model.eraserButtonText),&#13;
            isVisible: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            mode: mode,&#13;
            countErrors: ModelValidationUtils.validateBoolean(model.countErrors),&#13;
            modelText: modelText,&#13;
            height: height,&#13;
            legendTitle: legendTitle,&#13;
            langTag: model.langAttribute&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateUsingOnlyDefinedColors = function (text, colors) {&#13;
        var tokenHaveInvalidColor = text.filter(filterSelectablesTokens).some(function (token) {&#13;
            var foundColorDefinition = colors.some(function (colorDefinition) {&#13;
                return token.color == colorDefinition.id;&#13;
            });&#13;
&#13;
            return !foundColorDefinition;&#13;
        });&#13;
&#13;
        if (tokenHaveInvalidColor) {&#13;
            return ModelErrorUtils.getErrorObject(presenter.ERROR_CODES_KEYS.TC_TEXT_COLOR_DEFINITION_WRONG_ID);&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            isError: false&#13;
        };&#13;
    };&#13;
&#13;
    presenter.parseEraserButtonText = function (eraserButtonText) {&#13;
        if (ModelValidationUtils.isStringEmpty(eraserButtonText)) {&#13;
            return presenter.defaults.eraserButtonDefaultText;&#13;
        } else {&#13;
            return eraserButtonText.trim();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.parseButtonsPosition = function (buttonsPosition) {&#13;
        if (buttonsPosition === undefined) {&#13;
            return "top";&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(buttonsPosition.trim())) {&#13;
            return "top";&#13;
        }&#13;
&#13;
        return buttonsPosition.trim();&#13;
    };&#13;
&#13;
    presenter.validateColors = function (colorsDefinitions) {&#13;
        var parsedValues = colorsDefinitions.map(markAsValidValues).map(parseIDs).map(parseRGBHex).map(parseDescriptions);&#13;
&#13;
        var errorDefinitions = parsedValues.filter(filterInvalid);&#13;
        if (errorDefinitions.length &gt; 0) {&#13;
            return ModelErrorUtils.getErrorObject(errorDefinitions[0].errorCode);&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: parsedValues.map(removeIsValidFlag)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.parseText = function (text, mode) {&#13;
        if (ModelValidationUtils.isStringEmpty(text.trim())) {&#13;
            return [];&#13;
        }&#13;
&#13;
        var groups = text.trim().split("\n").map(function (element) {&#13;
            return element.trim();&#13;
        });&#13;
        var groupsLen = groups.length;&#13;
        var result = [];&#13;
        var lastGroup = groups.length - 1;&#13;
        for (var groupNumber = 0; groupNumber &lt; groupsLen; groupNumber++) {&#13;
            var wordGroup = groups[groupNumber];&#13;
            if (wordGroup.length == 0) {&#13;
                result.push(getNewLineToken());&#13;
                continue;&#13;
            }&#13;
&#13;
            var parsedWords = presenter.splitGroupToWords(groups[groupNumber], mode)&#13;
                .map(presenter.parseWords)&#13;
                .reduce(flattenArrays, []);&#13;
&#13;
            if (parsedWords[parsedWords.length - 1].type == presenter.TOKENS_TYPES.SPACE) {&#13;
                parsedWords = parsedWords.slice(0, -1);&#13;
            }&#13;
&#13;
            if (groupNumber != lastGroup) {&#13;
                result = result.concat(parsedWords, getNewLineToken());&#13;
            } else {&#13;
                result = result.concat(parsedWords)&#13;
            }&#13;
        }&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.splitGroupToWords = function (group, mode) {&#13;
        if (mode == "ALL_SELECTABLE") {&#13;
            return group.split(" ").map(function (element) {&#13;
                element.trim();&#13;
                return element;&#13;
            }).filter(function (element) {&#13;
                return element != "";&#13;
            });&#13;
        } else {&#13;
            var splitGroup = [];&#13;
            var space = / /.source;&#13;
            var color = /\\color{[^}]*?}{[^}]*?}[^\s]*/.source;&#13;
&#13;
            var mainRex = new RegExp([color,space].join('|'));&#13;
             var match = mainRex.exec(group);&#13;
            while (match !== null) {&#13;
                var before = group.substring(0,match.index);&#13;
                group = group.substring(match.index + match[0].length);&#13;
&#13;
                if (before.trim().length &gt; 0) {&#13;
                    splitGroup.push(before.trim());&#13;
                }&#13;
                if (match[0].trim().length &gt; 0) {&#13;
                    splitGroup.push(match[0].trim());&#13;
                }&#13;
&#13;
                match = mainRex.exec(group);&#13;
            }&#13;
            if (group.trim().length &gt; 0) {&#13;
                splitGroup.push(group.trim());&#13;
            }&#13;
            return splitGroup;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.parseWords = function (word) {&#13;
        var result = [];&#13;
&#13;
        var selectablePart = {&#13;
            pattern: /\\color{[^}]+}{[^}]+}/g,&#13;
&#13;
            getStartOfIndex: function () {&#13;
                return word.search(this.pattern);&#13;
            },&#13;
&#13;
            getStopOfIndex: function () {&#13;
                return this.pattern.lastIndex;&#13;
            },&#13;
&#13;
            getSelectablePhrase: function () {&#13;
                this.pattern.test(word);&#13;
                return word.substring(0, this.getStopOfIndex());&#13;
            },&#13;
&#13;
            isExists: function () {&#13;
                return this.getStartOfIndex() != -1;&#13;
            },&#13;
&#13;
            hasPrecedingWord: function () {&#13;
                return this.getStartOfIndex() &gt; 0;&#13;
            },&#13;
&#13;
            separatePrecedingWord: function () {&#13;
                var precedingWord = word.substring(0, this.getStartOfIndex());&#13;
                return precedingWord;&#13;
            }&#13;
        };&#13;
&#13;
        while (selectablePart.isExists()) {&#13;
            if (selectablePart.hasPrecedingWord()) {&#13;
                var precedingWord = selectablePart.separatePrecedingWord();&#13;
                result.push(getWordToken(precedingWord));&#13;
&#13;
                word = word.substring(selectablePart.getStartOfIndex(), word.length);&#13;
            }&#13;
&#13;
            var selectablePhrase = selectablePart.getSelectablePhrase();&#13;
            if (selectablePhrase.length &gt; 0) {&#13;
                var selectableWord = presenter.getSelectableWord(selectablePhrase);&#13;
                var selectableColor = presenter.getSelectableColor(selectablePhrase);&#13;
                result.push(getSelectableToken(selectableWord, selectableColor));&#13;
            }&#13;
&#13;
            word = word.substring(selectablePart.getStopOfIndex(), word.length);&#13;
            selectablePart.pattern = /\\color{[^}]+}{[^}]+}/g;&#13;
        }&#13;
&#13;
        if (word.length &gt; 0)&#13;
            result.push(getWordToken(word));&#13;
&#13;
        result.push(getSpaceToken());&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.getSelectableColor = function (phrase) {&#13;
        var pattern = /{[^}]+}/g;&#13;
&#13;
        pattern.test(phrase);&#13;
&#13;
        var startOfIndex = "\\color{".length;&#13;
        var stopOfIndex = pattern.lastIndex - 1;&#13;
&#13;
        var color = phrase.substring(startOfIndex, stopOfIndex);&#13;
&#13;
        return color;&#13;
    };&#13;
&#13;
    presenter.getSelectableWord = function (phrase) {&#13;
        var pattern = /{[^}]+}{/g;&#13;
&#13;
        pattern.test(phrase);&#13;
        phrase = phrase.substring(pattern.lastIndex, phrase.length);&#13;
&#13;
        var word = phrase.substring(0, phrase.length - 1);&#13;
&#13;
        return word;&#13;
    };&#13;
&#13;
    presenter.connectHandlers = function () {&#13;
        presenter.$colorButtons.hover(presenter.hoverInAddPointerHandler, presenter.hoverOutRemovePointerHandler);&#13;
        presenter.$colorButtons.click(presenter.selectColorButtonHandler);&#13;
&#13;
        presenter.$eraserButton.hover(presenter.hoverInAddPointerHandler, presenter.hoverOutRemovePointerHandler);&#13;
        presenter.$eraserButton.click(presenter.activateEraserMode);&#13;
    };&#13;
&#13;
    presenter.activateEraserMode = function (event) {&#13;
        deleteActiveClass();&#13;
        presenter.setEraserMode(event);&#13;
    };&#13;
&#13;
    presenter.disconnectHandlers = function () {&#13;
        presenter.$colorButtons.off();&#13;
        presenter.$eraserButton.off();&#13;
&#13;
        if (presenter.configuration.eraserMode) {&#13;
            presenter.disconnectWordTokensHandlers();&#13;
            presenter.toggleEraserMode();&#13;
        } else if (presenter.configuration.activeColorID !== null) {&#13;
            presenter.disconnectWordTokensHandlers();&#13;
            presenter.configuration.activeColor = null;&#13;
            presenter.configuration.activeColorID = null;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.connectWordTokensHandlers = function () {&#13;
        presenter.$wordTokens.hover(presenter.hoverInAddPointerHandler, presenter.hoverOutRemovePointerHandler);&#13;
        presenter.$wordTokens.hover(presenter.hoverInAddBackgroundHandler, presenter.hoverOutRemoveBackgroundHandler);&#13;
        presenter.$wordTokens.click(presenter.underlineWordHandler);&#13;
    };&#13;
&#13;
    presenter.disconnectWordTokensHandlers = function () {&#13;
        presenter.$wordTokens.off();&#13;
    };&#13;
&#13;
    presenter.eraserButtonClickHandler = function (event) {&#13;
        presenter.setEraserMode();&#13;
    };&#13;
&#13;
    presenter.toggleEraserMode = function () {&#13;
        presenter.configuration.eraserMode = !presenter.configuration.eraserMode;&#13;
    };&#13;
&#13;
    presenter.hoverInAddPointerHandler = function (event) {&#13;
        $(this).addClass(presenter.defaults.css.pointer);&#13;
    };&#13;
&#13;
    presenter.hoverOutRemovePointerHandler = function (event) {&#13;
        $(this).removeClass(presenter.defaults.css.pointer);&#13;
    };&#13;
&#13;
    presenter.hoverInAddBackgroundHandler = function (event) {&#13;
        $(this).addClass(presenter.defaults.css.hover);&#13;
    };&#13;
&#13;
    presenter.hoverOutRemoveBackgroundHandler = function (event) {&#13;
        $(this).removeClass(presenter.defaults.css.hover);&#13;
    };&#13;
&#13;
    presenter.resetColoredWords = function () {&#13;
        presenter.$view.find("[class*='text-coloring-colored-with']").each(function () {&#13;
            $(this).removeClass(function (index, css) {&#13;
                return (css.match(/\btext-coloring-colored-with\S+/g) || []).join(' ');&#13;
            });&#13;
        })&#13;
    };&#13;
&#13;
    presenter.resetColoredWord = function (element) {&#13;
        $(element).removeClass(function (index, css) {&#13;
            return (css.match(/\btext-coloring-colored-with\S+/g) || []).join(' ');&#13;
        });&#13;
    };&#13;
&#13;
    presenter.underlineWordHandler = function (event) {&#13;
        var $element = $(this);&#13;
        var wordIndex = $element.data("word-index");&#13;
        var tokenData = presenter.configuration.filteredTokens[wordIndex];&#13;
        if (presenter.configuration.eraserMode || (tokenData.selectionColorID == presenter.configuration.activeColorID)) {&#13;
            presenter.unmarkToken($element);&#13;
            presenter.removeColoredWordCss($element, presenter.configuration.filteredTokens[wordIndex]);&#13;
            presenter.removeColorData($element);&#13;
            presenter.sendErasingEvent(wordIndex);&#13;
        } else if (presenter.configuration.activeColor !== null &amp;&amp; tokenData.selectionColorID !== presenter.configuration.activeColorID) {&#13;
            presenter.markToken($element, presenter.configuration.activeColor);&#13;
            presenter.addColorData($element);&#13;
            presenter.sendMarkingEvent(wordIndex);&#13;
            presenter.resetColoredWord($element);&#13;
            presenter.addColoredWordCss($element, presenter.configuration.filteredTokens[wordIndex]);&#13;
        }&#13;
&#13;
&#13;
        if (presenter.isAllOK()) {&#13;
            presenter.sendAllOKEvent();&#13;
        }&#13;
&#13;
        presenter.stateMachine.notifyEdit();&#13;
    };&#13;
&#13;
    presenter.addColoredWordCss = function ($element, colorData) {&#13;
        var colorID = colorData.selectionColorID;&#13;
        $element.addClass(StringUtils.format(presenter.defaults.css.coloredWord, colorID))&#13;
    };&#13;
&#13;
    presenter.removeColoredWordCss = function ($element, colorData) {&#13;
        var colorID = colorData.selectionColorID;&#13;
        $element.removeClass(StringUtils.format(presenter.defaults.css.coloredWord, colorID))&#13;
    };&#13;
&#13;
    presenter.unmarkToken = function ($element) {&#13;
        $element.css({&#13;
            "text-decoration": "none",&#13;
            "padding-bottom": "none",&#13;
            "border-bottom": "none"&#13;
        });&#13;
    };&#13;
&#13;
    presenter.markToken = function ($element, color) {&#13;
        $element.css({&#13;
            "text-decoration": "none",&#13;
            "padding-bottom": "0.1em",&#13;
            "border-bottom": StringUtils.format("0.1em solid {0}", color)&#13;
        });&#13;
    };&#13;
&#13;
&#13;
    presenter.hideTokenClasses = function ($element) {&#13;
        if (!$element) return;&#13;
        $element.each(function(){&#13;
            var $this = $(this);&#13;
            var classNames = $this.attr('class').split(/\s+/);&#13;
            var disabledClasses = [];&#13;
            for (var i = 0; i &lt; classNames.length; i++) {&#13;
                if (classNames[i] != presenter.defaults.css.selectableWord){&#13;
                    $this.removeClass(classNames[i]);&#13;
                    disabledClasses.push(classNames[i]);&#13;
                }&#13;
            }&#13;
            this.dataset.disabledClasses = disabledClasses.join(' ');&#13;
        });&#13;
    };&#13;
&#13;
    presenter.showTokenClasses = function ($element) {&#13;
        if (!$element) return;&#13;
        $element.each(function(){&#13;
            var $this = $(this);&#13;
            var disabledClasses = this.dataset.disabledClasses;&#13;
            if (disabledClasses) {&#13;
                var classNames = disabledClasses.split(/\s+/);&#13;
                for (var i = 0; i &lt; classNames.length; i++) {&#13;
                    $this.addClass(classNames[i]);&#13;
                }&#13;
                this.dataset.disabledClasses = '';&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.addColorData = function ($element) {&#13;
        presenter.setTokenData($element, true, presenter.configuration.activeColorID);&#13;
    };&#13;
&#13;
    presenter.removeColorData = function ($element) {&#13;
        presenter.setTokenData($element, false, null);&#13;
    };&#13;
&#13;
    presenter.setTokenData = function ($element, isSelected, colorID) {&#13;
        var tokenIndex = $element.data("word-index");&#13;
        presenter.configuration.filteredTokens[tokenIndex].isSelected = isSelected;&#13;
        presenter.configuration.filteredTokens[tokenIndex].selectionColorID = colorID;&#13;
    };&#13;
&#13;
    presenter.selectColorButtonHandler = function (event) {&#13;
        var $button = $(this);&#13;
        presenter.setColor($button.data(presenter.defaults.dataHolders.colorID));&#13;
    };&#13;
&#13;
    presenter.shouldActivateColoringMode = function () {&#13;
        return presenter.configuration.activeColorID == null;&#13;
    };&#13;
&#13;
    presenter.shouldDisableColoringMode = function (colorID) {&#13;
        return colorID == presenter.configuration.activeColorID;&#13;
    };&#13;
&#13;
    presenter.activateColoringMode = function (colorID) {&#13;
        presenter.setActiveColor(colorID);&#13;
        presenter.connectWordTokensHandlers();&#13;
    };&#13;
&#13;
    presenter.disableColoringMode = function () {&#13;
        presenter.configuration.activeColor = null;&#13;
        presenter.configuration.activeColorID = null;&#13;
        presenter.disconnectWordTokensHandlers();&#13;
    };&#13;
&#13;
    presenter.setActiveColor = function (colorID) {&#13;
        var activeColorDefinition = presenter.getColorDefinitionById(colorID);&#13;
&#13;
        presenter.configuration.activeColor = activeColorDefinition.color;&#13;
        presenter.configuration.activeColorID = colorID;&#13;
    };&#13;
&#13;
    presenter.getColorDefinitionById = function (colorID) {&#13;
        return presenter.configuration.colors.filter(function (colorDefinition) {&#13;
            return colorDefinition.id == colorID;&#13;
        })[0];&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, data) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.stateMachine.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.stateMachine.hideAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "GradualShowAnswers") {&#13;
            if (presenter.configuration.ID == data.moduleID) {&#13;
                presenter.stateMachine.gradualBlockAnswers();&#13;
                presenter.stateMachine.gradualShowAnswers();&#13;
            } else {&#13;
                presenter.stateMachine.gradualBlockAnswers();&#13;
            }&#13;
        }&#13;
&#13;
        if (eventName == "GradualHideAnswers") {&#13;
            presenter.stateMachine.gradualHideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        if (!presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            var answersNumber = 0;&#13;
            presenter.configuration.filteredTokens.filter(filterSelectablesTokens).forEach(function (token) {&#13;
                var colorDefinition = presenter.getColorDefinitionById(token.color);&#13;
                if (colorDefinition !== undefined) {&#13;
                    answersNumber++;&#13;
                }&#13;
            });&#13;
            return answersNumber;&#13;
        }&#13;
        return 1;&#13;
    };&#13;
&#13;
    presenter.getWordTokenByIndex = function (tokenIndex) {&#13;
        if (presenter.configuration.mode == "ALL_SELECTABLE") {&#13;
            return $(presenter.$wordTokens[tokenIndex]);&#13;
        } else {&#13;
            return presenter.$view.find('[data-word-index='+tokenIndex+']');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.stateMachine.reset();&#13;
        presenter.stateMachine.notifyEdit();&#13;
        presenter.setVisibility(presenter.initialVisibility);&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        presenter.stateMachine.hideAnswers();&#13;
        presenter.stateMachine.onUnCorrect();&#13;
        presenter.stateMachine.notifyEdit();&#13;
&#13;
        if (presenter.configuration.activeColorID !== null) {&#13;
            presenter.configuration.activeColorID = null;&#13;
            presenter.configuration.activeColor = null;&#13;
        }&#13;
        presenter.disconnectWordTokensHandlers();&#13;
        if  (presenter.stateMachine.previousActiveColorID !== null) {&#13;
            presenter.setColor(presenter.stateMachine.previousActiveColorID);&#13;
        } else {&#13;
            presenter.setColor(presenter.configuration.colors[0].id);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        if (isCheckAnswersActive()) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.stateMachine.check();&#13;
    };&#13;
&#13;
    function isCheckAnswersActive() {&#13;
        return (presenter.stateMachine._actualState === StatefullAddonObject._internal.STATE.CORRECT&#13;
            || presenter.stateMachine._actualState === StatefullAddonObject._internal.STATE.WRONG);&#13;
    }&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'setEraserMode': presenter.setEraserMode,&#13;
            'setColor': presenter.setColorCommand,&#13;
            'isAttempted': presenter.isAttempted&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setColorCommand = function (args) {&#13;
        var validatedArgs = presenter.validateColorCommandArgs(args);&#13;
&#13;
        if (validatedArgs.isError) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.setColor(validatedArgs.value);&#13;
    };&#13;
&#13;
    presenter.validateColorCommandArgs = function (args) {&#13;
        if (args.length != 1) {&#13;
            return ModelErrorUtils.getErrorObject("");&#13;
        }&#13;
&#13;
        var colorDefinition = presenter.getColorDefinitionById(args[0]);&#13;
&#13;
        if (colorDefinition == undefined) {&#13;
            return ModelErrorUtils.getErrorObject("");&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            value: args[0]&#13;
        };&#13;
    };&#13;
&#13;
    presenter.setEraserMode = function () {&#13;
        if (!presenter.configuration.eraserMode) {&#13;
            presenter.disableColoringMode();&#13;
            presenter.connectWordTokensHandlers();&#13;
            presenter.toggleEraserMode();&#13;
        }&#13;
        presenter.setEraserButtonAsActive();&#13;
    };&#13;
&#13;
    presenter.setColor = function (colorID) {&#13;
        if (presenter.configuration.eraserMode) {&#13;
            presenter.toggleEraserMode();&#13;
            presenter.setActiveColor(colorID);&#13;
            presenter.unsetEraserButtonAsActive();&#13;
            presenter.setColorButtonAsActive(colorID);&#13;
        } else if (presenter.shouldActivateColoringMode()) {&#13;
            presenter.activateColoringMode(colorID);&#13;
            presenter.setColorButtonAsActive(colorID);&#13;
        } else {&#13;
            presenter.setActiveColor(colorID);&#13;
            presenter.setColorButtonAsActive(colorID);&#13;
        }&#13;
    };&#13;
 &#13;
     presenter.isAttempted = function () {&#13;
        var words = presenter.configuration.filteredTokens;&#13;
        var attempted = false;&#13;
        for (var i = 0; i &lt; words.length; i++) {&#13;
            if (words[i].isSelected) {&#13;
                attempted = true;&#13;
                break;&#13;
            }&#13;
        };&#13;
        return attempted;&#13;
    };&#13;
&#13;
    presenter.setEraserButtonAsActive = function () {&#13;
        if (presenter.$colorButtons !== null) {&#13;
            presenter.$colorButtons.removeClass(presenter.defaults.css.activeButton);&#13;
        }&#13;
&#13;
        if (presenter.$eraserButton !== null) {&#13;
            presenter.$eraserButton.addClass(presenter.defaults.css.activeButton);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.unsetEraserButtonAsActive = function () {&#13;
        if (presenter.$eraserButton !== null) {&#13;
            presenter.$eraserButton.removeClass(presenter.defaults.css.activeButton);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.unsetColorButtonsAsActive = function () {&#13;
        presenter.$colorButtons.removeClass(presenter.defaults.css.activeButton);&#13;
    };&#13;
&#13;
    presenter.setColorButtonAsActive = function (colorID) {&#13;
        var button = presenter.getColorButtonByID(colorID);&#13;
        if (button !== null) {&#13;
            presenter.unsetColorButtonsAsActive();&#13;
            $(button).addClass(presenter.defaults.css.activeButton);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getColorButtonByID = function (colorID) {&#13;
        var colorButton = $.makeArray(presenter.$colorButtons).filter(function (button) {&#13;
            return $(button).data(presenter.defaults.dataHolders.colorID) == colorID;&#13;
        });&#13;
&#13;
        if (colorButton.length &gt; 0) {&#13;
            return colorButton;&#13;
        } else {&#13;
            return null;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.configuration.isVisible = true;&#13;
        presenter.$view.css("visibility", "visible");&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.configuration.isVisible = false;&#13;
        presenter.$view.css("visibility", "hidden");&#13;
    };&#13;
&#13;
    presenter.sendErasingEvent = function (wordIndex) {&#13;
        presenter.eventBus.sendEvent('ValueChanged', {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': (wordIndex + 1),&#13;
            'value': presenter.EVENT_TYPES.DESELECTING,&#13;
            'score': 0&#13;
        });&#13;
    };&#13;
&#13;
    presenter.sendMarkingEvent = function (wordIndex) {&#13;
        presenter.eventBus.sendEvent('ValueChanged', {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': (wordIndex + 1),&#13;
            'value': presenter.EVENT_TYPES.SELECTING,&#13;
            'score': presenter.getScoreForWordMarking(wordIndex, presenter.configuration.activeColorID)&#13;
        });&#13;
    };&#13;
&#13;
    presenter.getScoreForWordMarking = function (wordIndex, colorID) {&#13;
        if (presenter.configuration.filteredTokens[wordIndex].color == colorID) {&#13;
            return 1;&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        return presenter.configuration.filteredTokens.filter(filterSelectablesTokens).length;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        return presenter.configuration.filteredTokens.filter(filterSelectedTokens).filter(filterWrongTokens).length;&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        return presenter.getMaxScore() - presenter.configuration.filteredTokens.filter(filterSelectablesTokens).filter(filterWrongTokens).length;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        var activeColorID = presenter.configuration.activeColorID;&#13;
        if (!presenter.configuration.eraserMode &amp;&amp; activeColorID === null) {&#13;
            activeColorID = presenter.stateMachine.previousActiveColorID;&#13;
        }&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            tokens: presenter.configuration.filteredTokens,&#13;
            activeColorID: activeColorID&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (stateString) {&#13;
        if (ModelValidationUtils.isStringEmpty(stateString)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsedState = JSON.parse(stateString);&#13;
&#13;
        presenter.configuration.filteredTokens = parsedState.tokens;&#13;
        presenter.configuration.isVisible = parsedState.isVisible;&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
        presenter.colorAllMarkedTokens();&#13;
&#13;
        if (parsedState.activeColorID !== undefined) {&#13;
            if (parsedState.activeColorID == null) {&#13;
                presenter.setEraserMode();&#13;
            } else {&#13;
                presenter.setColor(parsedState.activeColorID);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        if (isVisible) {&#13;
            presenter.show();&#13;
        } else {&#13;
            presenter.hide();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.colorAllMarkedTokens = function () {&#13;
        presenter.configuration.filteredTokens.filter(function (token) {&#13;
            return token.selectionColorID !== null;&#13;
        }).forEach(function (token) {&#13;
            var $token = presenter.getWordTokenByIndex(token.index);&#13;
            var colorDefinition = presenter.getColorDefinitionById(token.selectionColorID);&#13;
            presenter.markToken($token, colorDefinition.color);&#13;
            presenter.addColoredWordCss($token, token);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.sendAllOKEvent = function () {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        if (presenter.configuration.countErrors) {&#13;
            return presenter.getMaxScore() === presenter.getScore() - presenter.getErrorCount();&#13;
        } else {&#13;
            return presenter.configuration.filteredTokens.filter(filterSelectablesTokens).every(function (token) {&#13;
                return presenter.getScoreForWordMarking(token.index, token.selectionColorID);&#13;
            });&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.addCorrectClass = function (tokenIndex) {&#13;
        presenter.getWordTokenByIndex(tokenIndex).addClass(presenter.defaults.css.markings.correct);&#13;
    };&#13;
&#13;
    presenter.addWrongClass = function (tokenIndex) {&#13;
        presenter.getWordTokenByIndex(tokenIndex).addClass(presenter.defaults.css.markings.wrong);&#13;
    };&#13;
&#13;
    presenter.removeAllCheckAnswersClasses = function () {&#13;
        presenter.$wordTokens.removeClass(presenter.defaults.css.markings.correct);&#13;
        presenter.$wordTokens.removeClass(presenter.defaults.css.markings.wrong);&#13;
    };&#13;
&#13;
    presenter.setPrintableState = function(state) {&#13;
        if (state === null || ModelValidationUtils.isStringEmpty(state))&#13;
            return;&#13;
&#13;
        presenter.printableState = JSON.parse(state);&#13;
    }&#13;
&#13;
    presenter.getPrintableHTML = function (model, showAnswers) {&#13;
        var printableHTML = '';&#13;
        var userAnswer = presenter.getUserAnswer();&#13;
        var didUserAnswer = userAnswer ? userAnswer.some(answer =&gt; answer.isSelected) : false;&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        var modelText = presenter.configuration.textTokens.filter(token =&gt; ![presenter.TOKENS_TYPES.SPACE, presenter.TOKENS_TYPES.NEW_LINE].includes(token.type));&#13;
        var areAllSelectable = presenter.configuration.mode === 'ALL_SELECTABLE'&#13;
&#13;
        modelText.forEach((token, index) =&gt; {&#13;
            var colorId;&#13;
            var color;&#13;
            switch (true) {&#13;
                case (userAnswer &amp;&amp; userAnswer[index].isSelected) &amp;&amp; !showAnswers:&#13;
                    colorId = userAnswer[index].selectionColorID;&#13;
                    color = presenter.getColor(model, colorId);&#13;
&#13;
                    printableHTML += `&lt;span style="border: 2px solid ${color}"&gt;${userAnswer[index].value}&lt;/span&gt; `;&#13;
                    break;&#13;
&#13;
                case (userAnswer &amp;&amp; userAnswer[index].isSelected) &amp;&amp; showAnswers:&#13;
                    colorId = userAnswer[index].selectionColorID;&#13;
                    color = presenter.getColor(model, colorId);&#13;
&#13;
                    var answerMark = presenter.isAnswerCorrect(userAnswer[index], token.value) ? '&amp;#10004;' : '&amp;#10006;';&#13;
                    printableHTML += `&lt;span style="border: 2px solid ${color}"&gt;${userAnswer[index].value} ${answerMark}&lt;/span&gt; `;&#13;
                    break;&#13;
&#13;
                case token.hasOwnProperty('color') &amp;&amp; showAnswers &amp;&amp; !didUserAnswer:&#13;
                    colorId = token.color;&#13;
                    color = presenter.getColor(model, colorId);&#13;
&#13;
                    printableHTML += `&lt;span style="border: 2px dashed ${color}"&gt;${token.value}&lt;/span&gt; `;&#13;
                    break;&#13;
&#13;
                case token.hasOwnProperty('color') &amp;&amp; (!areAllSelectable || showAnswers):&#13;
                    printableHTML += `&lt;span style="border-bottom: 1px solid"&gt;${token.value}&lt;/span&gt; `;&#13;
                    break;&#13;
&#13;
                default:&#13;
                    printableHTML += `${token.value} `;&#13;
            }&#13;
        });&#13;
&#13;
        return presenter.createHTML(showAnswers || userAnswer, printableHTML, presenter.configuration);&#13;
    }&#13;
&#13;
    presenter.createHTML = function (shouldChangeLineHeight, htmlContent) {&#13;
        var $legend = $('&lt;div&gt;&lt;/div&gt;');&#13;
        var $wrapper = $('&lt;div&gt;&lt;/div&gt;');&#13;
        var colors = presenter.configuration.colors;&#13;
        var height = presenter.configuration.height + (2 + colors.length) * 20;&#13;
        var legendTitle = presenter.configuration.legendTitle&#13;
        $wrapper.addClass('printable_addon_Paragraph');&#13;
        $wrapper.css("left", "0px");&#13;
        $wrapper.css("right", "0px");&#13;
        $wrapper.css("height", `${height}px`);&#13;
        $wrapper.css("padding", "10px 10px 10px 0px");&#13;
        var $paragraph = $('&lt;div&gt;&lt;/div&gt;');&#13;
        $paragraph.css("left", "0px");&#13;
        $paragraph.css("right", "0px");&#13;
        $paragraph.css("height", `${presenter.configuration.height}`);&#13;
        $paragraph.css("border", "1px solid");&#13;
        $paragraph.css("padding", "10px");&#13;
        if (shouldChangeLineHeight) {&#13;
            $paragraph.css("line-height", "1.5");&#13;
        }&#13;
        $paragraph.html(htmlContent);&#13;
        $legend.append(presenter.createLegend(colors,  legendTitle))&#13;
        $wrapper.append($paragraph);&#13;
        $wrapper.append($legend);&#13;
        return $wrapper[0].outerHTML;&#13;
    }&#13;
&#13;
    /* Return colors in grayscale from the model */&#13;
    presenter.getColors = function (model) {&#13;
        var colors = [];&#13;
        model['colors'].forEach(colorObject =&gt; {&#13;
           colors.push({id: colorObject.id, value: parseToGrayscale(colorObject.color)});&#13;
        });&#13;
&#13;
        return colors;&#13;
    }&#13;
&#13;
    /* Returns color in hex code from color name */&#13;
    presenter.getColorInHex = function (model, colorId) {&#13;
        var colors =  presenter.getColors(model);&#13;
&#13;
        return colors.find(color =&gt; color.id === colorId).value;&#13;
    }&#13;
&#13;
    /* Extracts the word from phrase \\color{color}{word} */&#13;
    presenter.getWord = function (phrase) {&#13;
        var regExp = /(\\color{\w*}{)/;&#13;
        return phrase.replace(regExp, '').replace(/}/, '');&#13;
    }&#13;
&#13;
    /* Extracts the color from phrase and convert into grayscale \\color{color}{word} */&#13;
    presenter.getColor = function (model, colorId) {&#13;
        return parseToGrayscale(presenter.getColorInHex(model, colorId));&#13;
    }&#13;
&#13;
    /* Return user answers */&#13;
    presenter.getUserAnswer = function () {&#13;
        if (presenter.printableState &amp;&amp; presenter.printableState.hasOwnProperty('tokens')) {&#13;
            return presenter.printableState['tokens'];&#13;
        }&#13;
&#13;
        return null;&#13;
    }&#13;
&#13;
    /* Checks if the user answer is correct */&#13;
    presenter.isAnswerCorrect = function (userAnswer, modelAnswer) {&#13;
        return modelAnswer.includes(`{${userAnswer.selectionColorID}}{${userAnswer.value}}`);&#13;
    }&#13;
&#13;
    presenter.createLegend = function (colors, legendTitle) {&#13;
        var $table = $("&lt;table&gt;&lt;/table&gt;");&#13;
        var $tbody = $("&lt;tbody&gt;&lt;/tbody&gt;");&#13;
&#13;
        $tbody.append($(`&lt;caption&gt;${legendTitle}&lt;/caption&gt;`));&#13;
        colors.forEach(colorObject =&gt; {&#13;
            var $tr = $("&lt;tr&gt;&lt;/tr&gt;");&#13;
&#13;
            var $td = $("&lt;td&gt;&lt;div style='width: 20px; height: 10px'&gt;&lt;/div&gt;&lt;/td&gt;");&#13;
            $td.css('background', parseToGrayscale(colorObject.color));&#13;
&#13;
            var $description = $(`&lt;td&gt;&lt;div style="padding-left: 10px"&gt;${colorObject.description}&lt;/div&gt;&lt;/td&gt;`);&#13;
&#13;
            $tr.append($td);&#13;
            $tr.append($description);&#13;
            $tbody.append($tr);&#13;
        });&#13;
        $table.append($tbody);&#13;
&#13;
        return $table&#13;
    }&#13;
&#13;
    function TextColoringKeyboardController (elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
    }&#13;
&#13;
    TextColoringKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    TextColoringKeyboardController.prototype.constructor = TextColoringKeyboardController;&#13;
&#13;
    presenter.buildKeyboardController = function AddonText_Coloring_buildKeyboardController () {&#13;
        presenter.keyboardControllerObject = new TextColoringKeyboardController(presenter.getElementsForKeyboardNavigation(), 1);&#13;
    };&#13;
&#13;
    presenter.getDefaultElementsStringForKeyboardNavigation = function AddonText_Coloring_getDefaultElementsStringForKeyboardNavigation () {&#13;
        if (presenter.configuration.showSetEraserButtonMode) {&#13;
            return ".text-coloring-color-button, .text-coloring-eraser-button, .text-coloring-selectable-word";&#13;
        } else {&#13;
            return ".text-coloring-color-button, .text-coloring-selectable-word";&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        return presenter.$view.find(presenter.getDefaultElementsStringForKeyboardNavigation());&#13;
    };&#13;
&#13;
    presenter.getElementsForTTS = function () {&#13;
        const container = presenter.defaults.css.tokensContainer;&#13;
        const allPossibleContainerClasses = `.${container.bottom}, .${container.left}, .${container.top}, .${container.right}`;&#13;
        return presenter.$view.find(`${presenter.getDefaultElementsStringForKeyboardNavigation()}, ${allPossibleContainerClasses}`);&#13;
    };&#13;
&#13;
    presenter.keyboardController = function AddonText_Coloring_keyboardController (keycode, isShiftKeyDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
    };&#13;
&#13;
    TextColoringKeyboardController.prototype.getTarget = function (element) {&#13;
        return $(element);&#13;
    };&#13;
&#13;
    TextColoringKeyboardController.prototype.switchElement = function (move) {&#13;
        var new_position_index = this.keyboardNavigationCurrentElementIndex + move;&#13;
        if (new_position_index &gt;= this.keyboardNavigationElementsLen || new_position_index &lt; 0) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex;&#13;
        }&#13;
&#13;
        this.markCurrentElement(new_position_index);&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    TextColoringKeyboardController.prototype.enter = function (event) {&#13;
        if (presenter.isTTS() &amp;&amp; presenter.isFirstEnter) {&#13;
            KeyboardController.prototype.setElements.call(this, presenter.getElementsForTTS());&#13;
            presenter.isFirstEnter = false;&#13;
        }&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
     TextColoringKeyboardController.prototype.exitWCAGMode = function () {&#13;
        presenter.isFirstEnter = true;&#13;
        KeyboardController.prototype.setElements.call(this, presenter.getElementsForKeyboardNavigation());&#13;
        KeyboardController.prototype.exitWCAGMode.call(this);&#13;
    };&#13;
&#13;
    TextColoringKeyboardController.prototype.selectAction = function () {&#13;
        if (!presenter.isAddonInWorkMode()) {&#13;
            return;&#13;
        }&#13;
        KeyboardController.prototype.selectAction.call(this);&#13;
        presenter.speakOnElementSelection();&#13;
    };&#13;
&#13;
    presenter.speakOnElementSelection = function AddonText_Coloring_speakOnElementSelection () {&#13;
        const element = presenter.keyboardControllerObject.getTarget(presenter.keyboardControllerObject.keyboardNavigationCurrentElement);&#13;
        let text = ""&#13;
        if (element.hasClass(presenter.defaults.css.colorButton) || element.hasClass(presenter.defaults.css.eraserButton)) {&#13;
            text = presenter.speechTexts.selected;&#13;
        } else if (element.hasClass(presenter.defaults.css.selectableWord)) {&#13;
            const color = presenter.getColorObjectOrNoneFromElementClass(element);&#13;
            text = color ? `${presenter.speechTexts.selected} ${color.description}` : presenter.speechTexts.deselected;&#13;
        }&#13;
&#13;
        if (text) {&#13;
            presenter.speak(text);&#13;
        }&#13;
    };&#13;
&#13;
    TextColoringKeyboardController.prototype.readCurrentElement = function () {&#13;
        const element = this.getTarget(this.keyboardNavigationCurrentElement);&#13;
        let text = "";&#13;
        const elementContent = element[0].textContent;&#13;
&#13;
        if (element.hasClass(presenter.defaults.css.colorButton) || element.hasClass(presenter.defaults.css.eraserButton)) {&#13;
            text = presenter.getTTSForColorButton(element, elementContent);&#13;
        } else if (element[0].className.includes("text-coloring-tokens-container")) {&#13;
            text = presenter.getTTSForContent();&#13;
        } else if (element.hasClass(presenter.defaults.css.selectableWord)) {&#13;
            text = presenter.getTTSForWord(element, elementContent);&#13;
        }&#13;
&#13;
        presenter.speak(text);&#13;
    };&#13;
&#13;
    presenter.getTTSForColorButton = function AddonText_Coloring_getTTSForColorButton (element, text) {&#13;
        const selectedText = presenter.isColorButtonClicked(element) ? presenter.speechTexts.selected : "";&#13;
        return `${text} ${selectedText}`;&#13;
    };&#13;
&#13;
    presenter.getTTSForContent = function AddonText_Coloring_getTTSForContent () {&#13;
        const tts = [TTSUtils.getTextVoiceObject(presenter.speechTexts.textContent)];&#13;
        let text = "";&#13;
&#13;
        presenter.configuration.filteredTokens.forEach((token) =&gt; {&#13;
            let tokenContent = $("&lt;p&gt;" + token.value + "&lt;\p&gt;")[0].textContent;&#13;
            text += tokenContent + " ";&#13;
            const tokenElement = presenter.getWordTokenByIndex(token.index);&#13;
            if (!tokenElement.length) {&#13;
                return;&#13;
            }&#13;
            const ttsColoring = presenter.getWordTTSAttributes(tokenElement);&#13;
&#13;
            if (ttsColoring) {&#13;
                tts.push(TTSUtils.getTextVoiceObject(text, presenter.configuration.langTag));&#13;
                text = " ";&#13;
                tts.push(TTSUtils.getTextVoiceObject(ttsColoring));&#13;
            }&#13;
        });&#13;
&#13;
        tts.push(TTSUtils.getTextVoiceObject(text, presenter.configuration.langTag));&#13;
&#13;
        return tts;&#13;
    };&#13;
&#13;
    presenter.getTTSForWord = function AddonText_Coloring_getTTSForWord (element, word) {&#13;
        const tts = [TTSUtils.getTextVoiceObject(word, presenter.configuration.langTag)];&#13;
&#13;
        let wordAttributes = presenter.getWordTTSAttributes(element);&#13;
        if (wordAttributes) {&#13;
            tts.push(TTSUtils.getTextVoiceObject(wordAttributes));&#13;
        }&#13;
&#13;
        return tts;&#13;
    };&#13;
&#13;
    presenter.getWordTTSAttributes = function AddonText_Coloring_getWordTTSAttributes (element) {&#13;
        let text = "";&#13;
&#13;
        const color = presenter.getColorObjectOrNoneFromElementClass(element);&#13;
        if (color) {&#13;
           text += ` ${presenter.speechTexts.selected} ${color.description}`;&#13;
        }&#13;
&#13;
        if (element.hasClass(presenter.defaults.css.markings.correct)) {&#13;
           text += ` ${presenter.speechTexts.correct}`;&#13;
        } else if (element.hasClass(presenter.defaults.css.markings.wrong)) {&#13;
           text += ` ${presenter.speechTexts.incorrect}`;&#13;
        }&#13;
&#13;
        return text;&#13;
    };&#13;
&#13;
    presenter.isColorButtonClicked = function AddonText_Coloring_isColorButtonClicked (element) {&#13;
        return element.hasClass(presenter.defaults.css.activeButton);&#13;
    };&#13;
&#13;
    presenter.getColorObjectOrNoneFromElementClass = function AddonText_Coloring_getColorObjectOrNoneFromElementClass (element) {&#13;
        const classList = Array.from(element[0].classList);&#13;
        const underline = classList.find(c =&gt; c.includes("text-coloring-colored-with") || c.includes("text-coloring-show-answers"));&#13;
        if (!underline) {&#13;
            return;&#13;
        }&#13;
&#13;
        const colorKey = underline.split("-").slice(-1)[0];&#13;
        return presenter.getColorDefinitionById(colorKey);&#13;
    };&#13;
&#13;
    presenter.isAddonInWorkMode = function AddonText_Coloring_isAddonInWorkMode () {&#13;
        return presenter.stateMachine._actualState === StatefullAddonObject._internal.STATE.WORK;&#13;
    };&#13;
&#13;
    presenter.speak = function AddonText_Coloring_speak(data) {&#13;
        var tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function AddonText_Coloring_setWCAGStatus(isWCAGOn) {&#13;
        presenter.isWCAGOn = isWCAGOn;&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function AddonText_Coloring_getTextToSpeechOrNull(playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.isTTS = function AddonText_Coloring_isTTS () {&#13;
        return presenter.getTextToSpeechOrNull(presenter.playerController) &amp;&amp; presenter.isWCAGOn;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
&#13;
function parseToGrayscale(hexColor) {&#13;
    var rgbColor = hexToRGB(hexColor);&#13;
    return rgbToGrayscaleHex(rgbColor);&#13;
}&#13;
&#13;
function hexToRGB(hexColor) {&#13;
    var r = 0, g = 0, b = 0;&#13;
&#13;
    if (hexColor.length === 4) {&#13;
        r = '0x' + hexColor[1] + hexColor[1];&#13;
        g = '0x' + hexColor[2] + hexColor[2];&#13;
        b = '0x' + hexColor[3] + hexColor[3];&#13;
    } else if (hexColor.length === 7) {&#13;
        r = '0x' + hexColor[1] + hexColor[2];&#13;
        g = '0x' + hexColor[3] + hexColor[4];&#13;
        b = '0x' + hexColor[5] + hexColor[6];&#13;
    }&#13;
&#13;
    return [+r, +g, +b];&#13;
}&#13;
&#13;
function rgbToGrayscaleHex(rgbColor) {&#13;
    var grayIntensity = Math.round(0.3 * rgbColor[0] + 0.59 * rgbColor[1] + 0.11 * rgbColor[2]);&#13;
&#13;
    return '#' + decimalToHex(grayIntensity) + decimalToHex(grayIntensity) + decimalToHex(grayIntensity);&#13;
}&#13;
&#13;
function decimalToHex(value) {&#13;
    var hex = value.toString(16);&#13;
    return hex.length === 1 ? `0${hex}` : hex;&#13;
}&#13;
</presenter></addon>