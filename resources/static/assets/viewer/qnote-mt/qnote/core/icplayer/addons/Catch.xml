<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Catch" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="Items" nameLabel="Catch_property_items" type="list">
            <property name="Image" nameLabel="Catch_property_image" type="image"/>
            <property isLocalized="true" name="Description" nameLabel="Catch_property_description" type="string"/>
            <property name="Is Correct" nameLabel="Catch_property_is_correct" type="boolean"/>
            <property isLocalized="true" name="Level" nameLabel="Catch_property_level" type="string"/>
        </property>
        <property isLocalized="true" name="Item_Width" nameLabel="Catch_property_item_width" type="string"/>
        <property isLocalized="true" name="Item_Height" nameLabel="Catch_property_item_height" type="string"/>
        <property isLocalized="true" name="Points to finish" nameLabel="Catch_property_points_to_finish" type="string"/>
        <property name="Count errors" nameLabel="Catch_property_count_errors" type="boolean"/>
        <property name="Plate image" nameLabel="Catch_property_plate_image" type="image"/>
    </model>
<css>.addon_Catch {&#13;
    max-width: 100%;&#13;
    width: 100%;&#13;
    text-align: center;&#13;
    margin: 0 auto;&#13;
    /*border: 1px solid black;*/&#13;
    position: relative;&#13;
    overflow: hidden;&#13;
    box-sizing: border-box;&#13;
}&#13;
&#13;
.addon_Catch .plate,&#13;
.addon_Catch .fallingObject,&#13;
.addon_Catch .description {&#13;
    position: absolute;&#13;
    box-sizing: border-box;&#13;
    -webkit-touch-callout: none; /* iOS Safari */&#13;
    -webkit-user-select: none; /* Safari */&#13;
    -khtml-user-select: none; /* Konqueror HTML */&#13;
    -moz-user-select: none; /* Firefox */&#13;
    -ms-user-select: none; /* Internet Explorer/Edge */&#13;
    user-select: none; /* Non-prefixed version, currently supported by Chrome and Opera */&#13;
}&#13;
&#13;
.addon_Catch .plate {&#13;
    width: 50px;&#13;
    height: 25px;&#13;
    bottom: 0;&#13;
}&#13;
&#13;
.addon_Catch .fallingObject {&#13;
    width: 30px;&#13;
    height: 30px;&#13;
}&#13;
&#13;
.addon_Catch .welcome {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    cursor: pointer;&#13;
    background-size: auto;&#13;
}&#13;
</css><view/><preview/><presenter>function AddonCatch_create() {&#13;
&#13;
    var presenter = function () {};&#13;
    presenter.configuration = {};&#13;
&#13;
    var points = 0;&#13;
    var errors = 0;&#13;
    var $plateElement = null;&#13;
    var isGameOver = false;&#13;
    var isPaused = false;&#13;
    var pausedTimeInMs = 0;&#13;
    var objects = [];&#13;
&#13;
    function getErrorObject (ec) { return { isValid: false, errorCode: ec }; }&#13;
    function getCorrectObject (v) { return { isValid: true, value: v }; }&#13;
&#13;
    function getRandomInt (min, max) {&#13;
        return Math.floor(Math.random() * (max - min + 1)) + min;&#13;
    }&#13;
&#13;
    function getItemObject (index, image, description, isCorrect, level) {&#13;
        return {&#13;
            index: index,             // item index&#13;
            image: image,             // image url&#13;
            description: description, // description (max 20 characters)&#13;
            isCorrect: isCorrect,     // boolean&#13;
            levels: level             // array of levels in range 1 - 3&#13;
        };&#13;
    }&#13;
&#13;
    function getElementPositionLeft(element) {&#13;
        // can't use jquery position or offset, because they return values in virtual coordinate system&#13;
        // on high dpi devices such as smartphones, and we need CSS pixels coords&#13;
        return parseInt(element.css("left"), 10);&#13;
    }&#13;
&#13;
    var levelsParameters = [{&#13;
        speedMin: 10000,&#13;
        speedMax: 15000,&#13;
        density: 4&#13;
    },&#13;
    {&#13;
        speedMin: 7500,&#13;
        speedMax: 12500,&#13;
        density: 8&#13;
    },&#13;
    {&#13;
        speedMin: 5000,&#13;
        speedMax: 10000,&#13;
        density: 12&#13;
    }];&#13;
    var currentLevel = 0;&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        I01: 'Property Image cannot be empty',&#13;
        D01: 'Description too long. Max is 20 characters',&#13;
        L01: 'Property level cannot be empty',&#13;
        L02: 'Property level fill with numbers in range 1 - 3',&#13;
        P01: 'Property Points to Finish expects number',&#13;
        O01: 'Property Items cannot be empty',&#13;
        W01: 'Property Width or Height cannot be empty'&#13;
    };&#13;
&#13;
    function parseItems (rawItems) {&#13;
        var result = [];&#13;
&#13;
        if (ModelValidationUtils.isArrayEmpty(rawItems)) {&#13;
            return getErrorObject('O01');&#13;
        }&#13;
&#13;
        for (var i=0; i&lt;rawItems.length; i++) {&#13;
            var rawItem = rawItems[i];&#13;
&#13;
            var image = rawItem['Image'];&#13;
            var description = rawItem['Description'];&#13;
            var isCorrect = ModelValidationUtils.validateBoolean(rawItem['Is Correct']);&#13;
            var level = rawItem['Level'];&#13;
&#13;
            if (ModelValidationUtils.isStringWithPrefixEmpty(image, "/file/")) {&#13;
                return getErrorObject('I01');&#13;
            }&#13;
&#13;
            if (description.length &gt; 20) {&#13;
                return getErrorObject('D01');&#13;
            }&#13;
&#13;
            if (!level) {&#13;
                return getErrorObject('L01');&#13;
            }&#13;
&#13;
            level = level.split(',').filter(function (l) {&#13;
                return l !== '';&#13;
            }).map(function (l) {&#13;
                return parseInt(l.trim(), 10);&#13;
            });&#13;
&#13;
            // remove duplicates&#13;
            level = level.filter(function(item, pos) {&#13;
                return level.indexOf(item) === pos;&#13;
            });&#13;
&#13;
            var isCorrectNumbersInLevels = level.every(function (l) {&#13;
                return l === 1 || l === 2 || l === 3;&#13;
            });&#13;
            if (!isCorrectNumbersInLevels) {&#13;
                return getErrorObject('L02');&#13;
            }&#13;
&#13;
            result.push(getItemObject(i, image, description, isCorrect, level));&#13;
        }&#13;
&#13;
        return getCorrectObject(result);&#13;
    }&#13;
&#13;
    function parsePointsToFinish (pointsRaw) {&#13;
        var points = parseInt(pointsRaw || 0, 10);&#13;
&#13;
        if (isNaN(points)) {&#13;
            return getErrorObject('P01');&#13;
        }&#13;
&#13;
        return getCorrectObject(points);&#13;
    }&#13;
&#13;
    function parseWidthHeight (propertyValue) {&#13;
        var value = parseInt(propertyValue, 10);&#13;
&#13;
        if (isNaN(value)) {&#13;
            return getErrorObject('W01');&#13;
        }&#13;
&#13;
        return getCorrectObject(value);&#13;
    }&#13;
&#13;
    presenter.calculateLevelsItems = function (items) {&#13;
        var result = [[], [], []];&#13;
&#13;
        for (var i=0; i&lt;items.length; i++) {&#13;
            var item = items[i];&#13;
&#13;
            for (var j=0; j&lt;item.levels.length; j++) {&#13;
                result[item.levels[j]-1].push(item);&#13;
            }&#13;
        }&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var validatedItems = parseItems(model['Items']);&#13;
        if (!validatedItems.isValid) {&#13;
            return getErrorObject(validatedItems.errorCode);&#13;
        }&#13;
&#13;
        var validatedPointsToFinish = parsePointsToFinish(model['Points to finish']);&#13;
        if (!validatedPointsToFinish.isValid) {&#13;
            return getErrorObject(validatedPointsToFinish.errorCode);&#13;
        }&#13;
&#13;
        var validatedItemWidth = parseWidthHeight(model['Item_Width']);&#13;
        if (!validatedItemWidth.isValid) {&#13;
            return getErrorObject(validatedItemWidth.errorCode);&#13;
        }&#13;
&#13;
        var validatedItemHeight = parseWidthHeight(model['Item_Height']);&#13;
        if (!validatedItemHeight.isValid) {&#13;
            return getErrorObject(validatedItemHeight.errorCode);&#13;
        }&#13;
&#13;
        return {&#13;
            items: validatedItems.value,&#13;
            plateImage: model['Plate image'],&#13;
            levelsItems: presenter.calculateLevelsItems(validatedItems.value),&#13;
            pointsToFinish: validatedPointsToFinish.value,&#13;
            countErrors: ModelValidationUtils.validateBoolean(model["Count errors"]),&#13;
            itemWidth: validatedItemWidth.value,&#13;
            itemHeight: validatedItemHeight.value,&#13;
            ID: model.ID,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            isValid: true&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onDestroy = function () {&#13;
        presenter.clearCatchObjects(objects);&#13;
&#13;
        objects = null;&#13;
    };&#13;
&#13;
    presenter.clearCatchObjects = function (objects) {&#13;
        objects.forEach( function(value) {&#13;
            value.obj.stop();&#13;
            value.obj.remove();&#13;
            value.obj = null;&#13;
        });&#13;
    };&#13;
&#13;
    function makePlate () {&#13;
        var plateImage = presenter.configuration.plateImage !== "" &amp;&amp; presenter.configuration.plateImage !== undefined ? presenter.configuration.plateImage : getImageUrlFromResources('plate.png');&#13;
&#13;
        $plateElement = $('&lt;img class="plate" /&gt;');&#13;
        $plateElement.attr('src', plateImage);&#13;
&#13;
        presenter.$view.append($plateElement);&#13;
&#13;
        // put the plate in the center of screen&#13;
        var addOnWidth = presenter.$view.width();&#13;
        var centerPos = addOnWidth/2 - $plateElement.width()/2;&#13;
        $plateElement.css('left', centerPos + 'px' );&#13;
    }&#13;
&#13;
    function makeDescription (description) {&#13;
        var $description = $('&lt;span class="description"&gt;' + description + '&lt;/span&gt;');&#13;
        $description.css('top', '-15px');&#13;
        return $description;&#13;
    }&#13;
&#13;
    function setDescriptionPosition (description, itemWidth) {&#13;
        var descWidth = description.outerWidth(); // get full width, including padding&#13;
        var leftPos= (-descWidth/2 + itemWidth/2) + 'px';&#13;
        description.css('left', leftPos );&#13;
    }&#13;
&#13;
    function getRandomItemFromLevel (level) {&#13;
        var itemsForLevel = presenter.configuration.levelsItems[level];&#13;
        return itemsForLevel[Math.floor(Math.random() * itemsForLevel.length)];&#13;
    }&#13;
&#13;
    function onNewPoint (itemNumber) {&#13;
        points++;&#13;
        sendEvent(itemNumber, 1, true);&#13;
&#13;
        var isInfiniteGame = presenter.configuration.pointsToFinish === 0;&#13;
        var score = presenter.configuration.countErrors ? (points - errors) : points;&#13;
&#13;
        if (!isInfiniteGame &amp;&amp; score &gt;= presenter.configuration.pointsToFinish) {&#13;
            sendEvent('all', 'EOG', true);&#13;
            presenter.reset(true);&#13;
        }&#13;
    }&#13;
&#13;
    function onNewError (itemNumber) {&#13;
        errors++;&#13;
        sendEvent(itemNumber, 1, false);&#13;
    }&#13;
&#13;
    function reCreateFallingObject (itemNumber) {&#13;
        sendEvent(itemNumber, 0, false);&#13;
&#13;
        makeFallingObject(0);&#13;
    }&#13;
&#13;
    function makeFallingObject (yOffset) {&#13;
        if (isGameOver) {&#13;
            return;&#13;
        }&#13;
&#13;
        var addOnHeight = presenter.$view.height();&#13;
        var itemObject = getRandomItemFromLevel(currentLevel);&#13;
&#13;
        var $objectElement = $('&lt;div class="fallingObject"&gt;&lt;/div&gt;');&#13;
        $objectElement.css('background', 'url(' + itemObject.image + ')');&#13;
        var description = makeDescription(itemObject.description);&#13;
        $objectElement.append(description);&#13;
&#13;
        $objectElement.css('background-size', 'cover');&#13;
        presenter.$view.append($objectElement);&#13;
&#13;
        setDescriptionPosition(description, presenter.configuration.itemWidth); // we have to do this after appending object to DOM&#13;
&#13;
        var longestWidth = Math.max(description.outerWidth(), presenter.configuration.itemWidth);&#13;
        var xPosition = getRandomInt(longestWidth/2, presenter.$view.width() - longestWidth);&#13;
&#13;
        $objectElement.css('left', xPosition + 'px');&#13;
        $objectElement.css('top', '-' + (100 + yOffset) + 'px');&#13;
        $objectElement.css('width', presenter.configuration.itemWidth);&#13;
        $objectElement.css('height', presenter.configuration.itemHeight);&#13;
&#13;
        var duration = getRandomInt(levelsParameters[currentLevel].speedMin, levelsParameters[currentLevel].speedMax);&#13;
        var landingPosition = (addOnHeight + 10) + 'px';&#13;
        var initialTimeInMs = new Date().getTime();&#13;
&#13;
        startMoving($objectElement, landingPosition, duration, itemObject, xPosition, initialTimeInMs);&#13;
    }&#13;
&#13;
    function removeObject(object) {&#13;
        object.stop();&#13;
        object.remove();&#13;
        objects = objects.filter( function (objectIter) {&#13;
                return objectIter.obj !== object;&#13;
            }&#13;
        );&#13;
    }&#13;
&#13;
    function startMoving($objectElement, landingPosition, duration, itemObject, xPosition, initialTime) {&#13;
        var isRemoved = false;&#13;
&#13;
        objects.push( { obj: $objectElement, duration: duration, landing: landingPosition, item: itemObject, xPos: xPosition, initialTime: initialTime } );&#13;
&#13;
        $objectElement.animate({'top': landingPosition}, {&#13;
            duration: duration,&#13;
            easing: 'linear',&#13;
            complete: function () {&#13;
                removeObject($objectElement);&#13;
                reCreateFallingObject(itemObject.index + 1);&#13;
            },&#13;
            step: function (now, tween) {&#13;
                if (isRemoved) return;&#13;
&#13;
                var addOnHeight = presenter.$view.height();&#13;
                now = Math.round(now);&#13;
                var elementBotYPosition = now + $objectElement.height();&#13;
                var isInCatchLevel = elementBotYPosition &lt; addOnHeight &amp;&amp; elementBotYPosition &gt; addOnHeight - $plateElement.height();&#13;
&#13;
                if (isInCatchLevel) {&#13;
                    var elementLeftEdge = xPosition;&#13;
                    var elementRightEdge = elementLeftEdge + $objectElement.width();&#13;
&#13;
                    var plateLeftEdge = getElementPositionLeft($plateElement);&#13;
                    var plateRightEdge = plateLeftEdge + $plateElement.width();&#13;
&#13;
                    if (!(plateLeftEdge &gt; elementRightEdge || plateRightEdge &lt; elementLeftEdge)) {&#13;
                        if (itemObject.isCorrect) {&#13;
                            onNewPoint(itemObject.index + 1);&#13;
                        } else {&#13;
                            onNewError(itemObject.index + 1);&#13;
                        }&#13;
&#13;
                        removeObject($objectElement);&#13;
                        makeFallingObject(0);&#13;
                        isRemoved = true;&#13;
                    }&#13;
                }&#13;
            }&#13;
        });&#13;
&#13;
    }&#13;
&#13;
    function startGame (level) {&#13;
        makePlate();&#13;
&#13;
        var numberOfElements = levelsParameters[level].density;&#13;
        for (var i=0; i&lt;numberOfElements; i++) {&#13;
            makeFallingObject(150 * i);&#13;
        }&#13;
    }&#13;
&#13;
    function movePlate (isDirectionToRight) {&#13;
&#13;
        if (isPaused) {&#13;
            return;&#13;
        }&#13;
&#13;
        var addOnPositionLeft = getElementPositionLeft(presenter.$view);&#13;
        var addOnWidth = presenter.$view.width();&#13;
&#13;
        var platePositionLeft = addOnPositionLeft + getElementPositionLeft($plateElement);&#13;
        var plateWidth = $plateElement.width();&#13;
&#13;
        var isPositionZeroLeft = platePositionLeft &lt;= addOnPositionLeft;&#13;
        var isPositionZeroRight = platePositionLeft + plateWidth &gt;= addOnPositionLeft + addOnWidth;&#13;
&#13;
        if (!isDirectionToRight &amp;&amp; isPositionZeroLeft || isDirectionToRight &amp;&amp; isPositionZeroRight) {&#13;
            return;&#13;
        }&#13;
&#13;
        var hasSpaceLeft = !isDirectionToRight &amp;&amp; (platePositionLeft - addOnPositionLeft &lt; plateWidth);&#13;
        var hasSpaceRight = isDirectionToRight &amp;&amp; (platePositionLeft + plateWidth + plateWidth &gt;= addOnPositionLeft + addOnWidth);&#13;
&#13;
        var options = {&#13;
            duration: 'fast',&#13;
            easing: 'swing',&#13;
            queue: false&#13;
        };&#13;
&#13;
        if (hasSpaceLeft) {&#13;
            $plateElement.animate({&#13;
                left: '0px'&#13;
            }, options);&#13;
        } else if (hasSpaceRight) {&#13;
            $plateElement.animate({&#13;
                left: (addOnWidth - plateWidth) + 'px'&#13;
            }, options);&#13;
        } else {&#13;
            var directionSign = isDirectionToRight ? '+' : '-';&#13;
            $plateElement.animate({&#13;
                left: directionSign + '=[plateWidth]px'.replace('[plateWidth]', plateWidth)&#13;
            }, options);&#13;
        }&#13;
    }&#13;
&#13;
    function turnOnEventListeners () {&#13;
        presenter.$view.keydown(function (e) {&#13;
            if (e.key.localeCompare('ArrowLeft') === 0 || e.key.localeCompare('Left') === 0) {&#13;
                movePlate(false);&#13;
            }&#13;
            if (e.key.localeCompare('ArrowRight') === 0 || e.key.localeCompare('Right') === 0) {&#13;
                movePlate(true);&#13;
            }&#13;
        });&#13;
&#13;
        if (MobileUtils.isMobileUserAgent(navigator.userAgent)) {&#13;
            presenter.$view.on('touchstart', function (e) {&#13;
                e.preventDefault();&#13;
&#13;
                const posX = e.originalEvent.touches[0].pageX;&#13;
                const scaledX = posX / getScale().X;&#13;
&#13;
                if (!isAbovePlateCenter(scaledX)) {&#13;
                    var isLeftSide = isPointOnLeftSide(scaledX);&#13;
                    movePlate(isLeftSide);&#13;
                }&#13;
            });&#13;
        }&#13;
        else {&#13;
            presenter.$view.on('click', function (e) {&#13;
                if (!isAbovePlateCenter(e.clientX)) {&#13;
                    var isLeftSide = isPointOnLeftSide(e.clientX);&#13;
                    movePlate(isLeftSide);&#13;
                }&#13;
            });&#13;
        }&#13;
&#13;
        presenter.$view.focus();&#13;
    }&#13;
&#13;
    function getScale() {&#13;
        let $content = $("#content");&#13;
        if ($content.size() &gt; 0) {&#13;
            const contentElem = $content[0];&#13;
            const scaleX = contentElem.getBoundingClientRect().width / contentElem.offsetWidth;&#13;
            const scaleY = contentElem.getBoundingClientRect().height / contentElem.offsetHeight;&#13;
            return {X: scaleX, Y: scaleY};&#13;
        } else if (presenter.playerController) {&#13;
            const scale = presenter.playerController.getScaleInformation();&#13;
            return {X: scale.scaleX, Y: scale.scaleY};&#13;
        } else {&#13;
            return {X: 1.0, Y: 1.0};&#13;
        }&#13;
    }&#13;
&#13;
    function turnOffEventListeners () {&#13;
        presenter.$view.off();&#13;
    }&#13;
&#13;
    function isAbovePlateCenter(point) {&#13;
        var addonBounds = presenter.$view[0].getBoundingClientRect();&#13;
        var addonLeftPos = addonBounds.left;&#13;
        var relativePoint = point - addonLeftPos;&#13;
        var quarterWidth =  Math.round($plateElement.width() / 4);&#13;
        var plateLeft = getElementPositionLeft($plateElement) + quarterWidth;&#13;
        var plateRight = plateLeft + quarterWidth*2;&#13;
        return relativePoint &gt; plateLeft &amp;&amp; relativePoint &lt; plateRight;&#13;
    }&#13;
&#13;
    function isPointOnLeftSide(point) {&#13;
        // we have to obtain the virtual coordinates of addon, because point from touchstart&#13;
        // will come in virtual coords, in case of high dpi devices such as smartphones&#13;
        // getBoundingClientRect will work correctly in css pixels in case of low dpi devices&#13;
        var addonBounds = presenter.$view[0].getBoundingClientRect();&#13;
        var addonLeftPos = addonBounds.left;&#13;
        var plateCenterPos = getElementPositionLeft($plateElement) + Math.round($plateElement.width() / 2);&#13;
        return (point - addonLeftPos) &gt; plateCenterPos;&#13;
    }&#13;
&#13;
    function makeWelcomePage () {&#13;
        var $welcomePage = $('&lt;div class="welcome"&gt;&lt;/div&gt;');&#13;
        $welcomePage.css('background', 'url(' + getImageUrlFromResources('startGame.png') + ') no-repeat');&#13;
        $welcomePage.css('background-size', 'auto');&#13;
        $welcomePage.css('background-position-x', 'center');&#13;
        $welcomePage.css('background-position-y', 'center');&#13;
&#13;
        return $welcomePage;&#13;
    }&#13;
&#13;
    presenter.presenterLogic = function (view, model, isPreview) {&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return false;&#13;
        }&#13;
&#13;
        presenter.$view = $(view);&#13;
        presenter.$view.attr('tabindex', 1);&#13;
&#13;
        if (!isPreview) {&#13;
            var $welcomePage = makeWelcomePage();&#13;
            presenter.$view.append($welcomePage);&#13;
&#13;
            $welcomePage.on('click', function () {&#13;
                if (isPaused) {&#13;
                    return;&#13;
                }&#13;
                startGame(currentLevel);&#13;
                turnOnEventListeners();&#13;
                $welcomePage.remove();&#13;
            });&#13;
&#13;
        }&#13;
    };&#13;
&#13;
    function stopAndRemoveFallingObjects () {&#13;
        presenter.$view.find('.fallingObject').each(function () {&#13;
            $(this).stop();&#13;
            $(this).remove();&#13;
        });&#13;
        presenter.$view.empty();&#13;
    }&#13;
&#13;
    presenter.setLevel = function (level) {&#13;
        level = parseInt(level, 10);&#13;
        if (level === 1 || level === 2 || level === 3) {&#13;
            currentLevel = level-1;&#13;
            turnOffEventListeners();&#13;
            stopAndRemoveFallingObjects();&#13;
            startGame(currentLevel);&#13;
            turnOnEventListeners();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getPoints = function () {&#13;
        return points;&#13;
    };&#13;
&#13;
    presenter.getErrors = function () {&#13;
        return errors;&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.reset = function (isEndGame) {&#13;
        isEndGame = isEndGame || false;&#13;
        isGameOver = isEndGame;&#13;
&#13;
        if (!isEndGame) {&#13;
            points = 0;&#13;
            errors = 0;&#13;
            currentLevel = 0;&#13;
        }&#13;
        isPaused = false;&#13;
        objects = [];&#13;
&#13;
        turnOffEventListeners();&#13;
        stopAndRemoveFallingObjects();&#13;
&#13;
        if (!isEndGame) {&#13;
            var $welcomePage = makeWelcomePage();&#13;
            presenter.$view.append($welcomePage);&#13;
&#13;
            $welcomePage.on('click', function () {&#13;
                if (isPaused) {&#13;
                    return;&#13;
                }&#13;
                startGame(currentLevel);&#13;
                turnOnEventListeners();&#13;
                $welcomePage.remove();&#13;
            });&#13;
        }&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'reset': presenter.reset,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
&#13;
            'setLevel': presenter.setLevel,&#13;
            'getPoints': presenter.getPoints,&#13;
            'getErrors': presenter.getErrors&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        return errors;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.configuration.pointsToFinish === 0)&#13;
            return 0;&#13;
        else&#13;
            return presenter.configuration.pointsToFinish;&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        return presenter.configuration.countErrors ? Math.max((points - errors), 0) : points;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.$view.css('visibility') === 'visible',&#13;
            points: points,&#13;
            errors: errors&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        const parsedState = JSON.parse(state);&#13;
        points = parsedState.points;&#13;
        errors = parsedState.errors;&#13;
&#13;
        presenter.setVisibility(parsedState.isVisible);&#13;
    };&#13;
&#13;
    presenter.isAllOk = function () {&#13;
        return errors === 0;&#13;
    };&#13;
&#13;
    function sendEvent (item, value, isCorrect) {&#13;
        function createEventObject(_item, _value, _isCorrect) {&#13;
            return {&#13;
                'source': presenter.configuration.ID,&#13;
                'item': '' + _item,&#13;
                'value': '' + _value,&#13;
                'score': _isCorrect ? '1' : '0'&#13;
            };&#13;
        }&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', createEventObject(item, value, isCorrect));&#13;
    }&#13;
&#13;
    presenter.setEventBus = function(eventBus) {&#13;
        presenter.eventBus = eventBus;&#13;
&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
    };&#13;
&#13;
    function getImageUrlFromResources (fileName) {&#13;
        return presenter.playerController.getStaticFilesPath() + 'addons/resources/' + fileName;&#13;
    }&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        resumeSimulation();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        pauseSimulation();&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        pauseSimulation();&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        resumeSimulation();&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    function pauseSimulation() {&#13;
        if (isPaused)&#13;
            return;&#13;
        isPaused = true;&#13;
        pausedTimeInMs = new Date().getTime();&#13;
&#13;
        for (var i = 0; i &lt; objects.length; i++) {&#13;
            var object = objects[i];&#13;
            object.obj.clearQueue();&#13;
            object.obj.stop();&#13;
        }&#13;
    }&#13;
&#13;
    function resumeSimulation() {&#13;
        if (!isPaused)&#13;
            return;&#13;
        isPaused = false;&#13;
        // copy objects to new array, because it will be edited in startMoving&#13;
        var newObjects = objects.slice();&#13;
        objects = [];&#13;
        var currentTimeInMs = new Date().getTime();&#13;
&#13;
        for (var j = 0; j &lt; newObjects.length; j++) {&#13;
            var obj = newObjects[j];&#13;
&#13;
            // rescale animations&#13;
            var dt = obj.duration - (pausedTimeInMs - obj.initialTime);&#13;
            startMoving(obj.obj, obj.landing, dt, obj.item, obj.xPos, currentTimeInMs);&#13;
        }&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
&#13;
AddonCatch_create.__supported_player_options__ = {&#13;
    interfaceVersion: 2&#13;
};&#13;
</presenter></addon>