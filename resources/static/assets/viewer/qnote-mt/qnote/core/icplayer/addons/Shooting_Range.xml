<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Shooting_Range" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property displayName="Definitions" name="definitions" nameLabel="Shooting_Range_property_definitions" type="list">
            <property displayName="Definition" name="definition" nameLabel="Shooting_Range_property_definition" type="html"/>
            <property displayName="Answer" name="answer1" nameLabel="Shooting_Range_property_answer" type="string"/>
            <property displayName="Answer" name="answer2" nameLabel="Shooting_Range_property_answer" type="string"/>
            <property displayName="Answer" name="answer3" nameLabel="Shooting_Range_property_answer" type="string"/>
            <property displayName="Correct Answer(s)" name="correct_answers" nameLabel="Shooting_Range_property_correct_answer" type="string"/>
        </property>
            <property displayName="Initial Time For Answer" name="initial_time_for_answer" nameLabel="Shooting_Range_property_initial_time_for_answer" type="string"/>
            <property displayName="Time For Last Answer" name="time_for_last_answer" nameLabel="Shooting_Range_property_time_for_last_answer" type="string"/>
    </model>
<css>.addon-Shooting_Range-wrapper{&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    border: none;&#13;
    position: absolute;&#13;
}&#13;
&#13;
.addon-Shooting_Range-wrapper-question {&#13;
    background-color: lightgray;&#13;
    width: 100%;&#13;
}&#13;
&#13;
.addon-Shooting_Range-wrapper-level {&#13;
    background-color: lightgray;&#13;
    width: 100%;&#13;
}&#13;
&#13;
.addon-Shooting_Range-wrapper-answers-wrapper {&#13;
    top: 0px;&#13;
    bottom: 0px;&#13;
    background-color: darkgray;&#13;
    width: 100%;&#13;
    position:absolute;&#13;
    height: 100%;&#13;
    overflow: hidden;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-wrapper.clicked {&#13;
    background-color: darkslategray;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-wrapper.isHidden {&#13;
    display: none!important;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-wrapper.correct {&#13;
    background-color: green;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-wrapper.wrong {&#13;
    background-color: red;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-0 {&#13;
    position: relative;&#13;
    float: left;&#13;
    left: 20px;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-1 {&#13;
    position: relative;&#13;
    float: left;&#13;
    left: 50%;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-2 {&#13;
    position: relative;&#13;
    float: right;&#13;
    right: 20px;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-layer {&#13;
    top: 0px;&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.addon-Shooting_Range-answer-wrapper {&#13;
    border: 1px solid black;&#13;
    background-color: lightslategray;&#13;
}&#13;
&#13;
.addon-Shooting_Range-play-button-wrapper {&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    left: 50%;&#13;
    width: 99%;&#13;
    height: 40px;&#13;
    background-color: whitesmoke;&#13;
    border-radius: 2px;&#13;
    -moz-transform: translateX(-50%) translateY(-50%);&#13;
    -webkit-transform: translateX(-50%) translateY(-50%);&#13;
    transform: translateX(-50%) translateY(-50%);&#13;
}&#13;
&#13;
.addon-Shooting_Range-button-play {&#13;
    -moz-transform: translateX(50%) translateY(50%);&#13;
    -webkit-transform: translateX(50%) translateY(50%);&#13;
    transform: translateX(50%) translateY(50%);&#13;
}&#13;
</css><view>&lt;div class="addon-Shooting_Range-wrapper"&gt;&#13;
    &lt;div class="addon-Shooting_Range-wrapper-question"&gt;&lt;/div&gt;&#13;
    &lt;div class="addon-Shooting_Range-wrapper-level"&gt;&lt;/div&gt;&#13;
    &lt;div class="addon-Shooting_Range-wrapper-answers-wrapper"&gt;&lt;/div&gt;&#13;
    &lt;div class="addon-Shooting_Range-play-button-wrapper"&gt;&#13;
        &lt;div class="addon-Shooting_Range-button-play"&gt;&#13;
            Play&#13;
        &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="addon-Shooting_Range-wrapper"&gt;&#13;
    &lt;div class="addon-Shooting_Range-wrapper-question"&gt;&lt;/div&gt;&#13;
    &lt;div class="addon-Shooting_Range-wrapper-level"&gt;&lt;/div&gt;&#13;
    &lt;div class="addon-Shooting_Range-wrapper-answers-wrapper"&gt;&lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonShooting_Range_create() {&#13;
    var presenter = function (){};&#13;
&#13;
    presenter.state = {&#13;
        eventBus: null,&#13;
        playerController: null,&#13;
        view: null,&#13;
        $view: null,&#13;
        $questionDiv: null,&#13;
        $levelDiv: null,&#13;
        $answersWrapper: null,&#13;
        $playButton: null,&#13;
        levels: [],&#13;
        actualLevel: 0,&#13;
        destoyed: false,&#13;
        errorCount: 0,&#13;
        wholeErrorCount: 0,&#13;
        score: 0,&#13;
        isVisible: false,&#13;
        isShowingAnswers: false,&#13;
        showingErrors: false,&#13;
        isStarted: false,&#13;
        resultsList: []&#13;
    };&#13;
&#13;
    presenter.configuration = {&#13;
        isValid: false,&#13;
        addonID: null,&#13;
        definitions: [{&#13;
            isValid: true,&#13;
            gameMode: 0,&#13;
            definition: "",&#13;
            answers: [""],&#13;
            correctAnswers: [0]&#13;
        }],&#13;
        gameMode: 0,&#13;
        initialTimeForAnswer: 0,&#13;
        timeForLastAnswer: 0&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        "IT01": "Initial timer for answer must be positive float",&#13;
        "LT01": "Time for last answer must be positive float",&#13;
        "WM01": "All or non definition in definition list must be provided",&#13;
        "EA01": "Answer can't be empty",&#13;
        "WA01": "Answer range must be in number-number format",&#13;
        "WA02": "First value in answer range must be integer in range &lt;1;3&gt;",&#13;
        "WA03": "Second value in answer range must be integer in range &lt;1;3&gt;",&#13;
        "WA04": "Correct answer must be integer in range &lt;1;3&gt;"&#13;
    };&#13;
&#13;
    presenter.GAME_MODE = {&#13;
        UNDEFINED: -1,&#13;
        QUESTIONS: 0,&#13;
        SPEED_ATTACK: 1&#13;
    };&#13;
&#13;
    presenter.originalDisplay = "block";&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.state.playerController = controller;&#13;
        presenter.state.eventBus = presenter.state.playerController.getEventBus();&#13;
        presenter.state.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.state.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.initialize(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.initialize(view, model, true);&#13;
    };&#13;
&#13;
    presenter.initialize = function  (view, model, isPreview)  {&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.state.$view = $(view);&#13;
        presenter.state.view = view;&#13;
        presenter.state.$questionDiv = $(view).find(".addon-Shooting_Range-wrapper-question");&#13;
        presenter.state.$levelDiv = $(view).find(".addon-Shooting_Range-wrapper-level");&#13;
        presenter.state.$answersWrapper = $(view).find(".addon-Shooting_Range-wrapper-answers-wrapper");&#13;
        presenter.state.$playButton = $(view).find(".addon-Shooting_Range-play-button-wrapper");&#13;
&#13;
        if (!isPreview) {&#13;
           presenter.initializeGame();&#13;
           presenter.actualizeAnswersWrapperHeight();&#13;
           presenter.connectHandlers();&#13;
        }&#13;
&#13;
        var display = presenter.state.$view.css('display');&#13;
        if (display != null &amp;&amp; display.length &gt; 0) {&#13;
            presenter.originalDisplay = display;&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault || isPreview);&#13;
&#13;
        view.addEventListener('DOMNodeRemoved', presenter.destroy);&#13;
    };&#13;
&#13;
    presenter.connectHandlers = function () {&#13;
        presenter.state.$playButton.click(function (event) {&#13;
            event.preventDefault();&#13;
            event.stopPropagation();&#13;
&#13;
            if (presenter.state.isShowingAnswers || presenter.state.showingErrors) {&#13;
                return;&#13;
            }&#13;
&#13;
            presenter.startGame();&#13;
            presenter.state.$playButton.hide();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (presenter.isErrorCheckingMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'showAnswers' : presenter.showAnswers,&#13;
            'hideAnswers' : presenter.hideAnswers,&#13;
            'getResultsList': presenter.getResultsList,&#13;
            'restartGame': presenter.restartGame&#13;
        };&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.getResultsList = function () {&#13;
        return presenter.state.resultsList;&#13;
    };&#13;
&#13;
    presenter.restartGame = function () {&#13;
        var levelsLength = presenter.state.levels.length;&#13;
&#13;
        for (var i = 0; i &lt; levelsLength; i++) {&#13;
            presenter.state.levels[i].destroy();&#13;
        }&#13;
&#13;
        presenter.state.score = 0;&#13;
        presenter.state.errorCount = 0;&#13;
        presenter.state.wholeErrorCount = 0;&#13;
        presenter.state.$playButton.show();&#13;
        presenter.state.actualLevel = 0;&#13;
        presenter.actualizeAnswersWrapperHeight();&#13;
        presenter.state.isStarted = false;&#13;
        presenter.state.$questionDiv.html("&amp;nbsp;");&#13;
        presenter.state.$levelDiv.html("&amp;nbsp;");&#13;
&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        presenter.state.isShowingAnswers = true;&#13;
&#13;
        if (!presenter.state.isStarted || presenter.state.$playButton.is(":visible")) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.state.showingErrors) {&#13;
            presenter.setWorkMode();&#13;
        }&#13;
&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            presenter.getActualLevel().showAnswers();&#13;
            presenter.getActualLevel().pause();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        presenter.state.isShowingAnswers = false;&#13;
&#13;
        if (!presenter.state.isStarted || presenter.state.$playButton.is(":visible")) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            presenter.getActualLevel().hideAnswers();&#13;
            presenter.getActualLevel().resume();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore();&#13;
    };&#13;
&#13;
    presenter.actualizeAnswersWrapperHeight = function () {&#13;
        presenter.state.$answersWrapper.css({&#13;
            'top': presenter.state.$questionDiv.height() + presenter.state.$levelDiv.height(),&#13;
            'height': presenter.state.$view.height() - presenter.state.$questionDiv.height()&#13;
        });&#13;
    };&#13;
&#13;
    presenter.initializeGame = function () {&#13;
        var initialTimerForAnswer = presenter.configuration.initialTimeForAnswer;&#13;
        var timeForLastAnswer = presenter.configuration.timeForLastAnswer;&#13;
        if (timeForLastAnswer == -1) {&#13;
            timeForLastAnswer = initialTimerForAnswer;&#13;
        }&#13;
&#13;
        var diffOnLevel = initialTimerForAnswer;&#13;
        if (presenter.configuration.definitions.length &gt; 1) {&#13;
            diffOnLevel = (timeForLastAnswer - initialTimerForAnswer) / (presenter.configuration.definitions.length - 1);&#13;
        }&#13;
&#13;
&#13;
        for (var i = 0; i &lt; presenter.configuration.definitions.length; i++) {&#13;
            var configuration = {&#13;
                definition: presenter.configuration.definitions[i],&#13;
                timeForAnswer: initialTimerForAnswer + (diffOnLevel * i),&#13;
                questionNumber: i,&#13;
                numberOfLevel: (i + 1) + "/" + presenter.configuration.definitions.length,&#13;
                $levelDiv: presenter.state.$levelDiv,&#13;
                $questionDiv: presenter.state.$questionDiv,&#13;
                $answersWrapper: presenter.state.$answersWrapper,&#13;
                onCorrectAnswerCallback: presenter.onCorrectAnswerCallback.bind(this),&#13;
                onWrongAnswerCallback: presenter.onWrongAnswerCallback.bind(this),&#13;
                onDroppedCorrectAnswerCallback: presenter.onDroppedCorrectAnswerCallback.bind(this),&#13;
                onEndLevelCallback: presenter.onEndLevelCallback.bind(this)&#13;
            };&#13;
            var level = new Level(configuration);&#13;
            presenter.state.levels.push(level);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.startGame = function () {&#13;
        if (presenter.state.isStarted) {&#13;
            if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
                presenter.getActualLevel().resume(true);&#13;
            }&#13;
        } else {&#13;
            presenter.getActualLevel().start();&#13;
            presenter.state.isStarted = true;&#13;
        }&#13;
        presenter.actualizeAnswersWrapperHeight();&#13;
        presenter.mainLoop();&#13;
    };&#13;
&#13;
    presenter.mainLoop = function () {&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            presenter.getActualLevel().actualize();&#13;
        }&#13;
&#13;
        if (!presenter.state.destoyed) {&#13;
            requestAnimationFrame()(presenter.mainLoop);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.generateEventData = function (questionNumber, answerNumber, isCorrect, clicked) {&#13;
        var value = "0";&#13;
        if (clicked) {&#13;
            value = "1";&#13;
        }&#13;
&#13;
        var score = "0";&#13;
        if (isCorrect) {&#13;
            score = "1";&#13;
        }&#13;
&#13;
        return {&#13;
            source : presenter.configuration.addonID,&#13;
            item : questionNumber + "-" + answerNumber,&#13;
            value : value,&#13;
            score : score&#13;
        };&#13;
    };&#13;
&#13;
    presenter.onCorrectAnswerCallback = function (questionNumber, answerNumber) {&#13;
        presenter.state.score += 1;&#13;
        presenter.sendValueChangedEvent(presenter.generateEventData(questionNumber, answerNumber, true, true));&#13;
    };&#13;
&#13;
    presenter.onWrongAnswerCallback = function (questionNumber, answerNumber) {&#13;
        presenter.state.errorCount += 1;&#13;
        presenter.state.wholeErrorCount += 1;&#13;
        presenter.sendValueChangedEvent(presenter.generateEventData(questionNumber, answerNumber, false, true));&#13;
    };&#13;
&#13;
    presenter.onDroppedCorrectAnswerCallback = function (questionNumber, answerNumber) {&#13;
        presenter.state.errorCount += 1;&#13;
        presenter.state.wholeErrorCount += 1;&#13;
        presenter.sendValueChangedEvent(presenter.generateEventData(questionNumber, answerNumber, false, false));&#13;
    };&#13;
&#13;
    presenter.sendEndOfGameEvent = function () {&#13;
        presenter.sendValueChangedEvent({&#13;
            source : presenter.configuration.addonID,&#13;
            item : 'all',&#13;
            value : 'EOG',&#13;
            score : '1'&#13;
        });&#13;
    };&#13;
&#13;
    presenter.sendValueChangedEvent = function (eventData) {&#13;
        presenter.state.eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    /**&#13;
     * If all elements dropped then call this function&#13;
     * @param {boolean} dontPushResults Don't push results to the resultsList. It is used while loading state&#13;
     */&#13;
    presenter.onEndLevelCallback = function (dontPushResults) {&#13;
        presenter.state.actualLevel++;&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            presenter.getActualLevel().start();&#13;
            if (presenter.state.isShowingAnswers) {&#13;
                presenter.getActualLevel().showAnswers();&#13;
            }&#13;
            presenter.actualizeAnswersWrapperHeight();&#13;
        } else {&#13;
            if (!dontPushResults) {&#13;
                presenter.state.resultsList.push({&#13;
                    score: presenter.state.score,&#13;
                    errors: presenter.state.wholeErrorCount&#13;
                });&#13;
                presenter.sendEndOfGameEvent();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.changeLevel = function (levelIndex) {&#13;
        presenter.getActualLevel().destroy();&#13;
&#13;
        presenter.state.actualLevel = levelIndex;&#13;
        if (presenter.state.isShowingAnswers) {&#13;
            presenter.state.levels[levelIndex].showAnswers();&#13;
        }&#13;
        presenter.actualizeAnswersWrapperHeight();&#13;
    };&#13;
&#13;
    presenter.destroy = function () {&#13;
        if (event.target !== this) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.state.destoyed = true;&#13;
&#13;
        for (var i = 0; i &lt; presenter.state.levels.length; i++) {&#13;
            presenter.state.levels[i].destroy();&#13;
        }&#13;
&#13;
        presenter.state.$playButton.off();&#13;
        presenter.state.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var validatedInitialTime = presenter.validateInitialTimeForAnswer(model);&#13;
&#13;
        if (!validatedInitialTime.isValid) {&#13;
            return validatedInitialTime;&#13;
        }&#13;
&#13;
        var validatedTimeForLastAnswer = presenter.validateTimeForLastAnswer(model);&#13;
        if (!validatedInitialTime.isValid) {&#13;
            return validatedTimeForLastAnswer;&#13;
        }&#13;
&#13;
        var validatedDefinitions = presenter.validateDefinitions(model);&#13;
        if (!validatedDefinitions.isValid) {&#13;
            return validatedDefinitions;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            initialTimeForAnswer: validatedInitialTime.initialTimeForAnswer,&#13;
            timeForLastAnswer: validatedTimeForLastAnswer.timeForLastAnswer,&#13;
            definitions: validatedDefinitions.definitions,&#13;
            gameMode: validatedDefinitions.gameMode,&#13;
            addonID: model['ID'],&#13;
            isVisibleByDefault: ModelValidationUtils.validateBoolean(model['Is Visible'])&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateDefinitions = function (model) {&#13;
        var definitionsUnvalidated = model['definitions'];&#13;
        var definitionsValidated = [];&#13;
        var gameMode = presenter.GAME_MODE.UNDEFINED;&#13;
&#13;
&#13;
        for (var i = 0; i &lt; definitionsUnvalidated.length; i++) {&#13;
            var validatedDefinition = presenter.validateDefinition(definitionsUnvalidated[i]);&#13;
            if (!validatedDefinition.isValid) {&#13;
                return validatedDefinition;&#13;
            }&#13;
&#13;
            var validatedGameMode = presenter.validateGameMode(gameMode, validatedDefinition.gameMode);&#13;
            if (!validatedGameMode.isValid) {&#13;
                return validatedGameMode;&#13;
            }&#13;
            gameMode = validatedGameMode.gameMode;&#13;
&#13;
            definitionsValidated.push(validatedDefinition);&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            definitions: definitionsValidated,&#13;
            gameMode: gameMode&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateDefinition = function (definitionUnvalidated) {&#13;
        var gameMode = presenter.GAME_MODE.UNDEFINED;&#13;
&#13;
        if (htmlIsEmpty(definitionUnvalidated['definition'])) {&#13;
            definitionUnvalidated['definition'] = "";&#13;
            gameMode = presenter.GAME_MODE.SPEED_ATTACK;&#13;
        } else {&#13;
            gameMode = presenter.GAME_MODE.QUESTIONS;&#13;
        }&#13;
&#13;
        var answer1 = definitionUnvalidated['answer1'];&#13;
        var answer2 = definitionUnvalidated['answer2'];&#13;
        var answer3 = definitionUnvalidated['answer3'];&#13;
&#13;
        if (window.ModelValidationUtils.isStringEmpty(answer1)) {&#13;
            return generateValidationError("EA01");&#13;
        }&#13;
&#13;
        if (window.ModelValidationUtils.isStringEmpty(answer2)) {&#13;
            return generateValidationError("EA01");&#13;
        }&#13;
&#13;
        if (window.ModelValidationUtils.isStringEmpty(answer3)) {&#13;
            return generateValidationError("EA01");&#13;
        }&#13;
&#13;
        var validatedCorrectAnswers = presenter.validateCorrectAnswers(definitionUnvalidated['correct_answers']);&#13;
        if (!validatedCorrectAnswers.isValid) {&#13;
            return validatedCorrectAnswers;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            gameMode: gameMode,&#13;
            definition: definitionUnvalidated['definition'],&#13;
            answers: [answer1, answer2, answer3],&#13;
            correctAnswers: validatedCorrectAnswers.correctAnswers&#13;
        }&#13;
    };&#13;
&#13;
    function htmlIsEmpty(htmlValue) {&#13;
        var $container = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $container.html(htmlValue);&#13;
        var text = $container.text();&#13;
        return window.ModelValidationUtils.isStringEmpty(text);&#13;
    }&#13;
&#13;
    presenter.validateCorrectAnswers = function (correctAnswerValue) {&#13;
        var correctAnswers = [];&#13;
&#13;
        if (!window.ModelValidationUtils.isStringEmpty(correctAnswerValue)) {&#13;
            if (correctAnswerValue.indexOf("-") &gt; -1) {&#13;
                var range = getCorrectAnswersFromRange(correctAnswerValue);&#13;
                if (!range.isValid) {&#13;
                    return range;&#13;
                }&#13;
&#13;
                correctAnswers = range.correctAnswers;&#13;
            } else {&#13;
                var answers = getCorrectAnswersSeparatedByComma(correctAnswerValue);&#13;
                if (!answers.isValid) {&#13;
                    return answers;&#13;
                }&#13;
&#13;
                correctAnswers = answers.correctAnswers;&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            correctAnswers: correctAnswers&#13;
        };&#13;
    };&#13;
&#13;
    function getCorrectAnswersSeparatedByComma(answers) {&#13;
        var correctAnswers = [];&#13;
        var splitAnswers = answers.split(",");&#13;
&#13;
        for (var i = 0; i &lt; splitAnswers.length; i++) {&#13;
            var validatedCorrectAnswer = window.ModelValidationUtils.validateIntegerInRange(splitAnswers[i], 3, 1);&#13;
            if (!validatedCorrectAnswer.isValid) {&#13;
                return generateValidationError("WA04");&#13;
            }&#13;
&#13;
            correctAnswers.push(validatedCorrectAnswer.value - 1);&#13;
        }&#13;
&#13;
        correctAnswers = window.ModelValidationUtils.removeDuplicatesFromArray(correctAnswers);&#13;
        correctAnswers = correctAnswers.sort();&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            correctAnswers: correctAnswers&#13;
        };&#13;
    }&#13;
&#13;
    function getCorrectAnswersFromRange(range) {&#13;
        var correctAnswers = [];&#13;
        var splitRange = range.split("-");&#13;
&#13;
        if (splitRange.length !== 2) {&#13;
            return generateValidationError("WA01");&#13;
        }&#13;
&#13;
        var start = window.ModelValidationUtils.validateIntegerInRange(splitRange[0], 3, 1);&#13;
        if (!start.isValid) {&#13;
            return generateValidationError("WA02");&#13;
        }&#13;
&#13;
        var end = window.ModelValidationUtils.validateIntegerInRange(splitRange[1], 3, 1);&#13;
        if (!end.isValid) {&#13;
            return generateValidationError("WA03");&#13;
        }&#13;
&#13;
        for (var i = Math.min(start.value, end.value) - 1; i &lt;= Math.max(start.value, end.value) - 1; i++) {&#13;
            correctAnswers.push(i);&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            correctAnswers: correctAnswers&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    presenter.validateGameMode = function (lastGameMode, newGameMode) {&#13;
        if (lastGameMode == presenter.GAME_MODE.UNDEFINED || lastGameMode == newGameMode) {&#13;
            return {&#13;
                isValid: true,&#13;
                gameMode: newGameMode&#13;
            };&#13;
        }&#13;
&#13;
        if (lastGameMode !== newGameMode) {&#13;
            return generateValidationError("WM01");&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateTimeForLastAnswer = function (model) {&#13;
        var timeForLastAnswerUnvalidated = model['time_for_last_answer'];&#13;
&#13;
        if (window.ModelValidationUtils.isStringEmpty(timeForLastAnswerUnvalidated)) {&#13;
            return {&#13;
                isValid: true,&#13;
                timeForLastAnswer: -1&#13;
            };&#13;
        }&#13;
&#13;
        var validatedFloat = window.ModelValidationUtils.validateFloatInRange(timeForLastAnswerUnvalidated, Number.MAX_VALUE, 0.01);&#13;
        if (!validatedFloat.isValid) {&#13;
            return generateValidationError("LT01")&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            timeForLastAnswer: validatedFloat.parsedValue&#13;
        };&#13;
&#13;
    };&#13;
&#13;
    presenter.validateInitialTimeForAnswer = function (model) {&#13;
        var initialTimeForAnswerUnvalidated = model['initial_time_for_answer'];&#13;
        var validatedFloat = window.ModelValidationUtils.validateFloatInRange(initialTimeForAnswerUnvalidated, Number.MAX_VALUE, 0.01);&#13;
        if (!validatedFloat.isValid) {&#13;
            return generateValidationError("IT01")&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            initialTimeForAnswer: validatedFloat.parsedValue&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.state.$view.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
        presenter.state.$view.css('display', isVisible ? presenter.originalDisplay : 'none');&#13;
&#13;
        presenter.state.isVisible = isVisible;&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
&#13;
        presenter.setWorkMode();&#13;
        presenter.hideAnswers();&#13;
        presenter.state.resultsList = [];&#13;
        presenter.restartGame();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        presenter.state.showingErrors = true;&#13;
&#13;
        if (presenter.state.$playButton.is(":visible")) {&#13;
            return;&#13;
        }&#13;
        if (presenter.state.isShowingAnswers) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            presenter.getActualLevel().pause();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        presenter.state.showingErrors = false;&#13;
&#13;
        if (!presenter.state.isStarted || presenter.state.$playButton.is(":visible")) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            presenter.getActualLevel().resume();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setState = function (stateString) {&#13;
        var state = JSON.parse(stateString);&#13;
&#13;
        if (state.isStarted) {&#13;
            presenter.changeLevel(state['actualLevel']);&#13;
            presenter.getActualLevel().start(state['actualLevelTimeElapsed'], state['clickedElements']);&#13;
&#13;
            presenter.actualizeAnswersWrapperHeight();&#13;
            if (!state.isFinished) {&#13;
                presenter.getActualLevel().actualize();&#13;
                presenter.getActualLevel().pause(true);&#13;
            }&#13;
            presenter.state.isStarted = true;&#13;
        }&#13;
        presenter.state.errorCount = state.errorCount;&#13;
        presenter.state.wholeErrorCount = state.wholeErrorCount;&#13;
        presenter.state.score = state.score;&#13;
        presenter.state.resultsList = state.resultsList;&#13;
&#13;
        if (state.isFinished) {&#13;
            presenter.getActualLevel().destroy();&#13;
            presenter.onEndLevelCallback(true);&#13;
        }&#13;
&#13;
        presenter.setVisibility(state.isVisible);&#13;
    };&#13;
&#13;
    presenter.getActualLevel = function () {&#13;
        return presenter.state.levels[presenter.state.actualLevel];&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        var actualLevelTimeElapsed = 1;&#13;
        var isFinished = true;&#13;
        var actualLevel = presenter.state.levels.length - 1;&#13;
        var clickedElements = [];&#13;
        var isStarted = presenter.state.isStarted;&#13;
&#13;
        if (presenter.state.actualLevel &lt; presenter.state.levels.length) {&#13;
            actualLevelTimeElapsed = presenter.getActualLevel().getElapsedTime();&#13;
            isFinished = false;&#13;
            actualLevel = presenter.state.actualLevel;&#13;
            clickedElements = presenter.getActualLevel().getClicked();&#13;
        }&#13;
&#13;
        var state = {&#13;
            actualLevel: actualLevel,&#13;
            actualLevelTimeElapsed: actualLevelTimeElapsed,&#13;
            isFinished: isFinished,&#13;
            isVisible: presenter.state.isVisible,&#13;
            score: presenter.state.score,&#13;
            errorCount: presenter.state.errorCount,&#13;
            wholeErrorCount: presenter.state.wholeErrorCount,&#13;
            clickedElements: clickedElements,&#13;
            isStarted: isStarted,&#13;
            resultsList: presenter.state.resultsList&#13;
        };&#13;
&#13;
        return JSON.stringify(state);&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        return presenter.state.score;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        var definitionsLength = presenter.configuration.definitions.length;&#13;
        var maxScore = 0;&#13;
        for (var i = 0; i &lt; definitionsLength; i++) {&#13;
            maxScore += presenter.configuration.definitions[i].correctAnswers.length;&#13;
        }&#13;
&#13;
        return maxScore;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        var lastErrorCount = presenter.state.errorCount;&#13;
&#13;
        return lastErrorCount;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (presenter.isErrorCheckingMode) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.createEventData = function () {&#13;
        return {&#13;
            source : presenter.configuration.addonID,&#13;
            item : "all",&#13;
            value : '',&#13;
            score : ''&#13;
        };&#13;
&#13;
    };&#13;
&#13;
    function generateValidationError(errorCode) {&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: errorCode&#13;
        };&#13;
    }&#13;
&#13;
    presenter.__internalElements = {&#13;
        Level: Level&#13;
    };&#13;
&#13;
    function Level (configuration) {&#13;
        this.definition = configuration.definition;&#13;
        this.questionNumber = configuration.questionNumber;&#13;
        this.$answersWrapper = configuration.$answersWrapper;&#13;
        this.$questionDiv = configuration.$questionDiv;&#13;
        this.$levelDiv = configuration.$levelDiv;&#13;
        this.numberOfLevel = configuration.numberOfLevel;&#13;
        this.timeForAnswer = configuration.timeForAnswer;&#13;
        this.callbacks = {&#13;
            onCorrectAnswerCallback: configuration.onCorrectAnswerCallback,&#13;
            onWrongAnswerCallback: configuration.onWrongAnswerCallback,&#13;
            onDroppedCorrectAnswerCallback: configuration.onDroppedCorrectAnswerCallback,&#13;
            onEndLevelCallback: configuration.onEndLevelCallback&#13;
        };&#13;
&#13;
        this.initialElapsedTime = 0;&#13;
        this.startTime = 0;&#13;
        this.answers = [];&#13;
        this.levelWasEnded = false;&#13;
        this.destroyed = true;&#13;
        this.droppedElements = 0;&#13;
        this.clickedElements = 0;&#13;
        this.pauseTime = 0;&#13;
        this.isPaused = false;&#13;
    }&#13;
&#13;
    Level.prototype = {&#13;
        start: function (elapsedTime, clickedElements) {&#13;
            this.clickedElements = 0;&#13;
            this.startTime = new Date().getTime() / 1000;&#13;
            this.generateAnswers();&#13;
            this.$questionDiv.html(this.definition["definition"]);&#13;
            this.$levelDiv.html(this.numberOfLevel);&#13;
            this.destroyed = false;&#13;
            this.initialElapsedTime = 0;&#13;
            this.pauseTime = 0;&#13;
            this.isPaused = false;&#13;
            this.levelWasEnded = false;&#13;
            this.droppedElements = 0;&#13;
&#13;
            if (this.definition.gameMode == presenter.GAME_MODE.SPEED_ATTACK) {&#13;
                this.$questionDiv.hide();&#13;
            } else {&#13;
                this.$questionDiv.show();&#13;
            }&#13;
&#13;
            if (elapsedTime) {&#13;
                this.setElapsedTime(elapsedTime);&#13;
            }&#13;
&#13;
            if (clickedElements) {&#13;
                this.setClicked(clickedElements);&#13;
            }&#13;
        },&#13;
&#13;
        destroy: function () {&#13;
            if (this.destroyed) {&#13;
                return;&#13;
            }&#13;
            this.destroyed = true;&#13;
&#13;
            for (var i = 0; i &lt; 3; i++) {&#13;
                this.answers[i].element.off();&#13;
                this.answers[i].element.remove();&#13;
            }&#13;
        },&#13;
&#13;
        actualize: function () {&#13;
            if (this.destroyed || this.isPaused) {&#13;
                return;&#13;
            }&#13;
&#13;
            this.speedForSecond = this.$answersWrapper.height() / this.timeForAnswer;&#13;
&#13;
            var timeElapsed =(new Date().getTime() / 1000) - this.startTime + this.initialElapsedTime;&#13;
            var top = timeElapsed * this.speedForSecond;&#13;
&#13;
            for (var i = 0; i &lt; 3; i++) {&#13;
                this.answers[i].element.css({'top': top});&#13;
                if (top &gt; this.$answersWrapper.height()) {&#13;
                    this.onDrop(this.questionNumber, i);&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        generateAnswers: function () {&#13;
            this.answers = [];&#13;
            for (var i = 0; i &lt; 3; i++) {&#13;
                this.answers.push(this.generateAnswer(i));&#13;
            }&#13;
        },&#13;
&#13;
        generateAnswer: function (index) {&#13;
            var wrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
            wrapper.addClass("addon-Shooting_Range-answer-wrapper addon-Shooting_Range-answer-" + index);&#13;
&#13;
            var text = $("&lt;div&gt;&lt;/div&gt;");&#13;
            text.addClass("addon-Shooting_Range-answer-text");&#13;
&#13;
            var layer = $("&lt;div&gt;&lt;/div&gt;");&#13;
            layer.addClass("addon-Shooting_Range-answer-layer");&#13;
&#13;
            wrapper.append(text);&#13;
            wrapper.append(layer);&#13;
&#13;
            var isCorrect = $.inArray(index, this.definition.correctAnswers) &gt; -1;&#13;
            var functionOnClick = this.onClick.bind(this, this.questionNumber, isCorrect, index);&#13;
&#13;
            layer.mousedown(functionOnClick);&#13;
            layer.on('touchstart', functionOnClick);&#13;
            text.html(this.definition.answers[index]);&#13;
&#13;
            this.$answersWrapper.append(wrapper);&#13;
&#13;
            return {&#13;
                element: wrapper,&#13;
                text: text,&#13;
                layer: layer,&#13;
                isClicked: false,&#13;
                isCorrect: isCorrect&#13;
            };&#13;
        },&#13;
&#13;
        onClick: function (questionNumber, isCorrect, answerNumber, event) {&#13;
            event.stopPropagation();&#13;
            event.preventDefault();&#13;
&#13;
            if(this.isPaused) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (this.answers[answerNumber].isClicked) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (isCorrect) {&#13;
                this.callbacks.onCorrectAnswerCallback(questionNumber, answerNumber);&#13;
                this.setCorrectAnswer(answerNumber);&#13;
            } else {&#13;
                this.callbacks.onWrongAnswerCallback(questionNumber, answerNumber);&#13;
                this.setWrongAnswer(answerNumber);&#13;
            }&#13;
            this.setClickedAnswer(answerNumber);&#13;
        },&#13;
&#13;
        onDrop: function (questionNumber, answerNumber) {&#13;
            this.droppedElements++;&#13;
&#13;
            if (!this.answers[answerNumber].isClicked) {&#13;
                var isCorrect = this.answers[answerNumber].isCorrect;&#13;
                if (isCorrect) {&#13;
                    this.callbacks.onDroppedCorrectAnswerCallback(questionNumber, answerNumber);&#13;
                }&#13;
            }&#13;
&#13;
            if (this.droppedElements == 3) {&#13;
                this.endLevel();&#13;
            }&#13;
        },&#13;
&#13;
        endLevel: function () {&#13;
            if (this.levelWasEnded) {&#13;
                return;&#13;
            }&#13;
&#13;
            this.levelWasEnded = true;&#13;
            this.destroy();&#13;
            this.callbacks.onEndLevelCallback();&#13;
        },&#13;
&#13;
        setElapsedTime: function (elapsed) {&#13;
            this.initialElapsedTime = elapsed;&#13;
        },&#13;
&#13;
        getElapsedTime: function () {&#13;
            if (this.startTime == 0) {&#13;
                return 0;&#13;
            }&#13;
&#13;
            var pausedTime = 0;&#13;
&#13;
            if (this.isPaused) {&#13;
                pausedTime = this.pauseTime - new Date().getTime() / 1000&#13;
            }&#13;
&#13;
            return (new Date().getTime() / 1000) - this.startTime + this.initialElapsedTime + pausedTime;&#13;
        },&#13;
&#13;
        setWrongAnswer(answerNumber) {&#13;
            this.answers[answerNumber].element.addClass("wrong");&#13;
        },&#13;
&#13;
        setCorrectAnswer(answerNumber) {&#13;
            this.answers[answerNumber].element.addClass("correct");&#13;
        },&#13;
&#13;
        setClickedAnswer(answerNumber) {&#13;
            this.answers[answerNumber].isClicked = true;&#13;
            this.answers[answerNumber].element.addClass("clicked");&#13;
            this.clickedElements++;&#13;
        },&#13;
&#13;
&#13;
        setClicked: function (clickedArray) {&#13;
            for (var i = 0; i &lt; clickedArray.length; i++) {&#13;
                this.setClickedAnswer(clickedArray[i]);&#13;
                if(this.answers[clickedArray[i]].isCorrect){&#13;
                    this.setCorrectAnswer(clickedArray[i]);&#13;
                }else{&#13;
                    this.setWrongAnswer(clickedArray[i]);&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        getClicked: function () {&#13;
            var clicked = [];&#13;
&#13;
            if (this.destroyed) {&#13;
                return clicked;&#13;
            }&#13;
&#13;
            for (var  i = 0; i &lt; 3; i++) {&#13;
                if (this.answers[i].isClicked) {&#13;
                    clicked.push(i);&#13;
                }&#13;
            }&#13;
&#13;
            return clicked;&#13;
        },&#13;
&#13;
        showAnswers: function () {&#13;
            if (this.destroyed) {&#13;
                return;&#13;
            }&#13;
            for (var  i = 0; i &lt; 3; i++) {&#13;
                if (this.answers[i].isCorrect) {&#13;
                    this.answers[i].element.addClass('correct');&#13;
                } else {&#13;
                    this.answers[i].element.addClass('wrong');&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        hideAnswers: function () {&#13;
            if (this.destroyed) {&#13;
                return;&#13;
            }&#13;
            for (var  i = 0; i &lt; 3; i++) {&#13;
                this.answers[i].element.removeClass('correct');&#13;
                this.answers[i].element.removeClass('wrong');&#13;
            }&#13;
        },&#13;
&#13;
        pause: function (hideElements) {&#13;
            if (this.isPaused) {&#13;
                return;&#13;
            }&#13;
            this.isPaused = true;&#13;
            this.pauseTime = new Date().getTime() / 1000;&#13;
&#13;
            if (hideElements) {&#13;
                for (var i = 0; i &lt; 3; i++) {&#13;
                    this.answers[i].element.addClass("isHidden");&#13;
                }&#13;
            }&#13;
        },&#13;
&#13;
        resume: function (removeIsHidden) {&#13;
            if (!this.isPaused) {&#13;
                return;&#13;
            }&#13;
            this.isPaused = false;&#13;
            this.initialElapsedTime += this.pauseTime - new Date().getTime() / 1000;&#13;
            if (removeIsHidden) {&#13;
                for (var i = 0; i &lt; 3; i++) {&#13;
                    this.answers[i].element.removeClass("isHidden");&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    //https://stackoverflow.com/questions/5605588/how-to-use-requestanimationframe&#13;
    function requestAnimationFrame () {&#13;
        return window.requestAnimationFrame       ||&#13;
            window.webkitRequestAnimationFrame ||&#13;
            window.mozRequestAnimationFrame    ||&#13;
            window.oRequestAnimationFrame      ||&#13;
            window.msRequestAnimationFrame     ||&#13;
            function(/* function */ callback){&#13;
                window.setTimeout(callback, 1000 / 60);&#13;
            };&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>