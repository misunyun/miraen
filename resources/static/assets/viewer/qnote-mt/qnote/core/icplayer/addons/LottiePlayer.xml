<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="LottiePlayer" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
        <property isDefault="true" name="Items" nameLabel="LottiePlayer_property_items" type="list">
            <property name="AnimationJSON" nameLabel="LottiePlayer_property_animation_json" type="file"/>
            <property name="Loop" nameLabel="LottiePlayer_property_loop" type="boolean"/>
            <property name="LoopsNumber" nameLabel="LottiePlayer_property_loops_number" type="int"/>
            <property name="Autoplay" nameLabel="LottiePlayer_property_autoplay" type="boolean"/>
            <property name="Direction" nameLabel="LottiePlayer_property_direction" type="{Forward,Backward}"/>
            <property name="Mode" nameLabel="LottiePlayer_property_mode" type="{Normal,Bounce}"/>
            <property name="Speed" nameLabel="LottiePlayer_property_speed" type="number"/>
            <property name="Intermission" nameLabel="LottiePlayer_property_intermission_ms" type="int"/>
            <property name="Background" nameLabel="LottiePlayer_property_background" type="string"/>
            <property name="AlternativeText" nameLabel="LottiePlayer_property_alternative_text" type="text"/>
            <property name="PreviewAlternativeText" nameLabel="LottiePlayer_property_preview_alternative_text" type="text"/>
        </property>
        <property name="Controls" nameLabel="LottiePlayer_property_controls" type="boolean"/>
        <property name="PlayInSuccession" nameLabel="LottiePlayer_property_play_in_succession" type="boolean"/>
        <property name="LoopSuccession" nameLabel="LottiePlayer_property_loop_succession" type="boolean"/>
        <property name="SendEventOnEveryFrame" nameLabel="LottiePlayer_property_send_event_on_every_frame" type="boolean"/>
        <property displayName="Lang attribute" name="langAttribute" nameLabel="LottiePlayer_property_lang_attribute" type="string"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="LottiePlayer_property_speech_texts" type="staticlist">
            <property name="PlayButton" nameLabel="LottiePlayer_property_speech_text_play_button" type="staticrow">
                <property name="PlayButton" nameLabel="LottiePlayer_property_speech_text_play_button" type="string"/>
            </property>
            <property name="PauseButton" nameLabel="LottiePlayer_property_speech_text_pause_button" type="staticrow">
                <property name="PauseButton" nameLabel="LottiePlayer_property_speech_text_pause_button" type="string"/>
            </property>
            <property name="StopButton" nameLabel="LottiePlayer_property_speech_text_stop_button" type="staticrow">
                <property name="StopButton" nameLabel="LottiePlayer_property_speech_text_stop_button" type="string"/>
            </property>
            <property name="LoopButton" nameLabel="LottiePlayer_property_speech_text_loop_button" type="staticrow">
                <property name="LoopButton" nameLabel="LottiePlayer_property_speech_text_loop_button" type="string"/>
            </property>
            <property name="Paused" nameLabel="LottiePlayer_property_speech_text_paused" type="staticrow">
                <property name="Paused" nameLabel="LottiePlayer_property_speech_text_paused" type="string"/>
            </property>
            <property name="Stopped" nameLabel="LottiePlayer_property_speech_text_stopped" type="staticrow">
                <property name="Stopped" nameLabel="LottiePlayer_property_speech_text_stopped" type="string"/>
            </property>
        </property>
        <property name="{library}" nameLabel="LottiePlayer_property_library" type="script" value="//www.mauthor.com/file/serve/4732428471631872"/>
    </model>
<css>.lottie-player-invalid-configuration {&#13;
    border: 3px solid red !important;&#13;
    color: red;&#13;
    line-height: 18px;&#13;
    font-size: 18px;&#13;
    display: flex;&#13;
    justify-content: center;&#13;
    align-items: center;&#13;
    text-align: center;&#13;
    padding: 2px&#13;
}&#13;
&#13;
.lottie-player-visible-animation {&#13;
    display: flex;&#13;
}&#13;
&#13;
.lottie-player-invisible-animation {&#13;
    display: none;&#13;
}&#13;
&#13;
lottie-player::part(keyboard_navigation_active_element)  {&#13;
    border: 1px dotted grey;&#13;
}&#13;
</css><view/><preview/><presenter>function AddonLottiePlayer_create() {&#13;
    var presenter = function () {};&#13;
&#13;
    presenter.eventBus = null;&#13;
&#13;
    presenter.isVisible = true;&#13;
    presenter.currentAnimationIndex = 0;&#13;
    presenter.animationsStates = [];&#13;
    presenter.animationsElements = [];&#13;
    presenter.isPreview = true;&#13;
    presenter.previouslyVisited = false;&#13;
&#13;
    presenter.isWCAGOn = false;&#13;
    presenter.speechTexts = null;&#13;
    presenter.keyboardControllerObject = null;&#13;
&#13;
    presenter.DIRECTION = {&#13;
        Forward: "Forward",&#13;
        Backward: "Backward",&#13;
        DEFAULT: "Forward"&#13;
    };&#13;
&#13;
    presenter.MODE = {&#13;
        Normal: "Normal",&#13;
        Bounce: "Bounce",&#13;
        DEFAULT: "Normal"&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        IAS_0: "Please provide animation JSON file.",&#13;
        ILN_0: "Number of loops must be valid integer or empty.",&#13;
        ILN_1: "Number of loops must not be less than 0.",&#13;
        IS_0: "Speed value must be valid float or empty.",&#13;
        IS_1: "Speed value must not be less than 0.",&#13;
        II_0: "Intermission must be valid integer or empty.",&#13;
        II_1: "Intermission value must not be less than 0.",&#13;
        IB_0: "Background color must be valid HEX value, RGB value, RGBA value, transparent or empty (to be transparent)",&#13;
    };&#13;
&#13;
    presenter.CSS_CLASSES = {&#13;
        INVALID_CONFIGURATION: "lottie-player-invalid-configuration",&#13;
        VISIBLE_ANIMATION: "lottie-player-visible-animation",&#13;
        INVISIBLE_ANIMATION: "lottie-player-invisible-animation",&#13;
        LOTTIE_PLAYER: "lottie-player",&#13;
    };&#13;
&#13;
    presenter.DOM_IDS = {&#13;
        PLAY_BUTTON: "lottie-play-button",&#13;
        STOP_BUTTON: "lottie-stop-button",&#13;
        LOOP_BUTTON: "lottie-loop-toggle",&#13;
    };&#13;
&#13;
    presenter.DEFAULT_TTS_PHRASES = {&#13;
        PLAY_BUTTON: "Play button",&#13;
        PAUSE_BUTTON: "Pause button",&#13;
        STOP_BUTTON: "Stop button",&#13;
        LOOP_BUTTON: "Loop button",&#13;
        STOPPED: "Stopped",&#13;
        PAUSED: "Paused"&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = presenter.playerController.getEventBus();&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.initialize(view, model, true);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.initialize(view, model, false);&#13;
    };&#13;
&#13;
    presenter.initialize = function (view, model, isPreview) {&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
        presenter.isPreview = isPreview;&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            showErrorMessage();&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.addAnimations(view, presenter.configuration);&#13;
        presenter.attachEventListeners(isPreview);&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.setSpeechTexts(model["SpeechTexts"]);&#13;
            presenter.buildKeyboardController();&#13;
        }&#13;
        presenter.displayCurrentAnimation();&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        let isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
        let controls = ModelValidationUtils.validateBoolean(model["Controls"]);&#13;
        let playInSuccession = ModelValidationUtils.validateBoolean(model["PlayInSuccession"]);&#13;
        let loopSuccession = ModelValidationUtils.validateBoolean(model["LoopSuccession"]);&#13;
        let sendEventOnEveryFrame = ModelValidationUtils.validateBoolean(model["SendEventOnEveryFrame"]);&#13;
&#13;
        let animationsConfigurations = [];&#13;
        for (let itemIndex = 0; itemIndex &lt; model.Items.length; itemIndex++) {&#13;
            let validatedAnimationConfig = validateAnimationModel(model.Items[itemIndex], itemIndex);&#13;
            if (!validatedAnimationConfig.isValid) {&#13;
                return validatedAnimationConfig;&#13;
            }&#13;
            animationsConfigurations.push(validatedAnimationConfig.configuration);&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            addonID: model["ID"],&#13;
            isVisible: isVisible,&#13;
            animations: animationsConfigurations,&#13;
            controls: controls,&#13;
            playInSuccession: playInSuccession,&#13;
            loopSuccession: loopSuccession,&#13;
            sendEventOnEveryFrame: sendEventOnEveryFrame,&#13;
            langTag: model["langAttribute"],&#13;
        };&#13;
    };&#13;
&#13;
    function validateAnimationModel(animationModel, itemIndex) {&#13;
        let validatedAnimationSrc = validateAnimationSrc(animationModel["AnimationJSON"], itemIndex);&#13;
        if (!validatedAnimationSrc.isValid) {&#13;
            return validatedAnimationSrc;&#13;
        }&#13;
&#13;
        let isLoop = ModelValidationUtils.validateBoolean(animationModel["Loop"]);&#13;
        let isAutoplay = ModelValidationUtils.validateBoolean(animationModel["Autoplay"]);&#13;
        let direction = ModelValidationUtils.validateOption(presenter.DIRECTION, animationModel["Direction"]);&#13;
        let mode = ModelValidationUtils.validateOption(presenter.MODE, animationModel["Mode"]);&#13;
&#13;
        let validatedLoopsNumber = validateLoopsNumber(animationModel["LoopsNumber"], itemIndex);&#13;
        if (!validatedLoopsNumber.isValid) {&#13;
            return validatedLoopsNumber;&#13;
        }&#13;
&#13;
        let validatedSpeed = validateSpeed(animationModel["Speed"], itemIndex);&#13;
        if (!validatedSpeed.isValid) {&#13;
            return validatedSpeed;&#13;
        }&#13;
&#13;
        let validatedIntermission = validateIntermission(animationModel["Intermission"], itemIndex);&#13;
        if (!validatedIntermission.isValid) {&#13;
            return validatedIntermission;&#13;
        }&#13;
&#13;
        let validatedBackground = validateBackground(animationModel["Background"], itemIndex);&#13;
        if (!validatedBackground.isValid) {&#13;
            return validatedBackground;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            configuration: {&#13;
                animationSrc: validatedAnimationSrc.value,&#13;
                isLoop: isLoop,&#13;
                isAutoplay: isAutoplay,&#13;
                direction: direction,&#13;
                mode: mode,&#13;
                loopsNumber: validatedLoopsNumber.value,&#13;
                speed: validatedSpeed.value,&#13;
                intermission: validatedIntermission.value,&#13;
                background: validatedBackground.value,&#13;
                altText: animationModel["AlternativeText"],&#13;
                altTextPreview: animationModel["PreviewAlternativeText"],&#13;
            },&#13;
        };&#13;
    }&#13;
&#13;
    function validateAnimationSrc (value, itemIndex) {&#13;
        if (!value) {&#13;
            return getErrorObject("IAS_0", itemIndex);&#13;
        }&#13;
        return getValidObject(value);&#13;
    }&#13;
&#13;
    function validateLoopsNumber (value, itemIndex) {&#13;
        return validatePositiveIntValue("ILN", value, null, itemIndex);&#13;
    }&#13;
&#13;
    function validateSpeed (value, itemIndex) {&#13;
        return validatePositiveFloatValue("IS", value, 1, itemIndex);&#13;
    }&#13;
&#13;
    function validateIntermission (value, itemIndex) {&#13;
        return validatePositiveIntValue("II", value, null, itemIndex);&#13;
    }&#13;
&#13;
    function validateBackground (value, itemIndex) {&#13;
        let defaultValue = "transparent";&#13;
        if (ModelValidationUtils.isStringEmpty(value)) {&#13;
            return getValidObject(defaultValue);&#13;
        }&#13;
&#13;
        let parsedValue = value.toLowerCase();&#13;
        if (parsedValue === defaultValue) {&#13;
            return getValidObject(parsedValue);&#13;
        }&#13;
&#13;
        // Regex do not support RGBA with spaces&#13;
        let isColor = value.match(/#[a-f0-9]{6}\b|#[a-f0-9]{3}\b|rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$|rgba\((\s*\d+\s*,){3}[\d\.]+\)/gi);&#13;
        if (!isColor) {&#13;
            return getErrorObject("IB_0", itemIndex);&#13;
        }&#13;
        return getValidObject(parsedValue);&#13;
    }&#13;
&#13;
    function validatePositiveFloatValue(errorCodePrefix, value, defaultValue, itemIndex) {&#13;
        if (ModelValidationUtils.isStringEmpty(value)) {&#13;
            return getValidObject(defaultValue);&#13;
        }&#13;
&#13;
        const parsedValue = parseFloat(value);&#13;
        if (isNaN(parsedValue)) {&#13;
            return getErrorObject(`${errorCodePrefix}_0`, itemIndex);&#13;
        }&#13;
        if (parsedValue &lt; 0) {&#13;
            return getErrorObject(`${errorCodePrefix}_1`, itemIndex);&#13;
        }&#13;
&#13;
        return getValidObject(parsedValue);&#13;
    }&#13;
&#13;
    function validatePositiveIntValue(errorCodePrefix, value, defaultValue, itemIndex) {&#13;
        if (ModelValidationUtils.isStringEmpty(value)) {&#13;
            return getValidObject(defaultValue);&#13;
        }&#13;
&#13;
        const parsedValue = parseInt(value);&#13;
        if (isNaN(parsedValue)) {&#13;
            return getErrorObject(`${errorCodePrefix}_0`, itemIndex);&#13;
        }&#13;
        if (parsedValue &lt; 0) {&#13;
            return getErrorObject(`${errorCodePrefix}_1`, itemIndex);&#13;
        }&#13;
&#13;
        return getValidObject(parsedValue);&#13;
    }&#13;
&#13;
    function getValidObject (value) {&#13;
        return {&#13;
            isValid: true,&#13;
            value: value&#13;
        }&#13;
    }&#13;
&#13;
    function getErrorObject(errorCode, itemIndex = undefined) {&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: errorCode,&#13;
            itemIndex: itemIndex&#13;
        }&#13;
    }&#13;
&#13;
    function showErrorMessage() {&#13;
        let errorMessage = presenter.ERROR_CODES[presenter.configuration.errorCode];&#13;
        if (presenter.configuration.itemIndex !== undefined) {&#13;
            errorMessage = `Item ${presenter.configuration.itemIndex + 1}. ` + errorMessage;&#13;
        }&#13;
        presenter.$view.html(errorMessage);&#13;
        presenter.view.classList.add(presenter.CSS_CLASSES.INVALID_CONFIGURATION);&#13;
    }&#13;
&#13;
    presenter.addAnimations = function (view, configuration) {&#13;
        configuration.animations.forEach((animationConfiguration, index) =&gt; {&#13;
            let lottie = document.createElement("lottie-player");&#13;
            hideAnimation(lottie);&#13;
            lottie.classList.add(`${presenter.CSS_CLASSES.LOTTIE_PLAYER}-${index}`);&#13;
&#13;
            lottie.src = animationConfiguration.animationSrc;&#13;
            lottie.background = animationConfiguration.background;&#13;
&#13;
            lottie.setAttribute("direction", parseDirectionToValue(animationConfiguration.direction));&#13;
            lottie.setAttribute("speed", animationConfiguration.speed.toString());&#13;
&#13;
            if (animationConfiguration.isLoop) {&#13;
                lottie.setAttribute("loop", "loop");&#13;
            }&#13;
            if (animationConfiguration.isAutoplay) {&#13;
                lottie.setAttribute("autoplay", "autoplay");&#13;
            }&#13;
            if (configuration.controls) {&#13;
                lottie.setAttribute("controls", "controls");&#13;
            }&#13;
            if (animationConfiguration.mode === presenter.MODE.Bounce) {&#13;
                lottie.setAttribute("mode", "bounce");&#13;
            }&#13;
            if (animationConfiguration.loopsNumber !== null) {&#13;
                lottie.setAttribute("count", animationConfiguration.loopsNumber.toString());&#13;
            }&#13;
            if (animationConfiguration.intermission !== null) {&#13;
                lottie.setAttribute("intermission", animationConfiguration.intermission.toString());&#13;
            }&#13;
&#13;
            view.appendChild(lottie);&#13;
        });&#13;
&#13;
        presenter.animationsElements = findAnimationsElements();&#13;
        presenter.initializeAnimationsStates();&#13;
    };&#13;
&#13;
    presenter.initializeAnimationsStates = function () {&#13;
        presenter.animationsElements.forEach((animation, index) =&gt; {&#13;
            presenter.animationsStates.push(new AnimationState(index));&#13;
        })&#13;
    }&#13;
&#13;
    function parseDirectionToValue (mode) {&#13;
        if (mode === presenter.DIRECTION.Backward) {&#13;
            return "-1";&#13;
        } return "1";&#13;
    }&#13;
&#13;
    presenter.setSpeechTexts = function(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            PlayButton: presenter.DEFAULT_TTS_PHRASES.PLAY_BUTTON,&#13;
            PauseButton: presenter.DEFAULT_TTS_PHRASES.PAUSE_BUTTON,&#13;
            StopButton: presenter.DEFAULT_TTS_PHRASES.STOP_BUTTON,&#13;
            LoopButton: presenter.DEFAULT_TTS_PHRASES.LOOP_BUTTON,&#13;
            Paused: presenter.DEFAULT_TTS_PHRASES.PAUSED,&#13;
            Stopped: presenter.DEFAULT_TTS_PHRASES.STOPPED,&#13;
        };&#13;
&#13;
        if (!speechTexts || $.isEmptyObject(speechTexts)) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            PlayButton: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.PlayButton.PlayButton,&#13;
                presenter.speechTexts.PlayButton),&#13;
            PauseButton: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.PauseButton.PauseButton,&#13;
                presenter.speechTexts.PauseButton),&#13;
            StopButton: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.StopButton.StopButton,&#13;
                presenter.speechTexts.StopButton),&#13;
            LoopButton: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.LoopButton.LoopButton,&#13;
                presenter.speechTexts.LoopButton),&#13;
            Paused: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Paused.Paused,&#13;
                presenter.speechTexts.Paused),&#13;
            Stopped: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Stopped.Stopped,&#13;
                presenter.speechTexts.Stopped),&#13;
        };&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        let commands = {&#13;
            load: presenter.load,&#13;
            play: presenter.play,&#13;
            pause: presenter.pause,&#13;
            stop: presenter.stop,&#13;
            freeze: presenter.freeze,&#13;
            playAll: presenter.playAll,&#13;
            pauseAll: presenter.pauseAll,&#13;
            stopAll: presenter.stopAll,&#13;
            freezeAll: presenter.freezeAll,&#13;
            loop: presenter.loop,&#13;
            frame: presenter.frame,&#13;
            jumpTo: presenter.jumpToCommand,&#13;
            next: presenter.next,&#13;
            previous: presenter.previous,&#13;
            show: presenter.show,&#13;
            hide: presenter.hide,&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.load = function (animationIndex, url) {&#13;
        presenter.animationsElements[animationIndex - 1].load(url);&#13;
    };&#13;
&#13;
    presenter.play = function (animationIndex) {&#13;
        const parsedAnimationIndex = animationIndex ? animationIndex - 1 : presenter.currentAnimationIndex;&#13;
        play(parsedAnimationIndex);&#13;
    };&#13;
&#13;
    function play (animationIndex) {&#13;
        presenter.animationsElements.forEach((animation, index) =&gt; {&#13;
            if (index === animationIndex) {&#13;
                presenter.currentAnimationIndex = index;&#13;
                showAnimation(animation);&#13;
                animation.play();&#13;
            } else {&#13;
                animation.stop();&#13;
                hideAnimation(animation);&#13;
            }&#13;
        })&#13;
        if (presenter.isTTS()) {&#13;
            presenter.keyboardControllerObject.speakAlternativeText();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.pause = function (animationIndex) {&#13;
        const parsedAnimationIndex = animationIndex ? animationIndex - 1 : presenter.currentAnimationIndex;&#13;
        pause(parsedAnimationIndex);&#13;
    };&#13;
&#13;
    function pause (animationIndex) {&#13;
        presenter.animationsElements[animationIndex].pause();&#13;
        if (presenter.isTTS()) {&#13;
            presenter.keyboardControllerObject.speakPaused();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.stop = function (animationIndex) {&#13;
        const parsedAnimationIndex = animationIndex ? animationIndex - 1 : presenter.currentAnimationIndex;&#13;
        stop(parsedAnimationIndex);&#13;
    };&#13;
&#13;
    function stop (animationIndex) {&#13;
        presenter.animationsElements[animationIndex].stop();&#13;
        if (presenter.isTTS()) {&#13;
            presenter.keyboardControllerObject.speakStopped();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.freeze = function (animationIndex) {&#13;
        const parsedAnimationIndex = animationIndex ? animationIndex - 1 : presenter.currentAnimationIndex;&#13;
        freeze(parsedAnimationIndex);&#13;
    };&#13;
&#13;
    function freeze (animationIndex) {&#13;
        presenter.animationsElements[animationIndex].freeze();&#13;
    }&#13;
&#13;
    presenter.playAll = function () {&#13;
        presenter.play()&#13;
    };&#13;
&#13;
    presenter.pauseAll = function () {&#13;
        presenter.animationsElements.forEach(animation =&gt; {&#13;
            animation.pause();&#13;
        })&#13;
        if (presenter.isTTS()) {&#13;
            presenter.keyboardControllerObject.speakPaused();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.stopAll = function () {&#13;
        presenter.animationsElements.forEach(animation =&gt; {&#13;
            animation.stop();&#13;
        })&#13;
        if (presenter.isTTS()) {&#13;
            presenter.keyboardControllerObject.speakStopped();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.freezeAll = function () {&#13;
        presenter.animationsElements.forEach(animation =&gt; {&#13;
            animation.freeze();&#13;
        })&#13;
    };&#13;
&#13;
    presenter.loop = function (id, value) {&#13;
        presenter.animationsElements[id - 1].setLooping(value);&#13;
    };&#13;
&#13;
    presenter.frame = function (id, value) {&#13;
        presenter.animationsElements[id - 1].seek(value);&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
        presenter.isVisible = isVisible;&#13;
    };&#13;
&#13;
    presenter.next = function () {&#13;
        if (presenter.currentAnimationIndex + 1 &lt; presenter.configuration.animations.length) {&#13;
            presenter.currentAnimationIndex++;&#13;
            presenter.jumpTo(presenter.currentAnimationIndex + 1);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.previous = function () {&#13;
        if (presenter.currentAnimationIndex &gt; 0) {&#13;
            presenter.currentAnimationIndex--;&#13;
            presenter.jumpTo(presenter.currentAnimationIndex + 1);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.jumpToCommand = function (params) {&#13;
        presenter.jumpTo(parseInt(params[0], 10));&#13;
    };&#13;
&#13;
    presenter.jumpTo = function (animationIndex) {&#13;
        let newAnimationIndex = animationIndex - 1;&#13;
        if (newAnimationIndex &gt;= 0 &amp;&amp; newAnimationIndex &lt; presenter.configuration.animations.length) {&#13;
            presenter.currentAnimationIndex = newAnimationIndex;&#13;
            if (isAnimationAutoplay(newAnimationIndex) &amp;&amp; !isAnimationFinishedLoops(newAnimationIndex)) {&#13;
                play(presenter.currentAnimationIndex);&#13;
            } else {&#13;
                presenter.displayCurrentAnimation();&#13;
            }&#13;
            if (presenter.keyboardControllerObject) {&#13;
                presenter.keyboardControllerObject.reloadElements();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.attachEventListeners = function (isPreview) {&#13;
        if (!isPreview) {&#13;
            attachEventListenersToView();&#13;
        }&#13;
        presenter.animationsElements.forEach(&#13;
            (animation, index) =&gt; attachRunEventListenersToAnimationElement(animation, index, isPreview)&#13;
        );&#13;
    };&#13;
&#13;
    function attachEventListenersToView () {&#13;
        presenter.view.addEventListener("touchstart", (e) =&gt; {&#13;
            e.stopPropagation();&#13;
        });&#13;
        presenter.view.addEventListener("touchend", presenter.clickHandler);&#13;
        presenter.view.addEventListener("click", presenter.clickHandler);&#13;
        presenter.view.addEventListener("DOMNodeRemoved", presenter.destroy);&#13;
    }&#13;
&#13;
    presenter.clickHandler = function (event) {&#13;
        if (event !== undefined) {&#13;
            event.stopPropagation();&#13;
        }&#13;
        let eventData = presenter.createEventData(presenter.currentAnimationIndex, 1, "");&#13;
        presenter.eventBus.sendEvent("ValueChanged", eventData);&#13;
    };&#13;
&#13;
    function attachRunEventListenersToAnimationElement (animation, index, isPreview) {&#13;
        if (!isPreview) {&#13;
            animation.addEventListener("load", (e) =&gt; presenter.onAnimationLoadForRun(e, index));&#13;
            animation.addEventListener("error", (e) =&gt; presenter.onAnimationErrorForRun(e, index));&#13;
            animation.addEventListener("ready", (e) =&gt; presenter.onAnimationReadyForRun(e, index));&#13;
            animation.addEventListener("play", (e) =&gt; presenter.onAnimationPlayForRun(e, index));&#13;
            animation.addEventListener("pause", (e) =&gt; presenter.onAnimationPauseForRun(e, index));&#13;
            animation.addEventListener("stop", (e) =&gt; presenter.onAnimationStopForRun(e, index));&#13;
            animation.addEventListener("freeze", (e) =&gt; presenter.onAnimationFreezeForRun(e, index));&#13;
            animation.addEventListener("loop", (e) =&gt; presenter.onAnimationLoopForRun(e, index));&#13;
            animation.addEventListener("complete", (e) =&gt; presenter.onAnimationCompleteForRun(e, index));&#13;
&#13;
            if (presenter.configuration.sendEventOnEveryFrame) {&#13;
                animation.addEventListener("frame", (e) =&gt; presenter.onAnimationFrameForRun(e, index));&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.configuration.playInSuccession) {&#13;
            animation.addEventListener("ready", (e) =&gt; presenter.onAnimationReadyForPlayedInSuccession(e, index));&#13;
            animation.addEventListener("loop", (e) =&gt; presenter.onAnimationLoopForPlayedInSuccession(e, index));&#13;
            animation.addEventListener("complete", (e) =&gt; presenter.onAnimationCompleteForPlayedInSuccession(e, index));&#13;
        } else {&#13;
            animation.addEventListener("loop", (e) =&gt; presenter.onAnimationLoopForNotPlayedInSuccession(e, index));&#13;
        }&#13;
    }&#13;
&#13;
    presenter.onAnimationLoadForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "load");&#13;
    };&#13;
&#13;
    presenter.onAnimationErrorForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "error");&#13;
    };&#13;
&#13;
    presenter.onAnimationReadyForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "ready");&#13;
&#13;
        if (!presenter.previouslyVisited&#13;
            &amp;&amp; index !== presenter.currentAnimationIndex&#13;
            &amp;&amp; isAnimationAutoplay(index)) {&#13;
            presenter.animationsElements[index].stop();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onAnimationReadyForPlayedInSuccession = function (event, index) {&#13;
        if (!presenter.previouslyVisited&#13;
            &amp;&amp; index === presenter.currentAnimationIndex&#13;
            &amp;&amp; !presenter.configuration.animations[index].isAutoplay) {&#13;
            presenter.animationsElements[index].play();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onAnimationReadyForSetState = function (event, index, currentFrame) {&#13;
        setCurrentFrameForAnimation(index, currentFrame);&#13;
&#13;
        if (isAnimationStopped(index)) {&#13;
            presenter.animationsElements[index].stop()&#13;
        } else if (isAnimationPaused(index)) {&#13;
            presenter.animationsElements[index].pause();&#13;
        } else if (isAnimationFrozen(index)) {&#13;
            presenter.animationsElements[index].freeze();&#13;
        } else if (isAnimationPlaying(index)) {&#13;
            presenter.animationsElements[index].play();&#13;
        }&#13;
    }&#13;
&#13;
    function setCurrentFrameForAnimation(animationIndex, currentFrame) {&#13;
        if (currentFrame) {&#13;
            presenter.animationsElements[animationIndex].seek(Math.floor(currentFrame));&#13;
        }&#13;
    }&#13;
&#13;
    presenter.onAnimationPlayForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "play");&#13;
        setAnimationStateAsPlaying(index);&#13;
    };&#13;
&#13;
    presenter.onAnimationPauseForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "pause");&#13;
        setAnimationStateAsPaused(index);&#13;
    };&#13;
&#13;
    presenter.onAnimationFreezeForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "freeze");&#13;
        setAnimationStateAsFrozen(index);&#13;
    };&#13;
&#13;
    presenter.onAnimationStopForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "stop");&#13;
        setAnimationStateAsStopped(index);&#13;
    };&#13;
&#13;
    presenter.onAnimationFrameForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "frame");&#13;
    };&#13;
&#13;
    presenter.onAnimationCompleteForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "complete");&#13;
&#13;
        if (presenter.configuration.animations[index].isLoop &amp;&amp; presenter.configuration.animations[index].loopsNumber) {&#13;
            increaseAnimationPlayedLoops(index);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onAnimationCompleteForPlayedInSuccession = function (event, index) {&#13;
        jumpToNextAnimationInSuccession();&#13;
    };&#13;
&#13;
    presenter.onAnimationLoopForRun = function (event, index) {&#13;
        presenter.sendOnAnimationChangeEvent(index, "loop");&#13;
    };&#13;
&#13;
    presenter.onAnimationLoopForPlayedInSuccession = function (event, index) {&#13;
        if (!isAnimationFinishedLoops(index)) {&#13;
            increaseAnimationPlayedLoops(index);&#13;
        } else {&#13;
            resetAnimationPlayedLoops(index);&#13;
            jumpToNextAnimationInSuccession();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onAnimationLoopForNotPlayedInSuccession = function (event, index) {&#13;
        if (!isAnimationFinishedLoops(index)) {&#13;
            increaseAnimationPlayedLoops(index);&#13;
        }&#13;
    };&#13;
&#13;
    function isAnimationAutoplay (animationIndex) {&#13;
        return presenter.configuration.animations[animationIndex].isAutoplay || presenter.configuration.playInSuccession;&#13;
    }&#13;
&#13;
    function jumpToNextAnimationInSuccession() {&#13;
        presenter.animationsElements[presenter.currentAnimationIndex].stop();&#13;
&#13;
        let nextIndex = presenter.currentAnimationIndex + 1;&#13;
        if (nextIndex &gt;= presenter.animationsElements.length) {&#13;
            if (!presenter.configuration.loopSuccession) return;&#13;
            nextIndex = 0;&#13;
        }&#13;
&#13;
        hideAnimationWithIndex(presenter.currentAnimationIndex);&#13;
        presenter.currentAnimationIndex = nextIndex;&#13;
        showAnimationWithIndex(presenter.currentAnimationIndex);&#13;
        if (presenter.keyboardControllerObject) {&#13;
            presenter.keyboardControllerObject.reloadElements();&#13;
        }&#13;
        presenter.animationsElements[presenter.currentAnimationIndex].play();&#13;
        if (presenter.isTTS() &amp;&amp; !presenter.keyboardControllerObject.isReadInSuccession[presenter.currentAnimationIndex]){&#13;
            presenter.keyboardControllerObject.isReadInSuccession[presenter.currentAnimationIndex] = true;&#13;
            presenter.keyboardControllerObject.speakEnterAction();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.sendOnAnimationChangeEvent = function (item, value) {&#13;
        const eventData = presenter.createEventData(item, value);&#13;
        presenter.eventBus.sendEvent("ValueChanged", eventData);&#13;
    };&#13;
&#13;
    presenter.createEventData = function (item, value) {&#13;
        return {&#13;
            source: "" + presenter.configuration.addonID,&#13;
            item: "" + item,&#13;
            value: "" + value,&#13;
            score: "",&#13;
        };&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        let animationsStates = [];&#13;
        presenter.animationsStates.forEach(animationState =&gt;&#13;
            animationsStates.push(animationState.serialize())&#13;
        )&#13;
&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.isVisible,&#13;
            currentAnimationIndex: presenter.currentAnimationIndex,&#13;
            animationsStates: presenter.animationsStates,&#13;
            animationsSavedFrames: getCurrentAnimationsFrames(),&#13;
            previouslyVisited: true,&#13;
        });&#13;
    };&#13;
&#13;
    function getCurrentAnimationsFrames () {&#13;
        let currentFrames = [];&#13;
        presenter.animationsElements.forEach(animationElement =&gt;  {&#13;
            if (isAnimationPlayerDOMCreated(animationElement)) {&#13;
                currentFrames.push(animationElement.getLottie().currentFrame);&#13;
            }&#13;
        })&#13;
        return currentFrames;&#13;
    }&#13;
&#13;
    function isAnimationPlayerDOMCreated(animationElement) {&#13;
        return animationElement.shadowRoot &amp;&amp; animationElement.shadowRoot.childNodes &amp;&amp; animationElement.shadowRoot.childNodes[2];&#13;
    }&#13;
&#13;
    presenter.setState = function (state) {&#13;
        let parsedState = JSON.parse(state);&#13;
        presenter.setVisibility(parsedState.isVisible);&#13;
        presenter.previouslyVisited = parsedState.previouslyVisited;&#13;
        presenter.currentAnimationIndex = parsedState.currentAnimationIndex;&#13;
&#13;
        presenter.animationsStates = new Array(parsedState.animationsStates.length).fill(null);&#13;
        parsedState.animationsStates.forEach((savedAnimationState, index) =&gt; {&#13;
            let animationState = new AnimationState(index);&#13;
            animationState.deserialize(savedAnimationState);&#13;
            presenter.animationsStates[animationState.index] = animationState;&#13;
        })&#13;
&#13;
        presenter.animationsElements = findAnimationsElements();&#13;
        presenter.displayCurrentAnimation();&#13;
&#13;
        presenter.animationsElements.forEach((animationElement, index) =&gt; {&#13;
            animationElement.addEventListener("ready",&#13;
                (e) =&gt; presenter.onAnimationReadyForSetState(e, index, parsedState.animationsSavedFrames[index]))&#13;
        })&#13;
    };&#13;
&#13;
    presenter.displayCurrentAnimation = function () {&#13;
        presenter.animationsElements.forEach((element, index) =&gt; {&#13;
            if (index === presenter.currentAnimationIndex) {&#13;
                showAnimation(element);&#13;
            } else {&#13;
                hideAnimation(element);&#13;
            }&#13;
        })&#13;
    };&#13;
&#13;
    function findAnimationsElements () {&#13;
        return presenter.view.querySelectorAll("lottie-player");&#13;
    }&#13;
&#13;
    function hideAnimationWithIndex (animationIndex) {&#13;
        hideAnimation(presenter.animationsElements[animationIndex]);&#13;
    }&#13;
&#13;
    function hideAnimation (animationElement) {&#13;
        if (animationElement.classList.contains(presenter.CSS_CLASSES.VISIBLE_ANIMATION)) {&#13;
            animationElement.classList.remove(presenter.CSS_CLASSES.VISIBLE_ANIMATION);&#13;
        }&#13;
        animationElement.classList.add(presenter.CSS_CLASSES.INVISIBLE_ANIMATION);&#13;
    }&#13;
&#13;
    function showAnimationWithIndex (animationIndex) {&#13;
        showAnimation(presenter.animationsElements[animationIndex]);&#13;
    }&#13;
&#13;
    function showAnimation (animationElement) {&#13;
        if (animationElement.classList.contains(presenter.CSS_CLASSES.INVISIBLE_ANIMATION)) {&#13;
            animationElement.classList.remove(presenter.CSS_CLASSES.INVISIBLE_ANIMATION);&#13;
        }&#13;
        animationElement.classList.add(presenter.CSS_CLASSES.VISIBLE_ANIMATION);&#13;
    }&#13;
&#13;
    presenter.setWCAGStatus = function(isWCAGOn) {&#13;
        presenter.isWCAGOn = isWCAGOn;&#13;
    };&#13;
&#13;
    presenter.buildKeyboardController = function () {&#13;
        presenter.keyboardControllerObject&#13;
            = new LottiePlayerKeyboardController([], 1);&#13;
    };&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        let currentAnimation = presenter.$view.find(`.${presenter.CSS_CLASSES.VISIBLE_ANIMATION}`);&#13;
        let animations = $(currentAnimation[0].shadowRoot.childNodes[2].children[1]).find(`&#13;
            #${presenter.DOM_IDS.PLAY_BUTTON},&#13;
            #${presenter.DOM_IDS.STOP_BUTTON},&#13;
            #${presenter.DOM_IDS.LOOP_BUTTON}&#13;
        `);&#13;
        return animations&#13;
    };&#13;
&#13;
    function LottiePlayerKeyboardController(elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
        this.isReadInSuccession = new Array(presenter.animationsElements.length).fill(false);&#13;
    }&#13;
&#13;
    presenter.isTTS = function () {&#13;
        return presenter.isWCAGOn &amp;&amp; presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
    };&#13;
&#13;
    presenter.keyboardController = function (keycode, isShiftKeyDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype = Object.create(KeyboardController.prototype);&#13;
    LottiePlayerKeyboardController.prototype.constructor = LottiePlayerKeyboardController;&#13;
&#13;
    LottiePlayerKeyboardController.prototype.reloadElements = function () {&#13;
        let elements = presenter.getElementsForKeyboardNavigation();&#13;
&#13;
        for (let i = 0; i &lt; this.keyboardNavigationElementsLen; i++) {&#13;
            this.unmark(this.keyboardNavigationElements[i]);&#13;
        }&#13;
        this.removeEventListeners();&#13;
&#13;
        this.keyboardNavigationElements = elements;&#13;
        this.keyboardNavigationElementsLen = elements.length;&#13;
        this.attachEventListeners();&#13;
&#13;
        if (!this.keyboardNavigationActive) {&#13;
            this.keyboardNavigationCurrentElementIndex = 0;&#13;
            this.keyboardNavigationCurrentElement = this.keyboardNavigationElements[0];&#13;
            return;&#13;
        }&#13;
&#13;
        this.keyboardNavigationCurrentElement = this.keyboardNavigationElements[this.keyboardNavigationCurrentElementIndex];&#13;
        this.mark(this.keyboardNavigationCurrentElement)&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.attachEventListeners = function () {&#13;
        for (let i = 0; i &lt; this.keyboardNavigationElementsLen; i++) {&#13;
            let element = this.keyboardNavigationElements[i];&#13;
            let $element = $(element);&#13;
            if (hasId($element, presenter.DOM_IDS.PLAY_BUTTON)) {&#13;
                element.addEventListener("click", this.onPlayButtonClick);&#13;
            } else if (hasId($element, presenter.DOM_IDS.STOP_BUTTON)) {&#13;
                element.addEventListener("click", this.onStopButtonClick);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.removeEventListeners = function () {&#13;
        for (let i = 0; i &lt; this.keyboardNavigationElementsLen; i++) {&#13;
            let element = this.keyboardNavigationElements[i];&#13;
            let $element = $(element);&#13;
            if (hasId($element, presenter.DOM_IDS.PLAY_BUTTON)) {&#13;
                element.removeEventListener("click", this.onPlayButtonClick, false);&#13;
            } else if (hasId($element, presenter.DOM_IDS.STOP_BUTTON)) {&#13;
                element.removeEventListener("click", this.onStopButtonClick, false);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.onPlayButtonClick = function (event) {&#13;
        if (presenter.isTTS()) {&#13;
            if (presenter.animationsElements[presenter.currentAnimationIndex].getLottie().isPaused === true) {&#13;
                presenter.keyboardControllerObject.speakPaused();&#13;
            } else {&#13;
                presenter.keyboardControllerObject.speakAlternativeText();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.onStopButtonClick = function (event) {&#13;
        if (presenter.isTTS()) {&#13;
            presenter.keyboardControllerObject.speakStopped();&#13;
        }&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.mark = function (element) {&#13;
        if (element)&#13;
            element.setAttribute("part", "keyboard_navigation_active_element");&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.unmark = function (element) {&#13;
        if (element)&#13;
            element.removeAttribute("part");&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.nextElement = function (event) {&#13;
        KeyboardController.prototype.nextElement.call(this, event);&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.previousElement = function (event) {&#13;
        KeyboardController.prototype.previousElement.call(this, event);&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.nextRow = function (event) {&#13;
        KeyboardController.prototype.nextRow.call(this, event);&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.previousRow = function (event) {&#13;
        KeyboardController.prototype.previousRow.call(this, event);&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.enter = function (event) {&#13;
        if (!this.keyboardNavigationActive) {&#13;
            this.reloadElements();&#13;
            this.isReadInSuccession = new Array(presenter.animationsElements.length).fill(false);&#13;
            if (presenter.configuration.playInSuccession) {&#13;
                this.isReadInSuccession[presenter.currentAnimationIndex] = true;&#13;
            }&#13;
        }&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
        this.speakEnterAction();&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.readCurrentElement = function () {&#13;
        let $element = this.getCurrentElement();&#13;
&#13;
        if (hasId($element, presenter.DOM_IDS.PLAY_BUTTON)) {&#13;
            if (presenter.animationsElements[presenter.currentAnimationIndex].getLottie().isPaused === true) {&#13;
                this.speakPlayButton();&#13;
            } else {&#13;
                this.speakPauseButton();&#13;
            }&#13;
        } else if (hasId($element, presenter.DOM_IDS.STOP_BUTTON)) {&#13;
            this.speakStopButton();&#13;
        } else if (hasId($element, presenter.DOM_IDS.LOOP_BUTTON)) {&#13;
            this.speakLoopButton();&#13;
        }&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.getCurrentElement = function () {&#13;
        return this.getTarget(this.keyboardNavigationCurrentElement, false);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.getTarget = function (element, willBeClicked) {&#13;
        return $(element);&#13;
    };&#13;
&#13;
    function hasId($element, id) {&#13;
        return $element.attr("id") === id;&#13;
    }&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakEnterAction = function () {&#13;
        if (presenter.animationsElements[presenter.currentAnimationIndex].getLottie().isPaused === true){&#13;
            this.speakPreviewAlternativeText();&#13;
        } else {&#13;
            this.speakAlternativeText();&#13;
        }&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakPlayButton = function () {&#13;
        this.speakWithLanguageFromLesson(presenter.speechTexts.PlayButton);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakPauseButton = function () {&#13;
        this.speakWithLanguageFromLesson(presenter.speechTexts.PauseButton);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakStopButton = function () {&#13;
        this.speakWithLanguageFromLesson(presenter.speechTexts.StopButton);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakLoopButton = function () {&#13;
        this.speakWithLanguageFromLesson(presenter.speechTexts.LoopButton);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakStopped = function () {&#13;
        this.speakWithLanguageFromLesson(presenter.speechTexts.Stopped);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakPaused = function () {&#13;
        this.speakWithLanguageFromLesson(presenter.speechTexts.Paused);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakAlternativeText = function () {&#13;
        this.speakWithLanguageFromPresenter(presenter.configuration.animations[presenter.currentAnimationIndex].altText);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakPreviewAlternativeText = function () {&#13;
        this.speakWithLanguageFromPresenter(presenter.configuration.animations[presenter.currentAnimationIndex].altTextPreview);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakWithLanguageFromLesson = function (message) {&#13;
        this.speakMessage(message, false);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakWithLanguageFromPresenter = function (message) {&#13;
        this.speakMessage(message, true);&#13;
    };&#13;
&#13;
    LottiePlayerKeyboardController.prototype.speakMessage = function (message, isLangFromPresenter = true) {&#13;
        let textVoices = [];&#13;
        if (isLangFromPresenter) {&#13;
            textVoices.push(window.TTSUtils.getTextVoiceObject(message, presenter.configuration.langTag));&#13;
        } else {&#13;
            textVoices.push(window.TTSUtils.getTextVoiceObject(message));&#13;
        }&#13;
        presenter.speak(textVoices);&#13;
    };&#13;
&#13;
    presenter.speak = function (data) {&#13;
        let tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function (playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.destroy = function (event) {&#13;
        presenter.removeEventListeners(presenter.isPreview);&#13;
&#13;
        if (presenter.playerController &amp;&amp; !presenter.playerController.isPlayerInCrossDomain()) {&#13;
            $(window.parent.document).unbind("scroll");&#13;
        }&#13;
    };&#13;
&#13;
    presenter.removeEventListeners = function (isPreview) {&#13;
        if (!isPreview) {&#13;
            removeEventListenersToView();&#13;
        }&#13;
        presenter.animationsElements.forEach(&#13;
            (animation, index) =&gt; removeRunEventListenersToAnimationElement(animation, index, isPreview)&#13;
        );&#13;
        presenter.keyboardControllerObject.removeEventListeners();&#13;
    };&#13;
&#13;
    function removeEventListenersToView () {&#13;
        presenter.view.removeEventListener("touchstart", (e) =&gt; {&#13;
            e.stopPropagation();&#13;
        }, false);&#13;
        presenter.view.removeEventListener("touchend", presenter.clickHandler, false);&#13;
        presenter.view.removeEventListener("click", presenter.clickHandler, false);&#13;
        presenter.view.removeEventListener("DOMNodeRemoved", presenter.destroy, false);&#13;
    }&#13;
&#13;
    function removeRunEventListenersToAnimationElement (animation, index, isPreview) {&#13;
        if (!isPreview) {&#13;
            animation.removeEventListener("load", (e) =&gt; presenter.onAnimationLoadForRun(e, index), false);&#13;
            animation.removeEventListener("error", (e) =&gt; presenter.onAnimationErrorForRun(e, index), false);&#13;
            animation.removeEventListener("ready", (e) =&gt; presenter.onAnimationReadyForRun(e, index), false);&#13;
            animation.removeEventListener("play", (e) =&gt; presenter.onAnimationPlayForRun(e, index), false);&#13;
            animation.removeEventListener("pause", (e) =&gt; presenter.onAnimationPauseForRun(e, index), false);&#13;
            animation.removeEventListener("stop", (e) =&gt; presenter.onAnimationStopForRun(e, index), false);&#13;
            animation.removeEventListener("freeze", (e) =&gt; presenter.onAnimationFreezeForRun(e, index), false);&#13;
            animation.removeEventListener("loop", (e) =&gt; presenter.onAnimationLoopForRun(e, index), false);&#13;
            animation.removeEventListener("complete", (e) =&gt; presenter.onAnimationCompleteForRun(e, index), false);&#13;
&#13;
            if (presenter.configuration.sendEventOnEveryFrame) {&#13;
                animation.removeEventListener("frame", (e) =&gt; presenter.onAnimationFrameForRun(e, index), false);&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.configuration.playInSuccession) {&#13;
            animation.removeEventListener("ready", (e) =&gt; presenter.onAnimationReadyForPlayedInSuccession(e, index), false);&#13;
            animation.removeEventListener("loop", (e) =&gt; presenter.onAnimationLoopForPlayedInSuccession(e, index), false);&#13;
            animation.removeEventListener("complete", (e) =&gt; presenter.onAnimationCompleteForPlayedInSuccession(e, index), false);&#13;
        } else {&#13;
            animation.removeEventListener("loop", (e) =&gt; presenter.onAnimationLoopForNotPlayedInSuccession(e, index), false);&#13;
        }&#13;
        if (presenter.previouslyVisited) {&#13;
            animation.removeEventListener("ready", (e) =&gt; presenter.onAnimationReadyForSetState(e, index), false);&#13;
        }&#13;
    }&#13;
&#13;
    function setAnimationStateAsPlaying(index){&#13;
        return presenter.animationsStates[index].play();&#13;
    }&#13;
&#13;
    function setAnimationStateAsStopped(index){&#13;
        return presenter.animationsStates[index].stop();&#13;
    }&#13;
&#13;
    function setAnimationStateAsPaused(index){&#13;
        return presenter.animationsStates[index].pause();&#13;
    }&#13;
&#13;
    function setAnimationStateAsFrozen(index){&#13;
        return presenter.animationsStates[index].freeze();&#13;
    }&#13;
&#13;
    function isAnimationPlaying (index) {&#13;
        return presenter.animationsStates[index].isPlaying();&#13;
    }&#13;
&#13;
    function isAnimationStopped (index) {&#13;
        return presenter.animationsStates[index].isStopped();&#13;
    }&#13;
&#13;
    function isAnimationPaused (index) {&#13;
        return presenter.animationsStates[index].isPaused();&#13;
    }&#13;
&#13;
    function isAnimationFrozen (index) {&#13;
        return presenter.animationsStates[index].isFrozen();&#13;
    }&#13;
&#13;
    function increaseAnimationPlayedLoops (index) {&#13;
        return presenter.animationsStates[index].increasePlayedLoops()&#13;
    }&#13;
&#13;
    function resetAnimationPlayedLoops (index) {&#13;
        return presenter.animationsStates[index].resetPlayedLoops()&#13;
    }&#13;
&#13;
    function isAnimationFinishedLoops (index) {&#13;
        if (presenter.configuration.animations[index].loopsNumber === null) {&#13;
            return false;&#13;
        }&#13;
        return presenter.animationsStates[index].playedLoops === presenter.configuration.animations[index].loopsNumber;&#13;
    }&#13;
&#13;
    function AnimationState (index) {&#13;
        this.index = index;&#13;
&#13;
        this.playedLoops = 0;&#13;
        this.status = this.STATUES.STOPPED;&#13;
    }&#13;
&#13;
    AnimationState.prototype.STATUES = {&#13;
        STOPPED: 0,&#13;
        PLAYING: 1,&#13;
        PAUSED: 2,&#13;
        FROZEN: 3&#13;
    };&#13;
&#13;
    AnimationState.prototype.serialize = function () {&#13;
        return {&#13;
            index: this.index,&#13;
            status: this.status,&#13;
            playedLoops: this.playedLoops&#13;
        };&#13;
    };&#13;
&#13;
    AnimationState.prototype.deserialize = function (obj) {&#13;
        this.index = obj.index;&#13;
        this.status = obj.status;&#13;
        this.playedLoops = obj.playedLoops;&#13;
    };&#13;
&#13;
    AnimationState.prototype.increasePlayedLoops = function () {&#13;
        this.playedLoops++;&#13;
    };&#13;
&#13;
    AnimationState.prototype.resetPlayedLoops = function () {&#13;
        this.playedLoops = 0;&#13;
    };&#13;
&#13;
    AnimationState.prototype.play = function () {&#13;
        this.status = this.STATUES.PLAYING;&#13;
    };&#13;
&#13;
    AnimationState.prototype.stop = function () {&#13;
        this.status = this.STATUES.STOPPED;&#13;
    };&#13;
&#13;
    AnimationState.prototype.pause = function () {&#13;
        this.status = this.STATUES.PAUSED;&#13;
    };&#13;
&#13;
    AnimationState.prototype.freeze = function () {&#13;
        this.status = this.STATUES.FROZEN;&#13;
    };&#13;
&#13;
    AnimationState.prototype.isPlaying = function () {&#13;
        return this.status === this.STATUES.PLAYING;&#13;
    };&#13;
&#13;
    AnimationState.prototype.isStopped = function () {&#13;
        return this.status === this.STATUES.STOPPED;&#13;
    };&#13;
&#13;
    AnimationState.prototype.isPaused = function () {&#13;
        return this.status === this.STATUES.PAUSED;&#13;
    };&#13;
&#13;
    AnimationState.prototype.isFrozen = function () {&#13;
        return this.status === this.STATUES.FROZEN;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>