<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Line_Number" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="Decimal Separator" nameLabel="Line_Number_property_decimal_separator" type="string"/>
        <property name="Min" nameLabel="Line_Number_property_min" type="string"/>
        <property name="Max" nameLabel="Line_Number_property_max" type="string"/>
        <property name="Ranges" nameLabel="Line_Number_property_ranges" type="text"/>
        <property name="Not Activity" nameLabel="Line_Number_property_not_activity" type="boolean"/>
        <property name="Step" nameLabel="Line_Number_property_step" type="string"/>
        <property name="Show Axis X Values" nameLabel="Line_Number_property_show_axis_x_values" type="boolean"/>
        <property name="Axis X Values" nameLabel="Line_Number_property_axis_x_values" type="string"/>
        <property name="Disable" nameLabel="Line_Number_property_disable" type="boolean"/>
        <property name="Don't show ranges" nameLabel="Line_Number_property_dont_show_ranges" type="boolean"/>
    </model>
<css>.addon_Line_Number .outer .infinity-left,&#13;
.addon_Line_Number .outer .infinity-right {&#13;
    height: 100%;&#13;
    width: 5%;&#13;
    position: absolute;&#13;
    z-index: 9;&#13;
}&#13;
&#13;
.addon_Line_Number .outer .infinity-left {&#13;
    left: 0px;&#13;
}&#13;
&#13;
.addon_Line_Number .outer .infinity-right {&#13;
    right: 0px;&#13;
}&#13;
&#13;
.addon_Line_Number .outer {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    background-color: #f3f3f3;&#13;
    position: relative;&#13;
}&#13;
&#13;
.addon_Line_Number .inner {&#13;
    width: 90%;&#13;
    height: 100%;&#13;
    position: absolute;&#13;
    left: 5%;&#13;
    background-color: #fefefe;&#13;
}&#13;
&#13;
.addon_Line_Number .x-axis {&#13;
    width: 100%;&#13;
    height: 2px;&#13;
    min-height: 2px;&#13;
    max-height: 2px;&#13;
    position: absolute;&#13;
    z-index: 12;&#13;
    top: 50%;&#13;
    background-color: #111;&#13;
}&#13;
&#13;
.addon_Line_Number .stepLine {&#13;
    width: 2px;&#13;
    height: 8px;&#13;
    min-height: 8px;&#13;
    background-color: #111;&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    margin-top: -4px;&#13;
}&#13;
&#13;
.addon_Line_Number .rangeImage, .addon_Line_Number .currentMousePosition {&#13;
    background-repeat: no-repeat;&#13;
    width: 12px;&#13;
    height: 12px;&#13;
    position: absolute;&#13;
    left: -5px;&#13;
    top: -1px;&#13;
    z-index: 11;&#13;
    background-size: 12px 12px;&#13;
}&#13;
&#13;
.addon_Line_Number .exclude {&#13;
    background-image: url('resources/range_exclude.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .include {&#13;
    background-image: url('resources/range_include.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .correctRangeExclude {&#13;
    background-image: url('resources/correct_range_exclude.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .correctRangeInclude {&#13;
    background-image: url('resources/correct_range_include.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .wrongRangeExclude {&#13;
    background-image: url('resources/wrong_range_exclude.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .wrongRangeInclude {&#13;
    background-image: url('resources/wrong_range_include.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .clickArea {&#13;
    width: 10px;&#13;
    height: 50px;&#13;
    top: -25px;&#13;
    min-height: 10px;&#13;
    min-width: 10px;&#13;
    position: absolute;&#13;
    z-index: 12;&#13;
    overflow: hidden;&#13;
}&#13;
&#13;
.addon_Line_Number .stepText {&#13;
    position: absolute;&#13;
    font-size: 12px;&#13;
    top: 10px;&#13;
    white-space: nowrap;&#13;
}&#13;
&#13;
.addon_Line_Number .x-arrow {&#13;
    border-bottom: 6px solid transparent;&#13;
    border-left: 6px solid black;&#13;
    border-top: 6px solid transparent;&#13;
    right: -5px;&#13;
    top: -5px;&#13;
    position: absolute;&#13;
}&#13;
&#13;
.addon_Line_Number .clickArea:hover,&#13;
.addon_Line_Number .outer .infinity-left:hover,&#13;
.addon_Line_Number .outer .infinity-right:hover {&#13;
    cursor: pointer;&#13;
}&#13;
&#13;
.addon_Line_Number .selectedRange {&#13;
    background-color: #00bb44;&#13;
    box-shadow: 0px 0px 1px #111;&#13;
    min-height: 10px;&#13;
    height: 10px;&#13;
    min-width: 2px;&#13;
    width: 2px;&#13;
    top: -7px;&#13;
    position: absolute;&#13;
    z-index: 10;&#13;
    border-radius: 5px 5px 0px 0px;&#13;
}&#13;
&#13;
.addon_Line_Number .currentSelectedRange {&#13;
    background-color: #00aaff;&#13;
}&#13;
&#13;
.addon_Line_Number .correct {&#13;
    background-color: #00ff44;&#13;
}&#13;
&#13;
.addon_Line_Number .wrong {&#13;
    background-color: #ff3344;&#13;
}&#13;
&#13;
.addon_Line_Number .currentMousePosition {&#13;
    background-image: url('resources/current_mouse_pos.svg');&#13;
}&#13;
&#13;
.addon_Line_Number .infinityLeft {&#13;
    border-radius: 0px 5px 0px 0px;&#13;
}&#13;
&#13;
.addon_Line_Number .infinityRight {&#13;
    border-radius: 5px 0px 0px 0px;&#13;
}&#13;
&#13;
.addon_Line_Number .infinityBoth {&#13;
    border-radius: 0px;&#13;
}&#13;
&#13;
.addon_Line_Number .infinity-hover {&#13;
    background-color: #d8d8d8;&#13;
}&#13;
</css><view>&lt;div class="outer"&gt;&#13;
    &lt;div class="infinity-left" value="-INF"&gt;&lt;/div&gt;&#13;
        &lt;div class="inner"&gt;&#13;
            &lt;div class="x-axis"&gt;&#13;
                &lt;div class="x-arrow"&gt;&lt;/div&gt;&#13;
            &lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
    &lt;div class="infinity-right" value="INF"&gt;&lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="outer"&gt;&#13;
    &lt;div class="infinity-left" value="-INF"&gt;&lt;/div&gt;&#13;
    &lt;div class="inner"&gt;&#13;
        &lt;div class="x-axis"&gt;&#13;
            &lt;div class="x-arrow"&gt;&lt;/div&gt;&#13;
        &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
    &lt;div class="infinity-right" value="INF"&gt;&lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonLine_Number_create() {&#13;
    /*&#13;
        KNOWN ISSUES:&#13;
            PROPERTIES:&#13;
                Axis X Values:&#13;
                    0* - due to backward compatybility it should be treaten as 1*&#13;
&#13;
            (04.13.2015) CLICK &amp; DRAWING RANGES LOGIC:&#13;
                Due to logic of drawing ranges, presenter.configuration.max should be set before creating steps as a max&#13;
                value from field values. Changing this logic will break user click logic, which will not draw range to&#13;
                infinity right.&#13;
&#13;
&#13;
     */&#13;
&#13;
    var presenter = function() {};&#13;
&#13;
    var eventBus,&#13;
        playerController;&#13;
&#13;
    presenter.configuration = {};&#13;
    presenter.checkedPoints = [];&#13;
&#13;
&#13;
    presenter.startElement;&#13;
    presenter.endElement;&#13;
&#13;
    presenter.results = {&#13;
        correct: 0,&#13;
        wrong: 0&#13;
    };&#13;
    presenter.singleDot = {&#13;
        value: -1,&#13;
        element: null&#13;
    };&#13;
&#13;
    presenter.maxElement = function (array) {&#13;
        if (array.length == 0) {&#13;
            throw "Empty array";&#13;
        }&#13;
&#13;
        return Math.max.apply(null, array);&#13;
    };&#13;
&#13;
    presenter.errorCodes = {&#13;
        'MIN01' : 'Min value cannot be empty.',&#13;
        'MIN02' : 'Min value must be a number.',&#13;
        'MIN03' : 'Min value does not fit the separator.',&#13;
        'MAX01' : 'Max value cannot be empty.',&#13;
        'MAX02' : 'Max value must be a number',&#13;
        'MAX03' : 'Max value does not fit the separator.',&#13;
        'MAX04' : 'Max value must be within xAxisValues. Suggested value: {{lastValue}} or {{lastValuePlusStep}}.',&#13;
        'MIN/MAX01' : 'Min value cannot be greater than Max value.',&#13;
        'RAN01' : 'One or more ranges are invalid.',&#13;
        'RAN02' : 'One or more ranges are invalid. Please make sure, that all ranges start/end can be displayed on X axis.',&#13;
        'STEP01' : 'The value in Step property is invalid.',&#13;
        'STEP02' : 'The value in Step does not fit the separator.',&#13;
        'STEP03' : 'The value in step property have to be greater than 0',&#13;
        'VAL01' : 'One or more X axis values are invalid.',&#13;
        'VAL02' : 'One or more X axis do not fit the separator.',&#13;
        'OOR01' : 'Can not resolve which range is currently selected.',&#13;
        'DSE01' : 'Semicolon is a reserved symbol.',&#13;
        'AXV_01': "Axis X cyclic values have to be greater or equal than 0.",&#13;
        'AXV_02': "Axis X fixed values have to be greater or equal than Min.",&#13;
        'AXV_03': "Axis X fixed values have to be lower or equal than Max.",&#13;
        'AXV_04': "Axis X Values property can have only number values.",&#13;
        'AXV_05': "Axis X Valuese property cant have duplicates."&#13;
    };&#13;
&#13;
    presenter.CLICKED_POSITION = {&#13;
        START: 1,&#13;
        MIDDLE: 2,&#13;
        END: 3,&#13;
        NONE: 4&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
&#13;
        eventBus.addEventListener('ShowAnswers', this);&#13;
        eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.removeZIndexes = function () {&#13;
        var selector = '.outer .infinity-left, .outer .infinity-right, .x-axis, .rangeImage, .addon_Line_Number .currentMousePosition, .clickArea, .selectedRange';&#13;
        presenter.$view.find(selector).css('z-index', '0');&#13;
    };&#13;
&#13;
    function addInitPoints () {&#13;
        var points = presenter.configuration.shouldDrawRanges;&#13;
        for (var i = 0; i &lt; points.length; i++) {&#13;
            if (points[i].start.value === points[i].end.value) {&#13;
                presenter.checkedPoints.push(points[i].values[0]);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.presenterLogic = function (view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.$view.disableSelection();&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
&#13;
        presenter.configuration.isPreview = isPreview;&#13;
&#13;
        if ( presenter.configuration.isError ) {&#13;
            return DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, presenter.configuration.errorCode);&#13;
        }&#13;
&#13;
        presenter.createSteps();&#13;
&#13;
        var infinityleft = presenter.$view.find('.infinity-left');&#13;
        infinityleft.append("&lt;div class='startRange' style='top:42%;left:55%;pointer-events: none; visibility:hidden;'&gt;&lt;/div&gt;");&#13;
        var infinityright = presenter.$view.find('.infinity-right');&#13;
        infinityright.append("&lt;div class='startRange' style='top:42%;left:-1%;pointer-events: none; visibility:hidden;'&gt;&lt;/div&gt;");&#13;
&#13;
        if ( !isPreview &amp;&amp; !presenter.configuration.isDisabled &amp;&amp; !presenter.configuration.dontShowRanges) {&#13;
            presenter.bindInfinityAreas();&#13;
        }&#13;
&#13;
        presenter.drawRanges(presenter.configuration.shouldDrawRanges, true);&#13;
&#13;
        presenter.configuration.isInitialDraw = false;&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            addInitPoints();&#13;
        }&#13;
&#13;
        if ( !presenter.configuration.isVisibleByDefault &amp;&amp; !isPreview) {&#13;
            presenter.hide();&#13;
        }&#13;
&#13;
        if ( isPreview ) {&#13;
            // z-index in Editor breaks down properties popups&#13;
            presenter.removeZIndexes();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.bindInfinityAreas = function() {&#13;
        var infinityLeft = presenter.$view.find('.infinity-left');&#13;
        var infinityRight = presenter.$view.find('.infinity-right');&#13;
&#13;
        if (MobileUtils.isMobileUserAgent(navigator.userAgent)) {&#13;
            infinityLeft.on('touchstart', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
&#13;
                presenter.configuration.touchData.lastEvent = e;&#13;
            });&#13;
&#13;
            infinityLeft.on('touchend', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
&#13;
                if (presenter.configuration.touchData.lastEvent.type != e.type) {&#13;
                    var eventData = event.touches[0] || event.changedTouches[0];&#13;
                    clickLogic(eventData.target);&#13;
                }&#13;
&#13;
            });&#13;
        }&#13;
        else {&#13;
            infinityLeft.on('click', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
                clickLogic($(e.target));&#13;
            });&#13;
        }&#13;
&#13;
        infinityLeft.hover(function() {&#13;
            infinityLeft.addClass('infinity-hover');&#13;
        }, function() {&#13;
            infinityLeft.removeClass('infinity-hover');&#13;
        });&#13;
&#13;
        if (MobileUtils.isMobileUserAgent(navigator.userAgent)) {&#13;
            infinityRight.on('touchstart', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
                presenter.configuration.touchData.lastEvent = e;&#13;
            });&#13;
&#13;
            infinityRight.on('touchend', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
&#13;
                if (presenter.configuration.touchData.lastEvent.type != e.type) {&#13;
                    var eventData = event.touches[0] || event.changedTouches[0];&#13;
                    clickLogic(eventData.target);&#13;
                }&#13;
            });&#13;
        }&#13;
        else {&#13;
            infinityRight.on('click', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
                clickLogic($(e.target));&#13;
            });&#13;
        }&#13;
&#13;
        infinityRight.hover(function () {&#13;
            infinityRight.addClass('infinity-hover');&#13;
        }, function () {&#13;
            infinityRight.removeClass('infinity-hover');&#13;
        });&#13;
    };&#13;
&#13;
    function calculateStepWidth(xAxisValues) {&#13;
        var xAxisWidth = presenter.$view.find('.x-axis').width();&#13;
        return xAxisWidth / (xAxisValues.length + 1);&#13;
    }&#13;
&#13;
    function setClickedRanges(e) {&#13;
        var ranges = presenter.configuration.drawnRangesData.ranges,&#13;
            value = parseRangeStartOrEnd($(e).attr('value'), presenter.configuration.separator);&#13;
&#13;
        presenter.configuration.mouseData.clickedRanges = [];&#13;
&#13;
        $.each(ranges, function() {&#13;
            if ( $.inArray(value, this.values) &gt;= 0  ) {&#13;
                presenter.configuration.mouseData.clickedRanges.push(this);&#13;
            }&#13;
        });&#13;
&#13;
    }&#13;
&#13;
    function getClickedRangePosition(e) {&#13;
        var range = presenter.configuration.mouseData.clickedRanges[0];&#13;
&#13;
        if ( $(e).attr('value') == '-INF' ) {&#13;
            return presenter.CLICKED_POSITION.START;&#13;
        } else if ( $(e).attr('value') == 'INF' ) {&#13;
            return presenter.CLICKED_POSITION.END;&#13;
        } else if (range.start.element[0] == $(e).parent()[0]) {&#13;
            return presenter.CLICKED_POSITION.START;&#13;
        } else if (range.end.element[0] == $(e).parent()[0]) {&#13;
            return presenter.CLICKED_POSITION.END;&#13;
        } else {&#13;
            return presenter.CLICKED_POSITION.MIDDLE;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.removeRange = function(range, removeIncludeImages) {&#13;
/*try{&#13;
			range = JSON.parse(range);&#13;
		}catch(e){}&#13;
&#13;
		try{&#13;
			range.values = JSON.parse(range.values);&#13;
		}catch(e){}*/&#13;
&#13;
		try{&#13;
        getSelectedRange(range).remove();&#13;
}catch(e){};&#13;
&#13;
        if (!range.values) { range.values = [] }&#13;
        var index = presenter.configuration.drawnRangesData.ranges.indexOf(range);&#13;
        if (index &gt;= 0) {&#13;
            var removed = presenter.configuration.drawnRangesData.ranges.splice(index, 1);&#13;
&#13;
            if (removeIncludeImages &amp;&amp; removed.length &gt; 0) {&#13;
                try{&#13;
                    var start = parseElement(removed[0].start.element);&#13;
                    var end = parseElement(removed[0].end.element);&#13;
                    $(start).find('.rangeImage').remove();&#13;
                    $(end).find('.rangeImage').remove();&#13;
                    $(start).find('.selectedRange').remove();&#13;
	            }catch(e){};&#13;
&#13;
	            try{&#13;
                    if( removed[0].start.element == null &amp;&amp; removed[0].end.element == null ){&#13;
                        var start = presenter.startElement;&#13;
                        var end = presenter.endElement&#13;
                        $(start).find('.rangeImage').remove();&#13;
                        $(end).find('.rangeImage').remove();&#13;
                        $(start).find('.selectedRange').remove();&#13;
                    }&#13;
&#13;
		        }catch(e){};&#13;
&#13;
            }&#13;
        }&#13;
&#13;
        $.each(range.values, function() {&#13;
            var value = parseRangeStartOrEnd(this, presenter.configuration.separator);&#13;
            var index = presenter.configuration.drawnRangesData.values.indexOf(value);&#13;
            presenter.configuration.drawnRangesData.values.splice(index, 1);&#13;
        });&#13;
&#13;
    };&#13;
&#13;
    function splitRange(range, e) {&#13;
&#13;
        presenter.removeRange(range, false);&#13;
        var clickedArea = $(e);&#13;
&#13;
        var firstRange = {&#13;
            'start' : range.start,&#13;
            'end' : createRangeElement(clickedArea, clickedArea.attr('value'), false)&#13;
        };&#13;
&#13;
        var secondRange = {&#13;
            'start' : firstRange.end,&#13;
            'end' : range.end&#13;
        };&#13;
&#13;
        presenter.drawRanges([firstRange, secondRange], true);&#13;
    }&#13;
&#13;
    function joinRanges(ranges) {&#13;
        var firstRange, secondRange;&#13;
        var min = 1000,&#13;
            max = -1000;&#13;
&#13;
        $.each(ranges, function() {&#13;
            if (this.end.value &gt; max) {&#13;
                max = this.end.value;&#13;
                secondRange = this;&#13;
            }&#13;
&#13;
            if (this.start.value &lt; min) {&#13;
                min = this.start.value;&#13;
                firstRange = this;&#13;
            }&#13;
        });&#13;
&#13;
        $.each(ranges, function() {&#13;
            presenter.removeRange(this, true);&#13;
        });&#13;
&#13;
        var joinedRange = {&#13;
            'start' : firstRange.start,&#13;
            'end' : secondRange.end&#13;
        };&#13;
&#13;
        removeRangesBetweenRange(joinedRange);&#13;
&#13;
        presenter.drawRanges([joinedRange], true);&#13;
&#13;
    }&#13;
&#13;
    function setClicks(e) {&#13;
&#13;
        var element = $(e);&#13;
        var position;&#13;
&#13;
        if ( presenter.isMouseAboveExistingRange(e) ) {&#13;
            position = getClickedRangePosition(e);&#13;
        } else {&#13;
            position = presenter.CLICKED_POSITION.NONE;&#13;
        }&#13;
&#13;
        var click = {&#13;
            element: element,&#13;
            position: position,&#13;
            time: (new Date()).getTime()&#13;
        };&#13;
&#13;
        presenter.configuration.mouseData.clicks.push( click );&#13;
    }&#13;
&#13;
    function displayCurrentMousePosition(e) {&#13;
        presenter.$view.find('.currentMousePosition').remove();&#13;
        var circle = $('&lt;div&gt;&lt;/div&gt;');&#13;
        circle.addClass('currentMousePosition');&#13;
        $(e).parent().append(circle);&#13;
    }&#13;
&#13;
    function hideCurrentMousePosition() {&#13;
        presenter.$view.find('.currentMousePosition').remove();&#13;
    }&#13;
&#13;
    function createClickArea(element, value) {&#13;
        var clickArea = $('&lt;div&gt;&lt;/div&gt;');&#13;
        var selectedRange = $('&lt;div&gt;&lt;/div&gt;');&#13;
        var startRange = $('&lt;div&gt;&lt;/div&gt;');&#13;
        clickArea.addClass('clickArea');&#13;
        selectedRange.addClass('selectedRange');&#13;
        startRange.addClass('startRange');&#13;
&#13;
        $(element).append(clickArea);&#13;
        $(element).append(startRange);&#13;
        clickArea.attr('value', value);&#13;
&#13;
        var width = presenter.configuration.stepWidth, left = - (presenter.configuration.stepWidth / 2) + 'px';&#13;
&#13;
        if ( value == presenter.configuration.min || value == presenter.configuration.max ) {&#13;
            width = width / 2;&#13;
        }&#13;
&#13;
        if ( value == presenter.configuration.min ) {&#13;
            left = 0;&#13;
        }&#13;
&#13;
        if ( value == presenter.configuration.max ) {&#13;
            left = - width;&#13;
        }&#13;
&#13;
        clickArea.css({&#13;
            'width' : width,&#13;
            'left' : left&#13;
        });&#13;
&#13;
    }&#13;
&#13;
    function bindClickAreaListeners(clickArea) {&#13;
        removeAllClickListeners();&#13;
&#13;
        if (MobileUtils.isMobileUserAgent(navigator.userAgent)) {&#13;
            clickArea.on('touchstart', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
&#13;
                presenter.configuration.touchData.lastEvent = e;&#13;
            });&#13;
&#13;
            clickArea.on('touchend', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
&#13;
                if ( presenter.configuration.touchData.lastEvent.type != e.type ) {&#13;
                    var eventData = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0] || e.originalEvent.targetTouches[0];&#13;
                    if (presenter.configuration.dontShowRanges) {&#13;
                        togglePoint($(eventData.target));&#13;
                    } else {&#13;
                        clickLogic($(eventData.target));&#13;
                    }&#13;
                }&#13;
            });&#13;
&#13;
            clickArea.on('click', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
        }&#13;
        else {&#13;
            clickArea.on('mouseleave', function (e) {&#13;
                e.stopPropagation();&#13;
                hideCurrentMousePosition();&#13;
            });&#13;
&#13;
            clickArea.on('mouseenter', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
                displayCurrentMousePosition($(e.target));&#13;
            });&#13;
&#13;
            clickArea.on('contextmenu', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
            });&#13;
&#13;
            clickArea.on('click', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
                if (presenter.configuration.dontShowRanges) {&#13;
                    togglePoint($(e.target));&#13;
                } else {&#13;
                    clickLogic($(e.target));&#13;
                }&#13;
            });&#13;
        }&#13;
    }&#13;
&#13;
    function removeAllClickListeners() {&#13;
        var clickArea = presenter.$view.find('.clickArea');&#13;
        var infinityLeft = presenter.$view.find('.infinity-left');&#13;
        var infinityRight = presenter.$view.find('.infinity-right');&#13;
        var listeners = 'mouseleave mouseenter contextmenu touchstart touchend click';&#13;
&#13;
        clickArea.off(listeners);&#13;
        infinityRight.off(listeners);&#13;
        infinityLeft.off(listeners);&#13;
    }&#13;
&#13;
    function isFirstClick() {&#13;
        return presenter.configuration.mouseData.clicks.length == 1;&#13;
    }&#13;
&#13;
    function isSecondClick() {&#13;
        return presenter.configuration.mouseData.clicks.length == 2;&#13;
    }&#13;
&#13;
    function areBothClicksNone() {&#13;
        return presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.NONE&#13;
            &amp;&amp; presenter.configuration.mouseData.clicks[1].position == presenter.CLICKED_POSITION.NONE;&#13;
    }&#13;
&#13;
    function isFirstClickNoneAndSecondNotNone() {&#13;
        return presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.NONE&#13;
            &amp;&amp; presenter.configuration.mouseData.clicks[1].position != presenter.CLICKED_POSITION.NONE;&#13;
    }&#13;
&#13;
    function areTwoClickedRanges() {&#13;
        return presenter.configuration.mouseData.clickedRanges.length == 2;&#13;
    }&#13;
&#13;
    function isClickedStartOrEnd() {&#13;
        return presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.END&#13;
            || presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.START;&#13;
    }&#13;
&#13;
    function isClickedMiddle() {&#13;
        return presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.MIDDLE;&#13;
    }&#13;
&#13;
    function isFirstStartOrEndAndSecondMiddleClicked() {&#13;
        return presenter.configuration.mouseData.clicks[1].position == presenter.CLICKED_POSITION.MIDDLE&#13;
            &amp;&amp; isClickedStartOrEnd()&#13;
            &amp;&amp; isBothClicksTheSameRange()&#13;
    }&#13;
&#13;
    function isFirstStartOrEndAndSecondNoneClicked() {&#13;
        return presenter.configuration.mouseData.clicks[1].position == presenter.CLICKED_POSITION.NONE&#13;
            &amp;&amp; isClickedStartOrEnd();&#13;
    }&#13;
&#13;
    // toggle include image when this situation happens&#13;
    function isTheSameRangeEndOrStartClickedInBothClicks() {&#13;
        return presenter.configuration.mouseData.clicks[0].position == presenter.configuration.mouseData.clicks[1].position&#13;
            &amp;&amp; presenter.configuration.mouseData.clicks[0].element[0] == presenter.configuration.mouseData.clicks[1].element[0];&#13;
    }&#13;
&#13;
    // this is when range should be deleted when both clicks were on the same range or joined when 1st/2nd click is on different range&#13;
    function isBothClicksTheSameRangeStartOrEnd() {&#13;
        return presenter.configuration.mouseData.clicks[0].element[0] != presenter.configuration.mouseData.clicks[1].element[0]&#13;
            &amp;&amp; (presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.END&#13;
            || presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.START)&#13;
            &amp;&amp; (presenter.configuration.mouseData.clicks[1].position == presenter.CLICKED_POSITION.END&#13;
            || presenter.configuration.mouseData.clicks[1].position == presenter.CLICKED_POSITION.START);&#13;
    }&#13;
&#13;
    function isBothClicksTheSameRange() {&#13;
        var firstClickRange = getRangeByValue( presenter.configuration.mouseData.clicks[0].element.attr('value') );&#13;
        var secondClickRange = getRangeByValue( presenter.configuration.mouseData.clicks[1].element.attr('value') );&#13;
        return compareRanges(firstClickRange, secondClickRange);&#13;
    }&#13;
&#13;
    function setCurrentClickedRange() {&#13;
        var first, second;&#13;
&#13;
        if ( presenter.configuration.mouseData.twoClickedRangesCount == 1 ) {&#13;
&#13;
            if ( presenter.configuration.mouseData.clickedRanges[0].start.value &gt; presenter.configuration.mouseData.clickedRanges[1].start.value ) {&#13;
                first = presenter.configuration.mouseData.clickedRanges[1];&#13;
                second = presenter.configuration.mouseData.clickedRanges[0];&#13;
            } else {&#13;
                first = presenter.configuration.mouseData.clickedRanges[0];&#13;
                second = presenter.configuration.mouseData.clickedRanges[1];&#13;
            }&#13;
        } else {&#13;
            if ( presenter.configuration.mouseData.clickedRanges[0].start.value &gt; presenter.configuration.mouseData.clickedRanges[1].start.value ) {&#13;
                first = presenter.configuration.mouseData.clickedRanges[0];&#13;
                second = presenter.configuration.mouseData.clickedRanges[1];&#13;
            } else {&#13;
                first = presenter.configuration.mouseData.clickedRanges[1];&#13;
                second = presenter.configuration.mouseData.clickedRanges[0];&#13;
            }&#13;
        }&#13;
&#13;
        presenter.configuration.mouseData.clickedRanges = [first, second];&#13;
    }&#13;
&#13;
    function resetClicks() {&#13;
&#13;
        if ( presenter.configuration.notCurrentSelectedRange ) {&#13;
            if ( presenter.configuration.mouseData.twoClickedRangesCount == 1 ) {&#13;
                addEndRangeImage( presenter.configuration.notCurrentSelectedRange.start.element, false );&#13;
            } else if ( presenter.configuration.mouseData.twoClickedRangesCount == 2 ) {&#13;
                addEndRangeImage( presenter.configuration.notCurrentSelectedRange.end.element, false );&#13;
            }&#13;
        }&#13;
&#13;
        presenter.$view.find('.currentSelectedRange').removeClass('currentSelectedRange');&#13;
&#13;
        presenter.configuration.mouseData.clicks = [];&#13;
        presenter.configuration.mouseData.twoClickedRangesCount = 0;&#13;
        presenter.configuration.notCurrentSelectedRange = null;&#13;
    }&#13;
&#13;
    function getSelectedRange(range) {&#13;
        var selectedRange;&#13;
&#13;
        if ( isValueInfinity(range.start.value) ) {&#13;
            selectedRange = presenter.$view.find('.clickArea[value="' + presenter.configuration.min + '"]').parent().find('.selectedRange');&#13;
        } else {&#13;
            selectedRange = range.start.element.find('.selectedRange');&#13;
        }&#13;
&#13;
        return selectedRange;&#13;
    }&#13;
&#13;
    function isLineNumberDisabled () {&#13;
        return ((presenter.configuration.isActivity &amp;&amp; presenter.configuration.isShowErrorsMode) ||&#13;
                 presenter.configuration.isDisabled);&#13;
    }&#13;
&#13;
    function isPointCorrect(point) {&#13;
        var correctPoints = getCorrectPoints();&#13;
&#13;
        if (correctPoints.indexOf(point) !== -1) {&#13;
            return true;&#13;
        }&#13;
    }&#13;
&#13;
    function togglePoint($eventTarget) {&#13;
        if (presenter.configuration.isShowErrorsMode || isLineNumberDisabled() || presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
        var $parent = $eventTarget.parent('.stepLine');&#13;
        var $rangeImage = $parent.find('.rangeImage');&#13;
&#13;
        if ($rangeImage.length === 1) {&#13;
            $rangeImage.remove();&#13;
&#13;
            presenter.checkedPoints = presenter.checkedPoints.filter(function(elem) {&#13;
                return elem != $eventTarget[0].value;&#13;
            });&#13;
&#13;
            eventBus.sendEvent("ValueChanged", presenter.createActionEventData($eventTarget[0].value, "0", isPointCorrect($eventTarget[0].value) ? 1 : 0));&#13;
        } else {&#13;
            var $imageContainer = $('&lt;div&gt;&lt;/div&gt;');&#13;
&#13;
            $imageContainer.addClass('rangeImage exclude include');&#13;
            $parent.append($imageContainer);&#13;
&#13;
            presenter.checkedPoints.push($eventTarget[0].value);&#13;
&#13;
            eventBus.sendEvent("ValueChanged", presenter.createActionEventData($eventTarget[0].value, "1", isPointCorrect($eventTarget[0].value) ? 1 : 0));&#13;
        }&#13;
&#13;
        var correctPoints = getCorrectPoints().sort().toString(),&#13;
            checkedPoints = $.extend(true, [], presenter.checkedPoints);&#13;
&#13;
            checkedPoints = checkedPoints.sort().toString();&#13;
&#13;
        if (correctPoints === checkedPoints) {&#13;
            eventBus.sendEvent("ValueChanged", presenter.createAllOKEventData());&#13;
        }&#13;
&#13;
    }&#13;
&#13;
var twoPointClick = 0;&#13;
    function clickLogic(eventTarget) {&#13;
        if (isLineNumberDisabled() || presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.configuration.mouseData.twoClickedRangesCount &gt; 3) {&#13;
            presenter.configuration.mouseData.twoClickedRangesCount = 0;&#13;
        }&#13;
&#13;
        setClickedRanges(eventTarget);&#13;
        setClicks(eventTarget);&#13;
&#13;
        var firstClick = presenter.configuration.mouseData.clicks[0];&#13;
        if (isFirstClick()) {&#13;
            if (twoPointClick &lt; 1) {&#13;
	            twoPointClick++;&#13;
                if (firstClick.position == presenter.CLICKED_POSITION.NONE) {&#13;
                    var value = parseRangeStartOrEnd(presenter.configuration.mouseData.clicks[0].element.attr('value'),&#13;
                                                    presenter.configuration.separator);&#13;
                    presenter.singleDot = {&#13;
                        value: value,&#13;
                        element: firstClick.element&#13;
                    };&#13;
&#13;
                    if (!isValueInfinity(value)) {&#13;
                        // addEndRangeImage(presenter.configuration.mouseData.clicks[0].element.parent(), true);&#13;
                        addEndRangeImage(presenter.configuration.mouseData.clicks[0].element.parent(), false);&#13;
                    };&#13;
                    var infinityleft = presenter.$view.find('.infinity-left');&#13;
                    infinityleft.find('.startRange').css('visibility','visible');&#13;
                    var infinityright = presenter.$view.find('.infinity-right');&#13;
                        infinityright.find('.startRange').css('visibility','visible');;&#13;
                } else if (areTwoClickedRanges()) {&#13;
                    presenter.configuration.mouseData.twoClickedRangesCount++;&#13;
&#13;
                    if (presenter.configuration.mouseData.twoClickedRangesCount == 1) {&#13;
                        var selectedRange = getSelectedRange(presenter.configuration.mouseData.clickedRanges[0]);&#13;
                        selectedRange.addClass('currentSelectedRange');&#13;
                    }&#13;
&#13;
                    presenter.configuration.notCurrentSelectedRange = presenter.configuration.mouseData.clickedRanges[1];&#13;
                } else if (isClickedStartOrEnd()) {&#13;
                    var clickedRange = presenter.configuration.mouseData.clickedRanges[0],&#13;
                        selectedRange = getSelectedRange(clickedRange);&#13;
&#13;
                    selectedRange.addClass('currentSelectedRange');&#13;
                } else if (isClickedMiddle()) {&#13;
                    splitRange(presenter.configuration.mouseData.clickedRanges[0], eventTarget);&#13;
                    resetClicks();&#13;
                }&#13;
            } else {&#13;
	            try {&#13;
	                var imageWrapper = firstClick.element.parent().find('.rangeImage');&#13;
	                var shouldInclude = !imageWrapper.hasClass('include');&#13;
	                var index = presenter.configuration.drawnRangesData.ranges.indexOf(presenter.configuration.mouseData.clickedRanges[0]);&#13;
&#13;
	                if (presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.START) {&#13;
	                    presenter.configuration.drawnRangesData.ranges[index].start.include = shouldInclude;&#13;
	                } else if (presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.END) {&#13;
	                    presenter.configuration.drawnRangesData.ranges[index].end.include = shouldInclude;&#13;
	                }&#13;
&#13;
	                if (!(firstClick.element.hasClass('infinity-right') || firstClick.element.hasClass('infinity-left'))) {&#13;
	                    toggleIncludeImage(imageWrapper, shouldInclude);&#13;
	                }&#13;
&#13;
	                if (presenter.configuration.drawnRangesData.ranges[index].values.length == 1) {&#13;
	                    presenter.removeRange(presenter.configuration.drawnRangesData.ranges[index], true);&#13;
	                    imageWrapper.remove();&#13;
	                }&#13;
&#13;
	                presenter.$view.find('.currentSelectedRange').removeClass('currentSelectedRange');&#13;
	                if (!(presenter.configuration.drawnRangesData.ranges[index] === undefined) &amp;&amp; !presenter.isShowAnswersActive) {&#13;
	                    var rangeString = presenter.convertRangeToString(presenter.configuration.drawnRangesData.ranges[index]);&#13;
	                    var eventData = presenter.createEventData(rangeString, false, checkIsRangeCorrect(presenter.configuration.drawnRangesData.ranges[index]));&#13;
&#13;
	                    eventBus.sendEvent('ValueChanged', eventData);&#13;
	                }&#13;
&#13;
	                if (presenter.allRangesCorrect() &amp;&amp; !presenter.isShowAnswersActive) {&#13;
	                    var eventData = presenter.createAllOKEventData();&#13;
	                    eventBus.sendEvent('ValueChanged', eventData);&#13;
	                }&#13;
&#13;
	                resetClicks();&#13;
	            } catch (e) {&#13;
	                resetClicks();&#13;
	            }&#13;
&#13;
	        }&#13;
&#13;
        } else if (isSecondClick()) {&#13;
&#13;
            presenter.singleDot = {&#13;
                value: -1,&#13;
                element: null&#13;
            };&#13;
            var secondClick = presenter.configuration.mouseData.clicks[1];&#13;
            var firstValue = parseRangeStartOrEnd(firstClick.element.attr('value'), presenter.configuration.separator);&#13;
            var secondValue = parseRangeStartOrEnd(secondClick.element.attr('value'), presenter.configuration.separator);&#13;
            var newRange;&#13;
&#13;
&#13;
	        if (twoPointClick &gt; 1) return;&#13;
	        //if (isTheSameRangeEndOrStartClickedInBothClicks()) twoPointClick--;&#13;
            //else twoPointClick++;&#13;
            twoPointClick++;&#13;
&#13;
            presenter.$view.find('.infinity-left').find('.startRange').css('visibility','hidden');&#13;
            presenter.$view.find('.infinity-right').find('.startRange').css('visibility','hidden');&#13;
            presenter.$view.find('.startRange').css('visibility','hidden');&#13;
&#13;
            if (areBothClicksNone()) {&#13;
&#13;
                var timeDiff = presenter.configuration.mouseData.clicks[1].time - presenter.configuration.mouseData.clicks[0].time;&#13;
/*&#13;
                if (timeDiff &lt; 250 &amp;&amp; timeDiff &gt; 0) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(firstClick.element, firstValue, true),&#13;
                        end: createRangeElement(firstClick.element, firstValue, true)&#13;
                    };&#13;
                    setRangeValues(newRange, true);&#13;
                    addToDrawnRanges(newRange);&#13;
                } else {&#13;
                    if (firstValue &gt; secondValue) {&#13;
                        newRange = {&#13;
                            start: createRangeElement(secondClick.element, secondValue, true),&#13;
                            end: createRangeElement(firstClick.element, firstValue, true)&#13;
                        };&#13;
                        removeRangesBetweenRange(newRange);&#13;
                        presenter.drawRanges([newRange], true);&#13;
                    } else if (firstValue &lt; secondValue) {&#13;
                        newRange = {&#13;
                            start: createRangeElement(firstClick.element, firstValue, true),&#13;
                            end: createRangeElement(secondClick.element, secondValue, true)&#13;
                        };&#13;
                        removeRangesBetweenRange(newRange);&#13;
                        presenter.drawRanges([newRange], true);&#13;
                    } else {&#13;
                        var rangeImage = firstClick.element.parent().find('.rangeImage');&#13;
&#13;
                        if (rangeImage.hasClass('include')) {&#13;
                            rangeImage.remove();&#13;
                        } else {&#13;
                            rangeImage.removeClass('exclude');&#13;
                            rangeImage.addClass('include');&#13;
                        }&#13;
presenter.$view.find('.inner').find('.startRange').css('visibility','visible');&#13;
                    }&#13;
                }&#13;
                resetClicks();&#13;
*/&#13;
               var b_Infinity = false;&#13;
                presenter.$view.find('.infinity-left').find('.startRange').css('visibility','hidden');&#13;
                presenter.$view.find('.infinity-right').find('.startRange').css('visibility','hidden');&#13;
                presenter.$view.find('.startRange').css('visibility','hidden');&#13;
                if(secondValue == Number.POSITIVE_INFINITY || secondValue == Number.NEGATIVE_INFINITY) b_Infinity= true;&#13;
&#13;
                var firstClickRangeImage = firstClick.element.parent().find('.rangeImage');&#13;
                var b_FirsetClickInclude = false;&#13;
                if (firstClickRangeImage.hasClass('include')) {&#13;
                    b_FirsetClickInclude = true;&#13;
                }&#13;
&#13;
                if (firstValue &gt; secondValue) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(secondClick.element, secondValue, b_Infinity),&#13;
                        end: createRangeElement(firstClick.element, firstValue, b_FirsetClickInclude)&#13;
                    };&#13;
                    removeRangesBetweenRange(newRange);&#13;
                    presenter.drawRanges([newRange], true);&#13;
                } else if (firstValue &lt; secondValue) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(firstClick.element, firstValue, b_FirsetClickInclude),&#13;
                        end: createRangeElement(secondClick.element, secondValue, b_Infinity)&#13;
                    };&#13;
                    removeRangesBetweenRange(newRange);&#13;
                    presenter.drawRanges([newRange], true);&#13;
                } else {&#13;
                    var rangeImage = firstClick.element.parent().find('.rangeImage');&#13;
&#13;
                    if (rangeImage.hasClass('include')) {&#13;
                        rangeImage.removeClass('include');&#13;
                        rangeImage.addClass('exclude');&#13;
                    } else {&#13;
                        rangeImage.removeClass('exclude');&#13;
                        rangeImage.addClass('include');&#13;
                    }&#13;
                    twoPointClick--;&#13;
                    presenter.configuration.mouseData.clicks = presenter.configuration.mouseData.clicks.slice(0, 1);&#13;
                    presenter.$view.find('.infinity-left').find('.startRange').css('visibility','visible');&#13;
                    presenter.$view.find('.infinity-right').find('.startRange').css('visibility','visible');&#13;
                    presenter.$view.find('.inner').find('.startRange').css('visibility','visible');&#13;
                    return;&#13;
                }&#13;
&#13;
                resetClicks();&#13;
&#13;
&#13;
            } else if (isFirstClickNoneAndSecondNotNone()) {&#13;
                if (firstValue &gt; secondValue) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(secondClick.element, secondValue, true),&#13;
                        end: createRangeElement(firstClick.element, firstValue, true)&#13;
                    };&#13;
                } else if (firstValue &lt; secondValue) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(firstClick.element, firstValue, true),&#13;
                        end: createRangeElement(secondClick.element, secondValue, true)&#13;
                    };&#13;
                }&#13;
                joinRanges([newRange, presenter.configuration.mouseData.clickedRanges[0]]);&#13;
                resetClicks();&#13;
&#13;
            } else if (isFirstStartOrEndAndSecondMiddleClicked()) {&#13;
                var clickedRange = presenter.configuration.mouseData.clickedRanges[0];&#13;
&#13;
                if (firstClick.position == presenter.CLICKED_POSITION.START) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(secondClick.element, secondValue, firstClick.element.parent().find('.rangeImage').hasClass('include')),&#13;
                        end: createRangeElement(clickedRange.end.element, clickedRange.end.value, clickedRange.end.include)&#13;
                    };&#13;
                } else if (firstClick.position == presenter.CLICKED_POSITION.END) {&#13;
                    newRange = {&#13;
                        end: createRangeElement(secondClick.element, secondValue, firstClick.element.parent().find('.rangeImage').hasClass('include')),&#13;
                        start: createRangeElement(clickedRange.start.element, clickedRange.start.value, clickedRange.start.include)&#13;
                    };&#13;
                }&#13;
                presenter.removeRange(clickedRange, true);&#13;
                presenter.drawRanges([newRange], true);&#13;
                resetClicks();&#13;
&#13;
            } else if (areTwoClickedRanges()) {&#13;
                presenter.configuration.mouseData.twoClickedRangesCount++;&#13;
&#13;
                if (presenter.configuration.mouseData.twoClickedRangesCount == 2) {&#13;
                    var currentSelectedRange = getSelectedRange(presenter.configuration.mouseData.clickedRanges[0]);&#13;
                    var selectedRange = getSelectedRange(presenter.configuration.mouseData.clickedRanges[1]);&#13;
                    selectedRange.addClass('currentSelectedRange');&#13;
                    currentSelectedRange.removeClass('currentSelectedRange');&#13;
                    presenter.configuration.mouseData.clicks = presenter.configuration.mouseData.clicks.slice(0, 1);&#13;
                    presenter.configuration.mouseData.clicks[0].position = presenter.CLICKED_POSITION.START;&#13;
                    presenter.configuration.notCurrentSelectedRange = presenter.configuration.mouseData.clickedRanges[0];&#13;
                } else if (presenter.configuration.mouseData.twoClickedRangesCount == 3) {&#13;
                    joinRanges(presenter.configuration.mouseData.clickedRanges);&#13;
                    resetClicks();&#13;
                } else {&#13;
                    presenter.removeRange(getRangeByValue(firstValue), true);&#13;
                    addEndRangeImage(secondClick.element.parent(), false);&#13;
                    resetClicks();&#13;
                }&#13;
&#13;
                setCurrentClickedRange();&#13;
&#13;
            } else if (isFirstStartOrEndAndSecondNoneClicked()) {&#13;
                if (firstValue &gt; secondValue) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(secondClick.element, secondValue, firstClick.element.parent().find('.rangeImage').hasClass('include')),&#13;
                        end: createRangeElement(firstClick.element, firstValue, firstClick.element.parent().find('.rangeImage').hasClass('include'))&#13;
                    };&#13;
&#13;
                    joinRanges([newRange, getRangeByValue(firstValue)]);&#13;
                } else if (firstValue &lt; secondValue) {&#13;
                    newRange = {&#13;
                        start: createRangeElement(firstClick.element, firstValue, firstClick.element.parent().find('.rangeImage').hasClass('include')),&#13;
                        end: createRangeElement(secondClick.element, secondValue, firstClick.element.parent().find('.rangeImage').hasClass('include'))&#13;
                    };&#13;
&#13;
                    joinRanges([newRange, getRangeByValue(firstValue)]);&#13;
                }&#13;
&#13;
                resetClicks();&#13;
&#13;
            } else if (isTheSameRangeEndOrStartClickedInBothClicks()) {&#13;
                var imageWrapper = firstClick.element.parent().find('.rangeImage');&#13;
                var shouldInclude = !imageWrapper.hasClass('include');&#13;
                var index = presenter.configuration.drawnRangesData.ranges.indexOf(presenter.configuration.mouseData.clickedRanges[0]);&#13;
&#13;
                if (presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.START) {&#13;
                    presenter.configuration.drawnRangesData.ranges[index].start.include = shouldInclude;&#13;
                } else if (presenter.configuration.mouseData.clicks[0].position == presenter.CLICKED_POSITION.END) {&#13;
                    presenter.configuration.drawnRangesData.ranges[index].end.include = shouldInclude;&#13;
                }&#13;
&#13;
                if (!(firstClick.element.hasClass('infinity-right') || firstClick.element.hasClass('infinity-left'))) {&#13;
                    toggleIncludeImage(imageWrapper, shouldInclude);&#13;
                }&#13;
&#13;
                if (presenter.configuration.drawnRangesData.ranges[index].values.length == 1) {&#13;
                    presenter.removeRange(presenter.configuration.drawnRangesData.ranges[index], true);&#13;
                    imageWrapper.remove();&#13;
                }&#13;
&#13;
                presenter.$view.find('.currentSelectedRange').removeClass('currentSelectedRange');&#13;
                if (!(presenter.configuration.drawnRangesData.ranges[index] === undefined) &amp;&amp; !presenter.isShowAnswersActive) {&#13;
                    var rangeString = presenter.convertRangeToString(presenter.configuration.drawnRangesData.ranges[index]);&#13;
                    var eventData = presenter.createEventData(rangeString, false, checkIsRangeCorrect(presenter.configuration.drawnRangesData.ranges[index]));&#13;
&#13;
                    eventBus.sendEvent('ValueChanged', eventData);&#13;
                }&#13;
&#13;
                if (presenter.allRangesCorrect() &amp;&amp; !presenter.isShowAnswersActive) {&#13;
                    var eventData = presenter.createAllOKEventData();&#13;
                    eventBus.sendEvent('ValueChanged', eventData);&#13;
                }&#13;
&#13;
                resetClicks();&#13;
&#13;
            } else if (isBothClicksTheSameRangeStartOrEnd()) {&#13;
                var firstClickRange = getRangeByValue(firstValue);&#13;
                var secondClickRange = getRangeByValue(secondValue);&#13;
&#13;
                if (compareRanges(firstClickRange, secondClickRange)) {&#13;
                    presenter.removeRange(firstClickRange, true);&#13;
&#13;
                    var rangeString = presenter.convertRangeToString(firstClickRange);&#13;
                    var eventData = presenter.createEventData(rangeString, true, !checkIsRangeCorrect(firstClickRange));&#13;
                    eventBus.sendEvent('ValueChanged', eventData);&#13;
&#13;
                    if (presenter.allRangesCorrect()) {&#13;
                        var eventData = presenter.createAllOKEventData();&#13;
                        eventBus.sendEvent('ValueChanged', eventData);&#13;
                    }&#13;
                } else {&#13;
                    joinRanges([getRangeByValue(firstValue), getRangeByValue(secondValue)]);&#13;
                }&#13;
                resetClicks();&#13;
&#13;
            } else {&#13;
                resetClicks();&#13;
            }&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    function removeRangesBetweenRange(range) {&#13;
        var currentRanges = [];&#13;
        currentRanges = currentRanges.concat(presenter.configuration.drawnRangesData.ranges);&#13;
&#13;
        for( var i = 0; i &lt; currentRanges.length; i++) {&#13;
            var drawnRange = currentRanges[i];&#13;
            var drawnStartValue = drawnRange.start.value;&#13;
            var drawnEndValue = drawnRange.end.value;&#13;
&#13;
            if ( drawnStartValue == -Infinity ) {&#13;
                drawnStartValue = presenter.configuration.min;&#13;
            }&#13;
&#13;
            if ( drawnEndValue == Infinity ) {&#13;
                drawnEndValue = presenter.configuration.max;&#13;
            }&#13;
&#13;
            if ( range.start.value &lt; drawnEndValue &amp;&amp; range.end.value &gt; drawnStartValue ) {&#13;
                presenter.removeRange(drawnRange, true);&#13;
            }&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    function getRangeByValue(value) {&#13;
        value = parseRangeStartOrEnd(value, presenter.configuration.separator);&#13;
        var ranges = [];&#13;
&#13;
        $.each(presenter.configuration.drawnRangesData.ranges, function() {&#13;
            if ( this.values.indexOf(value) &gt;= 0 ) {&#13;
                ranges.push(this);&#13;
            }&#13;
&#13;
            return true;&#13;
        });&#13;
&#13;
        if (ranges.length == 2) {&#13;
&#13;
            if (presenter.configuration.mouseData.twoClickedRangesCount == 1) {&#13;
                return ranges[0];&#13;
            } else if (presenter.configuration.mouseData.twoClickedRangesCount == 2) {&#13;
                return ranges[1];&#13;
            }&#13;
&#13;
        } else if (ranges.length == 1) {&#13;
            return ranges[0];&#13;
        } else {&#13;
&#13;
            presenter.configuration.isError = true;&#13;
            presenter.configuration.errorCode = 'OOR01';&#13;
            return null;&#13;
&#13;
        }&#13;
    }&#13;
&#13;
    function createRangeElement(element, value, include) {&#13;
        if (element.hasClass('clickArea')) {&#13;
            element = element.parent();&#13;
        }&#13;
        return {&#13;
            element: parseElement(element),&#13;
            value: parseRangeStartOrEnd(value, presenter.configuration.separator),&#13;
            include: include&#13;
        }&#13;
    }&#13;
&#13;
    presenter.isMouseAboveExistingRange = function(e) {&#13;
        var value = parseRangeStartOrEnd($(e).attr('value'), presenter.configuration.separator);&#13;
        return $.inArray( value, presenter.configuration.drawnRangesData.values ) &gt;= 0;&#13;
    };&#13;
&#13;
    presenter.isValueInRange = function(value, range, takeExcludeIntoConsideration) {&#13;
&#13;
        var start, end;&#13;
        if (takeExcludeIntoConsideration) {&#13;
            start = range.start.include ? range.start.value : range.start.value + 1;&#13;
            end = range.end.include ? range.end.value + 1 : range.end.value;&#13;
        } else {&#13;
            start = range.start.value;&#13;
            end = range.end.value + 1;&#13;
        }&#13;
&#13;
        for( var i = start; i &lt; end; i++ ) {&#13;
            if ( i == value ) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    function toggleIncludeImage(imageWrapper, shouldInclude) {&#13;
        if (shouldInclude) {&#13;
            imageWrapper.addClass('include');&#13;
            imageWrapper.removeClass('exclude');&#13;
        } else {&#13;
            imageWrapper.addClass('exclude');&#13;
            imageWrapper.removeClass('include');&#13;
        }&#13;
    }&#13;
&#13;
    function getStartElement(isStartInfinity, startValue) {&#13;
        var startElement;&#13;
&#13;
        if ( isStartInfinity ) {&#13;
            startElement = presenter.$view.find('.clickArea[value="' + presenter.configuration.min + '"]').parent();&#13;
        } else {&#13;
            startElement = presenter.$view.find('.clickArea[value="' + startValue + '"]').parent();&#13;
        }&#13;
&#13;
        return startElement;&#13;
    }&#13;
&#13;
    function getEndElement(isEndInfinity, endValue) {&#13;
        var endElement;&#13;
&#13;
        if ( isEndInfinity ) {&#13;
            endElement = presenter.$view.find('.clickArea[value="' + presenter.configuration.max + '"]').parent();&#13;
        } else {&#13;
            endElement = presenter.$view.find('.clickArea[value="' + endValue + '"]').parent();&#13;
        }&#13;
&#13;
        return endElement;&#13;
    }&#13;
&#13;
    presenter.drawRanges = function(ranges, shouldSendEvents) {&#13;
&#13;
        $.each(ranges, function() {&#13;
&#13;
            var startValue = Math.min(this.start.value, this.end.value);&#13;
            var endValue = Math.max(this.start.value, this.end.value);&#13;
&#13;
            var isEndInfinity = isValueInfinity(endValue);&#13;
            var isStartInfinity = isValueInfinity(startValue);&#13;
            var startElement = getStartElement(isStartInfinity, startValue);&#13;
            var endElement = getEndElement(isEndInfinity, endValue);&#13;
&#13;
            if (!this.start.element || !this.end.element) {&#13;
                this.start.element = startElement;&#13;
                this.end.element = endElement;&#13;
            }&#13;
&#13;
            if ( startValue == endValue ) {&#13;
                setRangeValues(this, true);&#13;
                addToDrawnRanges(this, shouldSendEvents);&#13;
                addEndRangeImage(endElement, true);&#13;
&#13;
                // if start and end values are the same, that means range is a single point, so it should not draw range&#13;
&#13;
                return true;&#13;
            }&#13;
&#13;
            var start = parseFloat($(startElement).css('left'));&#13;
            var end = parseFloat(endElement.css('left'));&#13;
            var difference =  Math.abs(start - end);&#13;
            var range = $('&lt;div&gt;&lt;/div&gt;');&#13;
&#13;
            range.addClass('selectedRange');&#13;
&#13;
            addInfinityClass(isStartInfinity, isEndInfinity, range);&#13;
&#13;
            // when range is ending in infinity then it should be wider because there is space between arrowhead and last step line&#13;
            // + 2 is because stepLine is 2 px width&#13;
            var width = calculateRangeWidth(isEndInfinity, isStartInfinity, difference);&#13;
&#13;
            range.css('width', width);&#13;
            startElement.append(range);&#13;
&#13;
            if (start &gt; end) {&#13;
                range.css('left', - (difference) + 'px');&#13;
            }&#13;
&#13;
            if (isStartInfinity) {&#13;
                range.css('left', -presenter.configuration.stepWidth + 'px');&#13;
            }&#13;
&#13;
            addToDrawnRanges(this, shouldSendEvents);&#13;
            setRangeValues(this, true);&#13;
            addEndRangeImages(this, startElement, endElement, isStartInfinity, isEndInfinity);&#13;
        });&#13;
&#13;
    };&#13;
&#13;
    function addEndRangeImages(range, startElement, endElement, isStartInfinity, isEndInfinity) {&#13;
        if (!isEndInfinity) {&#13;
            addEndRangeImage(endElement, range.end.include);&#13;
        }&#13;
&#13;
        if (!isStartInfinity) {&#13;
            addEndRangeImage(startElement, range.start.include);&#13;
        }&#13;
    }&#13;
&#13;
    function addInfinityClass(isStartInfinity, isEndInfinity, range) {&#13;
        if ( isStartInfinity &amp;&amp; isEndInfinity ) {&#13;
            range.addClass(isStartInfinity ? 'infinityBoth' : '');&#13;
        } else {&#13;
            range.addClass(isStartInfinity ? 'infinityLeft' : '');&#13;
            range.addClass(isEndInfinity ? 'infinityRight' : '');&#13;
        }&#13;
    }&#13;
&#13;
    function calculateRangeWidth(isEndInfinity, isStartInfinity, difference) {&#13;
        var width;&#13;
&#13;
        if (isEndInfinity &amp;&amp; isStartInfinity) {&#13;
            width = difference + (presenter.configuration.stepWidth * 2) + 'px';&#13;
        } else if (isEndInfinity) {&#13;
            width = (difference + presenter.configuration.stepWidth) + 'px';&#13;
        } else if (isStartInfinity) {&#13;
            width = (difference + presenter.configuration.stepWidth + 2) + 'px';&#13;
        } else {&#13;
            width = difference + 2 + 'px';&#13;
        }&#13;
&#13;
        return width;&#13;
    }&#13;
&#13;
    function isValueInfinity(value) {&#13;
        return ( value == -Infinity || value == Infinity )&#13;
    }&#13;
&#13;
    function setRangeValues(range, shouldAddToDrawn, shouldSendEvents) {&#13;
        range.values = [];&#13;
&#13;
        var startValue = Math.min(range.start.value, range.end.value);&#13;
        var endValue = Math.max(range.start.value, range.end.value);&#13;
&#13;
        if (startValue == -Infinity) {&#13;
            range.values.push(-Infinity);&#13;
            if (shouldAddToDrawn) {&#13;
                presenter.configuration.drawnRangesData.values.push(-Infinity);&#13;
            }&#13;
            startValue = presenter.configuration.min;&#13;
        }&#13;
&#13;
        if (endValue == Infinity) {&#13;
            range.values.push(Infinity);&#13;
            if (shouldAddToDrawn) {&#13;
                presenter.configuration.drawnRangesData.values.push(Infinity);&#13;
            }&#13;
            endValue = presenter.configuration.max;&#13;
        }&#13;
&#13;
        var stepValue = presenter.configuration.step;&#13;
&#13;
        for ( var i = startValue; i &lt;= endValue; i += stepValue ) {&#13;
            range.values.push(i);&#13;
&#13;
            if (shouldAddToDrawn) {&#13;
                presenter.configuration.drawnRangesData.values.push(i);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function convertNdashToMinus(value) {&#13;
        return new String(value).replace('&amp;ndash;', '-');&#13;
    }&#13;
&#13;
    presenter.convertRangeToString = function( range ) {&#13;
        var startInclude = range.start.include ? '&lt;' : '(';&#13;
        var endInclude = range.end.include ? '&gt;' : ')';&#13;
        var startValue = isValueInfinity(range.start.value) ? '-INF' : convertNdashToMinus(range.start.value);&#13;
        var endValue = isValueInfinity(range.end.value) ? 'INF' : convertNdashToMinus(range.end.value);&#13;
&#13;
        return startInclude +&#13;
            transformValueToDisplayVersion(startValue, false) +&#13;
            '; ' +&#13;
            transformValueToDisplayVersion(endValue, false) + endInclude;&#13;
    };&#13;
&#13;
    function addEndRangeImage($element, include) {&#13;
        var currentImages = $element.find('.rangeImage');&#13;
        currentImages.remove();&#13;
&#13;
        var imageContainer = $('&lt;div&gt;&lt;/div&gt;');&#13;
        imageContainer.addClass('rangeImage');&#13;
&#13;
        imageContainer.addClass(include ? 'include' : 'exclude');&#13;
        $element.append(imageContainer);&#13;
&#13;
        if(!presenter.hideAnswerClicked &amp;&amp; !presenter.isShowAnswersActive){&#13;
            presenter.parentLeft = imageContainer.parent().css('left');&#13;
        }&#13;
&#13;
        return imageContainer;&#13;
    }&#13;
&#13;
    presenter.getElementPosition = function (value, axisXWidth, absoluteXRange, axisMin) {&#13;
        return ((value - axisMin) / absoluteXRange) * (axisXWidth - (presenter.configuration.stepWidth * 2));&#13;
    };&#13;
&#13;
    function getStepText(element) {&#13;
        var $text = $('&lt;div&gt;&lt;/div&gt;');&#13;
        $text.addClass('stepText');&#13;
        $text.html( transformValueToDisplayVersion( element, true ) );&#13;
        $text.css('left', - ((element.toString())).length * (4) + 'px');&#13;
&#13;
        return $text;&#13;
    }&#13;
&#13;
    function getStepLine() {&#13;
        var $stepLine = $('&lt;div&gt;&lt;/div&gt;');&#13;
        $stepLine.addClass('stepLine');&#13;
&#13;
        return $stepLine&#13;
    }&#13;
&#13;
    function appendTextToStepLine($stepLine, element) {&#13;
        var $text = getStepText(element);&#13;
&#13;
        $stepLine.append($text);&#13;
    }&#13;
&#13;
    function appendStepLineToAxis($stepLine) {&#13;
        presenter.$view.find('.x-axis').append($stepLine);&#13;
    }&#13;
&#13;
    function positionStepLineOnAxis($stepLine, element, configuration) {&#13;
        var position = presenter.getElementPosition(element, configuration.axisXWidth, configuration.axisAbsoluteRange,&#13;
                                                    configuration.axisMin);&#13;
&#13;
        $stepLine.css({&#13;
            'left': (position + presenter.configuration.stepWidth) + 'px'&#13;
        });&#13;
    }&#13;
&#13;
    function isMultiplicationOfCyclicValues (value) {&#13;
        function isMultiplication (element) { return (this % element) == 0;}&#13;
&#13;
        var elementIndex = presenter.configuration.axisXFieldValues.indexOf(value);&#13;
&#13;
        return (presenter.configuration.axisXValues.cyclicValues.filter(isMultiplication, elementIndex).length &gt; 0);&#13;
    }&#13;
&#13;
    function checkCustomValues(element) {&#13;
        var isCustomValue = isMultiplicationOfCyclicValues(element);&#13;
&#13;
        if (!isCustomValue) {&#13;
            isCustomValue = (presenter.configuration.axisXValues.fixedValues.indexOf(element) != -1)&#13;
        }&#13;
&#13;
        return isCustomValue;&#13;
    }&#13;
&#13;
    function shouldAppendTextToStepLine(element, configuration) {&#13;
        if (configuration.showAxisXValues) {&#13;
            if(configuration.customValuesSet) {&#13;
                return checkCustomValues(element)&#13;
            }&#13;
&#13;
            return true;&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.createStep = function (element) {&#13;
        //function for array.forEach, this is binded to object with lineNumber configuration&#13;
        /*&#13;
            this = {axisXWidth: float, axisMin: float, axisAbsoluteRange: float}&#13;
        */&#13;
&#13;
        var $stepLine = getStepLine();&#13;
        positionStepLineOnAxis($stepLine, element, this);&#13;
&#13;
        if(shouldAppendTextToStepLine(element, this)) {&#13;
            appendTextToStepLine($stepLine, element);&#13;
        }&#13;
&#13;
        createClickArea($stepLine, element);&#13;
&#13;
        appendStepLineToAxis($stepLine);&#13;
    };&#13;
&#13;
    presenter.createAxisXCustomValues = function () {&#13;
        var min = presenter.configuration.min;&#13;
        var max = presenter.configuration.max;&#13;
&#13;
        var values = presenter.configuration.axisXValues.fixedValues.concat([]);&#13;
        var cyclicValues = presenter.configuration.axisXValues.cyclicValues;&#13;
&#13;
        function createValues (element) {&#13;
            var precision = presenter.getNumberPrecision(element);&#13;
            var step = element;&#13;
            var values = [];&#13;
&#13;
            for(var i = step; i &lt;= max; i += step) {&#13;
                values.push(presenter.changeNumberToPrecision(i, precision));&#13;
            }&#13;
&#13;
            for(i = step * -1; i &gt;= min; i -= step ) {&#13;
                values.push(presenter.changeNumberToPrecision(i, precision));&#13;
            }&#13;
&#13;
            return values;&#13;
        }&#13;
&#13;
        cyclicValues = cyclicValues.map(createValues);&#13;
        for(var i = 0; i &lt; cyclicValues.length; i++) {&#13;
            values = values.concat(cyclicValues[i]);&#13;
        }&#13;
&#13;
        values = values.filter(function (element){&#13;
            if (this.indexOf(element) == -1) {&#13;
                this.push(element);&#13;
                return true;&#13;
            }&#13;
&#13;
            return false;&#13;
        }, []);&#13;
&#13;
        if(values.indexOf(0) == -1) values.push(0);&#13;
&#13;
        return values;&#13;
    };&#13;
&#13;
    presenter.getAxisConfigurationForCreatingSteps = function () {&#13;
        var configuration = {&#13;
            axisXWidth: presenter.$view.find('.x-axis').width(),&#13;
            axisMin: presenter.configuration.min,&#13;
            axisAbsoluteRange: presenter.configuration.max - presenter.configuration.min,&#13;
            showAxisXValues: presenter.configuration.showAxisXValues&#13;
        };&#13;
&#13;
        if (presenter.configuration.isCustomAxisXValuesSet) {&#13;
            configuration.customValuesSet = presenter.configuration.isCustomAxisXValuesSet;&#13;
            configuration.customValues = presenter.createAxisXCustomValues();&#13;
        }&#13;
&#13;
        return configuration;&#13;
    };&#13;
&#13;
    presenter.setStepWidthInConfiguration = function () {&#13;
        presenter.configuration.stepWidth = calculateStepWidth(presenter.configuration.axisXFieldValues);&#13;
    };&#13;
&#13;
    function setMaxValueInConfiguration () {&#13;
        presenter.configuration.max = presenter.maxElement(presenter.configuration.axisXFieldValues);//max()&#13;
    }&#13;
&#13;
    presenter.setOnClickAreaListeners = function () {&#13;
        if (!presenter.configuration.isPreview &amp;&amp; !presenter.configuration.isDisabled) {&#13;
            bindClickAreaListeners(presenter.$view.find('.clickArea'));&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createSteps = function () {&#13;
        setMaxValueInConfiguration();&#13;
        presenter.setStepWidthInConfiguration();&#13;
&#13;
        presenter.configuration.axisXFieldValues.forEach(presenter.createStep, presenter.getAxisConfigurationForCreatingSteps());&#13;
&#13;
        presenter.setOnClickAreaListeners();&#13;
    };&#13;
&#13;
    function transformValueToDisplayVersion(value, shouldReplaceMinus) {&#13;
        var transformed = ('' + value).replace('.', presenter.configuration.separator);&#13;
        if (shouldReplaceMinus) {&#13;
            transformed = transformed.replace('-', '&amp;ndash;');&#13;
        }&#13;
&#13;
        return transformed;&#13;
    }&#13;
&#13;
    function checkIsMinLowerThanMax(min, max) {&#13;
        var parsedMin = parseRangeStartOrEnd(min, presenter.configuration.separator);&#13;
        var parsedMax = parseRangeStartOrEnd(max, presenter.configuration.separator);&#13;
        return parsedMin &lt; parsedMax;&#13;
    }&#13;
&#13;
    presenter.getState = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
&#13;
        $.each(presenter.configuration.drawnRangesData.ranges, function() {&#13;
&#13;
        		presenter.startElement = this.start.element;&#13;
    			presenter.endElement = this.end.element;&#13;
&#13;
            this.start.element = null;&#13;
            this.end.element = null;&#13;
        });&#13;
&#13;
        return JSON.stringify({&#13;
            drawnRangesData: presenter.configuration.drawnRangesData,&#13;
            isVisible: presenter.configuration.isCurrentlyVisible,&#13;
            isDisabled: presenter.configuration.isDisabled,&#13;
            points: presenter.checkedPoints&#13;
        }, function (key, value) {&#13;
            if (value === Infinity) return "Infinity";&#13;
            else if (value === -Infinity) return "-Infinity";&#13;
            else if (value !== value) return "NaN";&#13;
            else return value;&#13;
        });&#13;
    };&#13;
&#13;
    presenter.redrawRanges = function (rangesToDraw) {&#13;
&#13;
   		try{&#13;
    			console.log("rangesToDraw", rangesToDraw);&#13;
    			rangesToDraw = JSON.parse(rangesToDraw);&#13;
    			console.log("item is string");&#13;
    		}catch(e){&#13;
&#13;
    		}&#13;
&#13;
        $.each(rangesToDraw, function () {&#13;
            this.start.element = presenter.$view.find('.clickArea[value="' + this.start.value + '"]').parent();&#13;
            this.end.element = presenter.$view.find('.clickArea[value="' + this.end.value + '"]').parent();&#13;
        });&#13;
&#13;
		console.log("presenter.configuration.shouldDrawRanges", presenter.configuration.shouldDrawRanges);&#13;
&#13;
        $.each(presenter.configuration.shouldDrawRanges, function() {&#13;
            presenter.removeRange(this, true);&#13;
        });&#13;
&#13;
        presenter.drawRanges(rangesToDraw, true);&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) return;&#13;
&#13;
        var parsedState = JSON.parse(state,&#13;
            function (key, value) {&#13;
                if (value === "Infinity") return Infinity;&#13;
                else if (value === "-Infinity") return -Infinity;&#13;
                else if (value === "NaN") return NaN;&#13;
                else return value;&#13;
            });&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
&#13;
        		try{&#13;
	    			//console.log("points", parsedState.points);&#13;
	    			parsedState.points = JSON.parse(parsedState.points);&#13;
	    			//console.log("item is string");&#13;
	    		}catch(e){&#13;
&#13;
	    		}&#13;
&#13;
            presenter.checkedPoints = parsedState.points;&#13;
            drawPoints(presenter.checkedPoints);&#13;
        } else {&#13;
&#13;
	        try{&#13;
	    			//console.log("rangesToDraw", parsedState.drawnRangesData);&#13;
	    			parsedState.drawnRangesData = JSON.parse(parsedState.drawnRangesData);&#13;
	    			console.log("item is string");&#13;
	    		}catch(e){&#13;
&#13;
	    		}&#13;
&#13;
            presenter.redrawRanges(parsedState.drawnRangesData.ranges);&#13;
&#13;
            try{&#13;
&#13;
                if (parsedState.drawnRangesData.ranges.length &gt; 0) {&#13;
                    presenter.$view.find('.startRange').css('visibility','hidden');&#13;
                    parsedState.isDisabled = true;&#13;
                }&#13;
            }catch(e){&#13;
            		console.log("setState", e);&#13;
            };&#13;
        }&#13;
        presenter.configuration.isCurrentlyVisible = parsedState.isVisible;&#13;
        presenter.setVisibility(parsedState.isVisible);&#13;
&#13;
        presenter.configuration.isDisabled = parsedState.isDisabled;&#13;
&#13;
    };&#13;
&#13;
    /*presenter.reset = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            presenter.$view.find('.rangeImage').remove();&#13;
            presenter.checkedPoints = [];&#13;
            addInitPoints();&#13;
            drawPoints(presenter.checkedPoints);&#13;
        } else {&#13;
            var rangesToRemove = [].concat(presenter.configuration.drawnRangesData.ranges);&#13;
            $.each(rangesToRemove, function() {&#13;
                presenter.removeRange(this, true);&#13;
            });&#13;
&#13;
            // removing all single dots&#13;
            presenter.$view.find('.rangeImage').remove();&#13;
&#13;
            var initRanges = presenter.validateRanges(presenter.configuration.ranges, presenter.configuration.separator);&#13;
            presenter.drawRanges(initRanges.shouldDrawRanges, true);&#13;
&#13;
            presenter.configuration.mouseData.clicks = [];&#13;
        }&#13;
&#13;
        presenter.configuration.isCurrentlyVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
&#13;
        presenter.configuration.isShowErrorsMode = false;&#13;
        presenter.configuration.isDisabled = presenter.configuration.isDisabledByDefault;&#13;
&#13;
        presenter.leftShowAnswers = false;&#13;
        presenter.parentLeft = false;&#13;
};*/&#13;
    presenter.reset = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            presenter.$view.find('.rangeImage').remove();&#13;
            presenter.checkedPoints = [];&#13;
            addInitPoints();&#13;
            drawPoints(presenter.checkedPoints);&#13;
        } else {&#13;
            var rangesToRemove = [].concat(presenter.configuration.drawnRangesData.ranges);&#13;
            $.each(rangesToRemove, function() {&#13;
                presenter.removeRange(this, true);&#13;
            });&#13;
            // removing all single dots&#13;
            presenter.$view.find('.rangeImage').remove();&#13;
&#13;
&#13;
            var initRanges = presenter.validateRanges(presenter.configuration.ranges, presenter.configuration.separator);&#13;
            presenter.drawRanges(initRanges.shouldDrawRanges, true);&#13;
            presenter.configuration.mouseData.clicks = [];&#13;
        }&#13;
&#13;
        presenter.configuration.isCurrentlyVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.configuration.isShowErrorsMode = false;&#13;
        presenter.configuration.isDisabled = presenter.configuration.isDisabledByDefault;&#13;
&#13;
        presenter.leftShowAnswers = false;&#13;
        presenter.parentLeft = false;&#13;
&#13;
        twoPointClick = 0;&#13;
        presenter.$view.find('.inner').find('.startRange').css('visibility','visible');&#13;
    };&#13;
&#13;
    function getCorrectPoints() {&#13;
        var correctPoints = [];&#13;
        $.each(presenter.configuration.shouldDrawRanges, function() {&#13;
            if ($(this)[0].start.value === $(this)[0].end.value) {&#13;
                correctPoints.push($(this)[0].start.value)&#13;
            }&#13;
        });&#13;
&#13;
        $.each(presenter.configuration.otherRanges, function() {&#13;
            if ($(this)[0].start.value === $(this)[0].end.value) {&#13;
                correctPoints.push($(this)[0].start.value)&#13;
            }&#13;
        });&#13;
&#13;
        return correctPoints;&#13;
    }&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if(!presenter.configuration.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            presenter.configuration.isShowErrorsMode = true;&#13;
            var correctPoints = getCorrectPoints(),&#13;
            $elem;&#13;
&#13;
            if (presenter.checkedPoints.length === 0) {&#13;
                addInitPoints();&#13;
            }&#13;
&#13;
            presenter.results = {&#13;
                correct: 0,&#13;
                wrong: 0&#13;
            };&#13;
&#13;
            for (var i = 0; i &lt; presenter.checkedPoints.length; i++) {&#13;
                var point = presenter.checkedPoints[i];&#13;
                if (correctPoints.indexOf(point) !== -1) {&#13;
                    $elem = presenter.$view.find(".clickArea[value='" + point + "']");&#13;
                    $elem.next().toggleClass('include correctRangeInclude');&#13;
                    $elem.next().toggleClass('exclude correctRangeExclude');&#13;
                    presenter.results['correct'] += 1;&#13;
                } else {&#13;
                    $elem = presenter.$view.find(".clickArea[value='" + point + "']");&#13;
                    $elem.next().toggleClass('include wrongRangeInclude');&#13;
                    $elem.next().toggleClass('exclude wrongRangeExclude');&#13;
                    presenter.results['wrong'] += 1;&#13;
                }&#13;
            }&#13;
            presenter.$view.find('.outer').addClass("disable");&#13;
        } else if (presenter.configuration.isActivity &amp;&amp; !presenter.configuration.isDisabled) {&#13;
            // change single dot to point on axis&#13;
            if (presenter.singleDot.value != -1) {&#13;
                var newRange = {&#13;
                    start: createRangeElement(presenter.singleDot.element, presenter.singleDot.value, true),&#13;
                    end: createRangeElement(presenter.singleDot.element, presenter.singleDot.value, true)&#13;
                };&#13;
                setRangeValues(newRange, true);&#13;
                addToDrawnRanges(newRange);&#13;
                presenter.singleDot.value = -1;&#13;
            }&#13;
&#13;
            presenter.configuration.isShowErrorsMode = true;&#13;
            var validated = validateDrawnRanges();&#13;
&#13;
            $.each(validated.correct, function() {&#13;
                getSelectedRange(this).addClass('correct');&#13;
                addCorrectnessClassToRangeEnds(this, 'correct');&#13;
            });&#13;
&#13;
            $.each(validated.wrong, function() {&#13;
                getSelectedRange(this).addClass('wrong');&#13;
                addCorrectnessClassToRangeEnds(this, 'wrong');&#13;
            });&#13;
&#13;
            if (presenter.configuration.mouseData.clicks.length &gt; 0) {&#13;
                presenter.configuration.mouseData.clicks[0].element.parent().find('.rangeImage').remove();&#13;
            }&#13;
&#13;
            resetClicks();&#13;
&#13;
            presenter.$view.find('.outer').addClass("disable");&#13;
        }&#13;
    };&#13;
&#13;
    function addCorrectnessClassToRangeEnds(range, includePrefix) {&#13;
        var startImage = range.start.element.find('.rangeImage ');&#13;
        var endImage = range.end.element.find('.rangeImage');&#13;
&#13;
        if( startImage.hasClass('include') ) {&#13;
            startImage.removeClass('include');&#13;
            startImage.addClass(includePrefix + 'RangeInclude');&#13;
        } else {&#13;
            startImage.removeClass('exclude');&#13;
            startImage.addClass(includePrefix + 'RangeExclude');&#13;
        }&#13;
&#13;
        if( endImage.hasClass('include') ) {&#13;
            endImage.removeClass('include');&#13;
            endImage.addClass(includePrefix + 'RangeInclude');&#13;
        } else {&#13;
            endImage.removeClass('exclude');&#13;
            endImage.addClass(includePrefix + 'RangeExclude');&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        if ( presenter.configuration.isActivity &amp;&amp; !presenter.configuration.isDisabled ) {&#13;
            presenter.configuration.isShowErrorsMode = false;&#13;
&#13;
            presenter.$view.find('.correct').removeClass('correct');&#13;
            presenter.$view.find('.wrong').removeClass('wrong');&#13;
            presenter.$view.find('.correctRangeExclude, .wrongRangeExclude').removeClass('correctRangeExclude wrongRangeExclude').addClass('exclude');&#13;
            presenter.$view.find('.correctRangeInclude, .wrongRangeInclude').removeClass('correctRangeInclude wrongRangeInclude').addClass('include');&#13;
            presenter.$view.find('.outer').removeClass("disable");&#13;
        }&#13;
    };&#13;
&#13;
    function updateScore() {&#13;
        var correctPoints = getCorrectPoints();&#13;
        presenter.results = {&#13;
            correct: 0,&#13;
            wrong: 0&#13;
        };&#13;
&#13;
        for (var i = 0; i &lt; presenter.checkedPoints.length; i++) {&#13;
            var point = presenter.checkedPoints[i];&#13;
            if (correctPoints.indexOf(point) !== -1) {&#13;
                presenter.results['correct'] += 1;&#13;
            } else {&#13;
                presenter.results['wrong'] += 1;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.getScore = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        resetClicks();&#13;
&#13;
        if (!presenter.configuration.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            updateScore();&#13;
&#13;
            return presenter.results.correct;&#13;
        } else {&#13;
            var validated = validateDrawnRanges();&#13;
            return validated.correct.length;&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.configuration.otherRanges.length + presenter.configuration.shouldDrawRanges.length;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (!presenter.configuration.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            updateScore();&#13;
            return presenter.results.wrong;&#13;
        } else {&#13;
            var validated = validateDrawnRanges();&#13;
            return validated.wrong.length;&#13;
        }&#13;
    };&#13;
&#13;
    function validateDrawnRanges() {&#13;
&#13;
        var correctSelectedRanges = [];&#13;
        var wrongSelectedRanges = [];&#13;
        var ranges = presenter.configuration.otherRanges.concat(presenter.configuration.shouldDrawRanges);&#13;
&#13;
        $.each( presenter.configuration.drawnRangesData.ranges, function() {&#13;
            var drawnRange = this;&#13;
&#13;
            $.each( ranges, function() {&#13;
                setRangeValues(this, false);&#13;
&#13;
                if (compareRanges(this, drawnRange)) {&#13;
                    correctSelectedRanges.push(drawnRange);&#13;
                }&#13;
            });&#13;
&#13;
            if (correctSelectedRanges.indexOf(drawnRange) == -1) {&#13;
                wrongSelectedRanges.push(drawnRange)&#13;
            }&#13;
        });&#13;
&#13;
        return  {&#13;
            correct: correctSelectedRanges,&#13;
            wrong: wrongSelectedRanges&#13;
        }&#13;
    }&#13;
&#13;
    function checkIsRangeCorrect( range ) {&#13;
        var ranges = presenter.configuration.otherRanges.concat(presenter.configuration.shouldDrawRanges);&#13;
        var isCorrect = false;&#13;
&#13;
        setRangeValues(range, false);&#13;
&#13;
        $.each( ranges, function() {&#13;
            setRangeValues(this, false);&#13;
            if ( compareRanges(this, range) ) {&#13;
                isCorrect = true;&#13;
                return false; // breaks each loop&#13;
            }&#13;
        });&#13;
&#13;
        return isCorrect;&#13;
    }&#13;
&#13;
    function addToDrawnRanges ( range, shouldSendRanges ) {&#13;
        presenter.configuration.drawnRangesData.ranges.push( range );&#13;
&#13;
        if ( !presenter.configuration.isPreview &amp;&amp; !presenter.configuration.isInitialDraw &amp;&amp; !presenter.isShowAnswersActive) {&#13;
            var rangeString = presenter.convertRangeToString(range);&#13;
            var isRangeCorrect = checkIsRangeCorrect(range);&#13;
            var eventData = presenter.createEventData(rangeString, false, isRangeCorrect);&#13;
            if (shouldSendRanges) {&#13;
                eventBus.sendEvent('ValueChanged', eventData);&#13;
            }&#13;
&#13;
            if ( shouldSendRanges &amp;&amp; presenter.allRangesCorrect() ) {&#13;
                eventData = presenter.createAllOKEventData();&#13;
                eventBus.sendEvent('ValueChanged', eventData);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.allRangesCorrect = function() {&#13;
        return presenter.getScore() - presenter.getMaxScore() == 0 &amp;&amp; presenter.getErrorCount() == 0;&#13;
    };&#13;
&#13;
    function compareRanges(rangeA, rangeB) {&#13;
        return (compareArray(rangeA.values, rangeB.values) &amp;&amp; rangeA.start.include == rangeB.start.include &amp;&amp; rangeA.end.include == rangeB.end.include)&#13;
    }&#13;
&#13;
    function compareArray(arrA, arrB) {&#13;
        var i = arrA.length;&#13;
        if (i != arrB.length) return false;&#13;
&#13;
        while ( i-- ) {&#13;
            if (arrA[i] !== arrB[i]) return false;&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function parseElement( element ) {&#13;
        switch (element) {&#13;
            case element.find('.infinity-left').length &gt; 0:&#13;
                return presenter.$view.find('.clickArea[value="' + presenter.configuration.min + '"]').parent();&#13;
            case element.find('.infinity-right').length &gt; 0:&#13;
                return presenter.$view.find('.clickArea[value="' + presenter.configuration.max + '"]').parent();&#13;
            default:&#13;
                return element;&#13;
        }&#13;
    }&#13;
&#13;
    function parseRangeStartOrEnd (value, separator) {&#13;
&#13;
        if ( value == '-INF' || value == -Infinity ) {&#13;
            return -Infinity;&#13;
        }&#13;
        else if ( value == 'INF' || value == Infinity ) {&#13;
            return Infinity;&#13;
        }&#13;
        else {&#13;
            var parsedValue = presenter.parseValueWithSeparator(value, separator);&#13;
            return parseFloat( parsedValue );&#13;
        }&#13;
    }&#13;
&#13;
    presenter.validateDecimalSeparator = function (decimalSeparator) {&#13;
        if ( ModelValidationUtils.isStringEmpty(decimalSeparator) ) {&#13;
            return {value: '.', isValid: true};&#13;
        }&#13;
&#13;
        if ( $.trim(decimalSeparator) == ';' ) {&#13;
            return {value: null, isValid: false, errorCode: 'DSE01'};&#13;
        }&#13;
&#13;
        return {value: decimalSeparator, isValid: true};&#13;
    };&#13;
&#13;
    presenter.validateRanges = function (ranges, separator) {&#13;
        if (separator == undefined) {&#13;
            separator = '.';&#13;
        }&#13;
&#13;
        var rangesList = Helpers.splitLines(ranges);&#13;
        separator = escapeRegexSpecialCharacters(separator);&#13;
        var rangesPattern = new RegExp('(\\(|&lt;){1}[(?P \\d|(-){1}INF' + separator + ')-]+;[(?P \\d|(-){1}INF' + separator + ')-]+(\\)|&gt;){1};[ ]*(0|1){1}', 'i'); // matches i.e. (1; 0); 0 or &lt;2; 15); 1, &lt;-INF; 10); 1, &lt;1.5; 2.5); 0&#13;
//        var rangesPattern = /(\(|&lt;){1}[(?P \d|(-){1}INF\.)-]+;[(?P \d|(-){1}INF\.)-]+(\)|&gt;){1};[ ]*(0|1){1}/i;&#13;
        var validatedShouldDrawRanges = [];&#13;
        var validatedOtherRanges = [];&#13;
        var isError = false,&#13;
            errorCode = '';&#13;
&#13;
        $.each(rangesList, function() {&#13;
            var rangeString = this.toString();&#13;
&#13;
            if( !rangesPattern.test(rangeString) ) {&#13;
                isError = true;&#13;
                errorCode = 'RAN01';&#13;
&#13;
                return false; // Breaks jQuery.each loop&#13;
            }&#13;
&#13;
            var regexResult = rangesPattern.exec(rangeString)[0];&#13;
            var brackets = regexResult.match(/[\(\)&lt;&gt;]+/g);&#13;
            var onlyNumbersAndCommas = regexResult.replace(/[ \(\)&lt;&gt;]*/g, '');&#13;
            var onlyNumbers = onlyNumbersAndCommas.split(';');&#13;
            var min = parseRangeStartOrEnd(onlyNumbers[0], separator);&#13;
            var max = parseRangeStartOrEnd(onlyNumbers[1], separator);&#13;
            var minInclude = brackets[0] == '&lt;' || min == -Infinity;&#13;
            var maxInclude = brackets[1] == '&gt;' || max == Infinity;&#13;
            var shouldDrawRange = onlyNumbers[2] == '1';&#13;
&#13;
            if ( (min &gt; max)&#13;
                || (min == Infinity &amp;&amp; max == Infinity)&#13;
                || (min == -Infinity &amp;&amp; max == -Infinity) ) {&#13;
&#13;
                isError = true;&#13;
                errorCode = 'MIN/MAX01';&#13;
&#13;
                return false; // Breaks jQuery.each loop&#13;
            }&#13;
&#13;
            var validatedRange = {&#13;
                start: { value : min, include: minInclude, element: null },&#13;
                end: { value: max, include: maxInclude, element: null }&#13;
            };&#13;
&#13;
            if (shouldDrawRange) {&#13;
                validatedShouldDrawRanges.push(validatedRange);&#13;
            } else {&#13;
                validatedOtherRanges.push(validatedRange);&#13;
            }&#13;
&#13;
            return true; // jQuery.each continue statement&#13;
        });&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            isError: isError,&#13;
            errorCode: errorCode,&#13;
            shouldDrawRanges : validatedShouldDrawRanges,&#13;
            otherRanges : validatedOtherRanges&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateRangesWithAxisXField = function (ranges, axisXFieldValues) {&#13;
        var allRanges = ranges.otherRanges.concat(ranges.shouldDrawRanges);&#13;
&#13;
        function checkRange(range) {&#13;
            if ( (axisXFieldValues.indexOf(range.start.value) == -1 || axisXFieldValues.indexOf(range.end.value) == -1)&#13;
                &amp;&amp; (!isValueInfinity(range.start.value) &amp;&amp; !isValueInfinity(range.end.value) )) {&#13;
&#13;
                presenter.configuration.isError = true;&#13;
                DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, 'RAN02');&#13;
&#13;
                return false;&#13;
            }&#13;
&#13;
            return true;&#13;
        }&#13;
&#13;
        if (!allRanges.every(checkRange)) {&#13;
            return presenter.getErrorObject("RAN02");&#13;
        }&#13;
&#13;
        var lastElement = presenter.maxFromArray(axisXFieldValues);&#13;
        if ( axisXFieldValues.indexOf(lastElement) == -1 ) {&#13;
            presenter.configuration.isError = true;&#13;
            DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, 'MAX04');&#13;
        }&#13;
&#13;
        return {isValid: true, value: allRanges};&#13;
    };&#13;
&#13;
    presenter.maxFromArray = function (array_of_numbers) {&#13;
        if (array_of_numbers.length == 0) {throw "ValueError: maxFromArray() arg is an empty array";}&#13;
&#13;
        var max = array_of_numbers[0];&#13;
&#13;
        for(var i = 0; i &lt; array_of_numbers.length; i++){&#13;
            if (array_of_numbers[i] &gt; max) {max = array_of_numbers[i];}&#13;
        }&#13;
&#13;
        return max;&#13;
    };&#13;
&#13;
    presenter.minFromArray = function (array_of_numbers) {&#13;
        if (array_of_numbers.length == 0) {throw "ValueError: minFromArray() arg is an empty array";}&#13;
&#13;
        var min = array_of_numbers[0];&#13;
&#13;
        for(var i = 0; i &lt; array_of_numbers.length; i++){&#13;
            if (array_of_numbers[i] &lt; min) {min = array_of_numbers[i];}&#13;
        }&#13;
&#13;
        return min;&#13;
    };&#13;
&#13;
    function escapeRegexSpecialCharacters(value) {&#13;
        return (value + '').replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&amp;'); // escape regex special characters&#13;
    }&#13;
&#13;
    presenter.validateValueWithSeparator = function (value, separator) {&#13;
        var escapedSeparator = escapeRegexSpecialCharacters(separator);&#13;
&#13;
        var pattern = new RegExp('^(-{0,1}\\d+)' + escapedSeparator + '{0,1}\\d*$', 'i');&#13;
&#13;
        if ( pattern.test(value) ) {&#13;
            return {&#13;
                'isValid' : true,&#13;
                'value' : presenter.parseValueWithSeparator(value, separator),&#13;
                'precision' : getPrecision(value, separator)&#13;
            }&#13;
        } else {&#13;
            return {&#13;
                'isValid' : false,&#13;
                'value' : null&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    function getPrecision(value, separator) {&#13;
        var splitted = value.split(separator);&#13;
        if ( splitted.length == 1 ) {&#13;
            return 0;&#13;
        } else {&#13;
            return splitted[1].length;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.parseValueWithSeparator = function (value, separator) {&#13;
        return (value + '').replace(separator, '.');&#13;
    };&#13;
&#13;
    presenter.getErrorObject = function (errorCode) {&#13;
        return {isValid: false, errorCode: errorCode, isError: true};&#13;
    };&#13;
&#13;
    presenter.validateMin = function (model, separator) {&#13;
        if(ModelValidationUtils.isStringEmpty(model['Min'])) {&#13;
            return presenter.getErrorObject("MIN01");&#13;
        }&#13;
&#13;
        var validatedMinWithSeparator = presenter.validateValueWithSeparator(model['Min'], separator);&#13;
        if(!validatedMinWithSeparator.isValid) {&#13;
            return presenter.getErrorObject("MIN03");&#13;
        }&#13;
&#13;
        validatedMinWithSeparator = ModelValidationUtils.validateFloat( validatedMinWithSeparator.value );&#13;
        if ( !validatedMinWithSeparator.isValid) {&#13;
            return presenter.getErrorObject("MIN02");&#13;
        }&#13;
&#13;
&#13;
        return {isValid: true, value: validatedMinWithSeparator.parsedValue};&#13;
    };&#13;
&#13;
    presenter.validateMax = function (model, separator) {&#13;
        if( ModelValidationUtils.isStringEmpty(model['Max']) ) {&#13;
            return presenter.getErrorObject("MAX01");&#13;
        }&#13;
&#13;
        var validatedMaxWithSeparator = presenter.validateValueWithSeparator(model['Max'], separator);&#13;
&#13;
        if(!validatedMaxWithSeparator.isValid) {&#13;
            return presenter.getErrorObject("MAX03");&#13;
        }&#13;
&#13;
        validatedMaxWithSeparator = ModelValidationUtils.validateFloat( validatedMaxWithSeparator.value );&#13;
        if ( !validatedMaxWithSeparator.isValid ) {&#13;
            return presenter.getErrorObject("MAX02");&#13;
        }&#13;
&#13;
        return {isValid: true, value: validatedMaxWithSeparator.parsedValue};&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var separator = presenter.validateDecimalSeparator(model['Decimal Separator']);&#13;
        if (!separator.isValid) {&#13;
            return presenter.getErrorObject("DSE01");&#13;
        }&#13;
&#13;
        var validatedMin = presenter.validateMin(model, separator.value);&#13;
        if ( !validatedMin.isValid ) {&#13;
            return validatedMin;&#13;
        }&#13;
&#13;
        var validatedMax = presenter.validateMax(model, separator.value);&#13;
        if ( !validatedMax.isValid ) {&#13;
            return validatedMax;&#13;
        }&#13;
&#13;
        if( !checkIsMinLowerThanMax(validatedMin.value, validatedMax.value) ) {&#13;
            return presenter.getErrorObject("MIN/MAX01");&#13;
        }&#13;
&#13;
        var validatedStep = presenter.validateStep(model, separator, validatedMax.value, validatedMin.value);&#13;
        if (!validatedStep.isValid) {&#13;
            return validatedStep;&#13;
        }&#13;
&#13;
        var axisXFieldValues = presenter.createAxisXFieldValues(validatedMin.value, validatedMax.value, validatedStep.value);&#13;
&#13;
        var validatedRanges = presenter.validateRanges(model["Ranges"], separator.value);&#13;
        if(!validatedRanges.isValid) {&#13;
            return validatedRanges;&#13;
        }&#13;
&#13;
        var validatedRangesWithAxisXField = presenter.validateRangesWithAxisXField(validatedRanges, axisXFieldValues);&#13;
        if (!validatedRangesWithAxisXField.isValid) {&#13;
            return validatedRangesWithAxisXField;&#13;
        }&#13;
&#13;
        var validatedIsActivity = !ModelValidationUtils.validateBoolean(model['Not Activity']);&#13;
&#13;
        var addonConfiguration = {&#13;
            isDecimalSeparatorSet: !ModelValidationUtils.isStringEmpty(separator.value),&#13;
            decimalSeparator: separator.value,&#13;
            max: validatedMax.value,&#13;
            min: validatedMin.value&#13;
        };&#13;
&#13;
        var validatedAxisXValues = presenter.validateAxisXValues(model, addonConfiguration);&#13;
&#13;
        if(!validatedAxisXValues.isValid) {&#13;
            return validatedAxisXValues;&#13;
        }&#13;
&#13;
        var isVisible = ModelValidationUtils.validateBoolean(model['Is Visible']);&#13;
        var isDisabled = ModelValidationUtils.validateBoolean(model['Disable']);&#13;
&#13;
        if (isDisabled) {&#13;
            presenter.$view.find('.outer').addClass('disable');&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            isError : false,&#13;
            min : validatedMin.value,&#13;
            max : validatedMax.value,&#13;
            shouldDrawRanges : validatedRanges.shouldDrawRanges,&#13;
            otherRanges : validatedRanges.otherRanges,&#13;
            isActivity : validatedIsActivity,&#13;
            step : validatedStep.value,&#13;
            showAxisXValues : ModelValidationUtils.validateBoolean(model['Show Axis X Values']),&#13;
            axisXValues : validatedAxisXValues.value,&#13;
            mouseData : {&#13;
                clickedRanges : [],&#13;
                clicks : [],&#13;
                twoClickedRangesCount : 0&#13;
            },&#13;
            drawnRangesData : {&#13;
                isDrawn : false,&#13;
                ranges : [],&#13;
                values : []&#13;
            },&#13;
            touchData : {&#13;
                lastEvent : null&#13;
            },&#13;
            isShowErrorsMode : false,&#13;
            isCurrentlyVisible: isVisible,&#13;
            isVisibleByDefault: isVisible,&#13;
            notCurrentSelectedRange : null,&#13;
            addonID : model['ID'],&#13;
            isInitialDraw : true,&#13;
            isDisabled: isDisabled,&#13;
            isDisabledByDefault: isDisabled,&#13;
            separator: separator.value,&#13;
            axisXFieldValues: axisXFieldValues,&#13;
            allRanges: validatedRangesWithAxisXField.value,&#13;
            isCustomAxisXValuesSet: validatedAxisXValues.isCustomAxisXValuesSet,&#13;
            ranges: model["Ranges"],&#13;
            dontShowRanges: ModelValidationUtils.validateBoolean(model["Don't show ranges"]) || false&#13;
        };&#13;
    };&#13;
&#13;
    presenter.isZeroInRange = function(min, max) {&#13;
        return (min &lt;= 0 &amp;&amp; max &gt;= 0) || (min &lt; 0 &amp;&amp; max == 0) || (min == 0 &amp;&amp; max &gt; 0);&#13;
    };&#13;
&#13;
    function getAxisXValuesErrors(fixedValues, cyclicValues, addonConfiguration) {&#13;
        if((fixedValues.filter(isNaN).length + cyclicValues.filter(isNaN).length) &gt; 0) {&#13;
            return presenter.getErrorObject("AXV_04");&#13;
        }&#13;
&#13;
        if(!cyclicValues.every(function (value) {return (value &gt;= 0)})) {&#13;
            return presenter.getErrorObject("AXV_01");&#13;
        }&#13;
&#13;
        if(!fixedValues.every(function (value) {return (value &gt;= addonConfiguration.min);})) {&#13;
            return presenter.getErrorObject("AXV_02");&#13;
        }&#13;
&#13;
        if(!fixedValues.every(function (value) {return (value &lt;= addonConfiguration.max);})) {&#13;
            return presenter.getErrorObject("AXV_03");&#13;
        }&#13;
&#13;
        return {isValid: true};&#13;
    }&#13;
&#13;
    function parseAxisXValuesFromModel(model, addonConfiguration) {&#13;
        return model["Axis X Values"].split(";").map(function (element) {&#13;
            element.trim();&#13;
            if (addonConfiguration.isDecimalSeparatorSet) {&#13;
                return element.replace(addonConfiguration.decimalSeparator, ".");&#13;
            }&#13;
&#13;
            return element;&#13;
        });&#13;
    }&#13;
&#13;
    function filterCyclicValues (value) {&#13;
        return (value.charAt(value.length - 1) == "*");&#13;
    }&#13;
&#13;
    function filterFixedValuesBasedOnCyclic (element) {&#13;
        return (this.indexOf(element) == -1);&#13;
    }&#13;
&#13;
    presenter.validateAxisXValues = function (model, addonConfiguration) {&#13;
&#13;
        if(ModelValidationUtils.isStringEmpty(model["Axis X Values"])) {&#13;
            return {isValid: true, isCustomAxisXValuesSet: false, value: {}};&#13;
        }&#13;
&#13;
        var values = parseAxisXValuesFromModel(model, addonConfiguration);&#13;
&#13;
        var cyclicValues = values.filter(filterCyclicValues);&#13;
&#13;
        var fixedValues = values.filter(filterFixedValuesBasedOnCyclic, cyclicValues).map(Number);&#13;
&#13;
        cyclicValues = cyclicValues.map(function (value) {&#13;
            return Number(value.slice(0, value.length -1));&#13;
        });&#13;
&#13;
        var axisXValuesErrors = getAxisXValuesErrors(fixedValues, cyclicValues, addonConfiguration);&#13;
        if (!axisXValuesErrors.isValid) {&#13;
            return axisXValuesErrors;&#13;
        }&#13;
&#13;
        cyclicValues = cyclicValues.map(function (value) {&#13;
            if(value == 0) {return 1};&#13;
            return value;&#13;
        });&#13;
&#13;
        function isDuplicate(value) {&#13;
            return (this.filter(function (currentValue) {return (value == currentValue);}).length == 1);&#13;
        }&#13;
&#13;
        if((!cyclicValues.every(isDuplicate, cyclicValues)) || (!fixedValues.every(isDuplicate, fixedValues))) {&#13;
            return presenter.getErrorObject("AXV_05");&#13;
        }&#13;
&#13;
        return {isValid: true, isCustomAxisXValuesSet: true, value: {cyclicValues: cyclicValues, fixedValues: fixedValues}};&#13;
    };&#13;
&#13;
    presenter.createAxisXFieldValues = function (min, max, step) {&#13;
        var precision = presenter.maxElement([presenter.getNumberPrecision(step), presenter.getNumberPrecision(min), presenter.getNumberPrecision(max)]);   //max()&#13;
        var values = [];&#13;
        var i;&#13;
&#13;
        function changePrecision(value) {return presenter.changeNumberToPrecision(value, precision);}&#13;
&#13;
        for (i = min; i &lt;= max; i += step) {&#13;
            values.push(i);&#13;
        }&#13;
&#13;
        if (presenter.isZeroInRange(min, max)) {&#13;
            if (values.indexOf(0) == -1) {&#13;
                values.push(0);&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        return values.map(changePrecision).sort(function(a, b) {&#13;
           return a - b;&#13;
        });&#13;
    };&#13;
&#13;
    presenter.getNumberPrecision = function(value) {&#13;
        value = value.toString();&#13;
        value = value.split(".");&#13;
&#13;
        var len;&#13;
        try {&#13;
            len = value[1].length;&#13;
        } catch (_){&#13;
            len = 0;&#13;
        }&#13;
&#13;
        return len;&#13;
    };&#13;
&#13;
    presenter.changeNumberToPrecision = function (value, precision) {&#13;
        //toFixed value rounds up to closest number eg. 23.6xx.toFixed(0) -&gt; 24, when we want get 23&#13;
        if (precision == 0) {&#13;
            return parseInt(value, 10);&#13;
        }&#13;
        return Number(value.toFixed(precision));&#13;
    };&#13;
&#13;
    presenter.findStartingPointInField = function (min, max, step) {&#13;
        var precision = presenter.getNumberPrecision(step);&#13;
        var startingPoint;&#13;
        if (min &gt; 0) {&#13;
            if (min % step == 0) {&#13;
                return {startingPoint: min, fieldEnd: max};&#13;
            }&#13;
&#13;
            startingPoint = ((parseInt(min / step) * step) + step);&#13;
            return {startingPoint: presenter.changeNumberToPrecision(startingPoint, precision), fieldEnd: max};&#13;
        }&#13;
&#13;
        if(min &lt; 0) {&#13;
            if (max % step == -0) {&#13;
                return {startingPoint: max, fieldEnd: min};&#13;
            }&#13;
&#13;
            startingPoint = ((parseInt(max / step) *  step) - step);&#13;
            return {startingPoint: presenter.changeNumberToPrecision(startingPoint, precision), fieldEnd: min};&#13;
        }&#13;
    };&#13;
&#13;
    presenter.abs = function (value) {&#13;
        if (value &lt; 0) {&#13;
            return value * -1;&#13;
        }&#13;
&#13;
        return value;&#13;
    };&#13;
&#13;
    presenter.validateStep = function (model, separator, max, min) {&#13;
        if(ModelValidationUtils.isStringEmpty(model['Step'])) {&#13;
            return {isValid: true, value : 1, precision : 0};&#13;
        }&#13;
&#13;
        var validatedStep = presenter.validateValueWithSeparator( model['Step'], separator.value );&#13;
&#13;
        var precision = validatedStep.precision;&#13;
&#13;
        if (!validatedStep.isValid) {&#13;
            return presenter.getErrorObject('STEP02');&#13;
        }&#13;
&#13;
        validatedStep = ModelValidationUtils.validateFloatInRange(validatedStep.value,&#13;
            presenter.maxFromArray([max, min].map(presenter.abs)), 0, precision);&#13;
        validatedStep.precision = precision;&#13;
&#13;
        if(validatedStep.value == 0) {&#13;
            return presenter.getErrorObject("STEP03");&#13;
        }&#13;
&#13;
        if (!validatedStep.isValid) {&#13;
            return presenter.getErrorObject("STEP01");&#13;
        }&#13;
&#13;
        return {isValid: true, value: validatedStep.parsedValue, precision: validatedStep.precision};&#13;
    };&#13;
&#13;
    presenter.isMultiplication = function (value) {&#13;
        var pattern = new RegExp('^[\\d]+\\*{1}$', 'i');&#13;
        return pattern.test(value);&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'drawRange' : presenter.drawRange,&#13;
            'enable': presenter.enable,&#13;
            'disable': presenter.disable,&#13;
            'showAnswers': presenter.showAnswers,&#13;
            'hideAnswers': presenter.hideAnswers&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.children('div').css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.configuration.isCurrentlyVisible = true;&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.configuration.isCurrentlyVisible = false;&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.setDisableState = function(isDisabled) {&#13;
        var element = presenter.$view.find('.outer');&#13;
&#13;
        if (isDisabled) {&#13;
            element.addClass("disable");&#13;
        } else {&#13;
            element.removeClass("disable");&#13;
        }&#13;
&#13;
        presenter.configuration.isDisabled = isDisabled;&#13;
    };&#13;
&#13;
    presenter.enable = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.setDisableState(false);&#13;
&#13;
        bindClickAreaListeners( presenter.$view.find('.clickArea') );&#13;
        presenter.bindInfinityAreas();&#13;
        resetClicks();&#13;
    };&#13;
&#13;
    presenter.disable = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.setDisableState(true);&#13;
&#13;
        removeAllClickListeners();&#13;
    };&#13;
&#13;
    presenter.drawRange = function (rangeList) {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        rangeList = [].concat(rangeList);&#13;
        var rangeString = rangeList.join('\n\r');&#13;
        var validatedRanges = presenter.validateRanges(rangeString);&#13;
&#13;
        $.each(validatedRanges.shouldDrawRanges, function() {&#13;
            removeRangesBetweenRange(this);&#13;
        });&#13;
&#13;
        presenter.drawRanges(validatedRanges.shouldDrawRanges, false);&#13;
&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        playerController = controller;&#13;
        eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    presenter.createEventData = function (rangeString, isRemove, isRangeCorrect) {&#13;
        return {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': rangeString,&#13;
            'value': isRemove ? '0' : '1',&#13;
            'score': isRangeCorrect ? '1' : '0'&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createActionEventData = function(item, action, isCorrect) {&#13;
        return {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': item,&#13;
            'value': action,&#13;
            'score': isCorrect ? '1' : '0'&#13;
        };&#13;
    }&#13;
&#13;
    presenter.createAllOKEventData = function () {&#13;
        return {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (!presenter.configuration.isActivity){&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
&#13;
        presenter.setWorkMode();&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            presenter.$view.find('.rangeImage').remove();&#13;
            var correctPoints = getCorrectPoints();&#13;
&#13;
            drawPoints(correctPoints);&#13;
            presenter.$view.find('.rangeImage').each(function() {&#13;
                $(this).addClass('show-answers');&#13;
            });&#13;
        } else {&#13;
            presenter.currentRanges = jQuery.extend(true ,{}, presenter.configuration.drawnRangesData);&#13;
&#13;
            presenter.leftShowAnswers = presenter.parentLeft;&#13;
            if (presenter.leftShowAnswers){&#13;
                presenter.$view.find('.rangeImage').each(function () {&#13;
                    if (parseInt($(this).parent()[0].style.left, 10).toFixed(1) == parseInt(presenter.leftShowAnswers, 10).toFixed(1)){&#13;
                        presenter.rangeShowAnswers = $(this);&#13;
                    }&#13;
                });&#13;
            }&#13;
&#13;
            presenter.$view.find('.rangeImage').remove();&#13;
&#13;
            var rangesToRemove = [].concat(presenter.configuration.drawnRangesData.ranges);&#13;
&#13;
            $.each(rangesToRemove, function() {&#13;
                presenter.removeRange(this, true);&#13;
            });&#13;
&#13;
            presenter.drawRanges(presenter.configuration.shouldDrawRanges, true);&#13;
            presenter.drawRanges(presenter.configuration.otherRanges, true);&#13;
&#13;
            $.each(presenter.configuration.drawnRangesData.ranges, function() {&#13;
                getSelectedRange(this).addClass('show-answers');&#13;
            });&#13;
        }&#13;
        presenter.$view.find('.outer').addClass("disable");&#13;
    };&#13;
&#13;
    function drawPoints(pointsToDraw) {&#13;
        presenter.$view.find('.rangeImage').remove();&#13;
        presenter.$view.find('.clickArea').each(function() {&#13;
            var $imageContainer = $('&lt;div&gt;&lt;/div&gt;');&#13;
            $imageContainer.addClass('rangeImage exclude include');&#13;
            if (pointsToDraw.indexOf($(this).attr('value')) != -1) {&#13;
                $(this).parent('').append($imageContainer);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if(!presenter.configuration.isActivity || !presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
        presenter.hideAnswerClicked = true;&#13;
&#13;
&#13;
        presenter.$view.find('.show-answers').removeClass('show-answers');&#13;
&#13;
        if (presenter.configuration.dontShowRanges) {&#13;
            drawPoints(presenter.checkedPoints);&#13;
        } else {&#13;
            var rangesToRemove = [].concat(presenter.configuration.drawnRangesData.ranges);&#13;
&#13;
            $.each(rangesToRemove, function() {&#13;
                presenter.removeRange(this, true);&#13;
            });&#13;
            presenter.redrawRanges(presenter.currentRanges.ranges);&#13;
&#13;
            if(presenter.leftShowAnswers){&#13;
                presenter.$view.find('.stepLine').each(function () {&#13;
                    if(parseInt($(this)[0].style.left, 10).toFixed(1) == parseInt(presenter.leftShowAnswers, 10).toFixed(1)){&#13;
                        $(this).append(presenter.rangeShowAnswers);&#13;
                    }&#13;
                });&#13;
            }&#13;
        }&#13;
&#13;
        presenter.hideAnswerClicked = false;&#13;
        presenter.isShowAnswersActive = false;&#13;
        presenter.$view.find('.outer').removeClass("disable");&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>