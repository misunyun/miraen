<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Maze" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="mazeWidth" nameLabel="Maze_property_width" type="string"/>
		<property name="mazeHeight" nameLabel="Maze_property_height" type="string"/>
		<property name="numberOfMazes" nameLabel="Maze_property_number_of_mazes" type="string"/>
		<property name="gameMode" nameLabel="Maze_property_game_mode" type="{Doors,Letters}"/>

		<property name="questions" nameLabel="Maze_property_questions" type="list">
            <property name="question" nameLabel="Maze_property_questions_question" type="html"/>
            <property name="answer" nameLabel="Maze_property_questions_answer" type="string"/>
			<property name="letter" nameLabel="Maze_property_questions_letter" type="string"/>
			<property name="mazeId" nameLabel="Maze_property_questions_maze_number" type="string"/>
			<property name="isCaseSensitive" nameLabel="Maze_property_questions_is_case_sensitive" type="boolean"/>
        </property>
		<property name="isDisabled" nameLabel="Maze_property_is_disabled" type="boolean"/>
		<property name="hideControlPanel" nameLabel="Maze_property_hide_control_panel" type="boolean"/>
		<property name="translations" nameLabel="Maze_property_translations" type="staticlist">
			<property name="endGame" nameLabel="Maze_property_translations_end_game" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="applyQuestion" nameLabel="Maze_property_translations_apply_question_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="nextMazeButton" nameLabel="Maze_property_translations_next_maze_button" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="solutionText" nameLabel="Maze_property_translations_level_solution_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="upButton" nameLabel="Maze_property_translations_up_button_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="leftButton" nameLabel="Maze_property_translations_left_button_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="rightButton" nameLabel="Maze_property_translations_right_button_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="downButton" nameLabel="Maze_property_translations_down_button_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="loose" nameLabel="Maze_property_translations_loose_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
			<property name="looseButton" nameLabel="Maze_property_translations_retry_button_text" type="staticrow">
				<property name="translation" nameLabel="Maze_property_translations_translation" type="string"/>
			</property>
		</property>
	</model>
<css>.Maze-wrapper {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.Maze-wrapper-menu {&#13;
    float: right;&#13;
    height: 100%;&#13;
    width: 200px;&#13;
    border-left: solid 1px;&#13;
    box-sizing: border-box;&#13;
}&#13;
&#13;
.Maze-wrapper-game-container{&#13;
    float: left;&#13;
    height: 100%;&#13;
    width: calc(100% - 200px);&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls {&#13;
    position: absolute;&#13;
    bottom: 0;&#13;
    width: inherit;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-up {&#13;
    width: 33%;&#13;
    margin-left: auto;&#13;
    margin-right: auto;&#13;
}&#13;
.Maze-wrapper-menu-controls-down {&#13;
    clear: both;&#13;
    width: 33%;&#13;
    margin-left: auto;&#13;
    margin-right: auto;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-left {&#13;
    float: left;&#13;
    width: 33%;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-right {&#13;
    float: right;&#13;
    width: 33%;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-no-select {&#13;
    -webkit-touch-callout: none; /* iOS Safari */&#13;
    -webkit-user-select: none; /* Safari */&#13;
    -khtml-user-select: none; /* Konqueror HTML */&#13;
    -moz-user-select: none; /* Firefox */&#13;
    -ms-user-select: none; /* Internet Explorer/Edge */&#13;
    user-select: none; /* Non-prefixed version, currently&#13;
                          supported by Chrome and Opera */&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-up-text {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-down-text {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-left-text {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze-wrapper-menu-controls-right-text {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_main_container {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.Maze_room {&#13;
    float: left;&#13;
    -webkit-transform: rotate(0deg);&#13;
    -moz-transform: rotate(0deg);&#13;
    -ms-transform: rotate(0deg);&#13;
    -o-transform: rotate(0deg);&#13;
    transform: rotate(0deg);&#13;
    background-color: white;&#13;
}&#13;
&#13;
.Maze_room &gt; div {&#13;
    width: 100%;&#13;
    height:100%;&#13;
    position: absolute;&#13;
}&#13;
&#13;
.Maze_room_image_top_left_right_bottom {&#13;
    background: url('resources/topleftrightbottom.svg') no-repeat center;&#13;
    background-size: contain;    &#13;
}&#13;
&#13;
.Maze_room_image_top_left_right {&#13;
    background: url('resources/topleftright.svg') no-repeat center;&#13;
    background-size: contain;  &#13;
}&#13;
&#13;
.Maze_room_image_top_left {&#13;
    background: url('resources/topleft.svg') no-repeat center;&#13;
    background-size: contain;  &#13;
}&#13;
&#13;
.Maze_room_image_top_bottom {&#13;
    background: url('resources/topbottom.svg') no-repeat center;&#13;
    background-size: contain;  &#13;
}&#13;
&#13;
.Maze_room_image_top {&#13;
    background: url('resources/top.svg') no-repeat center;&#13;
    background-size: contain;  &#13;
}&#13;
&#13;
.Maze_player_element {&#13;
    background: url('resources/player.svg') no-repeat center;&#13;
    background-size: contain;  &#13;
}&#13;
&#13;
.Maze_treasure_element {&#13;
    background: url('resources/treasure.svg') no-repeat center;&#13;
    background-size: 80% 80%;&#13;
}&#13;
&#13;
.Maze_door {&#13;
    background: url('resources/door.svg') no-repeat center;&#13;
    background-size: 80% 80%;&#13;
}&#13;
&#13;
.Maze_door_opened {&#13;
    background: url('resources/door_opened.svg') no-repeat center;&#13;
    background-size: 80% 80%;&#13;
}&#13;
&#13;
.Maze_room_left_top_dot {&#13;
    background: url('resources/dot.svg') no-repeat center;&#13;
    background-size: contain;   &#13;
}&#13;
&#13;
.Maze_game_question_background {&#13;
    background-color: lightgray;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    position: absolute;&#13;
    opacity: 0.6;&#13;
    left: -1px;&#13;
    top: -1px;&#13;
    display: none;&#13;
}&#13;
&#13;
.Maze_game_question_container {&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    transform: translateY(-50%);&#13;
    -webkit-transform: translateY(-50%);&#13;
    -ms-transform: translateY(-50%);&#13;
    width: 100%;&#13;
    display: none;&#13;
}&#13;
&#13;
.Maze_game_question_container_question_input {&#13;
    width: 100%;&#13;
    box-sizing: border-box;&#13;
}&#13;
&#13;
.Maze_game_question_container_question_apply_text {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_game_question_container_question_apply {&#13;
    background-color: gray;&#13;
    margin-top: 5px;&#13;
&#13;
}&#13;
&#13;
.Maze_game_question_container_question_apply:hover {&#13;
    background-color: lightgray;&#13;
}&#13;
&#13;
.Maze_game_end {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    position: absolute;&#13;
    top: -1px;&#13;
    left: -1px;&#13;
    background-color: gray;&#13;
    display: none;&#13;
}&#13;
&#13;
.Maze_loose {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    position: absolute;&#13;
    top: -1px;&#13;
    left: -1px;&#13;
    background-color: gray;&#13;
    display: none;&#13;
}&#13;
&#13;
.Maze_game_loose_wrapper {&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    transform: translateY(-50%);&#13;
    -webkit-transform: translateY(-50%);&#13;
    -ms-transform: translateY(-50%);&#13;
    width: 100%;&#13;
}&#13;
&#13;
.Maze_game_loose_text {&#13;
    width: 100%;&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_game_loose_button {&#13;
    width: 100%;&#13;
    background-color: lightgray;&#13;
    text-align: center;&#13;
    margin-top: 50px;&#13;
}&#13;
&#13;
.Maze_game_end_text {&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    transform: translateY(-50%);&#13;
    -webkit-transform: translateY(-50%);&#13;
    -ms-transform: translateY(-50%);&#13;
    width: 100%;&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_letters_end_level_answer_letters_end_game {&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    transform: translateY(-50%);&#13;
    -webkit-transform: translateY(-50%);&#13;
    -ms-transform: translateY(-50%);&#13;
    width: 100%;&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_letters_end_level {&#13;
    background: url('resources/letterEndGame.svg') no-repeat center;&#13;
    background-size: 80% 80%;&#13;
}&#13;
&#13;
.Maze_letters_end_level_background {&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    background-color: gray;&#13;
    display: none;&#13;
}&#13;
&#13;
.Maze_letters_end_level_next_maze_button {&#13;
    width: 100%;&#13;
    background-color: lightgray;&#13;
    text-align: center;&#13;
    margin-top: 50px;&#13;
}&#13;
&#13;
.Maze_end_level_answer_end_game {&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_letters_end_level_answer_wrapper {&#13;
    position: absolute;&#13;
    width: 100%;&#13;
    top: 50%;&#13;
    transform: translateY(-50%);&#13;
    -webkit-transform: translateY(-50%);&#13;
    -ms-transform: translateY(-50%);&#13;
    display: none;&#13;
}&#13;
&#13;
.Maze_letters_letter_element {&#13;
    float: left;&#13;
    width: 20px;&#13;
    border: 1px black solid;&#13;
    text-align: center;&#13;
}&#13;
&#13;
.Maze_levelSolutionText {&#13;
    float: left;&#13;
    margin-right: 5px;&#13;
}&#13;
&#13;
.Maze_letters_end_level_answer_container {&#13;
     position: absolute;&#13;
    left: 50%;&#13;
    -webkit-transform: translateX(-50%);&#13;
    -ms-transform: translateX(-50%);&#13;
    transform: translateX(-50%);&#13;
}&#13;
&#13;
.Maze_letters_room_letter {&#13;
    width: 100%;&#13;
    text-align: center;&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    transform: translateY(-50%);&#13;
    -webkit-transform: translateY(-50%);&#13;
    -ms-transform: translateY(-50%);&#13;
    font-size: 1em;&#13;
}&#13;
</css><view>&lt;div class="Maze-wrapper" tabindex="0"&gt;&#13;
  &lt;div class="Maze-wrapper-game-container"&gt;&#13;
&#13;
  &lt;/div&gt;&#13;
  &lt;div class="Maze-wrapper-menu"&gt;&#13;
    &lt;div class="Maze-wrapper-menu-state-container"&gt;&#13;
    &lt;/div&gt;&#13;
    &lt;div class="Maze-wrapper-menu-controls"&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-up"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-up-text Maze-wrapper-menu-controls-no-select"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-left"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-left-text Maze-wrapper-menu-controls-no-select"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-right"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-right-text Maze-wrapper-menu-controls-no-select"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-down"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-down-text Maze-wrapper-menu-controls-no-select"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
  &lt;div class="Maze_game_question_background"&gt;&lt;/div&gt;&#13;
  &lt;div class="Maze_game_question_container"&gt;&#13;
    &lt;div class="Maze_game_question_container_question_text"&gt;&lt;/div&gt;&#13;
    &lt;input class="Maze_game_question_container_question_input"/&gt;&#13;
    &lt;div class="Maze_game_question_container_question_apply"&gt;&#13;
      &lt;div class="Maze_game_question_container_question_apply_text"&gt;&lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
  &lt;div class="Maze_loose"&gt;&#13;
      &lt;div class="Maze_game_loose_wrapper"&gt;&#13;
        &lt;div class="Maze_game_loose_text"&gt;&lt;/div&gt;&#13;
        &lt;div class="Maze_game_loose_button"&gt;&lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
  &lt;div class="Maze_game_end"&gt;&#13;
    &lt;div class="Maze_game_end_text"&gt;&lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
&#13;
  &lt;div class="Maze_letters_end_level_background"&gt;&lt;/div&gt;&#13;
  &lt;div class="Maze_letters_end_level_answer_wrapper"&gt;&#13;
    &lt;div class="Maze_letters_end_level_answer_container"&gt;&#13;
      &lt;div class="Maze_end_level_answer_end_game"&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze_letters_end_level_answer_letters_container"&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
    &lt;div class="Maze_letters_end_level_next_maze_button"&gt;&lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="Maze-wrapper"&gt;&#13;
  &lt;div class="Maze-wrapper-game-container"&gt;&#13;
&#13;
  &lt;/div&gt;&#13;
  &lt;div class="Maze-wrapper-menu"&gt;&#13;
    &lt;div class="Maze-wrapper-menu-state-container"&gt;&#13;
    &lt;/div&gt;&#13;
    &lt;div class="Maze-wrapper-menu-controls"&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-up"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-up-text"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-left"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-left-text"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-right"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-right-text"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
      &lt;div class="Maze-wrapper-menu-controls-down"&gt;&#13;
        &lt;div class="Maze-wrapper-menu-controls-down-text"&gt;&#13;
        &lt;/div&gt;&#13;
      &lt;/div&gt;&#13;
    &lt;/div&gt;&#13;
  &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonMaze_create () {&#13;
    var presenter = function () {};&#13;
&#13;
    presenter.ERROR_MESSAGES = {&#13;
        'mazeWidth_INT01': 'Width can\'t be empty',&#13;
        'mazeWidth_INT02': 'Width must be integer',&#13;
        'mazeWidth_INT04': 'Width must be bigger than 5',&#13;
        'mazeHeight_INT01': 'Height can\'t be empty',&#13;
        'mazeHeight_INT02': 'Height must be integer',&#13;
        'mazeHeight_INT04': 'Height must be bigger than 5',&#13;
        'numberOfMazes_INT01': 'Number of mazes can\'t be empty',&#13;
        'numberOfMazes_INT02': 'Number of mazes must be integer',&#13;
        'numberOfMazes_INT04': 'Number of mazes must be positive integer',&#13;
        'questions_mazeId_INT02': 'Maze id must be integer',&#13;
        'questions_mazeId_INT04': 'Maze id must be positive integer',&#13;
        'questions_letter_STR01': 'Maze letter can\'t be empty'&#13;
    };&#13;
&#13;
    function escape(unsafe) {&#13;
        return unsafe.replace(/[&amp;&lt;"']/g, function (m) {&#13;
            switch (m) {&#13;
                case '&amp;':&#13;
                    return '&amp;amp;';&#13;
                case '&lt;':&#13;
                    return '&amp;lt;';&#13;
                case '"':&#13;
                    return '&amp;quot;';&#13;
                default:&#13;
                    // apostrophe character&#13;
                    return '&amp;#039;';&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.state = {&#13;
        games: [],&#13;
        actualGameIndex: 0,&#13;
        mistakes: 0,&#13;
        errorCount: 0,&#13;
        applyButtonClickCallback: function () {},&#13;
&#13;
        elements: {&#13;
            questionContainer: null,&#13;
            questionBackground: null,&#13;
            gameContainer: null,&#13;
            upButton: null,&#13;
            leftButton: null,&#13;
            rightButton: null,&#13;
            downButton: null,&#13;
            applyButton: null,&#13;
            questionText: null,&#13;
            answerInput: null,&#13;
            applyButtonText: null,&#13;
            endGameButtonText: null,&#13;
            endGame: null,&#13;
            menu: null,&#13;
            lettersAnswerBackground: null,&#13;
            lettersAnswerContainer: null,&#13;
            lettersAnswerButton: null,&#13;
            lettersContainer: null,&#13;
            lettersEndGameText: null,&#13;
            looseText: null,&#13;
            looseRetryButton: null,&#13;
            looseWrapper: null,&#13;
            addonWrapper: null&#13;
        },&#13;
&#13;
        isDisabled: false,&#13;
        nextMazeButtonCallback: function () {},&#13;
        isShowingAnswers: false,&#13;
        isShowingErrors: false,&#13;
        _isDisabled: false,  // is while showing question,&#13;
        isVisible: false&#13;
&#13;
    };&#13;
&#13;
    presenter.configuration = {};&#13;
&#13;
    presenter.GAME_TYPES = {&#13;
        'DOORS': 1,&#13;
        'LETTERS': 2&#13;
    };&#13;
&#13;
    presenter.showErrorMessage = function (message, substitutions) {&#13;
        var errorContainer,&#13;
            key;&#13;
        if (typeof(substitutions) == 'undefined') {&#13;
            errorContainer = '&lt;p&gt;' + message + '&lt;/p&gt;';&#13;
        } else {&#13;
            var messageSubst = message;&#13;
            for (key in substitutions) {&#13;
                messageSubst = messageSubst.replace('%' + key + '%', substitutions[key]);&#13;
            }&#13;
            errorContainer = '&lt;p&gt;' + messageSubst + '&lt;/p&gt;';&#13;
        }&#13;
        presenter.$view.html(errorContainer);&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.runLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.runLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        var actualGameScore = 0;&#13;
        if (presenter.getActualGame()) {&#13;
            actualGameScore = presenter.getActualGame().getScore();&#13;
        }&#13;
        return presenter.state.actualGameIndex + actualGameScore;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.configuration.isValid) {&#13;
            return presenter.configuration.numberOfMazes;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        var lastErrorCount = presenter.state.errorCount;&#13;
        presenter.state.errorCount = 0;&#13;
&#13;
        return lastErrorCount;&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = presenter.playerController.getEventBus();&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.destroy = function () {&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        if (presenter.getActualGame()) {&#13;
            presenter.getActualGame().destroy();&#13;
        }&#13;
        presenter.disconnectHandlers();&#13;
    };&#13;
&#13;
    /**&#13;
     * Set in state expected elements like DOM elements&#13;
     */&#13;
    presenter.completeState = function () {&#13;
        var expectedElements = {&#13;
                questionContainer: 'Maze_game_question_container',&#13;
                questionBackground: 'Maze_game_question_background',&#13;
                gameContainer: 'Maze-wrapper-game-container',&#13;
                upButton: 'Maze-wrapper-menu-controls-up',&#13;
                leftButton: 'Maze-wrapper-menu-controls-left',&#13;
                rightButton: 'Maze-wrapper-menu-controls-right',&#13;
                downButton: 'Maze-wrapper-menu-controls-down',&#13;
                applyButton: 'Maze_game_question_container_question_apply',&#13;
                applyButtonText: 'Maze_game_question_container_question_apply_text',&#13;
                questionText: 'Maze_game_question_container_question_text',&#13;
                answerInput: 'Maze_game_question_container_question_input',&#13;
                endGame: 'Maze_game_end',&#13;
                endGameButtonText: 'Maze_game_end_text',&#13;
                menu: 'Maze-wrapper-menu',&#13;
                lettersAnswerBackground: 'Maze_letters_end_level_background',&#13;
                lettersAnswerContainer: 'Maze_letters_end_level_answer_wrapper',&#13;
                lettersAnswerButton: 'Maze_letters_end_level_next_maze_button',&#13;
                lettersContainer: 'Maze_letters_end_level_answer_letters_container',&#13;
                lettersEndGameText: 'Maze_end_level_answer_end_game',&#13;
                looseText: 'Maze_game_loose_text',&#13;
                looseRetryButton :'Maze_game_loose_button',&#13;
                looseWrapper: 'Maze_loose',&#13;
                addonWrapper: 'Maze-wrapper'&#13;
            },&#13;
            i;&#13;
&#13;
        for (i in expectedElements) {&#13;
            if (expectedElements.hasOwnProperty(i)) {&#13;
                presenter.state.elements[i] = presenter.view.getElementsByClassName(expectedElements[i])[0];&#13;
            }&#13;
        }&#13;
&#13;
        presenter.state.isDisabled = presenter.configuration.isDisabled;&#13;
    };&#13;
&#13;
    function rotateElement (element, rotation) {&#13;
        element.style.webkitTransform = 'rotate(' + rotation + 'deg)';&#13;
        element.style.mozTransform    = 'rotate(' + rotation + 'deg)';&#13;
        element.style.msTransform     = 'rotate(' + rotation + 'deg)';&#13;
        element.style.oTransform      = 'rotate(' + rotation + 'deg)';&#13;
        element.style.transform       = 'rotate(' + rotation + 'deg)';&#13;
    }&#13;
&#13;
    presenter.initializeTexts = function () {&#13;
        var up = presenter.state.elements.upButton.getElementsByClassName('Maze-wrapper-menu-controls-no-select')[0];&#13;
        var left = presenter.state.elements.leftButton.getElementsByClassName('Maze-wrapper-menu-controls-no-select')[0];&#13;
        var right = presenter.state.elements.rightButton.getElementsByClassName('Maze-wrapper-menu-controls-no-select')[0];&#13;
        var down = presenter.state.elements.downButton.getElementsByClassName('Maze-wrapper-menu-controls-no-select')[0];&#13;
&#13;
        up.innerText = presenter.configuration.translations.upButton.translation;&#13;
        left.innerText = presenter.configuration.translations.leftButton.translation;&#13;
        down.innerText = presenter.configuration.translations.downButton.translation;&#13;
        right.innerText = presenter.configuration.translations.rightButton.translation;&#13;
&#13;
        presenter.state.elements.lettersAnswerButton.innerText = presenter.configuration.translations.nextMazeButton.translation;&#13;
        presenter.state.elements.applyButtonText.innerText = presenter.configuration.translations.applyQuestion.translation;&#13;
        presenter.state.elements.endGameButtonText.innerText = presenter.configuration.translations.endGame.translation;&#13;
        presenter.state.elements.lettersEndGameText.innerText = presenter.configuration.translations.endGame.translation;&#13;
        presenter.state.elements.looseText.innerText = presenter.configuration.translations.loose.translation;&#13;
        presenter.state.elements.looseRetryButton.innerText = presenter.configuration.translations.looseButton.translation;&#13;
    };&#13;
&#13;
    /**&#13;
     * @param  {HTMLDivElement} view&#13;
     * @param  {Object} model&#13;
     * @param  {Boolean} isPreview&#13;
     */&#13;
    presenter.runLogic = function (view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.view = view;&#13;
        var validatedModel = presenter.validateModel(model);&#13;
&#13;
        if (!validatedModel.isValid) {&#13;
            presenter.configuration.isValid = false;&#13;
            presenter.showErrorMessage(presenter.ERROR_MESSAGES[validatedModel.fieldName.join("_") + "_" + validatedModel.errorCode]);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration = validatedModel.value;&#13;
        presenter.configuration.isValid = true;&#13;
&#13;
        presenter.setVisibility(presenter.configuration['Is Visible']);&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.completeState();&#13;
            presenter.initializeTexts();&#13;
&#13;
            if (presenter.configuration.hideControlPanel) {&#13;
                presenter.state.elements.menu.style.display = 'none';&#13;
                presenter.state.elements.gameContainer.style.width = '100%';&#13;
            }&#13;
&#13;
            presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved(ev) {&#13;
                if (ev.target === this) {&#13;
                    presenter.destroy();&#13;
                }&#13;
            });&#13;
&#13;
            presenter.connectHandlers();&#13;
            presenter.initializeMaze();&#13;
&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.onKeyDown = function (event) {&#13;
        function stopEvent () {&#13;
            event.preventDefault();&#13;
            event.stopPropagation();&#13;
        }&#13;
        switch (event.keyCode) {&#13;
            case 37:    //Left&#13;
                presenter.moveLeft();&#13;
                stopEvent();&#13;
                break;&#13;
            case 38:    //Up&#13;
                presenter.moveUp();&#13;
                stopEvent();&#13;
                break;&#13;
            case 39:    //Right&#13;
                presenter.moveRight();&#13;
                stopEvent();&#13;
                break;&#13;
            case 40:    //Down&#13;
                presenter.moveDown();&#13;
                stopEvent();&#13;
                break;&#13;
            case 13:    //Enter&#13;
                presenter.onQuestionApplyButtonClick();&#13;
                presenter.onNextMazeButtonClick();&#13;
                stopEvent();&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onRetryButtonClick = function () {&#13;
        presenter.hideRetryView();&#13;
        presenter.sendEvent(presenter.getRetryButtonClickedEventData());&#13;
    };&#13;
&#13;
    presenter.initializeMaze = function () {&#13;
            var gameContainer = presenter.state.elements.gameContainer,&#13;
                i,&#13;
                minSize = Math.min(gameContainer.offsetWidth, gameContainer.offsetHeight),&#13;
                game;&#13;
&#13;
&#13;
            if (presenter.configuration.hideControlPanel) {&#13;
                minSize = Math.min(presenter.configuration.Width, presenter.configuration.Height);&#13;
            }&#13;
&#13;
            presenter.state.actualGameIndex = 0;&#13;
            presenter.state.games = [];&#13;
            var labirynthSize = {&#13;
                width: presenter.configuration.mazeWidth,&#13;
                height: presenter.configuration.mazeHeight&#13;
            };&#13;
&#13;
&#13;
            for (i = 0; i &lt; presenter.configuration.numberOfMazes; i += 1) {&#13;
                if (presenter.configuration.gameType === presenter.GAME_TYPES.DOORS) {&#13;
                    game = new DoorsGame(labirynthSize, minSize, presenter.configuration.questions[i] || []);&#13;
                    presenter.state.games.push(game);&#13;
                } else  {&#13;
                    game = new LetterGame(labirynthSize, minSize, presenter.configuration.questions[i] || []);&#13;
                    presenter.state.games.push(game);&#13;
                }&#13;
            }&#13;
&#13;
            presenter.getActualGame().start(gameContainer);&#13;
    };&#13;
&#13;
    /**@returns {Game}&#13;
     */&#13;
    presenter.getActualGame = function () {&#13;
        return presenter.state.games[presenter.state.actualGameIndex];&#13;
    };&#13;
&#13;
    function canMove() {&#13;
        if (presenter.state.isDisabled || presenter.state._isDisabled) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (presenter.state.isShowingErrors || presenter.state.isShowingAnswers) {&#13;
            return false;&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    presenter.moveUp = function () {&#13;
        if (canMove()) {&#13;
            presenter.getActualGame().goUp();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.moveDown = function () {&#13;
        if (canMove()) {&#13;
            presenter.getActualGame().goDown();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.moveLeft = function () {&#13;
        if (canMove()) {&#13;
            presenter.getActualGame().goLeft();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.moveRight = function () {&#13;
        if (canMove()) {&#13;
            presenter.getActualGame().goRight();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onQuestionApplyButtonClick = function () {&#13;
        presenter.state.applyButtonClickCallback(presenter.state.elements.answerInput.value);&#13;
        presenter.state.elements.answerInput.value = '';&#13;
        presenter.state.applyButtonClickCallback = function () {};&#13;
    };&#13;
&#13;
    presenter.setOnQuestionApplyCallback = function (fn) {&#13;
        presenter.state.applyButtonClickCallback = fn;&#13;
    };&#13;
&#13;
    presenter.setQuestionHTML = function (html) {&#13;
        presenter.state.elements.questionText.innerHTML = html;&#13;
    };&#13;
&#13;
    presenter.showQuestionModal = function () {&#13;
        presenter.state._isDisabled = true;&#13;
        presenter.state.elements.questionContainer.style.display = 'block';&#13;
        presenter.state.elements.questionBackground.style.display = 'block';&#13;
        presenter.state.elements.answerInput.focus();&#13;
    };&#13;
&#13;
    presenter.hideQuestionModal = function () {&#13;
        presenter.state._isDisabled = false;&#13;
        presenter.state.elements.questionContainer.style.display = 'none';&#13;
        presenter.state.elements.questionBackground.style.display = 'none';&#13;
        presenter.state.elements.answerInput.value = '';&#13;
        presenter.state.applyButtonClickCallback = function () {};&#13;
        presenter.state.elements.addonWrapper.focus();&#13;
    };&#13;
&#13;
    presenter.sendEvent = function (evData) {&#13;
        if (presenter.eventBus != undefined) {&#13;
            presenter.eventBus.sendEvent('ValueChanged', evData);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.disable = function () {&#13;
        presenter.state.isDisabled = true;&#13;
    };&#13;
&#13;
    presenter.enable = function () {&#13;
        presenter.state.isDisabled = false;&#13;
    };&#13;
&#13;
    presenter.getMistakeEventData = function () {&#13;
        return {&#13;
            source : presenter.configuration.ID,&#13;
            value: presenter.state.mistakes + '',&#13;
            item: 'mistake'&#13;
        };&#13;
    };&#13;
&#13;
    presenter.getOpenedDoorEventData = function (number) {&#13;
        return {&#13;
            source : presenter.configuration.ID,&#13;
            value: number + '',&#13;
            item: 'opened'&#13;
        };&#13;
    };&#13;
&#13;
    presenter.openedDoor = function (number) {&#13;
        presenter.sendEvent(presenter.getOpenedDoorEventData(number));&#13;
    };&#13;
&#13;
    presenter.getGatheredLetterEventData = function (letter) {&#13;
        return {&#13;
            source : presenter.configuration.ID,&#13;
            value: letter,&#13;
            item: 'gathered'&#13;
        };&#13;
    };&#13;
&#13;
    presenter.receivedLetter = function (letter) {&#13;
        presenter.sendEvent(presenter.getGatheredLetterEventData(letter));&#13;
    };&#13;
&#13;
    presenter.getFinishedMazeEventData = function (mazeNumber) {&#13;
        return {&#13;
            source: presenter.configuration.ID,&#13;
            value: '1',&#13;
            item: mazeNumber + '',&#13;
            score: 1&#13;
        };&#13;
    };&#13;
&#13;
    presenter.getFinishedAllMazeEventData = function () {&#13;
        return {&#13;
            source: presenter.configuration.ID,&#13;
            value: '1',&#13;
            item: 'all',&#13;
            score: 1&#13;
        };&#13;
    };&#13;
&#13;
    presenter.getRetryButtonClickedEventData = function () {&#13;
        return {&#13;
            source: presenter.configuration.ID,&#13;
            value: '1',&#13;
            item: 'retry',&#13;
            score: 0&#13;
        };&#13;
    };&#13;
&#13;
    presenter.showEndGame = function () {&#13;
        presenter.state.elements.endGame.style.display = 'block';&#13;
        presenter.state._isDisabled = true;&#13;
    };&#13;
&#13;
    presenter.hideEndGame = function () {&#13;
        presenter.state.elements.endGame.style.display = 'none';&#13;
        presenter.state._isDisabled = false;&#13;
    };&#13;
&#13;
    presenter.finishedMaze = function () {&#13;
        if (presenter.state.actualGameIndex + 1 === presenter.configuration.numberOfMazes) {&#13;
            presenter.state.actualGameIndex += 1;&#13;
            presenter.showEndGame();&#13;
            presenter.sendEvent(presenter.getFinishedAllMazeEventData());&#13;
        } else {&#13;
            presenter.getActualGame().destroy();&#13;
            presenter.state.actualGameIndex += 1;&#13;
            presenter.getActualGame().start(presenter.state.elements.gameContainer);&#13;
            presenter.sendEvent(presenter.getFinishedMazeEventData(presenter.state.actualGameIndex));&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setNextMazeButtonCallback = function (fn) {&#13;
        presenter.state.nextMazeButtonCallback = fn;&#13;
    };&#13;
&#13;
    presenter.showLettersAnswer = function (letters) {&#13;
        if (presenter.state.games[presenter.state.actualGameIndex + 1]) {&#13;
            presenter.state.elements.lettersAnswerButton.style.display = 'block';&#13;
            presenter.state.elements.lettersEndGameText.style.display = 'none';&#13;
        } else {&#13;
            presenter.state.elements.lettersAnswerButton.style.display = 'none';&#13;
            presenter.state.elements.lettersEndGameText.style.display = 'block';&#13;
            presenter.sendEvent(presenter.getFinishedAllMazeEventData());&#13;
        }&#13;
&#13;
        presenter.state.elements.lettersAnswerBackground.style.display = 'block';&#13;
        presenter.state.elements.lettersAnswerContainer.style.display = 'block';&#13;
&#13;
        presenter.state.elements.lettersContainer.innerHTML = '';&#13;
&#13;
        var textContainer = document.createElement('div');&#13;
        textContainer.classList.add('Maze_levelSolutionText');&#13;
        textContainer.innerText = presenter.configuration.translations.solutionText.translation;&#13;
        presenter.state.elements.lettersContainer.appendChild(textContainer);&#13;
&#13;
        letters.forEach(function (element) {&#13;
           var div = document.createElement('div');&#13;
           div.classList.add('Maze_letters_letter_element');&#13;
           div.innerHTML = escape(element).split(' ').join('&amp;nbsp;');&#13;
           presenter.state.elements.lettersContainer.appendChild(div);&#13;
        });&#13;
&#13;
        presenter.state._isDisabled = true;&#13;
    };&#13;
&#13;
    presenter.hideLettersAnswer = function () {&#13;
        presenter.state.elements.lettersAnswerBackground.style.display = 'none';&#13;
        presenter.state.elements.lettersAnswerContainer.style.display = 'none';&#13;
        presenter.state._isDisabled = false;&#13;
    };&#13;
&#13;
    presenter.showRetryView = function () {&#13;
        presenter.state.elements.looseWrapper.style.display = 'block';&#13;
    };&#13;
&#13;
    presenter.hideRetryView = function () {&#13;
        presenter.state.elements.looseWrapper.style.display = 'none';&#13;
    };&#13;
&#13;
    presenter.playerMistake = function () {&#13;
        presenter.state.mistakes += 1;&#13;
        presenter.state.errorCount += 1;&#13;
&#13;
        presenter.sendEvent(presenter.getMistakeEventData());&#13;
&#13;
        if (presenter.state.mistakes === 3) {&#13;
            presenter.getActualGame().destroy();&#13;
            presenter.initializeMaze();&#13;
            presenter.state.mistakes = 0;&#13;
            presenter.showRetryView();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onNextMazeButtonClick = function () {&#13;
        presenter.state.nextMazeButtonCallback.call(presenter.getActualGame());&#13;
        presenter.setNextMazeButtonCallback(function (){});&#13;
    };&#13;
&#13;
    presenter.connectHandlers = function () {&#13;
        presenter.state.elements.upButton.addEventListener('click', presenter.moveUp);&#13;
        presenter.state.elements.leftButton.addEventListener('click', presenter.moveLeft);&#13;
        presenter.state.elements.downButton.addEventListener('click', presenter.moveDown);&#13;
        presenter.state.elements.rightButton.addEventListener('click', presenter.moveRight);&#13;
        presenter.state.elements.applyButton.addEventListener('click', presenter.onQuestionApplyButtonClick);&#13;
        presenter.state.elements.lettersAnswerButton.addEventListener('click', presenter.onNextMazeButtonClick);&#13;
        presenter.state.elements.looseRetryButton.addEventListener('click', presenter.onRetryButtonClick);&#13;
        presenter.state.elements.addonWrapper.addEventListener('keydown', presenter.onKeyDown);&#13;
    };&#13;
&#13;
    presenter.disconnectHandlers = function () {&#13;
        presenter.state.elements.upButton.removeEventListener('click', presenter.moveUp);&#13;
        presenter.state.elements.leftButton.removeEventListener('click', presenter.moveLeft);&#13;
        presenter.state.elements.downButton.removeEventListener('click', presenter.moveDown);&#13;
        presenter.state.elements.rightButton.removeEventListener('click', presenter.moveRight);&#13;
        presenter.state.elements.applyButton.removeEventListener('click', presenter.onQuestionApplyButtonClick);&#13;
        presenter.state.elements.lettersAnswerButton.removeEventListener('click', presenter.onNextMazeButtonClick);&#13;
        presenter.state.elements.looseRetryButton.removeEventListener('click', presenter.onRetryButtonClick);&#13;
        presenter.state.elements.addonWrapper.removeEventListener('keydown', presenter.onKeyDown);&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'showAnswers' : presenter.showAnswers,&#13;
            'hideAnswers' : presenter.hideAnswers,&#13;
            'moveUp': presenter.moveUp,&#13;
            'moveDown': presenter.moveDown,&#13;
            'moveLeft': presenter.moveLeft,&#13;
            'moveRight': presenter.moveRight,&#13;
            'enable': presenter.enable,&#13;
            'disable': presenter.disable&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        presenter.state.isShowingAnswers = true;&#13;
&#13;
        if (presenter.state.showingErrors) {&#13;
            presenter.setWorkMode();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        presenter.state.isShowingAnswers = false;&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        presenter.state.isShowingErrors = true;&#13;
&#13;
        if (presenter.state.isShowingAnswers) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        presenter.state.isShowingErrors = false;&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName === 'ShowAnswers') {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName === 'HideAnswers') {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     *&#13;
     * @param {{question:String, answer:String, letter:String, mazeId:Number}[]} questions&#13;
     */&#13;
    presenter.completeQuestions = function (questions) {&#13;
        var questionsObject = [];&#13;
&#13;
        questions.forEach(function (element) {&#13;
           if (element.mazeId !== -1) {&#13;
               questionsObject[element.mazeId - 1] = questionsObject[element.mazeId - 1] || [];&#13;
&#13;
               questionsObject[element.mazeId -1].push(element);&#13;
           }&#13;
        });&#13;
&#13;
        return questionsObject;&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        function shouldValidateLetter(localValidated) {&#13;
            return localValidated['question'] !== '' &amp;&amp; this.validatedModel['gameMode'] === 'letters';&#13;
        }&#13;
&#13;
        if (model.gameMode === '') {&#13;
            model.gameMode = 'doors';&#13;
        }&#13;
&#13;
        var modelValidator = new ModelValidator();&#13;
        var validatedModel = modelValidator.validate(model, [&#13;
            ModelValidators.Boolean('Is Visible'),&#13;
            ModelValidators.DumbString('ID'),&#13;
            ModelValidators.Boolean('hideControlPanel'),&#13;
            ModelValidators.Boolean('isDisabled'),&#13;
            ModelValidators.Enum('gameMode', {values: ['doors', 'letters'], useLowerCase: true}),&#13;
            ModelValidators.Integer('mazeWidth', {minValue: 6}),&#13;
            ModelValidators.Integer('mazeHeight', {minValue: 6}),&#13;
            ModelValidators.Integer('Width'),&#13;
            ModelValidators.Integer('Height'),&#13;
            ModelValidators.Integer('numberOfMazes', {minValue: 1, default: 1}),&#13;
            ModelValidators.List('questions', [&#13;
                ModelValidators.DumbString("question"),&#13;
                ModelValidators.DumbString("answer"),&#13;
                ModelValidators.String("letter", {trim: false}, shouldValidateLetter),&#13;
                ModelValidators.Integer('mazeId', {minValue: 1, default: -1}),&#13;
                ModelValidators.Boolean('isCaseSensitive'),&#13;
            ]),&#13;
            ModelValidators.StaticList('translations', {&#13;
                'endGame': [ModelValidators.String('translation', {default: 'End Game'})],&#13;
                'applyQuestion': [ModelValidators.String('translation', {default: 'Apply'})],&#13;
                'nextMazeButton': [ModelValidators.String('translation', {default: 'Next maze'})],&#13;
                'solutionText': [ModelValidators.String('translation', {default: 'Level solution is: '})],&#13;
                'upButton': [ModelValidators.String('translation', {default: 'Up'})],&#13;
                'leftButton': [ModelValidators.String('translation', {default: 'Left'})],&#13;
                'rightButton': [ModelValidators.String('translation', {default: 'Right'})],&#13;
                'downButton': [ModelValidators.String('translation', {default: 'Down'})],&#13;
                'loose': [ModelValidators.String('translation', {default: 'You loose'})],&#13;
                'looseButton': [ModelValidators.String('translation', {default: 'Retry'})]&#13;
            })&#13;
        ]);&#13;
&#13;
        if (!validatedModel.isValid) {&#13;
            return validatedModel;&#13;
        }&#13;
&#13;
        validatedModel.value.questions = presenter.completeQuestions(validatedModel.value.questions);&#13;
        validatedModel.value.isVisible = validatedModel.value['Is Visible'];&#13;
        validatedModel.value.gameType = presenter.GAME_TYPES[validatedModel.value.gameMode.toUpperCase()];&#13;
&#13;
        return validatedModel;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            isDisabled: presenter.state.isDisabled,&#13;
            actualGameIndex: presenter.state.actualGameIndex,&#13;
            mistakes: presenter.state.mistakes,&#13;
            errorCount: presenter.state.errorCount,&#13;
            actualGame: presenter.getActualGame()? presenter.getActualGame().serialize(): null,&#13;
            isVisible: presenter.state.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        var object = JSON.parse(state);&#13;
        if (object.actualGameIndex !== 0) {&#13;
            presenter.getActualGame().destroy();&#13;
        }&#13;
&#13;
        presenter.state.isDisabled = object.isDisabled;&#13;
        presenter.state.actualGameIndex = object.actualGameIndex;&#13;
        presenter.state.mistakes = object.mistakes;&#13;
        presenter.state.errorCount = object.errorCount;&#13;
&#13;
        presenter.setVisibility(object.isVisible);&#13;
&#13;
        if (presenter.getActualGame()) {&#13;
            if (object.actualGameIndex !== 0) {&#13;
                presenter.getActualGame().start(presenter.state.elements.gameContainer);&#13;
            }&#13;
            presenter.getActualGame().deserialize(object.actualGame);&#13;
        } else {&#13;
            presenter.showEndGame();&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.setNextMazeButtonCallback(function () {});&#13;
        presenter.state.mistakes = 0;&#13;
        presenter.state.isDisabled = presenter.configuration.isDisabled;&#13;
        presenter.state.isShowingAnswers = false;&#13;
        presenter.state.isShowingErrors = false;&#13;
        presenter.setVisibility(presenter.configuration['Is Visible']);&#13;
&#13;
        if (presenter.getActualGame()) {&#13;
            presenter.getActualGame().destroy();&#13;
        } else {    //If getActualGame returns undefined then player finished all mazes&#13;
            presenter.state.actualGameIndex--;&#13;
            presenter.getActualGame().destroy();&#13;
        }&#13;
&#13;
        presenter.state.games = [];&#13;
&#13;
        presenter.hideQuestionModal();&#13;
        presenter.hideEndGame();&#13;
        presenter.hideLettersAnswer();&#13;
        presenter.hideRetryView();&#13;
&#13;
        presenter.initializeMaze();&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.state.isVisible = isVisible;&#13;
        presenter.$view.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
    };&#13;
&#13;
    /**&#13;
     * @class&#13;
     *&#13;
     * @param {{width: Number, height: Number}} size&#13;
     * @param {Number} maxSize of maze in px&#13;
     *&#13;
     */&#13;
    function Game (size, maxSize) {&#13;
        this.maze = new Maze(size, maxSize);&#13;
        this.playerElement = document.createElement('div');&#13;
        this.playerElement.classList.add('Maze_player_element');&#13;
&#13;
        this.playerPosition = {&#13;
            x: 0,&#13;
            y: 0&#13;
        };&#13;
    }&#13;
&#13;
    Game.prototype.serialize = function () {&#13;
        return {&#13;
            maze: this.maze.serialize(),&#13;
            playerPosition: this.playerPosition&#13;
        }&#13;
    };&#13;
&#13;
    Game.prototype.deserialize = function (obj) {&#13;
        this.playerPosition = obj.playerPosition;&#13;
        this.maze.deserialize(obj.maze);&#13;
    };&#13;
&#13;
    Game.prototype.getScore = function () {&#13;
        return 0;&#13;
    };&#13;
&#13;
    /**&#13;
     * @param  {HTMLDivElement} container&#13;
     */&#13;
    Game.prototype.start = function (container) {&#13;
        this.maze.generate();&#13;
        container.appendChild(this.maze.getElement());&#13;
    };&#13;
&#13;
    Game.prototype.destroy = function () {&#13;
        if (this.maze.getElement().parentNode) {&#13;
            this.maze.getElement().parentNode.removeChild(this.maze.getElement());&#13;
        }&#13;
        this.maze.mazeElements = [];&#13;
        this.maze.rooms = [];&#13;
        this.maze.walls = [];&#13;
    };&#13;
&#13;
    /**&#13;
     * @param {Room}room&#13;
     */&#13;
    Game.prototype.movePlayerTo = function (room) {&#13;
        var checkPromise = this.checkRoomCallback(room);&#13;
&#13;
        if (checkPromise) {&#13;
            var self = this;&#13;
            checkPromise.then(function (isOpened) {&#13;
                if (isOpened) {&#13;
                    room.element.appendChild(self.playerElement);&#13;
                    self.playerPosition = self.maze.getRoomPosition(room);&#13;
                }&#13;
            });&#13;
        } else {&#13;
            room.element.appendChild(this.playerElement);&#13;
            this.playerPosition = this.maze.getRoomPosition(room);&#13;
        }&#13;
    };&#13;
&#13;
    Game.prototype.goUp = function () {&#13;
        var wall = this.maze.mazeElements[this.playerPosition.y - 1][this.playerPosition.x];&#13;
&#13;
        if (wall.isOpened()) {&#13;
            var room = this.maze.mazeElements[this.playerPosition.y - 2][this.playerPosition.x];&#13;
            this.movePlayerTo(room);&#13;
        }&#13;
    };&#13;
&#13;
    Game.prototype.goLeft = function () {&#13;
        var wall = this.maze.mazeElements[this.playerPosition.y][this.playerPosition.x - 1];&#13;
&#13;
        if (wall.isOpened()) {&#13;
            var room = this.maze.mazeElements[this.playerPosition.y][this.playerPosition.x - 2];&#13;
            this.movePlayerTo(room);&#13;
        }&#13;
    };&#13;
&#13;
    Game.prototype.goRight = function () {&#13;
        var wall = this.maze.mazeElements[this.playerPosition.y][this.playerPosition.x + 1];&#13;
&#13;
        if (wall.isOpened()) {&#13;
            var room = this.maze.mazeElements[this.playerPosition.y][this.playerPosition.x + 2];&#13;
            this.movePlayerTo(room);&#13;
        }&#13;
    };&#13;
&#13;
    Game.prototype.goDown = function () {&#13;
        var wall = this.maze.mazeElements[this.playerPosition.y + 1][this.playerPosition.x];&#13;
&#13;
        if (wall.isOpened()) {&#13;
            var room = this.maze.mazeElements[this.playerPosition.y + 2][this.playerPosition.x];&#13;
            this.movePlayerTo(room);&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Call room callback if exists&#13;
     * @param {Room} room&#13;
     * @returns {Object|null} Promise if callback exists or null&#13;
     */&#13;
    Game.prototype.checkRoomCallback = function (room) {&#13;
        if (room.callback) {&#13;
            return room.callback.call(this, room);&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    function LetterGame (size, maxSize, questions) {&#13;
        Game.call(this, size, maxSize);&#13;
&#13;
        this.questionsToAnswer = 0;&#13;
        this.questions = questions;&#13;
&#13;
        this.isShowingEndGame = false;&#13;
        this.endLevelElement = document.createElement('div');&#13;
        this.endLevelElement.classList.add('Maze_letters_end_level');&#13;
        this.gatheredLettersCount = 0;&#13;
        this.questionsPositions = [];   //Saving question as [index] = roomIndex, if roomIndex is null then question is resolved&#13;
    }&#13;
&#13;
    LetterGame.prototype = Object.create(Game.prototype);&#13;
&#13;
    LetterGame.prototype.getScore = function () {&#13;
        return this.isShowingEndGame? 1 : 0;&#13;
    };&#13;
&#13;
    LetterGame.prototype.serialize = function () {&#13;
        var gameObj = Game.prototype.serialize.call(this);&#13;
&#13;
        return {&#13;
            gameObj: gameObj, &#13;
            gatheredLettersCount: this.gatheredLettersCount,&#13;
            questionsPositions: this.questionsPositions,&#13;
            isShowingEndGame: this.isShowingEndGame&#13;
        };&#13;
    };&#13;
&#13;
    LetterGame.prototype.deserialize = function (obj) {&#13;
        Game.prototype.deserialize.call(this, obj.gameObj);&#13;
        &#13;
        this.gatheredLettersCount = obj.gatheredLettersCount;&#13;
        var longestPath = this.maze.getLongestPath();&#13;
&#13;
        this.createEndLevelElement(longestPath);&#13;
        this.questionsPositions = obj.questionsPositions;&#13;
&#13;
        var self = this;&#13;
        this.questionsPositions.forEach(function (element, index) {&#13;
            if (element !== null) {&#13;
                self.setLetterInRoom(self.maze.rooms[element], self.questions[index]);&#13;
            }&#13;
        });&#13;
&#13;
        this.movePlayerTo(this.maze.mazeElements[this.playerPosition.y][this.playerPosition.x]);&#13;
&#13;
        if (obj.isShowingEndGame) {&#13;
            this.onEnterEndGame();&#13;
        }&#13;
    };&#13;
&#13;
    LetterGame.prototype.start = function (container) {&#13;
        Game.prototype.start.call(this, container);&#13;
&#13;
        var longestPath = this.maze.getLongestPath();&#13;
        this.movePlayerTo(longestPath[0]);&#13;
        this.createEndLevelElement(longestPath);&#13;
&#13;
        var questions = this.questions.slice();&#13;
&#13;
        while(questions.length !== 0) {&#13;
            var questionIndex = getRandomIndex(questions);&#13;
&#13;
            var question = questions.splice(questionIndex, 1)[0];&#13;
            var counter = 0;&#13;
&#13;
            while (true) {&#13;
                counter++;&#13;
&#13;
                var roomIndex = getRandomIndex(this.maze.rooms);&#13;
                var room = this.maze.rooms[roomIndex];&#13;
&#13;
                if (room === longestPath[0]) {&#13;
                    continue;&#13;
                }&#13;
&#13;
                if (!room.hasCallback()) {&#13;
                    this.setLetterInRoom(room, question);&#13;
                    this.questionsPositions[this.questions.indexOf(question)] = roomIndex;&#13;
                    this.questionsToAnswer++;&#13;
                    break;&#13;
                }&#13;
&#13;
                //Be sure that there never will be forever while&#13;
                if (counter &gt;= 50) {&#13;
                    return;&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     *&#13;
     * @param room {Room}&#13;
     * @param question {{}}&#13;
     */&#13;
    LetterGame.prototype.setLetterInRoom = function (room, question) {&#13;
        room.setCallback(this.onLetterEnterCallback.bind(this, question));&#13;
&#13;
        var paragraph = document.createElement('p');&#13;
        paragraph.classList.add('Maze_letters_room_letter');&#13;
        paragraph.innerText = question.letter;&#13;
&#13;
        room.getElement().appendChild(paragraph);        &#13;
    };&#13;
&#13;
    LetterGame.prototype.onLetterEnterCallback = function (questionObj, room) {&#13;
        var promise = $.Deferred();&#13;
        presenter.setQuestionHTML(questionObj.question);&#13;
        presenter.showQuestionModal();&#13;
&#13;
&#13;
        var self = this;&#13;
        presenter.setOnQuestionApplyCallback(function (value) {&#13;
            var answer = questionObj.answer;&#13;
            if (!questionObj.isCaseSensitive) {&#13;
                value = value.toLowerCase();&#13;
                answer = answer.toLowerCase();&#13;
            }&#13;
&#13;
            if (value === answer) {&#13;
                self.gatheredLettersCount += 1;&#13;
                room.removeCallback();&#13;
                var letter = room.element.getElementsByClassName('Maze_letters_room_letter')[0];&#13;
                letter.parentNode.removeChild(letter);&#13;
&#13;
                presenter.receivedLetter(questionObj.letter);&#13;
                self.questionsPositions[self.questions.indexOf(questionObj)] = null;&#13;
                promise.resolve(true);&#13;
            } else {&#13;
                presenter.playerMistake();&#13;
                promise.resolve(false);&#13;
            }&#13;
&#13;
            presenter.hideQuestionModal();&#13;
        });&#13;
&#13;
        return promise;&#13;
    };&#13;
&#13;
    LetterGame.prototype.createEndLevelElement = function (longestPath) {&#13;
        longestPath[longestPath.length - 1].element.appendChild(this.endLevelElement);&#13;
        longestPath[longestPath.length - 1].setCallback(this.onEnterEndGame);&#13;
    };&#13;
&#13;
    LetterGame.prototype.onEnterEndGame = function () {&#13;
        var i,&#13;
            letters = [],&#13;
            promise = $.Deferred();&#13;
&#13;
        if (this.questionsToAnswer !== this.gatheredLettersCount) {&#13;
            promise.resolve(false);&#13;
            return promise;&#13;
        }&#13;
&#13;
        this.isShowingEndGame = true;&#13;
&#13;
        for (i = 0; i &lt; this.questions.length; i += 1) {&#13;
            letters.push(this.questions[i].letter);&#13;
        }&#13;
&#13;
        presenter.showLettersAnswer(letters);&#13;
        presenter.setNextMazeButtonCallback(function () {&#13;
            if (presenter.state.games[presenter.state.actualGameIndex + 1]) {&#13;
                presenter.finishedMaze();&#13;
                presenter.hideLettersAnswer();&#13;
            }&#13;
            promise.resolve(true);&#13;
        });&#13;
&#13;
        return promise;&#13;
    };&#13;
&#13;
    /**&#13;
     *&#13;
     * @param size&#13;
     * @param maxSize&#13;
     * @param {{}[]}questions&#13;
     * @constructor&#13;
     */&#13;
    function DoorsGame (size, maxSize, questions) {&#13;
        Game.call(this, size, maxSize);&#13;
&#13;
        this.treasureElement = document.createElement('div');&#13;
        this.treasureElement.classList.add('Maze_treasure_element');&#13;
        this.questions = questions;&#13;
        this.keysCount = 0;&#13;
    }&#13;
&#13;
    DoorsGame.prototype = Object.create(Game.prototype);&#13;
&#13;
    DoorsGame.prototype.serialize = function () {&#13;
        var gameObj = Game.prototype.serialize.call(this);&#13;
&#13;
        return {&#13;
            gameObj: gameObj, &#13;
            keysCount: this.keysCount&#13;
        };&#13;
    };&#13;
&#13;
    DoorsGame.prototype.deserialize = function (obj) {&#13;
        Game.prototype.deserialize.call(this, obj.gameObj);&#13;
&#13;
        this.keysCount = obj.keysCount;&#13;
        var longestPath = this.maze.getLongestPath(),&#13;
            doorsCount = this.questions.length,&#13;
            spaceBetween = Math.max(1, Math.floor(longestPath.length / (doorsCount + 1)));&#13;
        &#13;
        this.createTreasureElement(longestPath);&#13;
        this.createDoors(longestPath);&#13;
&#13;
        for (var i = 0; i &lt; this.keysCount; i++) {&#13;
            this.openDoor(longestPath[(i + 1) * spaceBetween]);&#13;
        }&#13;
&#13;
        this.movePlayerTo(this.maze.mazeElements[this.playerPosition.y][this.playerPosition.x]);        &#13;
    };&#13;
&#13;
    DoorsGame.prototype.start = function (container) {&#13;
        Game.prototype.start.call(this, container);&#13;
        var longestPath = this.maze.getLongestPath();&#13;
        this.movePlayerTo(longestPath[0]);&#13;
&#13;
        this.createTreasureElement(longestPath);&#13;
        this.createDoors(longestPath);&#13;
    };&#13;
&#13;
    /**&#13;
     *val&#13;
     * @param {Room[]} longestPath&#13;
     */&#13;
    DoorsGame.prototype.createDoors = function (longestPath) {&#13;
        var doorsCount = this.questions.length,&#13;
            spaceBetween = Math.max(1, Math.floor(longestPath.length / (doorsCount + 1))),&#13;
            i;&#13;
&#13;
        for(i = 1; i &lt;= Math.min(doorsCount, longestPath.length - 2); i += 1) {&#13;
            this.createDoorElement(longestPath[i * spaceBetween]);&#13;
        }&#13;
    };&#13;
&#13;
    DoorsGame.prototype.createDoorElement = function (room) {&#13;
        var element = document.createElement('div');&#13;
        element.classList.add('Maze_door');&#13;
&#13;
        room.element.appendChild(element);&#13;
        room.setCallback(this.onEnterDoor);&#13;
    };&#13;
&#13;
    /**&#13;
     *&#13;
     * @param {Room} room&#13;
     */&#13;
    DoorsGame.prototype.createOpenedDoorElement = function (room) {&#13;
        var element = document.createElement('div');&#13;
        element.classList.add('Maze_door_opened');&#13;
&#13;
        room.element.appendChild(element);&#13;
    };&#13;
&#13;
    /**&#13;
     *&#13;
     * @param {Room} room&#13;
     * @returns {boolean}&#13;
     */&#13;
    DoorsGame.prototype.onEnterDoor = function (room) {&#13;
        var promise = $.Deferred();&#13;
&#13;
        presenter.setQuestionHTML(this.questions[this.keysCount].question);&#13;
        presenter.showQuestionModal();&#13;
&#13;
        var self = this;&#13;
        presenter.setOnQuestionApplyCallback(function (value) {&#13;
            var answer = self.questions[self.keysCount].answer;&#13;
            if (!self.questions[self.keysCount].isCaseSensitive) {&#13;
                value = value.toLowerCase();&#13;
                answer = answer.toLowerCase();&#13;
            }&#13;
&#13;
            if (value === answer) {&#13;
                self.openDoor(room);&#13;
                self.keysCount += 1;&#13;
&#13;
                presenter.openedDoor(self.keysCount);&#13;
                promise.resolve(true);&#13;
            } else {&#13;
                presenter.playerMistake();&#13;
                promise.resolve(false);&#13;
            }&#13;
&#13;
            presenter.hideQuestionModal();&#13;
        });&#13;
&#13;
        return promise;&#13;
    };&#13;
&#13;
    DoorsGame.prototype.openDoor = function (room) {&#13;
        var door = room.element.getElementsByClassName('Maze_door')[0];&#13;
        door.parentNode.removeChild(door);&#13;
        this.createOpenedDoorElement(room);&#13;
        room.removeCallback();&#13;
    };&#13;
&#13;
    DoorsGame.prototype.createTreasureElement = function (longestPath) {&#13;
        longestPath[longestPath.length - 1].element.appendChild(this.treasureElement);&#13;
        longestPath[longestPath.length - 1].setCallback(this.onEnterTreasure);&#13;
    };&#13;
&#13;
    DoorsGame.prototype.onEnterTreasure = function () {&#13;
        var promise = $.Deferred();&#13;
&#13;
        presenter.finishedMaze(promise);&#13;
        promise.resolve(true);&#13;
&#13;
        return promise;&#13;
    };&#13;
&#13;
    /**&#13;
     * @class&#13;
     * @param {Number} index&#13;
     *&#13;
     * @this Wall&#13;
     */&#13;
    function Wall (index) {&#13;
        this.index = index;&#13;
&#13;
        this.state = this.STATES.close;&#13;
    }&#13;
&#13;
    Wall.prototype.serialize = function () {&#13;
        return {&#13;
            state: this.state&#13;
        };&#13;
    };&#13;
&#13;
    Wall.prototype.deserialize = function (obj) {&#13;
        this.state = obj.state;&#13;
    };&#13;
&#13;
    /**&#13;
     * close this wall&#13;
     */&#13;
    Wall.prototype.close = function () {&#13;
        this.state = this.STATES.CLOSE;&#13;
    };&#13;
&#13;
    Wall.prototype.open = function () {&#13;
        this.state = this.STATES.OPEN;&#13;
    };&#13;
&#13;
    Wall.prototype.STATES = {&#13;
        OPEN: 1,&#13;
        CLOSE: 2&#13;
    };&#13;
&#13;
    Wall.prototype.isClosed = function () {&#13;
        return this.state === this.STATES.CLOSE;&#13;
    };&#13;
&#13;
    Wall.prototype.isOpened = function () {&#13;
        return this.state === this.STATES.OPEN;&#13;
    };&#13;
&#13;
    /**&#13;
     * @class&#13;
     * &#13;
     * @param {Number} index&#13;
     */&#13;
    function Room(index) {&#13;
        this.index = index;&#13;
&#13;
        this.element = document.createElement('div');&#13;
        this.element.classList.add('Maze_Room_container');&#13;
        this.walls = document.createElement('div');&#13;
        this.element.appendChild(this.walls);&#13;
        this.element.classList.add('Maze_room');&#13;
        this.callback = null;&#13;
    }&#13;
&#13;
    Room.prototype.serialize = function () {&#13;
        return {&#13;
        };&#13;
    };&#13;
&#13;
    Room.prototype.deserialize = function (obj) {&#13;
    };&#13;
&#13;
    Room.prototype.hasCallback = function () {&#13;
        return this.callback;&#13;
    };&#13;
&#13;
    Room.prototype.getElement = function() {&#13;
        return this.element;&#13;
    };&#13;
&#13;
    Room.prototype.addWallClass = function (className) {&#13;
        this.walls.classList.add(className);&#13;
    };&#13;
&#13;
    Room.prototype.getWallsElement = function () {&#13;
        return this.walls;&#13;
    };&#13;
&#13;
    Room.prototype.setCallback = function (callback) {&#13;
        this.callback = callback;&#13;
    };&#13;
&#13;
    Room.prototype.removeCallback = function () {&#13;
        this.callback = null;&#13;
    };&#13;
&#13;
    Room.prototype.setDotElement = function (rotation) {&#13;
        var dotDiv = document.createElement('div');&#13;
        dotDiv.classList.add('Maze_room_left_top_dot');&#13;
&#13;
        rotateElement(dotDiv, rotation);&#13;
        this.getElement().appendChild(dotDiv);&#13;
    };&#13;
&#13;
    /**&#13;
     * Helper for storing maze in memory as square&#13;
     */&#13;
    function Edge () {&#13;
&#13;
    }&#13;
&#13;
    Edge.prototype.serialize = function () {&#13;
        return {&#13;
&#13;
        };&#13;
    };&#13;
&#13;
    Edge.prototype.deserialize = function (obj) {&#13;
&#13;
    };&#13;
&#13;
    /**&#13;
     * @class&#13;
     *&#13;
     * @param {{width: Number, height: Number}} size&#13;
     * @param {Number} maxSize of maze in px&#13;
     * @this Maze&#13;
     *&#13;
     */&#13;
    function Maze (size, maxSize) {&#13;
        this.xSize = size.width;&#13;
        this.ySize = size.height;&#13;
        this.maxSize = maxSize;&#13;
&#13;
        this.mazeElements = []; //All elements in maze. This is {Edge|Wall|Room}[y][x]&#13;
&#13;
        this.mainDiv = document.createElement('div');&#13;
        this.mainDiv.className += ' Maze_main_container';&#13;
&#13;
        /** @type {Wall[]} */&#13;
        this.walls = [];&#13;
        /**@type {Room[]} */&#13;
        this.rooms = [];&#13;
    }&#13;
&#13;
    Maze.prototype.serialize = function () {&#13;
        var elements = [];&#13;
&#13;
        this.mazeElements.forEach(function (row) {&#13;
            var rowElements = [];&#13;
            row.forEach(function(value) {&#13;
                rowElements.push(value.serialize());&#13;
            });&#13;
&#13;
            elements.push(rowElements);&#13;
        });&#13;
&#13;
        return {&#13;
            elements: elements&#13;
        };&#13;
    };&#13;
&#13;
    Maze.prototype.deserialize = function (mazeObj) {&#13;
        this.getMazeElementsContainer().innerHTML = '';&#13;
        this.walls = [];&#13;
        this.rooms = [];&#13;
        this.mazeElements = [];&#13;
        this.buildStruct();&#13;
&#13;
        var self = this;&#13;
        mazeObj.elements.forEach(function (rowObj, yIndex) {&#13;
            rowObj.forEach(function (value, xIndex) {&#13;
                self.mazeElements[yIndex][xIndex].deserialize(value);&#13;
            });&#13;
        });&#13;
&#13;
        this.setValidClasses();&#13;
    };&#13;
&#13;
    /**&#13;
     * Build structure of maze in memory&#13;
     */&#13;
    Maze.prototype.buildStruct = function () {&#13;
        var i;&#13;
&#13;
        for (i = 0; i &lt; this.ySize; i++) {&#13;
            this.buildWallsLine();&#13;
            this.buildRoomsLine();&#13;
        }&#13;
&#13;
        this.buildWallsLine();&#13;
    };&#13;
&#13;
    Maze.prototype.buildWallsLine = function () {&#13;
            var i,&#13;
                elements = [];&#13;
&#13;
            for (i = 0; i &lt; this.xSize; i++) {&#13;
                elements.push(new Edge());&#13;
                elements.push(this.buildWall());&#13;
            }&#13;
&#13;
            elements.push(new Edge());&#13;
&#13;
            this.mazeElements.push(elements);&#13;
    };&#13;
&#13;
    Maze.prototype.buildRoomsLine = function () {&#13;
            var i,&#13;
                elements = [];&#13;
&#13;
            for (i = 0; i &lt; this.xSize; i++) {&#13;
                elements.push(this.buildWall());&#13;
                elements.push(this.buildRoom());&#13;
            }&#13;
&#13;
            elements.push(this.buildWall());&#13;
&#13;
            this.mazeElements.push(elements);&#13;
    };&#13;
&#13;
    Maze.prototype.buildWall = function () {&#13;
            var wall = new Wall(this.walls.length);&#13;
&#13;
            this.walls.push(wall);&#13;
&#13;
            return wall;&#13;
    };&#13;
&#13;
    Maze.prototype.buildRoom = function () {&#13;
            var room = new Room(this.rooms.length);&#13;
&#13;
            this.rooms.push(room);&#13;
            this.getMazeElementsContainer().appendChild(room.getElement());&#13;
&#13;
            return room;&#13;
    };&#13;
&#13;
    Maze.prototype.algorithms = {&#13;
        PRIMS: Prims&#13;
    };&#13;
&#13;
    Maze.prototype.getMazeElementsContainer = function () {&#13;
        return this.mazeElementsContainer;&#13;
    };&#13;
&#13;
    /**&#13;
     * Generate new maze&#13;
     * @param {"PRIMS"} [algorithmName] name of algorithm which will generate maze&#13;
     */&#13;
    Maze.prototype.generate = function (algorithmName) {&#13;
        algorithmName = algorithmName || 'PRIMS';&#13;
&#13;
        this.mazeElementsContainer = document.createElement('div');&#13;
        this.mazeElementsContainer.classList.add('Maze_game_elements_container');&#13;
&#13;
        this.buildStruct();&#13;
&#13;
        this.getElement().appendChild(this.mazeElementsContainer);&#13;
&#13;
        //Call algorithm to build maze&#13;
        this.algorithms[algorithmName](this);&#13;
&#13;
        this.setValidClasses();&#13;
&#13;
    };&#13;
&#13;
    /**&#13;
    * @returns {Number} count of walls in maze.&#13;
    */&#13;
    Maze.prototype.getWallsCount = function () {&#13;
        return this.walls.length;&#13;
    };&#13;
&#13;
    /**&#13;
     * @returns {HTMLDivElement}&#13;
     */&#13;
    Maze.prototype.getElement = function () {&#13;
        return this.mainDiv;&#13;
    };&#13;
&#13;
    /**&#13;
     * Set classes and styles for maze after generating valid maze.&#13;
     * Each maze cell is image with correct class name and rotation.&#13;
     * Sometimes cell contains single dot in corner to complete this corner.&#13;
     */&#13;
    Maze.prototype.setValidClasses = function () {&#13;
        var i;&#13;
&#13;
        for (i = 0; i &lt; this.rooms.length; i++) {&#13;
            var room = this.rooms[i];&#13;
&#13;
            var percent = (100 / Math.max(this.xSize, this.ySize));&#13;
            room.getElement().style.width = Math.floor(this.maxSize * percent / 100) + 'px';&#13;
            room.getElement().style.height = Math.floor(this.maxSize * percent / 100) + 'px';&#13;
&#13;
            if (i % this.xSize === 0) {&#13;
                room.getElement().style.clear = 'both';&#13;
            }&#13;
&#13;
            var roomWalls = this.getRoomWalls(room);&#13;
            var matchedClass = this.getCorrectClass(roomWalls);&#13;
&#13;
            room.addWallClass(matchedClass.className);&#13;
&#13;
            rotateElement(room.getWallsElement(), matchedClass.rotation * -1);&#13;
&#13;
            this.checkDotIsNeeded(1, 1, 0, room);&#13;
            this.checkDotIsNeeded(-1, 1, 90, room);&#13;
            this.checkDotIsNeeded(-1, -1, 180, room);&#13;
            this.checkDotIsNeeded(1, -1, 270, room);&#13;
        }&#13;
    };&#13;
&#13;
    /**&#13;
     * Sometimes on connection between two walls is needed to put small image for valid display (in corner)&#13;
     * @param xSign {Number} check x position with positive sign or negative&#13;
     * @param ySign {Number} check y position with positive sign or negative&#13;
     * @param rotation {Number}&#13;
     * @param room {Room}&#13;
     */&#13;
    Maze.prototype.checkDotIsNeeded = function (xSign, ySign, rotation, room) {&#13;
        var roomPosition = this.getRoomPosition(room);&#13;
&#13;
        if (this.mazeElements[roomPosition.y - (1 * ySign)] &amp;&amp; this.mazeElements[roomPosition.y - (2 * ySign)]) {&#13;
                var leftWall = this.mazeElements[roomPosition.y - (1 * ySign)][roomPosition.x - (2 * xSign)];&#13;
                var topWall = this.mazeElements[roomPosition.y - (2 * ySign)][roomPosition.x - (1 * xSign)];&#13;
                if (leftWall &amp;&amp; topWall &amp;&amp; leftWall.isClosed() &amp;&amp; topWall.isClosed()) {&#13;
                    room.setDotElement(rotation);&#13;
                }&#13;
            }&#13;
    };&#13;
&#13;
    /**&#13;
     * Rotate received walls and try match it to predefined values. Returns the best matched class name and rotation.&#13;
     * Be sure that order is correct.&#13;
     * @param  {Wall[]} walls in order top, right, bottom, left&#13;
     */&#13;
    Maze.prototype.getCorrectClass = function (walls) {&#13;
        var quad = [true, true, true, true];&#13;
        var leftTopRight = [true, true, false, true];&#13;
        var leftTop = [true, false, false, true];&#13;
        var topBottom = [true, false, true, false];&#13;
        var top = [true, false, false, false];&#13;
&#13;
        var matchers = [top, topBottom, leftTop, leftTopRight, quad];&#13;
&#13;
        function match () {&#13;
            var i,&#13;
                j;&#13;
            for (i = matchers.length - 1; i &gt;= 0 ; i--) {&#13;
                var matcher = matchers[i],&#13;
                    isMatched = true;&#13;
      &#13;
                for (j = 0; j &lt; 4; j++) {&#13;
                    if (matcher[j] !== walls[j].isClosed()) {&#13;
                        isMatched = false;&#13;
                        break;&#13;
                    }&#13;
                }&#13;
&#13;
                if (isMatched) {&#13;
                    return i;&#13;
                }&#13;
            }&#13;
&#13;
            return false;&#13;
        }&#13;
&#13;
        var matchedRotation = 0,&#13;
            bestMatch = -1,&#13;
            rotation;&#13;
&#13;
        for (rotation = 0; rotation &lt; 360; rotation += 90) {&#13;
            var matched = match();&#13;
            if (matched !== false &amp;&amp; matched &gt; bestMatch) {&#13;
                bestMatch = matched;&#13;
                matchedRotation = rotation;&#13;
            }&#13;
&#13;
            var wall = walls.pop();&#13;
            walls.unshift(wall);&#13;
        }&#13;
&#13;
        var classes = {&#13;
            4: 'Maze_room_image_top_left_right_bottom',&#13;
            3: 'Maze_room_image_top_left_right',&#13;
            2: 'Maze_room_image_top_left',&#13;
            1: 'Maze_room_image_top_bottom',&#13;
            0: 'Maze_room_image_top'&#13;
        };&#13;
&#13;
        return {&#13;
            className: classes[bestMatch],&#13;
            rotation: matchedRotation&#13;
        };&#13;
    };&#13;
&#13;
    /**Returns room walls in order: top, right, bottom, left&#13;
     * @returns  {Wall[]}&#13;
     */&#13;
    Maze.prototype.getRoomWalls = function (room) {&#13;
        var roomPosition = this.getRoomPosition(room);&#13;
&#13;
        var top = this.mazeElements[roomPosition.y - 1][roomPosition.x];&#13;
        var left = this.mazeElements[roomPosition.y][roomPosition.x - 1];&#13;
        var bottom = this.mazeElements[roomPosition.y + 1][roomPosition.x];&#13;
        var right = this.mazeElements[roomPosition.y][roomPosition.x + 1];&#13;
&#13;
        return [top, right, bottom, left];&#13;
    };&#13;
&#13;
    /**&#13;
     * Get room position in maze.&#13;
     * @param {Room} room &#13;
     */&#13;
    Maze.prototype.getRoomPosition = function (room) {&#13;
        var roomXPosition = room.index % this.xSize,&#13;
            roomYPosition = ~~(room.index / this.xSize);&#13;
&#13;
        var roomYPositionInElements = (roomYPosition * 2) + 1,&#13;
            roomXPositionInElements = (roomXPosition * 2) + 1;&#13;
&#13;
        return {&#13;
            y: roomYPositionInElements,&#13;
            x: roomXPositionInElements&#13;
        };&#13;
    };&#13;
&#13;
    /**Will return all neighbors&#13;
     * @param  {Room} room&#13;
     */&#13;
    Maze.prototype.getRoomNeigh = function (room) {&#13;
        var roomPosition = this.getRoomPosition(room);&#13;
&#13;
        var roomYPositionInElements = roomPosition.y,&#13;
            roomXPositionInElements = roomPosition.x;&#13;
&#13;
        var neigh = [];&#13;
&#13;
        if (roomXPositionInElements - 2 &gt; 0) {&#13;
            neigh.push(this.mazeElements[roomYPositionInElements][roomXPositionInElements - 2]);&#13;
        }&#13;
&#13;
        if (roomYPositionInElements - 2 &gt; 0) {&#13;
            neigh.push(this.mazeElements[roomYPositionInElements - 2][roomXPositionInElements]);&#13;
        }    &#13;
&#13;
        if (roomXPositionInElements + 2 &lt; this.mazeElements[0].length) {&#13;
            neigh.push(this.mazeElements[roomYPositionInElements][roomXPositionInElements + 2]);&#13;
        } &#13;
&#13;
        if (roomYPositionInElements + 2 &lt; this.mazeElements.length) {&#13;
            neigh.push(this.mazeElements[roomYPositionInElements + 2][roomXPositionInElements]);&#13;
        } &#13;
&#13;
        return neigh;&#13;
    };&#13;
&#13;
    /**&#13;
     * @param  {Room} roomA&#13;
     * @param  {Room} roomB&#13;
     */&#13;
    Maze.prototype.openWallBetween = function (roomA, roomB) {&#13;
        var roomAPosition = this.getRoomPosition(roomA),&#13;
            roomBPosition = this.getRoomPosition(roomB);&#13;
&#13;
        var wallXPosition = roomAPosition.x - (roomAPosition.x - roomBPosition.x) / 2,&#13;
            wallYPosition = roomAPosition.y - (roomAPosition.y- roomBPosition.y) / 2;&#13;
&#13;
        this.mazeElements[wallYPosition][wallXPosition].open();&#13;
    };&#13;
&#13;
    Maze.prototype.isOpenedBetween = function (roomA, roomB) {&#13;
        var roomAPosition = this.getRoomPosition(roomA),&#13;
            roomBPosition = this.getRoomPosition(roomB);&#13;
&#13;
        var wallXPosition = roomAPosition.x - (roomAPosition.x - roomBPosition.x) / 2,&#13;
            wallYPosition = roomAPosition.y - (roomAPosition.y- roomBPosition.y) / 2;&#13;
&#13;
        return this.mazeElements[wallYPosition][wallXPosition].isOpened();&#13;
    };&#13;
&#13;
    /**&#13;
     * Get longest path in maze.&#13;
     * Algorithm: get random element and find longest path from it. Get last element from that longest path and find next longest path which is longest path in maze&#13;
     * @returns {Array}&#13;
     */&#13;
    Maze.prototype.getLongestPath = function () {&#13;
        var self = this;&#13;
        var bestAnswer = [];&#13;
        function dfs(room, from, answer) {&#13;
            answer.push(room);&#13;
&#13;
            var neigh = self.getRoomNeigh(room).filter(function (element) {&#13;
                return self.isOpenedBetween(room, element);&#13;
            });&#13;
&#13;
            neigh.forEach(function (element) {&#13;
                if (element !== from) {&#13;
                    dfs(element, room, answer.slice());&#13;
                }&#13;
            });&#13;
&#13;
            if (neigh.length === 1) {&#13;
                if (answer.length &gt; bestAnswer.length) {&#13;
                    bestAnswer = answer;&#13;
                }&#13;
            }&#13;
        }&#13;
        var room = this.rooms[0];&#13;
&#13;
        dfs(room, null, []);&#13;
        room = bestAnswer[bestAnswer.length - 1];&#13;
&#13;
        bestAnswer = [];&#13;
        dfs(room, null, []);&#13;
&#13;
        return bestAnswer;&#13;
    };&#13;
&#13;
    function getRandomIndex (array) {&#13;
        return Math.floor(Math.random() * array.length);&#13;
    }&#13;
&#13;
    /**http://weblog.jamisbuck.org/2011/1/10/maze-generation-prim-s-algorithm&#13;
     * @param  {Maze} maze&#13;
     */&#13;
    function Prims (maze) {&#13;
        var roomsList = [];&#13;
        var selected = [];&#13;
&#13;
        function initialize () {&#13;
            var i;&#13;
&#13;
            for (i = 0; i &lt; maze.getWallsCount(); i++) {&#13;
                maze.walls[i].close();&#13;
            }&#13;
&#13;
            var neigh = maze.getRoomNeigh(maze.rooms[0]);&#13;
            roomsList = roomsList.concat(neigh);&#13;
            selected.push(maze.rooms[0]);&#13;
        }&#13;
&#13;
        initialize();&#13;
&#13;
        while (roomsList.length !== 0) {&#13;
            var roomIndex = getRandomIndex(roomsList);&#13;
            var room = roomsList.splice(roomIndex, 1)[0];&#13;
            var roomNeigh = maze.getRoomNeigh(room);&#13;
            var selectedNeight = [];&#13;
&#13;
            roomNeigh.forEach(function (element) {&#13;
                if (selected.indexOf(element) === -1) {&#13;
                    if (roomsList.indexOf(element) === -1) {&#13;
                        roomsList.push(element);&#13;
                    }&#13;
                } else {&#13;
                    selectedNeight.push(element);&#13;
                }&#13;
            });&#13;
&#13;
            var connectWithIndex = getRandomIndex(selectedNeight);&#13;
            maze.openWallBetween(room, selectedNeight[connectWithIndex]);&#13;
            selected.push(room);&#13;
&#13;
        }&#13;
&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>