<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Math" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="Variables" nameLabel="Math_property_variables" type="text"/>
        <property name="Expressions" nameLabel="Math_property_expressions" type="text"/>
        <property name="Show Answers" nameLabel="Math_property_show_answers" type="text"/>
        <property name="Decimal separator" nameLabel="Math_property_decimal_separator" type="string"/>
        <property name="Thousand separator" nameLabel="Math_property_thousand_separator" type="string"/>
        <property name="onCorrect" nameLabel="Math_property_on_correct" type="event"/>
        <property name="onIncorrect" nameLabel="Math_property_on_incorrect" type="event"/>
        <property name="onPartiallyCompleted" nameLabel="Math_property_on_partially_completed" type="event"/>
        <property name="Empty Answer" nameLabel="Math_property_empty_answer" type="string"/>
    </model>
<css/><view/><preview/><presenter>function AddonMath_create() {&#13;
&#13;
    function getCorrectObject(val) { return { isError: false, value: val }; }&#13;
    function getErrorObject(ec) { return { isError: true, errorCode: ec }; }&#13;
&#13;
    var presenter = function() {};&#13;
    presenter.isShowAnswers = false;&#13;
    presenter.currentGapIndex = 0;&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
    };&#13;
&#13;
    presenter.setEventBus = function (eventBus) {&#13;
        presenter.eventBus = eventBus;&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.presenterLogic(view, model);&#13;
        presenter.$view.css('visibility', 'hidden');&#13;
&#13;
        if (presenter.eventBus) {&#13;
            presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
            presenter.eventBus.addEventListener('HideAnswers', this);&#13;
            presenter.eventBus.addEventListener('PageLoaded', this);&#13;
            presenter.eventBus.addEventListener('ValueChanged', this);&#13;
            presenter.eventBus.addEventListener('GradualShowAnswers', this);&#13;
            presenter.eventBus.addEventListener('GradualHideAnswers', this);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model);&#13;
    };&#13;
&#13;
    presenter.presenterLogic = function (view, model) {&#13;
        presenter.$view = $(view);&#13;
        presenter.model = model;&#13;
&#13;
        presenter.configuration = presenter.convertModel(model);&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'CV_01': "Missing assignment operator!",&#13;
        'CV_02': "Missing gap ID!",&#13;
        'CV_03': "Unused variable!",&#13;
        'CV_04': "Decimal separator and thousand separator are the same!",&#13;
        'CV_05': "Number of defined gaps in Show Answers is different than number of Variables",&#13;
        'CV_06': "Incorrect gap name defined in Show Answers property",&#13;
        'SA04': "Empty line is inserted in Show Answers property",&#13;
        'SA02': "Name of gap is not defined in Show Answers",&#13;
        'SA03': "Value of gap is not defined in Show Answers",&#13;
        'EV_01': "Only one string can be declared"&#13;
    };&#13;
&#13;
    presenter.convertVariables = function (variables, expressions) {&#13;
        if (ModelValidationUtils.isStringEmpty(variables)) return { isError: false, variables: [] };&#13;
&#13;
        var variablesArray = [], splittedVariables = variables.split('\n'), i, j, expVariables = [];&#13;
&#13;
        for (i = 0; i &lt; splittedVariables.length; i++) {&#13;
            var line = splittedVariables[i];&#13;
            if (line.indexOf('=') === -1) return { isError: true, errorCode: 'CV_01' };&#13;
&#13;
            var splittedLine = line.split('=');&#13;
            if (splittedLine.length !== 2 || splittedLine[1].length === 0) return { isError: true, errorCode: 'CV_02' };&#13;
&#13;
            variablesArray.push({&#13;
                name: splittedLine[0].trim(),&#13;
                value: splittedLine[1].trim()&#13;
            });&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; expressions.length; i++) {&#13;
            var variablesInExp = presenter.selectVariablesFromExpression(expressions[i], variablesArray);&#13;
            for (j = 0; j &lt; variablesInExp.length; j++) {&#13;
                expVariables.push(variablesInExp[j]);&#13;
            }&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; variablesArray.length; i++) {&#13;
            if (expVariables.indexOf(variablesArray[i].name) === -1) return { isError: true, errorCode: 'CV_03' };&#13;
        }&#13;
&#13;
        return { isError: false, variables: variablesArray };&#13;
    };&#13;
&#13;
    presenter.parseShowAnswers = function (answers, convertedVariables) {&#13;
        if (ModelValidationUtils.isStringEmpty(answers)) return getCorrectObject([]);&#13;
&#13;
        var variables = answers.split('\n').map(function(line) {&#13;
            return {&#13;
                name:line.substr(0, line.indexOf('=')).trim(),&#13;
                value:line.substr(line.indexOf('=') + 1).trim(),&#13;
                users: ''&#13;
            }&#13;
        });&#13;
&#13;
        if (variables.some(function(v) { return v.value === '' &amp;&amp; v.name === ''; })) {&#13;
            return getErrorObject('SA04'); // check if empty line is in property&#13;
        }&#13;
&#13;
        if (variables.some(function(v) { return v.name === ''; })) {&#13;
            return getErrorObject('SA02'); // check if name of gap is defined&#13;
        }&#13;
&#13;
        if (variables.some(function(v) { return v.value === ''; })) {&#13;
            return getErrorObject('SA03'); // check if value of gap is defined&#13;
        }&#13;
&#13;
        if(variables.length &gt; 0 &amp;&amp; (variables.length != convertedVariables.length)){&#13;
            return getErrorObject('CV_05'); // check if number of gaps equals number of defined gaps in Show Answers&#13;
        }&#13;
&#13;
        var definedGaps = [];&#13;
        for (var j = 0; j &lt;  convertedVariables.length; j++){&#13;
            definedGaps.push(convertedVariables[j].name);&#13;
        }&#13;
&#13;
        for (var i = 0; i &lt;  variables.length; i++){&#13;
            if(!(definedGaps.indexOf(variables[i].name) &gt; -1)){&#13;
                return getErrorObject('CV_06'); // check if defined gap names are correct&#13;
            }&#13;
        }&#13;
&#13;
        return getCorrectObject(variables);&#13;
    };&#13;
&#13;
    presenter.convertExpressions = function (expressions) {&#13;
        var expressionsArray = [], splittedExpressions = expressions.split('\n');&#13;
&#13;
        for (var i = 0; i &lt; splittedExpressions.length; i++) {&#13;
            expressionsArray.push(splittedExpressions[i]);&#13;
        }&#13;
&#13;
        return expressionsArray;&#13;
    };&#13;
&#13;
&#13;
    presenter.convertEmptyAnswer = function(variable) {&#13;
        if (!variable) return "";&#13;
        if (variable.indexOf(' ') &gt;= 0) return { isError: true, errorCode: 'EV_01' };&#13;
&#13;
        return variable;&#13;
    };&#13;
&#13;
    presenter.convertModel = function (model) {&#13;
        var expressions = presenter.convertExpressions(model.Expressions);&#13;
&#13;
        var convertedVariables = presenter.convertVariables(model.Variables, expressions);&#13;
        if (convertedVariables.isError) {&#13;
            return { isError: true, errorCode: convertedVariables.errorCode };&#13;
        }&#13;
&#13;
        var parsedShowAnswers = presenter.parseShowAnswers(model['Show Answers'], convertedVariables.variables);&#13;
        if (parsedShowAnswers.isError) {&#13;
            return { isError: true, errorCode: parsedShowAnswers.errorCode };&#13;
        }&#13;
&#13;
        var decimalSeparator = model["Decimal separator"],&#13;
            isDecimalSeparatorSet = !ModelValidationUtils.isStringEmpty(decimalSeparator);&#13;
&#13;
        var thousandSeparator = model["Thousand separator"],&#13;
            isThousandSeparatorSet = !ModelValidationUtils.isStringEmpty(thousandSeparator);&#13;
&#13;
        if (decimalSeparator == thousandSeparator &amp;&amp; isDecimalSeparatorSet &amp;&amp; isThousandSeparatorSet) {&#13;
            return { isError: true, errorCode: 'CV_04' };&#13;
        }&#13;
&#13;
        var separators =  {&#13;
            decimalSeparator: isDecimalSeparatorSet ? decimalSeparator : undefined,&#13;
            isDecimalSeparatorSet: isDecimalSeparatorSet,&#13;
            thousandSeparator: isThousandSeparatorSet ? thousandSeparator : undefined,&#13;
            isThousandSeparatorSet: isThousandSeparatorSet&#13;
        };&#13;
&#13;
        var emptyAnswer = presenter.convertEmptyAnswer(model['Empty Answer']);&#13;
        if (emptyAnswer.isError) {&#13;
            return { isError: true, errorCode: 'EV_01' };&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            variables: convertedVariables.variables,&#13;
            expressions: expressions,&#13;
            answers: parsedShowAnswers.value,&#13;
            onCorrectEvent: model.onCorrect,&#13;
            onIncorrectEvent: model.onIncorrect,&#13;
            onPartialEvent: model.onPartiallyCompleted,&#13;
            separators: separators,&#13;
            emptyAnswer: emptyAnswer,&#13;
            addonID: model.ID&#13;
        };&#13;
    };&#13;
&#13;
    function isInExpressionString (expressions) {&#13;
        for (var i = 0; i &lt; expressions.length; i++) {&#13;
            if (!isNumber(expressions[i].value)) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function changeExpressionToString (expressions) {&#13;
        for (var i = 0; i &lt; expressions.length; i++) {&#13;
            expressions[i].value = expressions[i].value + "";&#13;
        }&#13;
        return expressions;&#13;
    }&#13;
&#13;
    presenter.evaluateExpression = function (expression, variables, separators) {&#13;
        var i, expressionRunner = {&#13;
            /**&#13;
             * @param  {string} expression&#13;
             * @param  {} variables&#13;
             */&#13;
            run: function (expression, variables) {&#13;
                presenter.assignVariablesToObject(this, variables, expression);&#13;
                var parser = math.parser();&#13;
&#13;
                parser.set('variables', this.variables);&#13;
&#13;
                if ((expression.indexOf("{") &gt; -1) &amp;&amp; (expression.indexOf("function") &gt; -1)) {     // There will be probably function declaration&#13;
                    delete math.iifeFunction;&#13;
&#13;
                    math.import({&#13;
                        iifeFunction: new Function(expression + "; return result;")&#13;
                    });&#13;
&#13;
                    expression = "result = iifeFunction.call({variables:variables})";&#13;
                } else {&#13;
                    expression = expression.replace(/&amp;&amp;/g," and ").replace(/\|\|/g, " or ").replace(/'/g, '"');&#13;
                }&#13;
&#13;
                parser.eval(expression);&#13;
                return parser.get('result');&#13;
            }&#13;
        };&#13;
&#13;
        try {&#13;
            var convertedVariables = [];&#13;
            for (i = 0; i &lt; variables.length; i++) {&#13;
                var convertedVariable = presenter.convertVariable(variables[i].value, separators);&#13;
                if (convertedVariable === undefined) return { isValid: false, result: getAlertMessage(variables[i]) };&#13;
                convertedVariables.push({&#13;
                    name: variables[i].name,&#13;
                    value: convertedVariable&#13;
                });&#13;
            }&#13;
&#13;
            if(isInExpressionString(convertedVariables)) {&#13;
                convertedVariables = changeExpressionToString(convertedVariables);&#13;
            }&#13;
&#13;
            var convertedExpression = presenter.convertExpression(expression, convertedVariables);&#13;
            return {isValid: true, result: expressionRunner.run(convertedExpression, convertedVariables)};&#13;
        } catch (exception) {&#13;
            return {isValid: true, result: false};&#13;
        }&#13;
    };&#13;
&#13;
    presenter.selectVariablesFromExpression = function (expression, variables) {&#13;
        var presentVariables = [], tempVariables = [], i, j;&#13;
&#13;
        for (i = 0; i &lt; variables.length; i++) {&#13;
            if (expression.indexOf(variables[i].name) !== -1) {&#13;
                tempVariables.push({&#13;
                    name: variables[i].name,&#13;
                    index: expression.indexOf(variables[i].name)&#13;
                });&#13;
            }&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; tempVariables.length; i++) {&#13;
            if (!tempVariables[i]) continue;&#13;
&#13;
            var variable = tempVariables[i];&#13;
            for (j = 0; j &lt; tempVariables.length; j++) {&#13;
                if (i === j || tempVariables[j] === undefined) continue;&#13;
&#13;
                if (variable.index === tempVariables[j].index) {&#13;
                    if (variable.name.length &lt; tempVariables[j].name.length) {&#13;
                        delete tempVariables[i];&#13;
                    } else {&#13;
                        delete tempVariables[j];&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; tempVariables.length; i++) {&#13;
            if (tempVariables[i]) presentVariables.push(tempVariables[i].name);&#13;
        }&#13;
&#13;
        return presentVariables;&#13;
    };&#13;
&#13;
    presenter.evaluateAllExpressions = function (expressions, variables, separators) {&#13;
        var results = [], i, overall = true, evaluationResult;&#13;
&#13;
        for (i = 0; i &lt; expressions.length; i++) {&#13;
            evaluationResult = presenter.evaluateExpression(expressions[i], variables, separators);&#13;
            if (!evaluationResult.isValid) {&#13;
                return { isError: true, errorMessage: evaluationResult.result };&#13;
            }&#13;
&#13;
            results.push(evaluationResult.result);&#13;
        }&#13;
&#13;
        for (i = 0; i &lt; results.length; i++) {&#13;
            if (!results[i]) {&#13;
                overall = false;&#13;
            }&#13;
        }&#13;
&#13;
        return { overall: overall, isError: false };&#13;
    };&#13;
&#13;
    presenter.getModule = function (moduleID) {&#13;
        return presenter.playerController.getModule(moduleID);&#13;
    };&#13;
&#13;
    function isNumber (number) {&#13;
        return !isNaN(parseFloat(number)) &amp;&amp; isFinite(number);&#13;
    }&#13;
&#13;
    presenter.convertVariable = function (gapIdentifier, separators) {&#13;
        var decodedReference = presenter.decodeModuleReference(gapIdentifier);&#13;
        if (!decodedReference.isValid) return undefined;&#13;
&#13;
        try {&#13;
            var textModule = presenter.getModule(decodedReference.moduleID);&#13;
            if (!textModule) return undefined;&#13;
&#13;
            var gapText = textModule.getGapValue(decodedReference.gapIndex);&#13;
            if (gapText == "[error]") return undefined;&#13;
&#13;
            if (separators.isThousandSeparatorSet) {&#13;
                gapText = StringUtils.replaceAll(gapText, separators.thousandSeparator, '');&#13;
            }&#13;
&#13;
            if (separators.isDecimalSeparatorSet) {&#13;
                gapText = gapText.replace(separators.decimalSeparator, '.');&#13;
            }&#13;
&#13;
            return isNumber(gapText) ? Number(gapText) : gapText;&#13;
        } catch (exception) {&#13;
            return undefined;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isGapAttempted = function (gapIdentifier) {&#13;
        var decodedReference = presenter.decodeModuleReference(gapIdentifier);&#13;
&#13;
        if (!decodedReference.isValid) return undefined;&#13;
&#13;
        try {&#13;
            var textModule = presenter.getModule(decodedReference.moduleID);&#13;
            if (!textModule) return undefined;&#13;
&#13;
            return textModule.isGapAttempted(decodedReference.gapIndex);&#13;
        } catch (exception) {&#13;
            return undefined;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.convertExpression = function (expression, variables) {&#13;
        var convertedExpression = 'result = ' + expression,&#13;
            expressionVariables = presenter.selectVariablesFromExpression(expression, variables), i;&#13;
&#13;
        for (i = 0; i &lt; expressionVariables.length; i++) {&#13;
            convertedExpression = presenter.replaceVariableNameWithReference(convertedExpression, expressionVariables[i]);&#13;
        }&#13;
&#13;
        return convertedExpression;&#13;
    };&#13;
&#13;
    function checkIfCorrectVariable(tempExpression, variable) {&#13;
        var lastChar = tempExpression.charAt(tempExpression.indexOf(variable)+variable.length);&#13;
        return lastChar == "." || lastChar == "(" || lastChar == ")" || lastChar == "" || lastChar == " " || lastChar == "/" || lastChar == "*" || lastChar == "=" || lastChar == "+" || lastChar == "-" || lastChar == "&gt;" || lastChar == "&lt;" || lastChar == "%" || lastChar == "!";&#13;
    }&#13;
&#13;
    presenter.findTextOccurrences = function (expression, variable) {&#13;
        var indexes = [], tempExpression = expression, offset = 0;&#13;
&#13;
        while (tempExpression.indexOf(variable) !== -1 &amp;&amp; checkIfCorrectVariable(tempExpression, variable)) {&#13;
            var indexOf = tempExpression.indexOf(variable);&#13;
            indexes.push(indexOf + offset);&#13;
            offset += indexOf + variable.length;&#13;
&#13;
            tempExpression = tempExpression.substring(indexOf + variable.length);&#13;
        }&#13;
&#13;
        return indexes;&#13;
    };&#13;
&#13;
    presenter.replaceVariableNameWithReference = function (expression, variable) {&#13;
        var prefix = 'variables["';&#13;
        var indexes = presenter.findTextOccurrences(expression, variable);&#13;
        var fixedExpression = expression.substring(0, indexes[0]);&#13;
&#13;
        for (var i = 0; i &lt; indexes.length - 1; i++) {&#13;
            fixedExpression += prefix + variable + '"]';&#13;
            fixedExpression += expression.substring(indexes[i] + variable.length, indexes[i + 1]);&#13;
        }&#13;
&#13;
        fixedExpression += prefix + variable + '"]';&#13;
        fixedExpression += expression.substring(indexes[indexes.length - 1] + variable.length);&#13;
&#13;
        return fixedExpression;&#13;
    };&#13;
&#13;
    presenter.assignVariablesToObject = function (object, variables, expression) {&#13;
        object.variables = {};&#13;
        if (expression != null) {&#13;
            var parsedExpression = expression.replace(/[\s]/g, '').replace(/'/g, '"').replace(/[&lt;&gt;+\-]/g, '=');&#13;
            parsedExpression = parsedExpression.replace(/===?/g, '=').replace(/variables\["(.*?)"]/g, '$1');&#13;
        }&#13;
&#13;
        for (var i = 0; i &lt; variables.length; i++) {&#13;
            var name = variables[i].name;&#13;
            if (parsedExpression != null &amp;&amp; (parsedExpression.indexOf('"='+name) != -1 || parsedExpression.indexOf(name+'="') != -1)) {&#13;
                object.variables[variables[i].name] = variables[i].value.toString();&#13;
            } else {&#13;
                object.variables[variables[i].name] = variables[i].value;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.decodeModuleReference = function (reference) {&#13;
        var dotIndex = reference.lastIndexOf('.');&#13;
        if (dotIndex === -1) return { isValid: false };&#13;
&#13;
        var moduleID = reference.substring(0, dotIndex);&#13;
        if (ModelValidationUtils.isStringEmpty(moduleID)) return { isValid: false };&#13;
&#13;
        var gapIndex = reference.substring(dotIndex + 1);&#13;
        if (ModelValidationUtils.isStringEmpty(gapIndex)) return { isValid: false };&#13;
&#13;
        return { isValid: true, moduleID: moduleID, gapIndex: gapIndex };&#13;
    };&#13;
&#13;
    presenter.getModuleReferenceFromVariable = function (variables, variableName) {&#13;
        for (var i = 0, length = variables.length; i &lt; length; i++) {&#13;
            if (variables[i].name === variableName) return variables[i].value;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.markGapsCorrectness = function (variables, overall) {&#13;
        var i, decodedReference, length, textModule;&#13;
&#13;
        for (i = 0, length = variables.length; i &lt; length; i++) {&#13;
            decodedReference = presenter.decodeModuleReference(variables[i].value);&#13;
            textModule = presenter.playerController.getModule(decodedReference.moduleID);&#13;
&#13;
            if (overall) {&#13;
                textModule.markGapAsCorrect(decodedReference.gapIndex);&#13;
            } else {&#13;
                textModule.markGapAsWrong(decodedReference.gapIndex);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if (presenter.isShowAnswers) {&#13;
            presenter.toggleAnswers(false, true);&#13;
        }&#13;
&#13;
        presenter.isErrorMode = true;&#13;
&#13;
        var variables = presenter.configuration.variables,&#13;
            emptyGaps = presenter.getEmptyGaps(variables);&#13;
&#13;
        if (!emptyGaps.isValid) {&#13;
            presenter.hideAnswers();&#13;
            alert(emptyGaps.errorMessage);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.markGapsEmptiness(emptyGaps.gaps);&#13;
&#13;
        if (emptyGaps.gaps.length !== 0) return;&#13;
&#13;
        var separators = presenter.configuration.separators,&#13;
            expressions = presenter.configuration.expressions,&#13;
            evaluationResult = presenter.evaluateAllExpressions(expressions, variables, separators);&#13;
&#13;
        presenter.markGapsCorrectness(presenter.configuration.variables, evaluationResult.overall);&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        presenter.isErrorMode = false;&#13;
    };&#13;
&#13;
    presenter.executeEventCode = function(eventCode) {&#13;
        presenter.playerController.getCommands().executeEventCode(eventCode);&#13;
    };&#13;
&#13;
    presenter.markGapsEmptiness = function(gaps) {&#13;
        var moduleReference, decodedReference, textModule, i, length;&#13;
&#13;
        for (i = 0, length = gaps.length; i &lt; length; i++) {&#13;
            moduleReference = presenter.getModuleReferenceFromVariable(presenter.configuration.variables, gaps[i]);&#13;
            decodedReference = presenter.decodeModuleReference(moduleReference);&#13;
            textModule = presenter.playerController.getModule(decodedReference.moduleID);&#13;
            textModule.markGapAsEmpty(decodedReference.gapIndex);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.evaluate = function () {&#13;
        if (presenter.isErrorMode) return;&#13;
&#13;
        var emptyGaps = presenter.getEmptyGaps(presenter.configuration.variables);&#13;
        if (!emptyGaps.isValid) {&#13;
            presenter.hideAnswers();&#13;
            alert(emptyGaps.errorMessage);&#13;
            return;&#13;
        }&#13;
&#13;
        if (emptyGaps.gaps.length !== 0) {&#13;
            presenter.executeEventCode(presenter.configuration.onPartialEvent);&#13;
        } else {&#13;
            var separators = presenter.configuration.separators,&#13;
                evaluationResult = presenter.evaluateAllExpressions(presenter.configuration.expressions,&#13;
                                                                    presenter.configuration.variables, separators),&#13;
                eventCode = evaluationResult.overall ? presenter.configuration.onCorrectEvent : presenter.configuration.onIncorrectEvent;&#13;
            presenter.executeEventCode(eventCode);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isAttempted = function() {&#13;
        var notAttemptedGaps = presenter.getNotAttemptedGaps(presenter.configuration.variables);&#13;
        return notAttemptedGaps.gaps.length === 0;&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        if(presenter.configuration.isError){&#13;
            return;&#13;
        }&#13;
        const isShowAnswers = presenter.isShowAnswers;&#13;
        if (isShowAnswers) presenter.toggleAnswers(false);&#13;
&#13;
        const variables = presenter.configuration.variables,&#13;
            emptyGaps = presenter.getEmptyGaps(variables);&#13;
        if (!emptyGaps.isValid || emptyGaps.gaps.length !== 0) {&#13;
            if (isShowAnswers) presenter.toggleAnswers(true);&#13;
            return 0;&#13;
        }&#13;
&#13;
        const separators = presenter.configuration.separators,&#13;
            expressions = presenter.configuration.expressions,&#13;
            evaluationResult = presenter.evaluateAllExpressions(expressions, variables, separators);&#13;
&#13;
        if (isShowAnswers) presenter.toggleAnswers(true);&#13;
        if (evaluationResult.isError) return;&#13;
&#13;
        return evaluationResult.overall ? presenter.getMaxScore() : 0;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (presenter.configuration.isError){&#13;
            return;&#13;
        }&#13;
&#13;
        var isShowAnswers = presenter.isShowAnswers;&#13;
        if (isShowAnswers) {&#13;
            presenter.toggleAnswers(false);&#13;
        }&#13;
&#13;
        var variables = presenter.configuration.variables,&#13;
            emptyGaps = presenter.getEmptyGaps(variables);&#13;
&#13;
        if (!emptyGaps.isValid || emptyGaps.gaps.length !== 0) {&#13;
            if (isShowAnswers) presenter.toggleAnswers(true);&#13;
            return 0;&#13;
        }&#13;
&#13;
        var separators = presenter.configuration.separators,&#13;
            expressions = presenter.configuration.expressions,&#13;
            evaluationResult = presenter.evaluateAllExpressions(expressions, variables, separators);&#13;
        if (isShowAnswers) presenter.toggleAnswers(true);&#13;
&#13;
        if (evaluationResult.isError) return;&#13;
&#13;
        return !evaluationResult.overall ? presenter.getMaxScore() : 0;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if(presenter.configuration.isError){&#13;
            return;&#13;
        }&#13;
        return presenter.configuration.variables.length;&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.isErrorMode = false;&#13;
        presenter.isShowAnswers = false;&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore();&#13;
    };&#13;
&#13;
    presenter.createAllOKEventData = function (){&#13;
        return{&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        }&#13;
    };&#13;
&#13;
    presenter.sendAllOKEvent = function (){&#13;
        presenter.eventBus.sendEvent('ValueChanged', presenter.createAllOKEventData());&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        if (presenter.isErrorMode) return;&#13;
&#13;
        var commands = {&#13;
            'evaluate': presenter.evaluate,&#13;
            'isAttempted': presenter.isAttempted,&#13;
            'showAnswers': presenter.showAnswers,&#13;
            'hideAnswers': presenter.hideAnswers,&#13;
            'isAllOK': presenter.isAllOK&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    function getAlertMessage(variable) {&#13;
        var decodedReference = presenter.decodeModuleReference(variable.value);&#13;
&#13;
        return "Text module with ID [ID] doesn't have gap with [INDEX] index or does not exists!"&#13;
            .replace('[ID]', decodedReference.moduleID)&#13;
            .replace('[INDEX]', decodedReference.gapIndex);&#13;
    }&#13;
&#13;
    function isVariableEmpty(variable) {&#13;
        return variable === "" || variable === presenter.configuration.emptyAnswer;&#13;
    }&#13;
&#13;
    presenter.getEmptyGaps = function (variables) {&#13;
        var emptyGaps = [], i, convertedVariable;&#13;
&#13;
        for (i = 0; i &lt; variables.length; i++) {&#13;
            convertedVariable = presenter.convertVariable(variables[i].value, presenter.configuration.separators);&#13;
            if (convertedVariable === undefined) return { isValid: false, errorMessage: getAlertMessage(variables[i]) };&#13;
&#13;
            if (isVariableEmpty(convertedVariable)) emptyGaps.push(variables[i].name);&#13;
        }&#13;
&#13;
        return { isValid: true, gaps: emptyGaps };&#13;
    };&#13;
&#13;
    presenter.getNotAttemptedGaps = function (variables) {&#13;
        var notAttemptedGaps = [], i, convertedVariable;&#13;
&#13;
        for (i = 0; i &lt; variables.length; i++) {&#13;
            convertedVariable = presenter.isGapAttempted(variables[i].value);&#13;
            if (convertedVariable === undefined) return { isValid: false, errorMessage: getAlertMessage(variables[i]) };&#13;
&#13;
            if (convertedVariable === false) notAttemptedGaps.push(variables[i].name);&#13;
        }&#13;
&#13;
        return { isValid: true, gaps: notAttemptedGaps };&#13;
    };&#13;
&#13;
    presenter.toggleAnswers = function (on, blockUnlocking = false) {&#13;
        presenter.isShowAnswers = on;&#13;
        for (var i=0; i&lt;presenter.configuration.answers.length; i++) {&#13;
            var answer = presenter.configuration.answers[i];&#13;
            var gapName = null;&#13;
            for (var j= 0; j&lt;presenter.configuration.variables.length; j++){&#13;
                if(presenter.configuration.variables[j].name == answer.name){&#13;
                    gapName = presenter.configuration.variables[j].value;&#13;
                }&#13;
            }&#13;
            if(gapName == null){&#13;
                return;&#13;
            }&#13;
&#13;
            var moduleReference = presenter.decodeModuleReference(gapName);&#13;
            var module = presenter.getModule(moduleReference.moduleID);&#13;
&#13;
            if (module != null &amp;&amp; !module.isActivity()) {&#13;
                if (on) {&#13;
                    answer.users = module.getValue(moduleReference.gapIndex);&#13;
                    module.setGapAnswer(moduleReference.gapIndex, answer.value, presenter.moduleAnswersCounter(moduleReference.moduleID));&#13;
                } else {&#13;
                    module.setUserValue(moduleReference.gapIndex, answer.users);&#13;
                    if (!blockUnlocking &amp;&amp; module.hasOwnProperty('enableGap')) module.enableGap(moduleReference.gapIndex);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.reloadMathJax();&#13;
    }&#13;
&#13;
    presenter.reloadMathJax = function() {&#13;
        MathJax.CallBack.Queue().Push(function () {&#13;
            MathJax.Hub.Typeset();&#13;
        });&#13;
    }&#13;
&#13;
    presenter.moduleAnswersCounter = function (module) {&#13;
        var counter = 0;&#13;
&#13;
        for (var j= 0; j&lt;presenter.configuration.variables.length; j++){&#13;
            if(presenter.configuration.variables[j].value.indexOf(module) &gt; -1){&#13;
                counter++;&#13;
            }&#13;
        }&#13;
&#13;
        return counter;&#13;
    };&#13;
&#13;
    presenter.showAnswers = function() {&#13;
        if (!presenter.isShowAnswers) {&#13;
            presenter.toggleAnswers(true);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function() {&#13;
        if (presenter.isShowAnswers) {&#13;
            presenter.toggleAnswers(false);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        return presenter.configuration.answers.length;&#13;
    }&#13;
&#13;
    presenter.gradualShowAnswers = function (data) {&#13;
        if (data.moduleID !== presenter.configuration.addonID) { return; }&#13;
&#13;
        var answer = presenter.configuration.answers[presenter.currentGapIndex];&#13;
        var gapName = null;&#13;
        for (var j = 0; j &lt; presenter.configuration.variables.length; j++) {&#13;
            if (presenter.configuration.variables[j].name === answer.name) {&#13;
                gapName = presenter.configuration.variables[j].value;&#13;
            }&#13;
        }&#13;
        if (gapName == null) {&#13;
            return;&#13;
        }&#13;
&#13;
        var moduleReference = presenter.decodeModuleReference(gapName);&#13;
        var module = presenter.getModule(moduleReference.moduleID);&#13;
&#13;
        module.setGapAnswer(moduleReference.gapIndex, answer.value, presenter.moduleAnswersCounter(moduleReference.moduleID));&#13;
        presenter.currentGapIndex++;&#13;
&#13;
        presenter.reloadMathJax();&#13;
    }&#13;
&#13;
    presenter.allOkSent = false;&#13;
&#13;
    presenter.onEventReceived = function(eventName, eventData) {&#13;
        switch(eventName) {&#13;
            case 'ShowAnswers': presenter.showAnswers(); break;&#13;
            case 'HideAnswers': presenter.hideAnswers(); break;&#13;
            case 'PageLoaded': markModules(); break;&#13;
            case 'ValueChanged':&#13;
                if (presenter.isAllOK() &amp;&amp; !presenter.allOkSent) {&#13;
                    presenter.allOkSent = true;&#13;
                    presenter.sendAllOKEvent();&#13;
                }else if(!presenter.isAllOK()){&#13;
                    presenter.allOkSent = false;&#13;
                }&#13;
                break;&#13;
            case 'GradualShowAnswers':&#13;
                presenter.gradualShowAnswers(eventData);&#13;
                break;&#13;
            case 'GradualHideAnswers':&#13;
                presenter.currentGapIndex = 0;&#13;
                presenter.hideAnswers();&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    function markModules() {&#13;
        if(presenter.configuration.isError){&#13;
            return;&#13;
        }&#13;
&#13;
        for (var i=0; i&lt;presenter.configuration.answers.length; i++) {&#13;
            var answer = presenter.configuration.answers[i];&#13;
            var moduleReference = presenter.decodeModuleReference(answer.name);&#13;
            var module = presenter.getModule(moduleReference.moduleID);&#13;
&#13;
            if (module != null &amp;&amp; !module.isActivity()) {&#13;
                module.markConnectionWithMath();&#13;
            }&#13;
        }&#13;
&#13;
        for (var j=0; j &lt; presenter.configuration.variables.length; j++){&#13;
            var decodedReference = presenter.decodeModuleReference(presenter.configuration.variables[j].value);&#13;
            var notSAmodule = presenter.getModule(decodedReference.moduleID);&#13;
&#13;
            if (notSAmodule != null &amp;&amp; !notSAmodule.isActivity()) {&#13;
                notSAmodule.markConnectionWithMath();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>