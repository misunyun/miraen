<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="LearnPen_Report" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="isDisable" nameLabel="LearnPen_Report_property_is_disable" type="boolean"/>
        <property name="correctRange" nameLabel="LearnPen_Report_property_correct_range" type="string"/>
        <property name="graphType" nameLabel="LearnPen_Report_property_graph_type" type="{Pie chart, Circle in circle, Four circles, Horizontal Bar}"/>
        <property name="sensor" nameLabel="LearnPen_Report_property_sensor" type="{All, Squeeze, Pressure, Squeeze A, Squeeze B, Squeeze C}"/>
        <property name="colors" nameLabel="LearnPen_Report_property_colors" type="text"/>
        <property name="dataUpdateInterval" nameLabel="LearnPen_Report_property_update_interval" type="string"/>
        <property name="calculateFromLastValues" nameLabel="LearnPen_Report_property_get_last_values" type="string"/>
    </model>
<css/><view>&lt;canvas style="display: none;"&gt;&lt;/canvas&gt;&#13;
&lt;img src=""&gt;&#13;
</view><preview>&lt;canvas&gt;Canvas is not supported in your browser&lt;/canvas&gt;&#13;
</preview><presenter>function AddonLearnPen_Report_create() {&#13;
&#13;
    // utilities functions&#13;
    function getCorrectObject(val) { return { isValid: true, value: val } }&#13;
&#13;
    function getErrorObject(ec) { return { isValid: false, errorCode: ec } }&#13;
&#13;
    function isInteger(n) { return n % 1 === 0; }&#13;
&#13;
    function round(n, precision) { return Math.round(n * Math.pow(10, precision)) / Math.pow(10, precision); }&#13;
&#13;
    function getLastElements (array, num) {&#13;
        num = num || 1;&#13;
&#13;
        if (array.length &lt; num) {&#13;
            return this;&#13;
        }&#13;
&#13;
        return this.slice(array.length - num);&#13;
    }&#13;
&#13;
    function shouldGetDataFromSensors (){&#13;
        for (var addon in presenter.addons) {&#13;
            if(presenter.addons[addon] == true){&#13;
                return true;&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    function getColorFromStatus(status) {&#13;
        switch (status) {&#13;
            case  1: return presenter.configuration.colors.above;&#13;
            case  0: return presenter.configuration.colors.correct;&#13;
            case -1: return presenter.configuration.colors.below;&#13;
        }&#13;
&#13;
        return "black";&#13;
    }&#13;
&#13;
    function half(v) { return parseInt(v / 2, 10); }&#13;
&#13;
    function hookToDrawingAreas(addon) {&#13;
        var $addon = $('.' + addon);&#13;
&#13;
        $addon.find('canvas').on('mousedown touchstart', function (){&#13;
            presenter.addons[addon] = true;&#13;
        });&#13;
&#13;
        $addon.find('canvas').on('mouseup mouseleave touchend', function (){&#13;
            presenter.addons[addon] = false;&#13;
        });&#13;
    }&#13;
&#13;
    var presenter = function() {};&#13;
    &#13;
    presenter.addons = {&#13;
        "addon_Drawing": false,&#13;
        "addon_Shape_Tracing": false,&#13;
        "addon_LearnPen": false&#13;
    };&#13;
&#13;
    presenter.data = {&#13;
        $canvas: null,&#13;
        context: null,&#13;
        $img: null,&#13;
&#13;
        sensorData: {&#13;
            below: 0,&#13;
            correct: 0,&#13;
            above: 0&#13;
        },&#13;
&#13;
        sensorsDataHistory: [],&#13;
&#13;
        isPreview: false,&#13;
        isIntervalOn: false,&#13;
        intervalId: null,&#13;
        isPaused: false&#13;
    };&#13;
&#13;
    presenter.SENSOR = {&#13;
        'All': 'ALL',&#13;
        'Squeeze': 'SQUEEZE',&#13;
        'Pressure': 'PRESSURE',&#13;
        'Squeeze A': 'SQUEEZEA',&#13;
        'Squeeze B': 'SQUEEZEB',&#13;
        'Squeeze C': 'SQUEEZEC',&#13;
        DEFAULT: 'All'&#13;
    };&#13;
    // {Pie chart, Circle in circle, Four circles}&#13;
    presenter.GRAPH = {&#13;
        'Pie chart': 'PIE',&#13;
        'Circle in circle': 'CINC',&#13;
        'Four circles': '4CIRCLES',&#13;
        'Horizontal Bar': 'BAR',&#13;
        DEFAULT: 'Pie chart'&#13;
    };&#13;
&#13;
    presenter.filteredDataCount = 0;&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        R01: "Number of arguments in Correct range is different then 2",&#13;
        R02: "All values in Correct range has to be numeric",&#13;
        R03: "All values in Correct range has to be between 0 and 100",&#13;
        R04: "Second argument in Correct range hast to be bigger then the first",&#13;
&#13;
        C01: "Number of argument is property Colors is different then 3",&#13;
&#13;
        I01: "Property Data update interval has to be numeric",&#13;
        I02: "Value of property Data update interval has to be between 50 and 2000 ms",&#13;
&#13;
        G01: "You cannot set sensor different then All and graph Circle in Circle or Four circles",&#13;
&#13;
        CALC01: "Property Calculate from last values has to be integer",&#13;
        CALC02: "Property Calculate from last values has to be positive value"&#13;
    };&#13;
&#13;
    function toPercent(val) { return parseInt(val / 1024 * 100); }&#13;
    &#13;
    function isDataNotNoise(element, index, array) {&#13;
        return element &gt;= 200;&#13;
    }&#13;
&#13;
&#13;
    function getCurrentDataFromSensor() {&#13;
        if(window.LearnPen) {&#13;
            var a = window.LearnPen.getA();&#13;
            var b = window.LearnPen.getB();&#13;
            var c = window.LearnPen.getC();&#13;
            var p = window.LearnPen.getP();&#13;
            var isValid = [a, b, c].some(isDataNotNoise);&#13;
            &#13;
            if(!isValid) {&#13;
                isValid = (p &gt;= 200);&#13;
            }&#13;
&#13;
            return {&#13;
                isValid: isValid,&#13;
                a: toPercent(a),&#13;
                b: toPercent(b),&#13;
                c: toPercent(c),&#13;
                p: toPercent(p)&#13;
            };&#13;
        } else {&#13;
            return {&#13;
                isValid: false,&#13;
                a: 0,&#13;
                b: 0,&#13;
                c: 0,&#13;
                p: 0&#13;
&#13;
//                isValid: true,&#13;
//                a: toPercent(Math.floor(Math.random() * 1000)),&#13;
//                b: toPercent(Math.floor(Math.random() * 1000)),&#13;
//                c: toPercent(Math.floor(Math.random() * 1000)),&#13;
//                p: toPercent(Math.floor(Math.random() * 1000))&#13;
            };            &#13;
        }&#13;
    }&#13;
&#13;
    function getSensorHistory(historyArray, sensorsArray) {&#13;
        var noise = toPercent(200);&#13;
&#13;
        function filterNoise(element) {&#13;
            return this.some(function (variable) {&#13;
               return element[variable] &gt; noise;&#13;
            }, this);&#13;
        }&#13;
&#13;
        return historyArray.filter(filterNoise, sensorsArray);&#13;
    }&#13;
&#13;
    function getValues() {&#13;
        var returnedData;&#13;
        if (presenter.configuration.calculateFromLastValues === 0) {&#13;
            returnedData = getSensorHistory(presenter.data.sensorsDataHistory, getSensorsConfiguration());&#13;
        } else {&#13;
            returnedData = getSensorHistory(getLastElements(presenter.data.sensorsDataHistory, getSensorsConfiguration(), presenter.configuration.calculateFromLastValues));&#13;
        }&#13;
&#13;
        return returnedData;&#13;
    }&#13;
&#13;
    function getSensorsConfiguration () {&#13;
        switch (presenter.configuration.sensor) {&#13;
            case presenter.SENSOR.All:&#13;
                return ['a', 'b', 'c', 'p'];&#13;
                break;&#13;
            case presenter.SENSOR.Pressure:&#13;
                return ['p'];&#13;
                break;&#13;
            case presenter.SENSOR.Squeeze:&#13;
                return ['a', 'b', 'c'];&#13;
                break;&#13;
            case presenter.SENSOR['Squeeze A']:&#13;
                return ['a'];&#13;
                break;&#13;
            case presenter.SENSOR['Squeeze B']:&#13;
                return ['b'];&#13;
                break;&#13;
            case presenter.SENSOR['Squeeze C']:&#13;
                return ['c'];&#13;
                break;&#13;
            default:&#13;
                return ['a', 'b', 'c', 'p'];&#13;
                break;&#13;
        }&#13;
    }&#13;
&#13;
    function updateSensorDataHistory(data) {&#13;
        if (data.isValid) {&#13;
            presenter.filteredDataCount = 0;&#13;
            presenter.data.sensorsDataHistory.push(data);&#13;
        }&#13;
&#13;
        if (presenter.configuration.calculateFromLastValues &gt; 0) {&#13;
            if(!data.isValid) {&#13;
                if (presenter.filteredDataCount &lt; presenter.configuration.calculateFromLastValues) {&#13;
                    presenter.filteredDataCount += 1;&#13;
                    presenter.data.sensorsDataHistory.push(data);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getStatus(v) {&#13;
        if (v &gt; presenter.configuration.range.end) {&#13;
            return 1;&#13;
        } else if (v &lt; presenter.configuration.range.start) {&#13;
            return -1;&#13;
        }&#13;
&#13;
        return 0;&#13;
    }&#13;
&#13;
    function updateResultDataFromSensorValue(value, result) {&#13;
        switch (getStatus(value)) {&#13;
            case  1: result.above++; break;&#13;
            case  0: result.correct++; break;&#13;
            case -1: result.below++; break;&#13;
        }&#13;
    }&#13;
&#13;
    function prepareData() {&#13;
        var resultObject = {&#13;
            above: 0,&#13;
            correct: 0,&#13;
            below: 0,&#13;
            aStatus: 0,&#13;
            bStatus: 0,&#13;
            cStatus: 0,&#13;
            pStatus: 0&#13;
        };&#13;
&#13;
        getValues().forEach(function(sensorDataObj, _, arr) {&#13;
            switch (presenter.configuration.sensor) {&#13;
                case presenter.SENSOR.All: updateResultDataFromSensorValue((sensorDataObj.a + sensorDataObj.b + sensorDataObj.c + sensorDataObj.p) / 4, resultObject); break;&#13;
                case presenter.SENSOR.Pressure: updateResultDataFromSensorValue(sensorDataObj.p, resultObject); break;&#13;
                case presenter.SENSOR.Squeeze: updateResultDataFromSensorValue((sensorDataObj.a + sensorDataObj.b + sensorDataObj.c) / 3, resultObject); break;&#13;
                case presenter.SENSOR['Squeeze A']: updateResultDataFromSensorValue(sensorDataObj.a, resultObject); break;&#13;
                case presenter.SENSOR['Squeeze B']: updateResultDataFromSensorValue(sensorDataObj.b, resultObject); break;&#13;
                case presenter.SENSOR['Squeeze C']: updateResultDataFromSensorValue(sensorDataObj.c, resultObject); break;&#13;
            }&#13;
&#13;
            resultObject.aStatus += sensorDataObj.a / arr.length;&#13;
            resultObject.bStatus += sensorDataObj.b / arr.length;&#13;
            resultObject.cStatus += sensorDataObj.c / arr.length;&#13;
            resultObject.pStatus += sensorDataObj.p / arr.length;&#13;
        });&#13;
&#13;
        resultObject.aStatus = getStatus(resultObject.aStatus);&#13;
        resultObject.bStatus = getStatus(resultObject.bStatus);&#13;
        resultObject.cStatus = getStatus(resultObject.cStatus);&#13;
        resultObject.pStatus = getStatus(resultObject.pStatus);&#13;
&#13;
        return resultObject;&#13;
    }&#13;
&#13;
    function validateRange(range) {&#13;
        if (ModelValidationUtils.isStringEmpty(range)) {&#13;
            return getCorrectObject({ start: 40, end: 80 });&#13;
        }&#13;
&#13;
        var values = range.split(';');&#13;
&#13;
        if (values.length !== 2) {&#13;
            return getErrorObject('R01');&#13;
        }&#13;
&#13;
        for (var i=0; i&lt;values.length; i++) {&#13;
            if (isInteger(values[i])) {&#13;
                values[i] = parseInt(values[i], 10);&#13;
            } else {&#13;
                return getErrorObject('R02');&#13;
            }&#13;
&#13;
            if (0 &gt; values[i] || values[i] &gt; 100) {&#13;
                return getErrorObject('R03');&#13;
            }&#13;
        }&#13;
&#13;
        if (values[0] &gt;= values[1]) {&#13;
            return getErrorObject('R04');&#13;
        }&#13;
&#13;
        return getCorrectObject({ start: values[0], end: values[1] });&#13;
    }&#13;
&#13;
    function validateColors(colors) {&#13;
        if (ModelValidationUtils.isStringEmpty(colors)) {&#13;
            return getCorrectObject({ above: "red", correct: "green", below: "yellow" });&#13;
        }&#13;
&#13;
        colors = colors.split(';');&#13;
&#13;
        if (colors.length !== 3) {&#13;
            return getErrorObject('C01');&#13;
        }&#13;
&#13;
        return getCorrectObject({ above: colors[0], correct: colors[1], below: colors[2] });&#13;
    }&#13;
&#13;
    function validateInterval(interval) {&#13;
        if (ModelValidationUtils.isStringEmpty(interval)) {&#13;
            return getCorrectObject(100);&#13;
        }&#13;
&#13;
        if (isInteger(interval)) {&#13;
            interval = parseInt(interval, 10);&#13;
        } else {&#13;
            return getErrorObject('I01');&#13;
        }&#13;
&#13;
        if (interval &lt; 0 || interval &gt; 2000) {&#13;
            return getErrorObject('I02');&#13;
        }&#13;
&#13;
        return getCorrectObject(interval);&#13;
    }&#13;
&#13;
    function validateInteger(val) {&#13;
        if (ModelValidationUtils.isStringEmpty(val)) {&#13;
            return getCorrectObject(0);&#13;
        }&#13;
&#13;
        if (isInteger(val)) {&#13;
            val = parseInt(val, 10);&#13;
        } else {&#13;
            return getErrorObject('CALC01');&#13;
        }&#13;
&#13;
        if (val &lt; 0) {&#13;
            return getErrorObject('CALC02');&#13;
        }&#13;
&#13;
        return getCorrectObject(val);&#13;
    }&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var validatedRange = validateRange(model.correctRange);&#13;
        if (validatedRange.errorCode) {&#13;
            return validatedRange;&#13;
        }&#13;
&#13;
        var graph = ModelValidationUtils.validateOption(presenter.GRAPH, model.graphType);&#13;
        var sensor = ModelValidationUtils.validateOption(presenter.SENSOR, model.sensor);&#13;
&#13;
        if ((graph === presenter.GRAPH['Circle in circle'] || graph === presenter.GRAPH['Four circles']) &amp;&amp; sensor !== presenter.SENSOR['All']) {&#13;
            return getErrorObject('G01');&#13;
        }&#13;
&#13;
        var validatedColors = validateColors(model.colors);&#13;
        if (validatedColors.errorCode) {&#13;
            return validatedColors;&#13;
        }&#13;
&#13;
        var validatedDataUpdateInterval = validateInterval(model.dataUpdateInterval);&#13;
        if (validatedDataUpdateInterval.errorCode) {&#13;
            return validatedDataUpdateInterval;&#13;
        }&#13;
&#13;
        var validatedCalcFromLastValues = validateInteger(model.calculateFromLastValues);&#13;
        if (validatedCalcFromLastValues.errorCode) {&#13;
            return validatedCalcFromLastValues;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
            isVisibleByDefault: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
            ID: model.ID,&#13;
            width: parseInt(model.Width, 10),&#13;
            height: parseInt(model.Height, 10),&#13;
&#13;
            isDisable: ModelValidationUtils.validateBoolean(model.isDisable),&#13;
            range: validatedRange.value,&#13;
            graphType: graph,&#13;
            sensor: sensor,&#13;
            colors: validatedColors.value,&#13;
            updateTime: validatedDataUpdateInterval.value,&#13;
            calculateFromLastValues: validatedCalcFromLastValues.value&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = controller.getEventBus();&#13;
        presenter.eventBus.addEventListener('PageLoaded', this);&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "PageLoaded") {&#13;
            for (var addon in presenter.addons) {&#13;
                if (presenter.addons.hasOwnProperty(addon)) {&#13;
                    hookToDrawingAreas(addon);&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.view = view;&#13;
        presenterLogic(view, model, false);&#13;
&#13;
        if (!presenter.configuration.isDisable) {&#13;
            presenter.record();&#13;
        }&#13;
&#13;
        presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved(ev) {&#13;
            presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
            if (ev.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    function presenterLogic(view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        presenter.data.$img = presenter.$view.find('img');&#13;
        presenter.data.$canvas = presenter.$view.find('canvas');&#13;
        presenter.data.context = presenter.data.$canvas[0].getContext('2d');&#13;
&#13;
        presenter.data.$canvas[0].width = presenter.configuration.width;&#13;
        presenter.data.$canvas[0].height = presenter.configuration.height;&#13;
&#13;
        presenter.data.isPreview = isPreview;&#13;
    }&#13;
&#13;
    presenter.destroy = function () {&#13;
        if (presenter.data.isIntervalOn) {&#13;
            clearInterval(presenter.data.intervalId);&#13;
            presenter.data.isIntervalOn = false;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenterLogic(view, model, true);&#13;
&#13;
        if (presenter.configuration.isValid) {&#13;
            presenter.displayCurrentData();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    function getRotateCoordinates(x, y, rad) {&#13;
        // Subtract midpoints, so that midpoint is translated to origin and add it in the end again&#13;
        return {&#13;
            x: round(x * Math.cos(rad) - y * Math.sin(rad), 2),&#13;
            y: round(x * Math.sin(rad) + y * Math.cos(rad), 2)&#13;
        }&#13;
    }&#13;
&#13;
    function generateHorizontalBar(above, correct, below) {&#13;
        function drawRec(ctx, x, y, w, h, color, percent) {&#13;
            if(percent &gt; 0){&#13;
                ctx.beginPath();&#13;
                ctx.lineWidth="1";&#13;
                ctx.strokeStyle=color;&#13;
                ctx.rect(x, y, w, h);&#13;
                ctx.fillStyle = color;&#13;
                ctx.fill();&#13;
                ctx.stroke();&#13;
            }&#13;
        }&#13;
&#13;
        function drawText(ctx, x, y, text) {&#13;
            if(text &gt; 0){&#13;
                ctx.font = "12px Calibri";&#13;
                ctx.textAlign = "center";&#13;
                ctx.fillStyle = "black";&#13;
                ctx.fillText(text + '%', x, y);&#13;
            }&#13;
        }&#13;
&#13;
        var moduleHeight = presenter.configuration.height;&#13;
&#13;
        var sum = above + correct + below;&#13;
&#13;
        var text = [];&#13;
        text[0] = Math.round((below / sum) * 100);&#13;
        text[1] = Math.round((correct / sum) * 100);&#13;
        text[2] = Math.round(100 - (text[0] + text[1]));&#13;
&#13;
        var widthA = Math.round(((text[0]/100)*presenter.configuration.width));&#13;
        var widthB = Math.round(((text[1]/100)*presenter.configuration.width));&#13;
        var widthC = Math.round(((text[2]/100)*presenter.configuration.width));&#13;
        var moduleWidth = widthA + widthB + widthC;&#13;
&#13;
        var xA = 0;&#13;
        var xB = widthA;&#13;
        var xC = widthA + widthB;&#13;
&#13;
        presenter.data.context.clearRect(0, 0, presenter.configuration.width, presenter.configuration.height);&#13;
&#13;
        drawRec(presenter.data.context, xA, Math.round(moduleHeight/4), widthA, Math.round(moduleHeight/2), presenter.configuration.colors.below, text[0]);&#13;
        drawRec(presenter.data.context, xB, Math.round(moduleHeight/4), widthB, Math.round(moduleHeight/2), presenter.configuration.colors.correct, text[1]);&#13;
        drawRec(presenter.data.context, xC, Math.round(moduleHeight/4), widthC, Math.round(moduleHeight/2), presenter.configuration.colors.above, text[2]);&#13;
&#13;
        var xTextA = xA + (widthA/2);&#13;
        var xTextB = xB + (widthB/2);&#13;
        var xTextC = xC + (widthC/2);&#13;
&#13;
        if(text[0] &gt; 0 &amp;&amp; xTextA &lt; 10){&#13;
            xTextA = 10;&#13;
        }&#13;
        if(text[2] &gt; 0 &amp;&amp; xTextC &gt; (moduleWidth-11)){&#13;
            xTextC = moduleWidth-11;&#13;
        }&#13;
        if(text[0] == 0 &amp;&amp; xTextB &lt; 10){&#13;
            xTextB = 10;&#13;
        }&#13;
        if(text[2] == 0 &amp;&amp; xTextB &gt; (moduleWidth-10)){&#13;
            xTextB = moduleWidth-10;&#13;
        }&#13;
        if(text[0] &gt; 0 &amp;&amp; xTextB &lt; (xTextA+19)){&#13;
            xTextB = xTextA+19;&#13;
        }else if(text[2] &gt; 0 &amp;&amp; xTextB &gt; (xTextC-20)){&#13;
            xTextB = xTextC-20;&#13;
        }else{} // 10, 19, 20.. - width of text&#13;
&#13;
        drawText(presenter.data.context, xTextA, Math.round(moduleHeight/4)-3, text[0]);&#13;
        drawText(presenter.data.context, xTextB, Math.round(moduleHeight/4)-3, text[1]);&#13;
        drawText(presenter.data.context, xTextC, Math.round(moduleHeight/4)-3, text[2]);&#13;
    }&#13;
&#13;
    function generatePieChart(above, correct, below) {&#13;
        function drawArc(ctx, x, y, r, start, end, color) {&#13;
            ctx.beginPath();&#13;
            ctx.moveTo(x, y);&#13;
            ctx.arc(x, y, r, start, end, false);&#13;
            ctx.closePath();&#13;
            ctx.fillStyle = color;&#13;
            ctx.fill();&#13;
        }&#13;
&#13;
        function drawText(ctx, x, y, r, start, end, text) {&#13;
            var halfAngle = (end - start) / 2;&#13;
            var coordinates = getRotateCoordinates(r / 2, 0, halfAngle + start);&#13;
&#13;
            ctx.font = "20px Calibri";&#13;
            ctx.textAlign = "center";&#13;
            ctx.fillStyle = "black";&#13;
            ctx.fillText(text + '%', coordinates.x + x, coordinates.y + y);&#13;
        }&#13;
&#13;
        var sum = above + correct + below;&#13;
        var centerX = Math.floor(presenter.configuration.width / 2);&#13;
        var centerY = Math.floor(presenter.configuration.height / 2);&#13;
        var radius = Math.min(presenter.configuration.width, presenter.configuration.height) / 2;&#13;
&#13;
        var sep = [];&#13;
        sep[0] = 0;&#13;
        sep[1] = (below / sum) * 2 * Math.PI;&#13;
        sep[2] = ((below + correct) / sum) * 2 * Math.PI;&#13;
        sep[3] = 2 * Math.PI;&#13;
&#13;
        var text = [];&#13;
        text[0] = round((below / sum) * 100, 2);&#13;
        text[1] = round((correct / sum) * 100, 2);&#13;
        text[2] = round(100 - (text[0] + text[1]), 2);&#13;
&#13;
        presenter.data.context.clearRect(0, 0, presenter.configuration.width, presenter.configuration.height);&#13;
&#13;
        drawArc(presenter.data.context, centerX, centerY, radius, sep[0], sep[1], presenter.configuration.colors.above);&#13;
        drawArc(presenter.data.context, centerX, centerY, radius, sep[1], sep[2], presenter.configuration.colors.correct);&#13;
        drawArc(presenter.data.context, centerX, centerY, radius, sep[2], sep[3], presenter.configuration.colors.below);&#13;
&#13;
        drawText(presenter.data.context, centerX, centerY, radius, sep[0], sep[1], text[0]);&#13;
        drawText(presenter.data.context, centerX, centerY, radius, sep[1], sep[2], text[1]);&#13;
        drawText(presenter.data.context, centerX, centerY, radius, sep[2], sep[3], text[2]);&#13;
    }&#13;
&#13;
    function drawCircle(ctx, x, y, r, color) {&#13;
        ctx.beginPath();&#13;
        ctx.arc(x, y, r, 0, 2 * Math.PI, false);&#13;
        ctx.fillStyle = color;&#13;
        ctx.fill();&#13;
        ctx.lineWidth = 1;&#13;
        ctx.strokeStyle = 'white';&#13;
        ctx.stroke();&#13;
    }&#13;
&#13;
    function generateFourCircles(aStatus, bStatus, cStatus, pStatus) {&#13;
        function getCircleData(_x, _y, _r, _c) { return { x: _x, y: _y, r: _r, color: _c }; }&#13;
&#13;
        var min = Math.min(presenter.configuration.width, presenter.configuration.height);&#13;
        var smallRadius = parseInt(min / 8, 10);&#13;
        var bigRadius = parseInt(min / 3, 10);&#13;
&#13;
        var offset = half(Math.abs(presenter.configuration.width - presenter.configuration.height));&#13;
&#13;
        var a, b, c, p;&#13;
&#13;
        var aColor = getColorFromStatus(aStatus);&#13;
        var bColor = getColorFromStatus(bStatus);&#13;
        var cColor = getColorFromStatus(cStatus);&#13;
        var pColor = getColorFromStatus(pStatus);&#13;
&#13;
        if (presenter.configuration.height &gt; presenter.configuration.width) {&#13;
            a = getCircleData(smallRadius, offset + smallRadius, smallRadius, aColor);&#13;
            b = getCircleData(min - smallRadius, offset + smallRadius, smallRadius, bColor);&#13;
            c = getCircleData(half(min), offset + min - smallRadius, smallRadius, cColor);&#13;
            p = getCircleData(half(min), offset + parseInt(min * 0.41, 10), bigRadius, pColor);&#13;
        } else {&#13;
            a = getCircleData(offset + smallRadius, smallRadius, smallRadius, aColor);&#13;
            b = getCircleData(offset + min - smallRadius, smallRadius, smallRadius, bColor);&#13;
            c = getCircleData(offset + half(min), min - smallRadius, smallRadius, cColor);&#13;
            p = getCircleData(offset + half(min), parseInt(min * 0.41, 10), bigRadius, pColor);&#13;
        }&#13;
&#13;
        drawCircle(presenter.data.context, a.x, a.y, a.r, a.color);&#13;
        drawCircle(presenter.data.context, b.x, b.y, b.r, b.color);&#13;
        drawCircle(presenter.data.context, c.x, c.y, c.r, c.color);&#13;
        drawCircle(presenter.data.context, p.x, p.y, p.r, p.color);&#13;
    }&#13;
&#13;
    function generateCircleInCircle(aStatus, bStatus, cStatus, pStatus) {&#13;
        var centerX = Math.floor(presenter.configuration.width / 2);&#13;
        var centerY = Math.floor(presenter.configuration.height / 2);&#13;
&#13;
        var radiusOuter = Math.min(presenter.configuration.width, presenter.configuration.height) / 2;&#13;
        var radiusInner = parseInt(radiusOuter / 2, 10);&#13;
&#13;
        var colorOuter = getColorFromStatus(Math.round((aStatus + bStatus + cStatus) / 3));&#13;
        var colorInner = getColorFromStatus(pStatus);&#13;
&#13;
        drawCircle(presenter.data.context, centerX, centerY, radiusOuter, colorOuter);&#13;
        drawCircle(presenter.data.context, centerX, centerY, radiusInner, colorInner);&#13;
    }&#13;
&#13;
    presenter.displayCurrentData = function() {&#13;
        var shouldUpdate = shouldGetDataFromSensors();&#13;
        if (shouldUpdate){&#13;
            var dataFromSensors = getCurrentDataFromSensor();&#13;
            updateSensorDataHistory(dataFromSensors);&#13;
        }&#13;
&#13;
        var data = presenter.getData();&#13;
        presenter.displayData(data);&#13;
    };&#13;
&#13;
    presenter.getData = function getData() {&#13;
        return presenter.data.isPreview ? {&#13;
            above: 1,&#13;
            correct: 1,&#13;
            below: 1,&#13;
            aStatus: 0,&#13;
            bStatus: 0,&#13;
            cStatus: 0,&#13;
            pStatus: 0&#13;
        } : prepareData();&#13;
    };&#13;
&#13;
    presenter.displayData = function (data) {&#13;
        switch (presenter.configuration.graphType) {&#13;
            case presenter.GRAPH['Pie chart']: generatePieChart(data.above, data.correct, data.below); break;&#13;
            case presenter.GRAPH['Four circles']: generateFourCircles(data.aStatus, data.bStatus, data.cStatus, data.pStatus); break;&#13;
            case presenter.GRAPH['Circle in circle']: generateCircleInCircle(data.aStatus, data.bStatus, data.cStatus, data.pStatus); break;&#13;
            case presenter.GRAPH['Horizontal Bar']: generateHorizontalBar(data.above, data.correct, data.below); break;&#13;
            default: break;&#13;
        }&#13;
&#13;
        // copy chart to img&#13;
        presenter.data.$img.attr("src", presenter.data.$canvas[0].toDataURL("image/png"));&#13;
    };&#13;
&#13;
    presenter.reset = function() {&#13;
        var addon;&#13;
        presenter.data.sensorsDataHistory = [];&#13;
        presenter.displayData(presenter.getData());&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
&#13;
        for (addon in presenter.addons) {&#13;
            if (presenter.addons.hasOwnProperty(addon)) {&#13;
                hookToDrawingAreas(addon);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.record = function() {&#13;
        if (presenter.configuration.isDisable) { return false; }&#13;
&#13;
        if (!presenter.data.isIntervalOn) {&#13;
            presenter.data.isIntervalOn = true;&#13;
            presenter.data.intervalId = setInterval(presenter.displayCurrentData, presenter.configuration.updateTime);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.pause = function() {&#13;
        if (presenter.configuration.isDisable) { return false; }&#13;
&#13;
        if (presenter.data.isIntervalOn) {&#13;
            clearInterval(presenter.data.intervalId);&#13;
            presenter.data.isIntervalOn = false;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.stop = function() {&#13;
        if (presenter.configuration.isDisable) { return false; }&#13;
&#13;
        if (presenter.data.isIntervalOn) {&#13;
            clearInterval(presenter.data.intervalId);&#13;
            presenter.data.isIntervalOn = false;&#13;
        }&#13;
        presenter.reset();&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        if (!presenter.configuration.isValid) { return false; }&#13;
&#13;
        Commands.dispatch({&#13;
            "reset": presenter.reset,&#13;
            "show": presenter.show,&#13;
            "hide": presenter.hide,&#13;
            "record": presenter.record,&#13;
            "stop": presenter.stop,&#13;
            "pause": presenter.pause&#13;
        }, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        presenter.pause();&#13;
&#13;
        return JSON.stringify({&#13;
            sensorData: presenter.data.sensorData,&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function(state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) { return; }&#13;
&#13;
        var parsedState = JSON.parse(state);&#13;
&#13;
        presenter.data.sensorData = parsedState.sensorData;&#13;
        presenter.configuration.isVisible = parsedState.isVisible;&#13;
&#13;
        presenter.record();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        presenter.pause();&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        presenter.record();&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>