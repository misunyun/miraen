<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Drawing" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Color" nameLabel="Drawing_property_color" type="string"/>
		<property name="Thickness" nameLabel="Drawing_property_thickness" type="string"/>
		<property name="Border" nameLabel="Drawing_property_border" type="string"/>
		<property name="Opacity" nameLabel="Drawing_property_opacity" type="string"/>
		<property name="Font" nameLabel="Drawing_property_font" type="string"/>
		<!-- <property name='Whiteboard mode' nameLabel="Drawing_property_whiteboard_mode" type='boolean'/> -->
	</model>
<css>.drawing .tmp_canvas {&#13;
    position: absolute;&#13;
    left: 0; right: 0;&#13;
    bottom: 0; top: 0;&#13;
&#13;
    cursor: crosshair;&#13;
&#13;
    -ms-touch-action: none;&#13;
    touch-action: none;&#13;
}&#13;
&#13;
.drawing .tmp_canvas:active {&#13;
    cursor: crosshair;&#13;
}&#13;
</css><view>&lt;div class="drawing"&gt;&lt;/div&gt;&#13;
</view><preview>&lt;div class="drawing"&gt;&lt;/div&gt;&#13;
</preview><presenter>function AddonDrawing_create() {&#13;
&#13;
    var presenter = function() {};&#13;
&#13;
    const ModeEnum = {&#13;
        pencil: "pencil",&#13;
        eraser: "eraser",&#13;
        imageEdition: "imageEdition",&#13;
        textEdition: "textEdition",&#13;
    };&#13;
&#13;
    const AnchorEnum = {&#13;
        topLeft: 0,&#13;
        topRight: 1,&#13;
        bottomLeft: 2,&#13;
        bottomRight: 3,&#13;
    };&#13;
&#13;
    presenter.imageInputElement = null;&#13;
&#13;
    presenter.$textWrapper = null;&#13;
&#13;
    function setDefaultAddonMode() {&#13;
        setAddonMode(ModeEnum.pencil)&#13;
    }&#13;
&#13;
    function setAddonMode(addonMode) {&#13;
        if (isOnTextEditionMode()) {&#13;
            presenter.closeTextFieldPopup();&#13;
        }&#13;
        presenter.configuration.addonMode = addonMode;&#13;
    }&#13;
&#13;
    function isOnPencilMode() {&#13;
        return presenter.configuration.addonMode === ModeEnum.pencil;&#13;
    }&#13;
&#13;
    function isOnEraserMode() {&#13;
        return presenter.configuration.addonMode === ModeEnum.eraser;&#13;
    }&#13;
&#13;
    function isOnImageEditionMode() {&#13;
        return presenter.configuration.addonMode === ModeEnum.imageEdition;&#13;
    }&#13;
&#13;
    function isOnTextEditionMode() {&#13;
        return presenter.configuration.addonMode === ModeEnum.textEdition;&#13;
    }&#13;
&#13;
    // work-around for double line in android browser&#13;
    function setOverflowWorkAround(turnOn) {&#13;
&#13;
        if (!MobileUtils.isAndroidWebBrowser(window.navigator.userAgent)) { return false; }&#13;
&#13;
        var android_ver = MobileUtils.getAndroidVersion(window.navigator.userAgent);&#13;
        if (["4.1.1", "4.1.2", "4.2.2", "4.3", "4.4.2"].indexOf(android_ver) !== -1) {&#13;
&#13;
            presenter.$view.parents("*").each(function() {&#13;
                var overflow = null;&#13;
                if (turnOn) {&#13;
                    $(this).attr("data-overflow", $(this).css("overflow"));&#13;
                    $(this).css("overflow", "visible");&#13;
                } else {&#13;
                    overflow = $(this).attr("data-overflow");&#13;
                    if (overflow !== "") {&#13;
                        $(this).css("overflow", overflow);&#13;
                    }&#13;
                    $(this).removeAttr("data-overflow");&#13;
                }&#13;
            });&#13;
&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    presenter.points = [];&#13;
    presenter.mouse = {x: 0, y: 0};&#13;
    presenter.isStarted = false;&#13;
&#13;
    presenter.addedImage = {};&#13;
    presenter.draggingAnchor = {&#13;
        x: 0,&#13;
        y: 0&#13;
    };&#13;
    presenter.draggingImage = false;&#13;
    var pi2 = Math.PI * 2;&#13;
    var resizerRadius = 8;&#13;
    var rr = resizerRadius * resizerRadius;&#13;
&#13;
    function getZoom() {&#13;
        var val = $('#_icplayer').css('zoom');&#13;
        if (val == "normal" || val == "") { // IE 11&#13;
            val = 1;&#13;
        }&#13;
&#13;
        val = parseInt(val, 10);&#13;
        if (val == NaN || val == undefined) {&#13;
            val = 1;&#13;
        }&#13;
        return val;&#13;
    }&#13;
&#13;
    function getScale() {&#13;
        var $content = $("#content"); // the div transform css is attached to&#13;
		if($content.size()&gt;0){&#13;
            var contentElem = $content[0];&#13;
            var scaleX = contentElem.getBoundingClientRect().width / contentElem.offsetWidth;&#13;
            var scaleY = contentElem.getBoundingClientRect().height / contentElem.offsetHeight;&#13;
            return {X:scaleX, Y:scaleY};&#13;
		};&#13;
		return {X:1.0, Y:1.0};&#13;
    }&#13;
&#13;
    presenter.hexToRGBA = function(hex, opacity) {&#13;
        hex = hex.replace('#', '');&#13;
        var r = parseInt(hex.substring(0,2), 16);&#13;
        var g = parseInt(hex.substring(2,4), 16);&#13;
        var b = parseInt(hex.substring(4,6), 16);&#13;
&#13;
        return 'rgba(' + r + ',' + g + ',' + b + ',' + opacity + ')';&#13;
    };&#13;
&#13;
    presenter.colourNameToHex = function(color) {&#13;
&#13;
        var colors = {&#13;
            "aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff","beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887","cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff","darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f","darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1","darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff","firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff","gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f","honeydew":"#f0fff0","hotpink":"#ff69b4","indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c","lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2","lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de","lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6","magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee","mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5","navajowhite":"#ffdead","navy":"#000080","oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6","palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080","red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1","saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4","tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0","violet":"#ee82ee","wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5","yellow":"#ffff00","yellowgreen":"#9acd32"&#13;
        };&#13;
&#13;
        if (typeof colors[color.toLowerCase()] !== 'undefined') {&#13;
            return colors[color.toLowerCase()];&#13;
        }&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.onMobilePaint = function(e) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
        var tmp_canvas;&#13;
        if (isOnPencilMode()) {&#13;
            tmp_canvas = presenter.configuration.tmp_canvas;&#13;
        } else {&#13;
            tmp_canvas = presenter.configuration.canvas;&#13;
        }&#13;
&#13;
        var x = e.targetTouches[0].pageX - $(tmp_canvas).offset().left;&#13;
        var y = e.targetTouches[0].pageY - $(tmp_canvas).offset().top;&#13;
&#13;
        if (presenter.zoom !== 1) {&#13;
            x = x * (1 / presenter.zoom);&#13;
            y = y * (1 / presenter.zoom);&#13;
        }&#13;
&#13;
        var scale = getScale();&#13;
        if(scale.X!==1.0 || scale.Y!==1.0){&#13;
            x = x/scale.X;&#13;
            y = y/scale.Y;&#13;
        }&#13;
&#13;
        presenter.mouse.x = x;&#13;
        presenter.mouse.y = y;&#13;
        presenter.onPaint(e);&#13;
    };&#13;
&#13;
    presenter.onMobileImageEdition = function(e) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
        var tmp_canvas = presenter.configuration.tmp_canvas;&#13;
&#13;
        var x = e.targetTouches[0].pageX - $(tmp_canvas).offset().left;&#13;
        var y = e.targetTouches[0].pageY - $(tmp_canvas).offset().top;&#13;
&#13;
        if (presenter.zoom !== 1) {&#13;
            x = x * (1 / presenter.zoom);&#13;
            y = y * (1 / presenter.zoom);&#13;
        }&#13;
&#13;
        var scale = getScale();&#13;
        if(scale.X!==1.0 || scale.Y!==1.0){&#13;
            x = x/scale.X;&#13;
            y = y/scale.Y;&#13;
        }&#13;
&#13;
        presenter.mouse.x = x;&#13;
        presenter.mouse.y = y;&#13;
        presenter.onImageEdition(e);&#13;
    };&#13;
&#13;
    function anchorHitTest(x, y, image) {&#13;
&#13;
        var dx, dy;&#13;
    &#13;
        // top-left&#13;
        dx = x - image.left;&#13;
        dy = y - image.top;&#13;
        if (dx * dx + dy * dy &lt;= rr) {&#13;
            return AnchorEnum.topLeft;&#13;
        }&#13;
        // top-right&#13;
        dx = x - (image.left + image.width);&#13;
        dy = y - image.top;&#13;
        if (dx * dx + dy * dy &lt;= rr) {&#13;
            return AnchorEnum.topRight;&#13;
        }&#13;
        // bottom-right&#13;
        dx = x - (image.left + image.width);&#13;
        dy = y - (image.top + image.height);&#13;
        if (dx * dx + dy * dy &lt;= rr) {&#13;
            return AnchorEnum.bottomRight;&#13;
        }&#13;
        // bottom-left&#13;
        dx = x - image.left;&#13;
        dy = y - (image.top + image.height);&#13;
        if (dx * dx + dy * dy &lt;= rr) {&#13;
            return AnchorEnum.bottomLeft;&#13;
        }&#13;
        return (-1);&#13;
    }&#13;
&#13;
    function hitImage(x, y, image) {&#13;
        return (x &gt; image.left &amp;&amp; x &lt; image.left + image.width &amp;&amp; y &gt; image.top &amp;&amp; y &lt; image.top + image.height);&#13;
    }&#13;
&#13;
    function drawDragAnchor(x, y) {&#13;
&#13;
        presenter.configuration.tmp_ctx.beginPath();&#13;
        presenter.configuration.tmp_ctx.arc(x, y, resizerRadius, 0, pi2, false);&#13;
        presenter.configuration.tmp_ctx.closePath();&#13;
        presenter.configuration.tmp_ctx.fill();&#13;
    }&#13;
&#13;
    presenter.drawImage = function (tmp_ctx, tmp_canvas, withAnchors, withBorders, image) {&#13;
        // clear the canvas&#13;
        tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
        // draw image&#13;
        tmp_ctx.drawImage(image.image, 0, 0, image.originalWidth, image.originalHeight, image.left, image.top, image.width, image.height);&#13;
        &#13;
        // optionally draw the draggable anchors&#13;
        if (withAnchors) {&#13;
            drawDragAnchor(image.left, image.top);&#13;
            drawDragAnchor(image.left + image.width, image.top);&#13;
            drawDragAnchor(image.left + image.width, image.top + image.height);&#13;
            drawDragAnchor(image.left, image.top + image.height);&#13;
        }&#13;
&#13;
        // optionally draw the connecting anchor lines&#13;
        if (withBorders) {&#13;
            tmp_ctx.beginPath();&#13;
            tmp_ctx.moveTo(image.left, image.top);&#13;
            tmp_ctx.lineTo(image.left + image.width, image.top);&#13;
            tmp_ctx.lineTo(image.left + image.width, image.top + image.height);&#13;
            tmp_ctx.lineTo(image.left, image.top + image.height);&#13;
            tmp_ctx.closePath();&#13;
            tmp_ctx.stroke();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.addImage = function (img) {&#13;
        presenter.setEraserOff();&#13;
        setAddonMode(ModeEnum.imageEdition);&#13;
        var tmp_canvas = presenter.configuration.tmp_canvas;&#13;
        var tmp_ctx = presenter.configuration.tmp_ctx;&#13;
        var image = {};&#13;
        var widthRatio = 1;&#13;
        var heightRatio = 1;&#13;
        if (img.width &gt; tmp_canvas.width) {&#13;
            widthRatio = tmp_canvas.width / img.width;&#13;
            heightRatio = widthRatio;&#13;
        }&#13;
        if (img.height &gt; tmp_canvas.height){&#13;
            var tempHeightRatio = tmp_canvas.height / img.height;&#13;
            if (Math.fround(tempHeightRatio) &lt; Math.fround(heightRatio))&#13;
            {&#13;
                widthRatio = tempHeightRatio;&#13;
                heightRatio = tempHeightRatio;&#13;
            }&#13;
        }&#13;
&#13;
        image.width = img.width * widthRatio;&#13;
        image.originalWidth = img.width;&#13;
        image.height = img.height * heightRatio;&#13;
        image.originalHeight = img.height;&#13;
        image.left = tmp_canvas.width / 2 - image.width / 2;&#13;
        image.top = tmp_canvas.height / 2 - image.height / 2;&#13;
        image.image = img;&#13;
        image.showUpMoment = presenter.points.length;&#13;
        presenter.addedImage = image;&#13;
        &#13;
        // draw for first time&#13;
        tmp_ctx.drawImage(image.image, 0, 0, image.originalWidth, image.originalHeight, image.left, image.top, image.width, image.height);&#13;
&#13;
        drawDragAnchor(image.left, image.top);&#13;
        drawDragAnchor(image.left + image.width, image.top);&#13;
        drawDragAnchor(image.left + image.width, image.top + image.height);&#13;
        drawDragAnchor(image.left, image.top + image.height);&#13;
    }&#13;
&#13;
    presenter.embedText = function(textArray, x, y, lineHeight) {&#13;
        if (presenter.configuration.font) presenter.configuration.tmp_ctx.font = presenter.configuration.font;&#13;
        presenter.configuration.tmp_ctx.clearRect(0, 0, presenter.configuration.tmp_canvas.width, presenter.configuration.tmp_canvas.height);&#13;
        presenter.configuration.tmp_ctx.fillStyle = presenter.configuration.color;&#13;
        for(var i = 0; i &lt; textArray.length; i++) {&#13;
            presenter.configuration.tmp_ctx.fillText(textArray[i], x, y + (i+1) * lineHeight);&#13;
        }&#13;
        presenter.configuration.context.drawImage(presenter.configuration.tmp_canvas, 0, 0);&#13;
        presenter.configuration.tmp_ctx.clearRect(0, 0, presenter.configuration.tmp_canvas.width, presenter.configuration.tmp_canvas.height);&#13;
    }&#13;
&#13;
    presenter.onPaint = function(e) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
        var tmp_canvas, tmp_ctx;&#13;
&#13;
        if (isOnPencilMode()) {&#13;
            tmp_canvas = presenter.configuration.tmp_canvas;&#13;
            tmp_ctx = presenter.configuration.tmp_ctx;&#13;
            tmp_ctx.globalAlpha = presenter.configuration.opacity;&#13;
        } else if (isOnEraserMode()) {&#13;
            tmp_canvas = presenter.configuration.canvas;&#13;
            tmp_ctx = presenter.configuration.context;&#13;
        }&#13;
&#13;
        tmp_ctx.lineWidth = presenter.configuration.thickness;&#13;
        tmp_ctx.lineJoin = 'round';&#13;
        tmp_ctx.lineCap = 'round';&#13;
        tmp_ctx.strokeStyle = presenter.configuration.color;&#13;
        tmp_ctx.fillStyle = presenter.configuration.color;&#13;
&#13;
        presenter.points.push({x: presenter.mouse.x, y: presenter.mouse.y});&#13;
        if (presenter.points.length &lt; 3) {&#13;
            var b = presenter.points[0];&#13;
            tmp_ctx.beginPath();&#13;
            tmp_ctx.arc(b.x, b.y, tmp_ctx.lineWidth / 2, 0, Math.PI * 2, !0);&#13;
            tmp_ctx.fill();&#13;
            tmp_ctx.closePath();&#13;
        } else {&#13;
            tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
&#13;
            tmp_ctx.beginPath();&#13;
            tmp_ctx.moveTo(presenter.points[0].x, presenter.points[0].y);&#13;
            for (var i = 1; i &lt; presenter.points.length - 2; i++) {&#13;
                var c = (presenter.points[i].x + presenter.points[i + 1].x) / 2;&#13;
                var d = (presenter.points[i].y + presenter.points[i + 1].y) / 2;&#13;
&#13;
                tmp_ctx.quadraticCurveTo(presenter.points[i].x, presenter.points[i].y, c, d);&#13;
            }&#13;
&#13;
            tmp_ctx.quadraticCurveTo(&#13;
                presenter.points[i].x,&#13;
                presenter.points[i].y,&#13;
                presenter.points[i + 1].x,&#13;
                presenter.points[i + 1].y&#13;
            );&#13;
            tmp_ctx.stroke();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onImageEdition = function(e) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
        var tmp_canvas, tmp_ctx;&#13;
&#13;
        tmp_canvas = presenter.configuration.tmp_canvas;&#13;
        tmp_ctx = presenter.configuration.tmp_ctx;&#13;
        tmp_ctx.globalAlpha = presenter.configuration.opacity;&#13;
        presenter.points.push({x: presenter.mouse.x, y: presenter.mouse.y});&#13;
        if (presenter.points.length &lt; 4) {&#13;
            presenter.draggingAnchor = anchorHitTest(presenter.points[0].x, presenter.points[0].y, presenter.addedImage);&#13;
            presenter.draggingImage = presenter.draggingAnchor &lt; 0 &amp;&amp; hitImage(presenter.points[0].x, presenter.points[0].y, presenter.addedImage);&#13;
            if( presenter.draggingAnchor == -1 &amp;&amp; !presenter.draggingImage){&#13;
                presenter.finishEditImageMode(tmp_ctx, tmp_canvas, false);&#13;
            }&#13;
        } else {&#13;
            if (presenter.draggingAnchor &gt; -1) {&#13;
                mouseX = presenter.points[presenter.points.length - 1].x;&#13;
                mouseY = presenter.points[presenter.points.length - 1].y;&#13;
                switch (presenter.draggingAnchor) {                    &#13;
                    case AnchorEnum.topLeft:&#13;
                        //top-left&#13;
                        presenter.addedImage.width = (presenter.addedImage.left + presenter.addedImage.width) - mouseX;&#13;
                        presenter.addedImage.height = (presenter.addedImage.top + presenter.addedImage.height) - mouseY;&#13;
                        presenter.addedImage.left = mouseX;&#13;
                        presenter.addedImage.top = mouseY;&#13;
                        break;&#13;
                    case AnchorEnum.topRight:&#13;
                        //top-right&#13;
                        presenter.addedImage.width = mouseX - presenter.addedImage.left;&#13;
                        presenter.addedImage.height = (presenter.addedImage.top + presenter.addedImage.height) - mouseY;&#13;
                        presenter.addedImage.top = mouseY;&#13;
                        break;&#13;
                    case AnchorEnum.bottomRight:&#13;
                        //bottom-right&#13;
                        presenter.addedImage.width = mouseX - presenter.addedImage.left;&#13;
                        presenter.addedImage.height = mouseY - presenter.addedImage.top;&#13;
                        break;&#13;
                    case AnchorEnum.bottomLeft:&#13;
                        //bottom-left&#13;
                        presenter.addedImage.width = (presenter.addedImage.left + presenter.addedImage.width) - mouseX;&#13;
                        presenter.addedImage.height = mouseY - presenter.addedImage.top;;&#13;
                        presenter.addedImage.left = mouseX;&#13;
                        break;&#13;
                }&#13;
&#13;
                if(presenter.addedImage.width&lt;25){presenter.addedImage.width=25;}&#13;
                if(presenter.addedImage.height&lt;25){presenter.addedImage.height=25;}&#13;
                &#13;
                presenter.drawImage(tmp_ctx, tmp_canvas, true, true, presenter.addedImage);&#13;
&#13;
            } else if (presenter.draggingImage) {&#13;
                var dx = presenter.points[presenter.points.length - 1].x - presenter.points[presenter.points.length - 2].x;&#13;
                var dy = presenter.points[presenter.points.length - 1].y - presenter.points[presenter.points.length - 2].y;&#13;
                presenter.addedImage.left += dx;&#13;
                presenter.addedImage.top += dy;&#13;
                // draw the image&#13;
                presenter.drawImage(tmp_ctx, tmp_canvas, true, true, presenter.addedImage);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.removeImage = function (e) {&#13;
        var tmp_canvas, tmp_ctx;&#13;
        tmp_canvas = presenter.configuration.tmp_canvas;&#13;
        tmp_ctx = presenter.configuration.tmp_ctx;&#13;
        &#13;
        const key = e.key;&#13;
        if (key === "Delete" &amp;&amp; presenter.configuration.addonMode === ModeEnum.imageEdition) {&#13;
            presenter.finishEditImageMode(tmp_ctx, tmp_canvas, true);&#13;
        }&#13;
        e.stopPropagation();&#13;
    }&#13;
&#13;
    presenter.turnOnEventListeners = function() {&#13;
        var tmp_canvas = presenter.configuration.tmp_canvas,&#13;
            tmp_ctx = presenter.configuration.tmp_ctx,&#13;
            ctx = presenter.configuration.context;&#13;
&#13;
        // TOUCH&#13;
        if (MobileUtils.isEventSupported('touchstart')) {&#13;
            connectTouchEvents(tmp_canvas, tmp_ctx, ctx);&#13;
        }&#13;
&#13;
        // MOUSE&#13;
        connectMouseEvents(tmp_canvas, tmp_ctx, ctx);&#13;
&#13;
        tmp_canvas.addEventListener('click', function(e) {&#13;
            e.stopPropagation();&#13;
        }, false);&#13;
        &#13;
        // KEYBOARD DELETE EDIT IMAGE &#13;
        document.addEventListener('keydown', presenter.removeImage, false);&#13;
    };&#13;
&#13;
    presenter.onMobilePaintWithoutPropagation = function (e) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
        presenter.onMobilePaint(e);&#13;
    };&#13;
&#13;
    function addImageToCanvasIfOnImageEditionMode(){&#13;
        if (isOnImageEditionMode()){&#13;
            presenter.finishEditImageMode(presenter.configuration.tmp_ctx, presenter.configuration.tmp_canvas, false);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.finishEditImageMode = function (tmp_ctx, tmp_canvas, rejectAdding) {&#13;
        setDefaultAddonMode();&#13;
        setOverflowWorkAround(false);&#13;
        tmp_canvas.removeEventListener('mousemove', presenter.onImageEdition, false);&#13;
        tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
        if(!rejectAdding){&#13;
            presenter.drawImage(tmp_ctx, tmp_canvas, false, false, presenter.addedImage);&#13;
            presenter.configuration.context.drawImage(tmp_canvas, 0, 0);&#13;
        }&#13;
        tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
        presenter.points = [];&#13;
    }&#13;
&#13;
    function connectTouchEvents(tmp_canvas, tmp_ctx, ctx) {&#13;
        tmp_canvas.addEventListener('touchstart', function (e) {&#13;
            setOverflowWorkAround(true);&#13;
&#13;
            if (isOnEraserMode()) {&#13;
                presenter.configuration.context.globalCompositeOperation = "destination-out";&#13;
            }&#13;
&#13;
            presenter.zoom = getZoom();&#13;
            presenter.isStarted = true;&#13;
            if (isOnPencilMode() || isOnEraserMode()) {&#13;
                presenter.onMobilePaint(e);&#13;
                tmp_canvas.addEventListener('touchmove', presenter.onMobilePaintWithoutPropagation);&#13;
            } else if (isOnImageEditionMode()) {&#13;
                presenter.onMobileImageEdition(e);&#13;
                tmp_canvas.addEventListener('touchmove', presenter.onMobileImageEdition);&#13;
            } else if (isOnTextEditionMode()) {&#13;
                presenter.finishEditTextMode();&#13;
            }&#13;
        }, false);&#13;
&#13;
        tmp_canvas.addEventListener('touchend', function (e) {&#13;
            setOverflowWorkAround(false);&#13;
&#13;
            tmp_canvas.removeEventListener('touchmove', presenter.onMobilePaintWithoutPropagation, false);&#13;
            tmp_canvas.removeEventListener('touchmove', presenter.onMobileImageEdition, false);&#13;
            &#13;
            if (isOnPencilMode() || isOnEraserMode()) {&#13;
                ctx.drawImage(tmp_canvas, 0, 0);&#13;
                tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
            } else if (isOnImageEditionMode()) {&#13;
                tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
                presenter.drawImage(tmp_ctx, tmp_canvas, true, false, presenter.addedImage);&#13;
            }&#13;
            presenter.points = [];&#13;
        }, false);&#13;
    }&#13;
&#13;
    function connectMouseEvents(tmp_canvas, tmp_ctx, ctx) {&#13;
        tmp_canvas.addEventListener('mousemove', function (e) {&#13;
            if (isOnTextEditionMode()) return;&#13;
            e.stopPropagation();&#13;
&#13;
            var x = typeof e.offsetX !== 'undefined' ? e.offsetX : e.layerX;&#13;
            var y = typeof e.offsetY !== 'undefined' ? e.offsetY : e.layerY;&#13;
&#13;
            if (presenter.zoom !== 1) {&#13;
                x = x * (1 / parseInt(presenter.zoom, 10));&#13;
                y = y * (1 / parseInt(presenter.zoom, 10));&#13;
            }&#13;
&#13;
            presenter.mouse.x = x;&#13;
            presenter.mouse.y = y;&#13;
&#13;
            presenter.configuration.tmp_canvas.style.cursor = 'crosshair';&#13;
            if (isOnImageEditionMode() &amp;&amp; presenter.addedImage.image !== undefined) {&#13;
                if (hitImage(x, y, presenter.addedImage)) {&#13;
                    presenter.configuration.tmp_canvas.style.cursor = 'pointer';&#13;
                } else {&#13;
                    var anchorIndex = anchorHitTest(x, y, presenter.addedImage);&#13;
                    if (anchorIndex == 0 || anchorIndex == 2) {&#13;
                        presenter.configuration.tmp_canvas.style.cursor = 'nwse-resize';&#13;
                    } else if (anchorIndex == 1 || anchorIndex == 3) {&#13;
                        presenter.configuration.tmp_canvas.style.cursor = 'nesw-resize';&#13;
                    }&#13;
&#13;
                }&#13;
            }&#13;
&#13;
        }, false);&#13;
        $(tmp_canvas).on('mouseleave', function (e) {&#13;
            setOverflowWorkAround(false);&#13;
            if (isOnPencilMode() || isOnEraserMode()) {&#13;
                tmp_canvas.removeEventListener('mousemove', presenter.onPaint, false);&#13;
                ctx.drawImage(tmp_canvas, 0, 0);&#13;
                tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
            } else if (isOnImageEditionMode()) {&#13;
                tmp_canvas.removeEventListener('mousemove', presenter.onImageEdition, false);&#13;
                tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
                presenter.drawImage(tmp_ctx, tmp_canvas, true, false, presenter.addedImage);&#13;
            }&#13;
            presenter.points = [];&#13;
        });&#13;
        tmp_canvas.addEventListener('mousedown', function (e) {&#13;
            setOverflowWorkAround(true);&#13;
&#13;
            if (isOnEraserMode()) {&#13;
                presenter.configuration.context.globalCompositeOperation = "destination-out";&#13;
            }&#13;
&#13;
            presenter.zoom = getZoom();&#13;
            if (presenter.zoom == "" || presenter.zoom == undefined) {&#13;
                presenter.zoom = 1;&#13;
            }&#13;
&#13;
            if (isOnPencilMode() || isOnEraserMode()) {&#13;
                tmp_canvas.addEventListener('mousemove', presenter.onPaint, false);&#13;
            } else if (isOnImageEditionMode()) {&#13;
                tmp_canvas.addEventListener('mousemove', presenter.onImageEdition, false);&#13;
            }&#13;
            presenter.isStarted = true;&#13;
&#13;
            var x = typeof e.offsetX !== 'undefined' ? e.offsetX : e.layerX;&#13;
            var y = typeof e.offsetY !== 'undefined' ? e.offsetY : e.layerY;&#13;
&#13;
            if (presenter.zoom !== 1) {&#13;
                x = x * (1 / presenter.zoom);&#13;
                y = y * (1 / presenter.zoom);&#13;
            }&#13;
&#13;
            presenter.points.push({x: x, y: y});&#13;
&#13;
            if (isOnPencilMode() || isOnEraserMode()) {&#13;
                presenter.onPaint(e);&#13;
            } else if (isOnImageEditionMode()) {&#13;
                presenter.onImageEdition(e);&#13;
            } else if (isOnTextEditionMode()) {&#13;
                presenter.finishEditTextMode();&#13;
            }&#13;
        }, false);&#13;
&#13;
        tmp_canvas.addEventListener('mouseup', function (e) {&#13;
            setOverflowWorkAround(false);&#13;
            if (isOnPencilMode() || isOnEraserMode()) {&#13;
                tmp_canvas.removeEventListener('mousemove', presenter.onPaint, false);&#13;
                ctx.drawImage(tmp_canvas, 0, 0);&#13;
                tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
            } else if (isOnImageEditionMode()) {&#13;
                tmp_canvas.removeEventListener('mousemove', presenter.onImageEdition, false);&#13;
                tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
                presenter.drawImage(tmp_ctx, tmp_canvas, true, false, presenter.addedImage);&#13;
            }&#13;
            presenter.points = [];&#13;
        }, false);&#13;
    }&#13;
&#13;
    function getErrorObject(ec) { return { isValid: false, errorCode: ec }; }&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        C01: 'Property color cannot be empty',&#13;
        C02: 'Property color has wrong length in hex format, should be # and 6 digits [0 - F]',&#13;
        C03: 'Property color has wrong color name',&#13;
&#13;
        T01: 'Property thickness cannot be empty',&#13;
        T02: 'Property thickness cannot be smaller than 1',&#13;
        T03: 'Property thickness cannot be bigger than 40',&#13;
&#13;
        B01: 'Property border cannot be empty',&#13;
        B02: 'Property border cannot be smaller than 0',&#13;
        B03: 'Property border cannot be bigger than 5',&#13;
&#13;
        O01: 'Property opacity cannot be empty',&#13;
        O02: 'Property opacity cannot be smaller than 0',&#13;
        O03: 'Property opacity cannot be bigger than 1'&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    function resizeCanvas() {&#13;
        var con = presenter.$view.find('.drawing').parent(),&#13;
            canvas = presenter.configuration.canvas[0];&#13;
&#13;
        canvas.width = con.width();&#13;
        canvas.height = con.height();&#13;
    }&#13;
&#13;
    presenter.handleImage = function (e) {&#13;
        var reader = new FileReader();&#13;
        reader.onload = function(event){&#13;
            var img = new Image();&#13;
            img.onload = function(){&#13;
                presenter.addImage(img);&#13;
            }&#13;
            img.src = event.target.result;&#13;
        }&#13;
        if(e.target.files[0]){&#13;
            reader.readAsDataURL(e.target.files[0]);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function(model) {&#13;
        var upgradedModel = presenter.upgradeFont(model);&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.upgradeFont = function (model) {&#13;
            var upgradedModel = {};&#13;
            $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
            if (upgradedModel['Font'] === undefined) {&#13;
                upgradedModel['Font'] = '';&#13;
            }&#13;
&#13;
            return upgradedModel;&#13;
        };&#13;
&#13;
    presenter.presenterLogic = function(view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        presenter.$pagePanel = presenter.$view.parent().parent('.ic_page_panel');&#13;
&#13;
        var upgradedModel = presenter.upgradeModel(model);&#13;
        presenter.model = upgradedModel;&#13;
&#13;
        presenter.configuration = presenter.validateModel(upgradedModel);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.configuration.font.length === 0) presenter.configuration.font = "12px Arial";&#13;
&#13;
        setDefaultAddonMode()&#13;
        presenter.configuration.pencilThickness = presenter.configuration.thickness;&#13;
        presenter.opacityByDefault = presenter.configuration.opacity;&#13;
&#13;
        var $drawing = presenter.$view.find('.drawing')&#13;
        var $canvas = createCanvas()&#13;
        $drawing.append($canvas)&#13;
&#13;
        var border = presenter.configuration.border;&#13;
&#13;
        presenter.configuration.canvas = presenter.$view.find('canvas');&#13;
        presenter.configuration.context = presenter.configuration.canvas[0].getContext("2d");&#13;
&#13;
        $(presenter.$view.find('.drawing')[0]).css('opacity', presenter.configuration.opacity);&#13;
        resizeCanvas();&#13;
&#13;
        presenter.configuration.tmp_canvas = document.createElement('canvas');&#13;
        presenter.configuration.tmp_ctx = presenter.configuration.tmp_canvas.getContext('2d');&#13;
        $(presenter.configuration.tmp_canvas).addClass('tmp_canvas');&#13;
        presenter.configuration.tmp_canvas.width = presenter.configuration.canvas.width();&#13;
        presenter.configuration.tmp_canvas.height = presenter.configuration.canvas.height();&#13;
&#13;
        presenter.$view.find('.drawing')[0].appendChild(presenter.configuration.tmp_canvas);&#13;
&#13;
        if (presenter.configuration.border !== 0) {&#13;
            presenter.$view.find('canvas').css('border', border + 'px solid black');&#13;
        }&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.turnOnEventListeners();&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault || isPreview);&#13;
&#13;
        presenter.zoom = getZoom();&#13;
        if (presenter.zoom == "" || presenter.zoom == undefined) {&#13;
            presenter.zoom = 1;&#13;
        }&#13;
    };&#13;
&#13;
    function createCanvas() {&#13;
        var $canvas = $(document.createElement('canvas'));&#13;
        $canvas.addClass('canvas');&#13;
        $canvas.html('element canvas is not supported by your browser');&#13;
        return $canvas&#13;
    }&#13;
&#13;
    presenter.setColor = function(color) {&#13;
        if (!isOnTextEditionMode()) {&#13;
            setDefaultAddonMode();&#13;
        }&#13;
        if (typeof color === "object") color = color[0];&#13;
        presenter.configuration.thickness = presenter.configuration.pencilThickness;&#13;
        presenter.configuration.context.globalCompositeOperation = "source-over";&#13;
        presenter.configuration.color = presenter.parseColor(color).color;&#13;
        presenter.beforeEraserColor = presenter.configuration.color;&#13;
        if (presenter.$textWrapper) {&#13;
            presenter.$textWrapper.find('textarea').css('color', presenter.configuration.color);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setThickness = function(thickness) {&#13;
        if (typeof thickness === "object") thickness = thickness[0];&#13;
&#13;
        presenter.configuration.pencilThickness = presenter.parseThickness(thickness).thickness;&#13;
        if (isOnPencilMode()) {&#13;
            presenter.configuration.thickness = presenter.configuration.pencilThickness;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setOpacity = function(opacity) {&#13;
        if (typeof opacity === "object") opacity = opacity[0];&#13;
&#13;
        presenter.configuration.opacity = presenter.parseOpacity(opacity).opacity;&#13;
    };&#13;
&#13;
    presenter.setFont = function(font) {&#13;
        if (font !== undefined) {&#13;
            presenter.configuration.font = font;&#13;
            if (font) {&#13;
                presenter.configuration.tmp_ctx.font = font;&#13;
                if (presenter.$textWrapper) {&#13;
                    var $textarea = presenter.$textWrapper.find('textarea');&#13;
                    var oldWidth = $textarea.css('width');&#13;
                    var oldHeight = $textarea.css('height');&#13;
                    $textarea.css('font', font);&#13;
                    $textarea.css('width', oldWidth);&#13;
                    $textarea.css('height', oldHeight);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setEraserOff = function () {&#13;
        setDefaultAddonMode()&#13;
        if (presenter.beforeEraserColor == undefined) {&#13;
            presenter.setColor(presenter.configuration.color);&#13;
        } else {&#13;
            presenter.setColor(presenter.beforeEraserColor);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setEraserOn = function() {&#13;
        setAddonMode(ModeEnum.eraser);&#13;
&#13;
        presenter.configuration.thickness = presenter.configuration.eraserThickness;&#13;
        presenter.configuration.context.globalCompositeOperation = "destination-out";&#13;
        presenter.beforeEraserColor = presenter.configuration.color;&#13;
    };&#13;
&#13;
    presenter.setEraserThickness = function(thickness) {&#13;
        presenter.configuration.eraserThickness = presenter.parseThickness(thickness).thickness;&#13;
        if (isOnEraserMode()) {&#13;
            presenter.configuration.thickness = presenter.configuration.eraserThickness;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(model.Color)) {&#13;
            return getErrorObject('C01');&#13;
        }&#13;
&#13;
        var parsedColor = presenter.parseColor(model.Color);&#13;
        if (!parsedColor.isValid) {&#13;
            return getErrorObject(parsedColor.errorCode);&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(model.Thickness)) {&#13;
            return getErrorObject('T01');&#13;
        }&#13;
&#13;
        var parsedThickness = presenter.parseThickness(model.Thickness);&#13;
        if (!parsedThickness.isValid) {&#13;
            return getErrorObject(parsedThickness.errorCode);&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(model.Border)) {&#13;
            return getErrorObject('B01');&#13;
        }&#13;
&#13;
        var parsedBorder = presenter.parseBorder(model.Border);&#13;
        if (!parsedBorder.isValid) {&#13;
            return getErrorObject(parsedBorder.errorCode);&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(model.Opacity)) {&#13;
            return getErrorObject('O01');&#13;
        }&#13;
&#13;
        var parsedOpacity = presenter.parseOpacity(model.Opacity);&#13;
        if (!parsedOpacity.isValid) {&#13;
            return getErrorObject(parsedOpacity.errorCode);&#13;
        }&#13;
&#13;
        var isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        return {&#13;
            color: parsedColor.color,&#13;
            thickness: parsedThickness.thickness,&#13;
            border: parsedBorder.border,&#13;
            opacity: parsedOpacity.opacity,&#13;
&#13;
            canvas: null,&#13;
            context: null,&#13;
&#13;
            width: model.Width,&#13;
            height: model.Height,&#13;
            isValid: true,&#13;
            isVisible: isVisible,&#13;
            isVisibleByDefault: isVisible,&#13;
            isExerciseStarted: false,&#13;
            font: model.Font&#13;
        };&#13;
    };&#13;
&#13;
    presenter.parseColor = function(color) {&#13;
&#13;
        if (color[0] === '#' &amp;&amp; !(color.length === 7)) {&#13;
            return getErrorObject('C02');&#13;
        }&#13;
&#13;
        if (color[0] !== '#') {&#13;
            color = presenter.colourNameToHex(color);&#13;
        }&#13;
&#13;
        if (!color) {&#13;
            return getErrorObject('C03');&#13;
        }&#13;
&#13;
        return {&#13;
            color: color,&#13;
            isValid: true&#13;
        };&#13;
&#13;
    };&#13;
&#13;
    presenter.parseThickness = function(thickness) {&#13;
&#13;
        if (thickness &lt; 1) {&#13;
            return getErrorObject('T02');&#13;
        }&#13;
&#13;
        if (thickness &gt; 40) {&#13;
            return getErrorObject('T03');&#13;
        }&#13;
&#13;
        return {&#13;
            thickness: thickness,&#13;
            isValid: true&#13;
        };&#13;
&#13;
    };&#13;
&#13;
    presenter.parseBorder = function(border) {&#13;
&#13;
        if (border &lt; 0) {&#13;
            return getErrorObject('B02');&#13;
        }&#13;
&#13;
        if (border &gt; 5) {&#13;
            return getErrorObject('B03');&#13;
        }&#13;
&#13;
        return {&#13;
            border: border,&#13;
            isValid: true&#13;
        };&#13;
&#13;
    };&#13;
&#13;
    presenter.parseOpacity = function(opacity) {&#13;
        if (opacity &lt; 0) {&#13;
            return getErrorObject('O02');&#13;
        }&#13;
&#13;
        if (opacity &gt; 1) {&#13;
            return getErrorObject('O03');&#13;
        }&#13;
&#13;
        return {&#13;
            opacity: opacity,&#13;
            isValid: true&#13;
        };&#13;
    };&#13;
&#13;
    function setColorToBackgroundTmpCanvas (color) {&#13;
        var tmp_ctx = presenter.configuration.tmp_ctx;&#13;
        var tmp_canvas = presenter.configuration.tmp_canvas;&#13;
        tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
        tmp_ctx.fillStyle = color;&#13;
        tmp_ctx.fillRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
        tmp_ctx.drawImage(presenter.$view.find("canvas")[0], 0, 0);&#13;
    }&#13;
&#13;
    presenter.handleDownloadImage = function () {&#13;
        var fillStyle = presenter.configuration.tmp_ctx.fillStyle;&#13;
        setColorToBackgroundTmpCanvas('white');&#13;
&#13;
        var canvas = presenter.$view.find("canvas.tmp_canvas")[0], data = canvas.toDataURL("image/png");&#13;
        data = data.replace(/^data:image\/[^;]*/, 'data:application/octet-stream');&#13;
        data = data.replace(/^data:application\/octet-stream/, 'data:application/octet-stream;headers=Content-Disposition%3A%20attachment%3B%20filename=Board.png');&#13;
        this.href = data;&#13;
&#13;
        tmp_ctx.clearRect(0, 0, tmp_canvas.width, tmp_canvas.height);&#13;
        tmp_ctx.fillStyle = fillStyle;&#13;
    }&#13;
&#13;
    presenter.downloadBoard = function () {&#13;
        &#13;
        var element = document.createElement("a");&#13;
        element.setAttribute("id", "dl");&#13;
        element.setAttribute("download", "Board.png");&#13;
        element.setAttribute("href", "#");&#13;
        element.onclick = presenter.handleDownloadImage;&#13;
        element.click();&#13;
    }&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'uploadImage': presenter.uploadImage,&#13;
            'setColor': presenter.setColor,&#13;
            'addText': presenter.addText,&#13;
            'setThickness': presenter.setThickness,&#13;
            'setEraserOn': presenter.setEraserOn,&#13;
            'setEraserThickness': presenter.setEraserThickness,&#13;
            'setOpacity': presenter.setOpacity,&#13;
            'setFont': presenter.setFont,&#13;
            'setEraserOff': presenter.setEraserOff,&#13;
            'downloadBoard': presenter.downloadBoard&#13;
        };&#13;
&#13;
        addImageToCanvasIfOnImageEditionMode();&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.uploadImage = function() {&#13;
        var element = document.createElement("input");&#13;
        $('body')[0].append(element);&#13;
        element.style.display = 'none';&#13;
        element.setAttribute("id", "importFile");&#13;
        element.setAttribute("type", "file");&#13;
        element.setAttribute("accept", "image/png,image/jpeg");&#13;
&#13;
        if (presenter.imageInputElement) presenter.imageInputElement.remove();&#13;
        presenter.imageInputElement = element;&#13;
&#13;
        element.addEventListener('change', presenter.handleImage);&#13;
        element.click();&#13;
    }&#13;
&#13;
    presenter.reset = function() {&#13;
        presenter.configuration.context.clearRect(0, 0, presenter.configuration.canvas[0].width, presenter.configuration.canvas[0].height);&#13;
        presenter.isStarted = false;&#13;
&#13;
        presenter.setColor(presenter.model.Color);&#13;
        presenter.setThickness(presenter.model.Thickness);&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.configuration.opacity = presenter.opacityByDefault;&#13;
        presenter.beforeEraserColor = presenter.configuration.color;&#13;
&#13;
        setOverflowWorkAround(true);&#13;
        setOverflowWorkAround(false);&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        if (!presenter.isStarted) {&#13;
            return;&#13;
        }&#13;
        addImageToCanvasIfOnImageEditionMode();&#13;
&#13;
        var addonMode = presenter.configuration.addonMode,&#13;
            color = presenter.configuration.color,&#13;
            pencilThickness = presenter.configuration.pencilThickness,&#13;
            eraserThickness = presenter.configuration.eraserThickness,&#13;
            c = presenter.$view.find("canvas")[0],&#13;
            data = c.toDataURL("image/png"),&#13;
            font = presenter.configuration.font;&#13;
&#13;
        return JSON.stringify({&#13;
            addonMode: addonMode,&#13;
            color: color,&#13;
            pencilThickness: pencilThickness,&#13;
            eraserThickness: eraserThickness,&#13;
            data: data,&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            opacity: presenter.configuration.opacity,&#13;
            font: font&#13;
        });&#13;
    };&#13;
&#13;
    presenter.upgradeStateForOpacity = function (parsedState) {&#13;
        if (parsedState.opacity == undefined) {&#13;
            parsedState.opacity = 0.9;&#13;
        }&#13;
&#13;
        return parsedState;&#13;
    };&#13;
&#13;
    presenter.upgradeStateForImageAndText = function (parsedState) {&#13;
        if (parsedState.font == undefined) {&#13;
            parsedState.font = "";&#13;
        }&#13;
&#13;
        if (parsedState.addonMode == undefined) {&#13;
            if (parsedState.isPencil !== undefined &amp;&amp; !parsedState.isPencil) {&#13;
                parsedState.addonMode = "eraser";&#13;
            } else {&#13;
                parsedState.addonMode = "pencil";&#13;
            }&#13;
        }&#13;
&#13;
        return parsedState;&#13;
    }&#13;
&#13;
    presenter.upgradeState = function (parsedState) {&#13;
        var upgradedState = presenter.upgradeStateForOpacity(parsedState);&#13;
        upgradedState = presenter.upgradeStateForImageAndText(upgradedState);&#13;
        return upgradedState;&#13;
    };&#13;
&#13;
    presenter.setState = function(state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsedState = JSON.parse(state);&#13;
&#13;
        parsedState = presenter.upgradeState(parsedState);&#13;
&#13;
        var data = parsedState.data,&#13;
            addonMode = parsedState.addonMode,&#13;
            color = parsedState.color,&#13;
            savedImg = new Image();&#13;
&#13;
        savedImg.onload = function() {&#13;
            presenter.configuration.context.drawImage(savedImg, 0, 0);&#13;
        };&#13;
        savedImg.src = data;&#13;
&#13;
        presenter.configuration.pencilThickness = parsedState.pencilThickness;&#13;
        presenter.configuration.eraserThickness = parsedState.eraserThickness;&#13;
        presenter.configuration.isVisible = parsedState.isVisible;&#13;
        presenter.configuration.addonMode = addonMode;&#13;
        presenter.isStarted = true;&#13;
        presenter.configuration.opacity = parsedState.opacity;&#13;
        if (isOnPencilMode()) {&#13;
            presenter.setColor(color);&#13;
        } else {&#13;
            presenter.configuration.thickness = presenter.configuration.eraserThickness;&#13;
            presenter.configuration.color = "rgba(0, 0, 0, 1)";&#13;
        }&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
        presenter.beforeEraserColor = color;&#13;
        presenter.setFont(parsedState.font);&#13;
    };&#13;
&#13;
    presenter.addText = function() {&#13;
        if (!isOnTextEditionMode()) {&#13;
            presenter.setEraserOff();&#13;
            setAddonMode(ModeEnum.textEdition);&#13;
            presenter.displayTextFieldPopup();&#13;
        } else {&#13;
            presenter.closeTextFieldPopup();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.displayTextFieldPopup = function() {&#13;
        if (presenter.$textWrapper != null) return;&#13;
        var $wrapper = $('&lt;div&gt;&lt;/div&gt;');&#13;
        var textareaWidth = 100;&#13;
        $wrapper.css('position', 'absolute');&#13;
        $wrapper.css('left', Math.round(presenter.configuration.canvas.width()/2 - textareaWidth/2) + 'px');&#13;
        $wrapper.css('top', '45%');&#13;
        $wrapper.css('padding', '0px');&#13;
&#13;
        var $textHandle = $('&lt;div&gt;&lt;/div&gt;');&#13;
        $textHandle.addClass('text-handle');&#13;
        $textHandle.css('display', 'block');&#13;
        $textHandle.css('width', '14px');&#13;
        $textHandle.css('height', '14px');&#13;
        $textHandle.css('position', 'absolute');&#13;
        $textHandle.css('left', '-13px');&#13;
        $textHandle.css('top', '-13px');&#13;
        $textHandle.css('background-color', 'rgb(133,133,133)');&#13;
        $textHandle.css('cursor', 'pointer');&#13;
        $wrapper.append($textHandle);&#13;
&#13;
        var $closeButton = $('&lt;div&gt;x&lt;/div&gt;');&#13;
        $closeButton.addClass('text-close');&#13;
        $closeButton.css('display', 'block');&#13;
        $closeButton.css('color', 'rgb(133,133,133)');&#13;
        $closeButton.css('font-size', '16px');&#13;
        $closeButton.css('width', '0.6em');&#13;
        $closeButton.css('height', '1em');&#13;
        $closeButton.css('position', 'absolute');&#13;
        $closeButton.css('right', '0px');&#13;
        $closeButton.css('top', '-1.2em');&#13;
        $closeButton.css('cursor', 'pointer');&#13;
        $closeButton.click(presenter.closeTextFieldPopup);&#13;
        $wrapper.append($closeButton);&#13;
&#13;
        var $textarea = $('&lt;textarea&gt;&lt;/textarea&gt;');&#13;
        $textarea.css('font',presenter.configuration.font);&#13;
        $textarea.css('color',presenter.configuration.color);&#13;
        $textarea.css('padding','0px');&#13;
        $textarea.css('background-color','#0000');&#13;
        $textarea.css('width',textareaWidth + 'px');&#13;
        $textarea.on('input', function() {&#13;
            if ($textarea[0].scrollHeight &gt; $textarea[0].clientHeight) {&#13;
                $textarea.css('height', $textarea[0].scrollHeight+'px');&#13;
            }&#13;
        });&#13;
        $wrapper.append($textarea);&#13;
&#13;
        presenter.$view.append($wrapper);&#13;
        presenter.$textWrapper = $wrapper;&#13;
        var scale = getScale();&#13;
        $wrapper.draggable({&#13;
            handle: ".text-handle",&#13;
            containment: "parent",&#13;
            drag: function( event, ui ) {&#13;
                ui.position.left = ui.position.left / scale.X;&#13;
                ui.position.top = ui.position.top / scale.Y;&#13;
              }&#13;
        });&#13;
        $textarea.focus();&#13;
    };&#13;
&#13;
    presenter.closeTextFieldPopup = function() {&#13;
        if (presenter.$textWrapper != null) {&#13;
            presenter.$textWrapper.remove();&#13;
            presenter.$textWrapper = null;&#13;
            setDefaultAddonMode();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.finishEditTextMode = function() {&#13;
        if (presenter.$textWrapper == null) return;&#13;
        var $textarea = presenter.$textWrapper.find('textarea');&#13;
        var textArray = presenter.getBrokenText($textarea);&#13;
        if (textArray.length != 0) {&#13;
            var drawingWrapper = presenter.$view.find('.drawing')[0];&#13;
            var x = presenter.$textWrapper[0].offsetLeft - drawingWrapper.offsetLeft + 1;&#13;
            var y = presenter.$textWrapper[0].offsetTop - drawingWrapper.offsetTop - 1;&#13;
            var lineHeight = presenter.getLineHeight($textarea, textArray.length);&#13;
            presenter.embedText(textArray, x, y, lineHeight);&#13;
        }&#13;
        presenter.closeTextFieldPopup();&#13;
    }&#13;
&#13;
    presenter.getLineHeight = function($textarea, lineNumber) {&#13;
        var $testArea = $textarea.clone(true);&#13;
        $testArea.attr('visibility', 'hidden');&#13;
        $textarea.after($testArea);&#13;
        $testArea.css('height', '0px');&#13;
        var lineHeight = $testArea[0].scrollHeight / lineNumber;&#13;
        $testArea.remove();&#13;
        return lineHeight;&#13;
    }&#13;
&#13;
    presenter.getBrokenText = function($textarea) {&#13;
        var $testArea = $textarea.clone(true);&#13;
        $testArea.attr('visibility', 'hidden');&#13;
        $testArea.attr('wrap', 'off');&#13;
        $textarea.after($testArea);&#13;
        $testArea.val('');&#13;
        var emptyWidth = $testArea[0].scrollWidth;&#13;
&#13;
        var srcTextArray = $textarea.val().split(/\n/);&#13;
&#13;
        function isBrokenText(text) {&#13;
            // If a scroll would show up, that means that the text is too long&#13;
            // and would end up broken into multiple lines&#13;
            $testArea.val(text);&#13;
            var result = emptyWidth &lt; $testArea[0].scrollWidth;&#13;
            $testArea.val('');&#13;
            return result;&#13;
        }&#13;
&#13;
        var resultArray = [];&#13;
&#13;
        for (var i = 0; i &lt; srcTextArray.length; i++) {&#13;
            var srcText = srcTextArray[i];&#13;
            if (srcText.length == 0) {&#13;
                // save an empty line and move on&#13;
                resultArray.push(srcText);&#13;
                continue;&#13;
            }&#13;
            var wordArray = srcText.match(/[^\s][^\s]*|\s/g); // split the current line we're working on into individual words and whitespaces&#13;
            var workString = "";&#13;
            for (var j = 0; j &lt; wordArray.length; j++) {&#13;
                if (j &gt; 0 &amp;&amp; /^\s$/.test(wordArray[j]) &amp;&amp; workString.length == 0) {&#13;
                    // if a line has been broken due to being too long, the new row should not start with whitespaces&#13;
                    continue;&#13;
                }&#13;
                if (isBrokenText(workString + wordArray[j])) {&#13;
                    if (workString.length == 0) {&#13;
                        // In this case a single word is too long to fit and needs to be broken into lines&#13;
                        var brokenString = "";&#13;
                        for (var k = 0; k &lt; wordArray[j].length; k++) {&#13;
                            var newLetter = wordArray[j][k];&#13;
                            if (isBrokenText(brokenString + newLetter)) {&#13;
                                resultArray.push(brokenString);&#13;
                                brokenString = newLetter;&#13;
                            } else {&#13;
                                brokenString += newLetter;&#13;
                            }&#13;
                        }&#13;
                        workString += brokenString;&#13;
                    } else {&#13;
                        // the new word would cause the work string to exceed line length&#13;
                        resultArray.push(workString);&#13;
                        if (/^\s$/.test(wordArray[j])) {&#13;
                            workString = "";&#13;
                        } else {&#13;
                            workString = wordArray[j];&#13;
                        }&#13;
                    }&#13;
                } else {&#13;
                    workString += wordArray[j];&#13;
                }&#13;
            }&#13;
            if (workString.length &gt; 0) resultArray.push(workString);&#13;
        }&#13;
        $testArea.remove();&#13;
        return resultArray;&#13;
    }&#13;
&#13;
    presenter.destroy = function () {&#13;
        document.removeEventListener('keydown', presenter.removeImage, false);&#13;
        presenter.configuration.tmp_ctx.removeEventListener('click', function(e) {&#13;
            e.stopPropagation();&#13;
        }, false);&#13;
        if (presenter.imageInputElement) presenter.imageInputElement.remove();&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>