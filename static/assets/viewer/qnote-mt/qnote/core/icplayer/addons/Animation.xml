<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Animation" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Preview image" nameLabel="Animation_property_preview_image" type="image"/>
		<property name="Animation" nameLabel="Animation_property_animation" type="image"/>
		<property name="Frames count" nameLabel="Animation_property_frames_count" type="string"/>
		<property name="Frame duration" nameLabel="Animation_property_frame_duration" type="string"/>
		<property name="Frame size" nameLabel="Animation_property_frame_size" type="{Original, Keep aspect ratio, Stretch}"/>
		<property name="Loop" nameLabel="Animation_property_loop" type="boolean"/>
		<property name="Labels" nameLabel="Animation_property_labels" type="list">
			<property isLocalized="true" name="Text" nameLabel="Animation_property_text" type="string"/>
			<property name="Top" nameLabel="Animation_property_top" type="string"/>
			<property name="Left" nameLabel="Animation_property_left" type="string"/>
			<property name="Frames" nameLabel="Animation_property_frames" type="string"/>
		</property>
		<property name="Show watermark" nameLabel="Animation_property_show_watermark" type="boolean"/>
		<property name="Watermark color" nameLabel="Animation_property_watermark_color" type="string"/>
		<property name="Watermark opacity" nameLabel="Animation_property_watermark_opacity" type="string"/>
		<property name="Watermark size" nameLabel="Animation_property_watermark_size" type="string"/>
		<property name="Don't reset on end" nameLabel="Animation_property_do_not_reset_on_end" type="boolean"/>
		<property name="Is click disabled" nameLabel="Animation_property_is_click_disabled" type="boolean"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="Animation_property_speech_texts" type="staticlist">
            <property name="Stop" nameLabel="Animation_property_stop_speech_text" type="staticrow">
                <property name="Stop" nameLabel="Animation_property_stop_speech_text" type="string"/>
            </property>
		</property>
		<property displayName="Alternative Text" name="Alternative Text" nameLabel="Animation_property_alt_text" type="text"/>
		<property displayName="Preview Alternative Text" name="Preview Alternative Text" nameLabel="Animation_property_alt_text_prev" type="text"/>
		<property displayName="Lang attribute" name="langAttribute" nameLabel="Animation_property_lang_attribute" type="string"/>
	</model>
<css>.animation-image-animation,&#13;
.animation-image-preview,&#13;
.animation-loading-image,&#13;
.animation-label {&#13;
    border: 0;&#13;
    margin: 0;&#13;
    padding: 0;&#13;
}&#13;
&#13;
.animation-image-animation,&#13;
.animation-image-preview {&#13;
    border: none;&#13;
    float: left;&#13;
    overflow: hidden;&#13;
    background: no-repeat 0 0;&#13;
}&#13;
&#13;
.animation-image-animation {&#13;
    display: none;&#13;
}&#13;
&#13;
.animation-image-preview {&#13;
    position: relative;&#13;
}&#13;
&#13;
.animation-loading-image {&#13;
    display: none;&#13;
    position: absolute;&#13;
    border: 0 solid black;&#13;
    width: 50px;&#13;
    height: 50px;&#13;
}&#13;
&#13;
.animation-label {&#13;
    position: absolute;&#13;
}&#13;
&#13;
.animation-hidden-image {&#13;
    visibility: hidden;&#13;
}&#13;
&#13;
.animation-watermark {&#13;
    border: 0;&#13;
    margin: 0;&#13;
    padding: 0;&#13;
    display: none;&#13;
    position: absolute;&#13;
}&#13;
</css><view>&lt;div class='animation-image-preview'&gt;&#13;
&lt;/div&gt;&#13;
&lt;div class='animation-image-animation'&gt;&#13;
&lt;/div&gt;&#13;
&lt;div class="animation-watermark"&gt;&#13;
&lt;/div&gt;&#13;
&lt;img src="" alt="Loading..." class="animation-loading-image"/&gt;&#13;
</view><preview>&lt;div class='animation-image-preview'&gt;&#13;
&lt;/div&gt;&#13;
&lt;div class='animation-image-animation'&gt;&#13;
&lt;/div&gt;&#13;
&lt;div class="animation-watermark"&gt;&#13;
&lt;/div&gt;&#13;
&lt;img src="/media/images/loading.gif" alt="Loading..." class="animation-loading-image"/&gt;&#13;
</preview><presenter>function AddonAnimation_create (){&#13;
    var deferredSyncQueue = window.DecoratorUtils.DeferredSyncQueue(deferredQueueDecoratorChecker);&#13;
&#13;
    var presenter = function () {};&#13;
    presenter.DOMElements = {};&#13;
    presenter.configuration = {};&#13;
    &#13;
    var isSpeaking = false; //tts is currently attempting to play the alternative text (but not the preview alt text)&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'AI_01': "Animation image wasn't set or was set incorrectly!",&#13;
        'PI_01': "Preview image wasn't set or was set incorrectly!",&#13;
        'FC_01': "Frames count must be positive integer number!",&#13;
        'FD_01': "Frame duration time must be positive integer number!",&#13;
        'L_01': "Text value cannot be empty!",&#13;
        'L_02': "Top position value is invalid!",&#13;
        'L_03': "Left position value is invalid!",&#13;
        'WM_01': "Watermark color must be provided in #RRGGBB format!",&#13;
        'WM_02': "Watermark opacity must be a value from 0.0 to 1.0!",&#13;
        'WM_03': "Watermark size must be a positive integer number!",&#13;
        'FL01': "Frame list - undefined or empty!",&#13;
        'FL02': "Frame list - syntax incorrect (probably wrong separator)!",&#13;
        'FL03': "Frame list - frame number invalid!",&#13;
        'FL04': "Frame list - frame number missing inside list!",&#13;
        'FL05': "Frame list - frame numbers range incorrect!"&#13;
    };&#13;
&#13;
    presenter.ANIMATION_STATE = {&#13;
        PAUSED: 0,&#13;
        PLAYING: 1,&#13;
        STOPPED: 2,&#13;
        ENDED: 3&#13;
    };&#13;
&#13;
    presenter.FRAME_SIZE = {&#13;
        ORIGINAL: 0,&#13;
        SCALED: 1,&#13;
        STRETCHED: 2&#13;
    };&#13;
&#13;
    presenter.IMAGE_TYPE = {&#13;
        PREVIEW: 0,&#13;
        ANIMATION: 1&#13;
    };&#13;
&#13;
    presenter.eventBus = null;&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        var upgradedModel = presenter.addFramesToLabels(model);&#13;
        return presenter.upgradeTextToSpeech(upgradedModel);&#13;
    };&#13;
&#13;
    presenter.addFramesToLabels = function (model) {&#13;
        var upgradedModel = {}, i;&#13;
        $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        for (i = 0; i &lt; model["Labels"].length; i++) {&#13;
            if (upgradedModel["Labels"][i]["Frames"] == undefined) {&#13;
                upgradedModel["Labels"][i]["Frames"] = "";&#13;
            }&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeTextToSpeech = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!upgradedModel['Alternative Text']) {&#13;
            upgradedModel['Alternative Text'] = ''&#13;
        }&#13;
&#13;
        if (!upgradedModel['Preview Alternative Text']) {&#13;
            upgradedModel['Preview Alternative Text'] = ''&#13;
        }&#13;
&#13;
        if (!upgradedModel['speechTexts']) {&#13;
            upgradedModel['speechTexts'] = {&#13;
                Stop: {Stop: "stopped"}&#13;
            };&#13;
        }&#13;
&#13;
        if (!upgradedModel['langAttribute']) {&#13;
            upgradedModel['langAttribute'] = '';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    function getSpeechTextProperty (rawValue, defaultValue) {&#13;
        var value = rawValue.trim();&#13;
&#13;
        if (value === '') {&#13;
            return defaultValue;&#13;
        }&#13;
&#13;
        return value;&#13;
    }&#13;
&#13;
    presenter.getspeechTexts = function(speechTexts) {&#13;
        var speechTexts = {&#13;
            stop:    getSpeechTextProperty(speechTexts['Stop']['Stop'], "Stopped")&#13;
        };&#13;
&#13;
        return speechTexts;&#13;
    };&#13;
&#13;
    function setDOMElementsHrefsAndSelectors(view) {&#13;
        presenter.DOMElements.viewContainer = $(view);&#13;
        presenter.DOMElements.animation = $(view).find('.animation-image-animation:first')[0];&#13;
        presenter.DOMElements.preview = $(view).find('.animation-image-preview:first')[0];&#13;
        presenter.DOMElements.loading = $(presenter.DOMElements.viewContainer.find('.animation-loading-image:first')[0]);&#13;
        presenter.DOMElements.watermark = $(presenter.DOMElements.viewContainer.find('.animation-watermark:first')[0]);&#13;
    }&#13;
&#13;
    // Calculate scale for image containing element depending on frame aspect ratio&#13;
    presenter.calculateContainerDimensions = function(imageWidth, imageHeight, containerWidth, containerHeight) {&#13;
        var imageRatio = imageWidth / imageHeight;&#13;
        var containerRatio = containerWidth / containerHeight;&#13;
&#13;
        var horizontal = imageRatio &gt;= containerRatio ? containerWidth : containerHeight * imageRatio;&#13;
        var vertical = imageRatio &gt;= containerRatio ? containerWidth / imageRatio : containerHeight;&#13;
&#13;
        return {&#13;
            horizontal: horizontal,&#13;
            vertical: vertical&#13;
        };&#13;
    };&#13;
&#13;
    function setElementsDimensions(wrapper) {&#13;
        var previewReducedSize = DOMOperationsUtils.calculateReducedSize(wrapper, presenter.DOMElements.preview);&#13;
        $(presenter.DOMElements.preview).css({&#13;
            width: previewReducedSize.width,&#13;
            height: previewReducedSize.height&#13;
        });&#13;
&#13;
        var animationReducedSize = DOMOperationsUtils.calculateReducedSize(wrapper, presenter.DOMElements.animation);&#13;
        $(presenter.DOMElements.animation).css({&#13;
            width: animationReducedSize.width,&#13;
            height: animationReducedSize.height&#13;
        });&#13;
&#13;
        presenter.configuration.dimensions = {&#13;
            preview: { width: previewReducedSize.width, height: previewReducedSize.height },&#13;
            animation: { width: animationReducedSize.width, height: animationReducedSize.height }&#13;
        };&#13;
    }&#13;
&#13;
    function deferredQueueDecoratorChecker() {&#13;
        return presenter.isLoaded;&#13;
    }&#13;
&#13;
    // This function returns string containing CSS declaration of elements&#13;
    // background image size in percentage measure&#13;
    function calculateBackgroundSize(size, framesCount, imageType) {&#13;
        var cssValue;&#13;
&#13;
        switch(size) {&#13;
            case presenter.FRAME_SIZE.SCALED:&#13;
            case presenter.FRAME_SIZE.STRETCHED:&#13;
                cssValue = imageType === presenter.IMAGE_TYPE.ANIMATION ? (framesCount * 100) : 100;&#13;
                cssValue += '% 100%';&#13;
                break;&#13;
            default:&#13;
                cssValue = '';&#13;
        }&#13;
&#13;
        return cssValue;&#13;
    }&#13;
&#13;
    function previewImageLogic(previewImage) {&#13;
        var isScaledMode = presenter.configuration.frameSize === presenter.FRAME_SIZE.SCALED;&#13;
        var previewWidth = presenter.configuration.dimensions.preview.width;&#13;
        var previewHeight = presenter.configuration.dimensions.preview.height;&#13;
&#13;
        $(previewImage).addClass('animation-hidden-image');&#13;
        $(presenter.DOMElements.viewContainer).append(previewImage);&#13;
        var previewDimensions = presenter.calculateContainerDimensions($(previewImage).width(), $(previewImage).height(), previewWidth, previewHeight);&#13;
&#13;
        var previewBackgroundSize = calculateBackgroundSize(presenter.configuration.frameSize, presenter.configuration.framesCount, presenter.IMAGE_TYPE.PREVIEW);&#13;
        $(presenter.DOMElements.preview).css({&#13;
            'background-image': 'url(' + presenter.configuration.image + ')',&#13;
            width: isScaledMode ? previewDimensions.horizontal + 'px' : previewWidth + 'px',&#13;
            height: isScaledMode ? previewDimensions.vertical + 'px' : previewHeight + 'px'&#13;
        });&#13;
&#13;
        if (previewBackgroundSize) {&#13;
            $(presenter.DOMElements.preview).css('background-size', previewBackgroundSize);&#13;
        }&#13;
&#13;
        $(previewImage).remove();&#13;
    }&#13;
&#13;
    function getCanvasFromImg(image) {&#13;
        var canvas = document.createElement('canvas');&#13;
        canvas.setAttribute('width', $(image).width());&#13;
        canvas.setAttribute('height', $(image).height());&#13;
        var ctx = canvas.getContext('2d');&#13;
        ctx.drawImage(image, 0, 0);&#13;
&#13;
        return canvas;&#13;
    }&#13;
&#13;
    function animationImageLogic(animationImage) {&#13;
        $(animationImage).addClass('animation-hidden-image');&#13;
        $(presenter.DOMElements.viewContainer).append(animationImage);&#13;
&#13;
        var animationWidth = presenter.configuration.dimensions.animation.width;&#13;
        var animationHeight = presenter.configuration.dimensions.animation.height;&#13;
        var animationDimensions = presenter.calculateContainerDimensions($(animationImage).width() / presenter.configuration.framesCount, $(animationImage).height(), animationWidth, animationHeight);&#13;
        var animationBackgroundSize = calculateBackgroundSize(presenter.configuration.frameSize, presenter.configuration.framesCount, presenter.IMAGE_TYPE.ANIMATION);&#13;
        var source_width = (parseInt(presenter.configuration.oryginal_width, 10) ? presenter.configuration.oryginal_width : $(animationImage).width()) / presenter.configuration.framesCount;&#13;
        var source_height = parseInt(presenter.configuration.oryginal_height,10) ? presenter.configuration.oryginal_height : $(animationImage).height();&#13;
        var elementWidth;&#13;
        var elementHeight;&#13;
&#13;
        switch (presenter.configuration.frameSize) {&#13;
            case presenter.FRAME_SIZE.ORIGINAL:&#13;
                elementWidth = source_width;&#13;
                elementHeight = source_height;&#13;
                break;&#13;
            case presenter.FRAME_SIZE.SCALED:&#13;
                elementWidth = animationDimensions.horizontal;&#13;
                elementHeight = animationDimensions.vertical;&#13;
                break;&#13;
            case presenter.FRAME_SIZE.STRETCHED:&#13;
                elementWidth = animationWidth;&#13;
                elementHeight = animationHeight;&#13;
                break;&#13;
        }&#13;
        elementWidth = Math.round(elementWidth);&#13;
        elementHeight = Math.round(elementHeight);&#13;
        var image = animationImage;&#13;
&#13;
        //Repair bug with jpg in android&#13;
        if (["5.1.1", "5.0.2"].indexOf(window.MobileUtils.getAndroidVersion(navigator.userAgent)) &gt; -1) {&#13;
            image = getCanvasFromImg(animationImage);&#13;
        }&#13;
&#13;
        presenter.images = [];&#13;
        var makeFrames = function() {&#13;
            var i;&#13;
            try {&#13;
                for (i = 0; i &lt; presenter.configuration.framesCount; i++) {&#13;
                    presenter.images.push(new presenter.ImageWrapper({&#13;
                        destinationHeight: elementHeight,&#13;
                        destinationWidth: elementWidth,&#13;
                        destinationX: 0,&#13;
                        destinationY: 0,&#13;
                        image: image,&#13;
                        sourceHeight: source_height,&#13;
                        sourceWidth: source_width,&#13;
                        sourceX: i * source_width,&#13;
                        sourceY: 0&#13;
                    }));&#13;
                }&#13;
            } catch (e) {&#13;
                if (e.name === "NS_ERROR_NOT_AVAILABLE") {&#13;
                    makeFrames();&#13;
                } else {&#13;
                    throw e;&#13;
                }&#13;
            }&#13;
        };&#13;
        makeFrames();&#13;
&#13;
        var $animationDOM = $(presenter.DOMElements.animation);&#13;
        var clickhandler = $("&lt;div&gt;&lt;/div&gt;").css({"background":"transparent", 'width': elementWidth, 'height': elementHeight, 'position':'absolute'});&#13;
        $animationDOM.append(clickhandler);&#13;
&#13;
&#13;
        presenter.createCanvas(elementWidth, elementHeight);&#13;
        $animationDOM.append(presenter.canvas);&#13;
&#13;
&#13;
        $(presenter.DOMElements.animation).css({&#13;
            width: elementWidth + 'px',&#13;
            height: elementHeight + 'px'&#13;
        });&#13;
&#13;
        if (animationBackgroundSize) {&#13;
            $(presenter.DOMElements.animation).css('background-size', animationBackgroundSize);&#13;
        }&#13;
&#13;
        $(animationImage).remove();&#13;
    }&#13;
&#13;
    presenter.createCanvas = function AddonAnimation_createCanvas(elementWidth, elementHeight) {&#13;
        presenter.canvas = document.createElement('canvas');&#13;
        presenter.canvas.setAttribute('width', elementWidth);&#13;
        presenter.canvas.setAttribute('height', elementHeight);&#13;
&#13;
        presenter.canvasContext = presenter.canvas.getContext('2d');&#13;
&#13;
        // draw first frame&#13;
        presenter.drawImage(&#13;
            presenter.canvasContext,&#13;
            presenter.images[0]&#13;
        );&#13;
    };&#13;
&#13;
    presenter.drawImage = function AddonAnimation_drawImage(ctx, image) {&#13;
        drawImageIOSFix(&#13;
            ctx,&#13;
            image.image,&#13;
            image.sourceX,&#13;
            image.sourceY,&#13;
            image.sourceWidth,&#13;
            image.sourceHeight,&#13;
            image.destinationX,&#13;
            image.destinationY,&#13;
            image.destinationWidth,&#13;
            image.destinationHeight&#13;
        );&#13;
    };&#13;
&#13;
    function loadImages() {&#13;
        showLoadingScreen();&#13;
&#13;
        var img = $('&lt;img src="'+ presenter.configuration.animation +'"/&gt;').load(function() {&#13;
        	presenter.configuration.oryginal_width = this.width;&#13;
        	presenter.configuration.oryginal_height = this.height;&#13;
        	$(this).remove();&#13;
        });&#13;
&#13;
        if (presenter.configuration.isPreview) {&#13;
            $.imgpreload([presenter.configuration.image], {&#13;
                all: function () {&#13;
                    previewImageLogic(this[0]);&#13;
                    hideLoadingScreen();&#13;
                }&#13;
            });&#13;
        } else {&#13;
            $.imgpreload([presenter.configuration.image, presenter.configuration.animation], {&#13;
                all: function() {&#13;
                    var isFirstPreview = $(this[0]).attr('src') == presenter.configuration.image;&#13;
                    var previewImage = isFirstPreview ? this[0] : this[1];&#13;
                    var animationImage = isFirstPreview ? this[1] : this[0];&#13;
    &#13;
                    previewImageLogic(previewImage);&#13;
                    imageLoadedCallback(animationImage);&#13;
                }&#13;
            });&#13;
        }&#13;
    }&#13;
&#13;
    function imageLoadedCallback (image) {&#13;
        animationImageLogic(image);&#13;
        hideLoadingScreen();&#13;
        loadImagesEndCallback();&#13;
    }&#13;
    &#13;
    function prepareLoadingScreen(containerWidth, containerHeight) {&#13;
        if (presenter.configuration.isPreview) return;&#13;
&#13;
        var loadingSrc = DOMOperationsUtils.getResourceFullPath(presenter.playerController, "media/loading.gif");&#13;
        if (loadingSrc) presenter.DOMElements.loading.attr('src', loadingSrc);&#13;
&#13;
        $(presenter.DOMElements.loading).css({&#13;
            top: ((containerHeight - $(presenter.DOMElements.loading).height()) / 2) + 'px',&#13;
            left: ((containerWidth - $(presenter.DOMElements.loading).width()) / 2) + 'px'&#13;
        });&#13;
    }&#13;
&#13;
    function showLoadingScreen() {&#13;
        $(presenter.DOMElements.loading).show();&#13;
    }&#13;
&#13;
    function hideLoadingScreen() {&#13;
        $(presenter.DOMElements.loading).hide();&#13;
    }&#13;
&#13;
    function changeFrame() {&#13;
        var i = presenter.configuration.currentFrame;&#13;
&#13;
        presenter.drawImage(presenter.canvasContext, presenter.images[i]);&#13;
&#13;
        if (presenter.configuration.animationState === presenter.ANIMATION_STATE.STOPPED) {&#13;
            showLabelsForFrame(0);&#13;
        } else {&#13;
            showLabelsForFrame(presenter.configuration.currentFrame + 1);&#13;
        }&#13;
    }&#13;
&#13;
    function prepareLabels() {&#13;
        for (var i = 0; i &lt; presenter.configuration.labels.count; i++) {&#13;
            var label = presenter.configuration.labels.content[i];&#13;
            var labelElement = document.createElement('span');&#13;
&#13;
            $(labelElement).addClass('animation-label');&#13;
            $(labelElement).html(label.text);&#13;
            $(labelElement).css({&#13;
                top: label.top,&#13;
                left: label.left,&#13;
                visibility: 'hidden'&#13;
            });&#13;
&#13;
            $(presenter.DOMElements.viewContainer).append(labelElement);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.playAnimation = function() {&#13;
        $(presenter.DOMElements.preview).hide();&#13;
        $(presenter.DOMElements.animation).show();&#13;
        presenter.configuration.animationState = presenter.ANIMATION_STATE.PLAYING;&#13;
        showLabelsForFrame(presenter.configuration.currentFrame + 1);&#13;
        if (presenter.configuration.watermarkOptions.show) {&#13;
            $(presenter.DOMElements.watermark).hide();&#13;
        }&#13;
        presenter.configuration.watermarkOptions.clicked = true;&#13;
        $.doTimeout(presenter.configuration.queueName, presenter.configuration.frameDuration, presenter.onTimeoutCallback);&#13;
    };&#13;
&#13;
    presenter.onTimeoutCallback = function AddonAnimation_onTimeoutCallback() {&#13;
        if (presenter.configuration.animationState !== presenter.ANIMATION_STATE.PLAYING) {&#13;
                return false;&#13;
        }&#13;
&#13;
        if (presenter.configuration.currentFrame &lt; presenter.configuration.framesCount - 1) {&#13;
            presenter.configuration.currentFrame++;&#13;
            changeFrame();&#13;
        } else {&#13;
            if (presenter.configuration.loop || presenter.configuration.resetOnEnd) {&#13;
                presenter.configuration.currentFrame = 0;&#13;
                presenter.sendEndAnimationEvent();&#13;
                changeFrame();&#13;
            } else {&#13;
                presenter.configuration.animationState = presenter.ANIMATION_STATE.ENDED;&#13;
                $.doTimeout(presenter.configuration.queueName, false);&#13;
                presenter.endAnimationHandler();&#13;
                return false;&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.configuration.currentFrame === 0 &amp;&amp; !presenter.configuration.loop) {&#13;
            if (presenter.configuration.resetOnEnd) {&#13;
                presenter.stop();&#13;
                return false;&#13;
            }&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.pause = deferredSyncQueue.decorate(function() {&#13;
        if (presenter.configuration.animationState !== presenter.ANIMATION_STATE.PLAYING) return;&#13;
&#13;
        presenter.configuration.animationState = presenter.ANIMATION_STATE.PAUSED;&#13;
        if (presenter.configuration.watermarkOptions.show) {&#13;
            $(presenter.DOMElements.watermark).show();&#13;
        }&#13;
        presenter.configuration.watermarkOptions.clicked = false;&#13;
        $.doTimeout(presenter.configuration.queueName, true);&#13;
    });&#13;
&#13;
    presenter.stop = deferredSyncQueue.decorate(function() {&#13;
        $(presenter.DOMElements.preview).show();&#13;
        $(presenter.DOMElements.animation).hide();&#13;
        presenter.configuration.animationState = presenter.ANIMATION_STATE.STOPPED;&#13;
        presenter.configuration.currentFrame = 0;&#13;
        changeFrame();&#13;
        if (presenter.configuration.watermarkOptions.show) {&#13;
            $(presenter.DOMElements.watermark).show();&#13;
        }&#13;
        presenter.configuration.watermarkOptions.clicked = false;&#13;
        $.doTimeout(presenter.configuration.queueName, false);&#13;
    });&#13;
&#13;
    function elementClickHandler(e) {&#13;
        e.stopPropagation();&#13;
&#13;
        switch (presenter.configuration.animationState) {&#13;
            case presenter.ANIMATION_STATE.PAUSED:&#13;
            case presenter.ANIMATION_STATE.STOPPED:&#13;
                presenter.playAnimation();&#13;
                break;&#13;
&#13;
            case presenter.ANIMATION_STATE.PLAYING:&#13;
                presenter.pause();&#13;
                break;&#13;
&#13;
            case presenter.ANIMATION_STATE.ENDED:&#13;
                presenter.stop();&#13;
                break;&#13;
        }&#13;
    }&#13;
&#13;
    function handleMouseActions() {&#13;
        if (presenter.configuration.isClickDisabled) return;&#13;
&#13;
        $(presenter.DOMElements.preview).click(elementClickHandler);&#13;
        $(presenter.DOMElements.animation).click(elementClickHandler);&#13;
        $(presenter.DOMElements.watermark).click(elementClickHandler);&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
&#13;
        presenter.eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    function presenterLogic(view, model, isPreview) {&#13;
        setDOMElementsHrefsAndSelectors(view);&#13;
&#13;
        presenter.model = presenter.upgradeModel(model);&#13;
        presenter.configuration = presenter.validateModel(presenter.model);&#13;
        presenter.configuration.isPreview = isPreview;&#13;
&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.isLoaded = false;&#13;
        setElementsDimensions(view);&#13;
        prepareLoadingScreen(model.Width, model.Height);&#13;
&#13;
        presenter.imagesLoadedDfd = new jQuery.Deferred();&#13;
        presenter.imagesLoaded = presenter.imagesLoadedDfd.promise();&#13;
&#13;
        $.when(presenter.imagesLoaded).then(function () {&#13;
            presenter.isLoaded = true;&#13;
&#13;
            deferredSyncQueue.resolve()&#13;
        });&#13;
&#13;
        loadImages();&#13;
        prepareLabels();&#13;
        showLabelsForFrame(0);&#13;
    }&#13;
&#13;
    presenter.createPreview = function(view, model){&#13;
        presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.destroy = function AddonAnimation_destroy() {&#13;
        presenter.canvas = null;&#13;
        presenter.canvasContext = null;&#13;
    };&#13;
&#13;
    presenter.run = function(view, model){&#13;
        presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.reset = deferredSyncQueue.decorate(function(){&#13;
        this.stop();&#13;
        presenter.configuration.watermarkOptions.clicked = false;&#13;
        if(presenter.configuration.watermarkOptions.show) {&#13;
            $(presenter.DOMElements.watermark).show();&#13;
        } else {&#13;
            $(presenter.DOMElements.watermark).hide();&#13;
        }&#13;
&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        if (!presenter.configuration.isVisibleByDefault) {&#13;
            presenter.hideLabels();&#13;
        }&#13;
    });&#13;
&#13;
    presenter.getState = function() {&#13;
        if (!presenter.isLoaded) return '';&#13;
&#13;
        if (presenter.ANIMATION_STATE.PLAYING === presenter.configuration.animationState) {&#13;
            presenter.pause();&#13;
        }&#13;
&#13;
        return JSON.stringify({&#13;
            currentFrame: presenter.configuration.currentFrame,&#13;
            animationState: presenter.configuration.animationState,&#13;
            isVisible : presenter.configuration.isVisible,&#13;
            watermarkClicked : presenter.configuration.watermarkOptions.clicked&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = deferredSyncQueue.decorate(function(stateString) {&#13;
        if (!stateString) return;&#13;
&#13;
        var state = JSON.parse(stateString);&#13;
&#13;
        presenter.configuration.currentFrame = state.currentFrame;&#13;
        presenter.configuration.animationState = state.animationState;&#13;
        presenter.configuration.watermarkOptions.clicked = state.watermarkClicked;&#13;
        changeFrame();&#13;
&#13;
        if (state.isVisible) {&#13;
            presenter.show();&#13;
        } else {&#13;
            presenter.hide();&#13;
        }&#13;
&#13;
        if (!presenter.configuration.watermarkOptions.clicked) {&#13;
            showLabelsForFrame(0);&#13;
        }&#13;
&#13;
        //noinspection FallthroughInSwitchStatementJS&#13;
        switch (presenter.configuration.animationState) {&#13;
            case presenter.ANIMATION_STATE.PLAYING:&#13;
                presenter.playAnimation();&#13;
                break;&#13;
            case presenter.ANIMATION_STATE.PAUSED:&#13;
            case presenter.ANIMATION_STATE.ENDED:&#13;
                $(presenter.DOMElements.preview).hide();&#13;
                $(presenter.DOMElements.animation).show();&#13;
                break;&#13;
        }&#13;
&#13;
        if (presenter.configuration.watermarkOptions.show &amp;&amp; !presenter.configuration.watermarkOptions.clicked) {&#13;
            $(presenter.DOMElements.watermark).show();&#13;
        } else {&#13;
            $(presenter.DOMElements.watermark).hide();&#13;
        }&#13;
    });&#13;
&#13;
    function loadImagesEndCallback () {&#13;
        presenter.configuration.animationState = presenter.ANIMATION_STATE.PAUSED;&#13;
        presenter.configuration.currentFrame = 0;&#13;
&#13;
        handleMouseActions();&#13;
&#13;
        Watermark.draw(presenter.DOMElements.watermark, presenter.configuration.watermarkOptions);&#13;
        if (presenter.configuration.watermarkOptions.show &amp;&amp; !presenter.configuration.watermarkOptions.clicked) {&#13;
            $(presenter.DOMElements.watermark).show();&#13;
        } else {&#13;
            $(presenter.DOMElements.watermark).hide();&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        if (!presenter.configuration.isVisibleByDefault) {&#13;
            presenter.hideLabels();&#13;
        }&#13;
&#13;
        presenter.imagesLoadedDfd.resolve();&#13;
    }&#13;
&#13;
    presenter.play = deferredSyncQueue.decorate(function () {&#13;
        if (presenter.configuration.animationState === presenter.ANIMATION_STATE.ENDED) {&#13;
            presenter.stop();&#13;
        } else {&#13;
            presenter.playAnimation();&#13;
            if (presenter.playerController.isWCAGOn()) {&#13;
                isSpeaking = true;&#13;
&#13;
                var speakCallback = function () {&#13;
                    isSpeaking = false;&#13;
                    presenter.endAnimationHandler();&#13;
                };&#13;
&#13;
                presenter.speakWithDelay([window.TTSUtils.getTextVoiceObject(presenter.configuration.altText, presenter.configuration.lang)], speakCallback);&#13;
            }&#13;
        }&#13;
    });&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'stop': presenter.stop,&#13;
            'pause': presenter.pause,&#13;
            'play': presenter.play,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        $(presenter.DOMElements.viewContainer).css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.hideLabels = function() {&#13;
        $(presenter.DOMElements.viewContainer).find('.animation-label').each(function () {&#13;
            $(this).css('visibility', 'hidden');&#13;
        });&#13;
    };&#13;
&#13;
    presenter.hide = deferredSyncQueue.decorate(function() {&#13;
        this.configuration.isVisible = false;&#13;
        if(presenter.configuration.animationState == presenter.ANIMATION_STATE.PLAYING) {&#13;
            this.pause();&#13;
        }&#13;
        this.setVisibility(false);&#13;
        this.hideLabels();&#13;
    });&#13;
&#13;
    presenter.show = deferredSyncQueue.decorate(function() {&#13;
        this.configuration.isVisible = true;&#13;
        if(presenter.configuration.animationState == presenter.ANIMATION_STATE.PLAYING) {&#13;
            this.playAnimation();&#13;
        }&#13;
        this.setVisibility(true);&#13;
        showLabelsForFrame(presenter.configuration.currentFrame + 1);&#13;
    });&#13;
&#13;
    // This function validates and converts number from string representation to positive integer value&#13;
    presenter.sanitizePositiveNumber = function(number) {&#13;
        if (!number) {&#13;
            return {&#13;
                isError: true&#13;
            };&#13;
        }&#13;
&#13;
        var parsedNumber = parseInt(number, 10);&#13;
        if (isNaN(parsedNumber)) {&#13;
            return {&#13;
                isError: true&#13;
            };&#13;
        }&#13;
&#13;
        if (parsedNumber &lt; 0) {&#13;
            return {&#13;
                isError: true&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            number: parsedNumber&#13;
        };&#13;
    };&#13;
&#13;
    // If validation error occurs then one of the following error codes are returned&#13;
    // L_01 - 'Text' value invalid&#13;
    // L_02 - 'Top' value invalid&#13;
    // L_03 - 'Left' value invalid&#13;
    // L_04 - Label empty&#13;
    presenter.validateLabels = function(labelsArray, framesCount) {&#13;
        var labels = { count: 0, content: [] };&#13;
&#13;
        if (ModelValidationUtils.isArrayEmpty(labelsArray)) {&#13;
            return { isError: false, labels: labels };&#13;
        }&#13;
&#13;
        for (var i = 0; i  &lt; labelsArray.length; i++) {&#13;
            if (ModelValidationUtils.isArrayElementEmpty(labelsArray[i])) {&#13;
                return { isError: true, errorCode: "L_04" };&#13;
            }&#13;
&#13;
            if (ModelValidationUtils.isStringEmpty(labelsArray[i].Text)) {&#13;
                return { isError: true, errorCode: "L_01" };&#13;
            }&#13;
&#13;
            var sanitizedTopPosition = presenter.sanitizePositiveNumber(labelsArray[i].Top);&#13;
            if (sanitizedTopPosition.isError) {&#13;
                return { isError: true, errorCode: "L_02" };&#13;
            }&#13;
&#13;
            var sanitizedLeftPosition = presenter.sanitizePositiveNumber(labelsArray[i].Left);&#13;
            if (sanitizedLeftPosition.isError) {&#13;
                return { isError: true, errorCode: "L_03" };&#13;
            }&#13;
&#13;
            if (ModelValidationUtils.isStringEmpty(labelsArray[i].Frames)) {&#13;
                labelsArray[i].Frames = "0";&#13;
            }&#13;
&#13;
            var convertedFrames = ImageViewer.convertFramesList(labelsArray[i].Frames, 0, framesCount);&#13;
            if (convertedFrames.isError) {&#13;
                return { isError: true, errorCode: convertedFrames.errorCode};&#13;
            }&#13;
&#13;
            var label = {&#13;
                text: labelsArray[i].Text,&#13;
                top: sanitizedTopPosition.number,&#13;
                left: sanitizedLeftPosition.number,&#13;
                frames: convertedFrames.list&#13;
            };&#13;
&#13;
            labels.content.push(label);&#13;
            labels.count++;&#13;
        }&#13;
&#13;
        return { isError: false, labels: labels };&#13;
    };&#13;
&#13;
    presenter.validateFramesCount = function(framesCount) {&#13;
        var sanitizedFramesCount = presenter.sanitizePositiveNumber(framesCount);&#13;
&#13;
        if (sanitizedFramesCount.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorCode: "FC_01"&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            framesCount: sanitizedFramesCount.number&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateFrameDuration = function(frameDuration) {&#13;
        var sanitizedFrameDuration = presenter.sanitizePositiveNumber(frameDuration);&#13;
&#13;
        if (sanitizedFrameDuration.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorCode: "FD_01"&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            frameDuration: sanitizedFrameDuration.number&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateFrameSize = function(frameSize) {&#13;
        var result;&#13;
&#13;
        switch (frameSize) {&#13;
            case "Keep aspect ratio":&#13;
                result = presenter.FRAME_SIZE.SCALED;&#13;
                break;&#13;
            case "Stretch":&#13;
                result = presenter.FRAME_SIZE.STRETCHED;&#13;
                break;&#13;
            default:&#13;
                result = presenter.FRAME_SIZE.ORIGINAL;&#13;
                break;&#13;
        }&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var speechTexts = presenter.getspeechTexts(model['speechTexts']);&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(model["Preview image"])) {&#13;
            return { isError: true, errorCode: "PI_01" };&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(model.Animation)) {&#13;
            return { isError: true, errorCode: "AI_01" };&#13;
        }&#13;
&#13;
        var validatedFramesCount = presenter.validateFramesCount(model["Frames count"]);&#13;
        if (validatedFramesCount.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorCode: validatedFramesCount.errorCode&#13;
            };&#13;
        }&#13;
&#13;
        var validatedFrameDuration = presenter.validateFrameDuration(model["Frame duration"]);&#13;
        if (validatedFrameDuration.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorCode: validatedFrameDuration.errorCode&#13;
            };&#13;
        }&#13;
&#13;
        var validatedLabels = presenter.validateLabels(model.Labels, validatedFramesCount.framesCount);&#13;
        if (validatedLabels.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorCode: validatedLabels.errorCode&#13;
            };&#13;
        }&#13;
&#13;
        var watermarkOptions = {&#13;
            "color": model["Watermark color"],&#13;
            "opacity": model["Watermark opacity"],&#13;
            "size": model["Watermark size"]&#13;
        };&#13;
        var validatedOptions = Watermark.validateOptions(watermarkOptions);&#13;
        validatedOptions.show = ModelValidationUtils.validateBoolean(model["Show watermark"]);&#13;
        validatedOptions.clicked = false;&#13;
&#13;
        var isVisibleByDefault = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            queueName: model.ID,&#13;
            image: model["Preview image"],&#13;
            animation: model.Animation,&#13;
            framesCount: validatedFramesCount.framesCount,&#13;
            frameDuration: validatedFrameDuration.frameDuration,&#13;
            loop: ModelValidationUtils.validateBoolean(model.Loop),&#13;
            labels: validatedLabels.labels,&#13;
            frameSize: presenter.validateFrameSize(model["Frame size"]),&#13;
            resetOnEnd: !ModelValidationUtils.validateBoolean(model["Don't reset on end"]),&#13;
            isClickDisabled: ModelValidationUtils.validateBoolean(model["Is click disabled"]),&#13;
            isVisibleByDefault: isVisibleByDefault,&#13;
            isVisible: isVisibleByDefault,&#13;
            watermarkOptions: validatedOptions,&#13;
            addonID: model.ID,&#13;
            altText: model['Alternative Text'],&#13;
            altTextPreview: model['Preview Alternative Text'],&#13;
            lang: model['langAttribute'],&#13;
            speechTexts: speechTexts&#13;
        };&#13;
    };&#13;
&#13;
    presenter.getLabelIndexesForFrame = function (labels, frame) {&#13;
        var indexes = [];&#13;
&#13;
        if(!labels) return indexes;&#13;
&#13;
        for (var i = 0, length = labels.length; i &lt; length; i++) {&#13;
            if (labels[i].frames.indexOf(frame) !== -1) {&#13;
                indexes.push(i);&#13;
            }&#13;
        }&#13;
&#13;
        return indexes;&#13;
    };&#13;
&#13;
    presenter._internal = {&#13;
        deferredSyncQueue: deferredSyncQueue&#13;
    };&#13;
&#13;
    function showLabelsForFrame(frame) {&#13;
        var labels = presenter.configuration.labels.content,&#13;
            indexes = presenter.getLabelIndexesForFrame(labels, frame);&#13;
&#13;
        presenter.hideLabels();&#13;
&#13;
        if (!presenter.configuration.isVisible) return;&#13;
&#13;
        for (var i = 0, length = indexes.length; i &lt; length; i++) {&#13;
            $(presenter.DOMElements.viewContainer).find('.animation-label:eq(' + indexes[i] + ')').css('visibility', 'visible');&#13;
        }&#13;
    }&#13;
&#13;
    // This function is from https://github.com/stomita/ios-imagefile-megapixel&#13;
    function detectVerticalSquash(img) {&#13;
        if (!navigator.userAgent.match(/(iPad|iPhone|iPod touch);.*CPU.*OS 7_\d/i)){&#13;
            return 1;&#13;
        }&#13;
&#13;
        try {&#13;
            var iw = img.naturalWidth, ih = img.naturalHeight;&#13;
            var canvas = document.createElement('canvas');&#13;
            canvas.width = 1;&#13;
            canvas.height = ih;&#13;
            var ctx = canvas.getContext('2d');&#13;
            ctx.drawImage(img, 0, 0);&#13;
            var data = ctx.getImageData(0, 0, 1, ih).data;&#13;
            // search image edge pixel position in case it is squashed vertically.&#13;
            var sy = 0;&#13;
            var ey = ih;&#13;
            var py = ih;&#13;
            while (py &gt; sy) {&#13;
                var alpha = data[(py - 1) * 4 + 3];&#13;
                if (alpha === 0) {&#13;
                    ey = py;&#13;
                } else {&#13;
                    sy = py;&#13;
                }&#13;
                py = (ey + sy) &gt;&gt; 1;&#13;
            }&#13;
            var ratio = (py / ih);&#13;
        }&#13;
        catch (err) {&#13;
            // we expect Security error on SVG files&#13;
            return 1;&#13;
        }&#13;
        return (ratio === 0) ? 1 : ratio;&#13;
    }&#13;
&#13;
    function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {&#13;
        var vertSquashRatio = detectVerticalSquash(img);&#13;
        ctx.clearRect(0, 0, presenter.canvas.width, presenter.canvas.height);&#13;
        ctx.drawImage(img, sx * vertSquashRatio, sy * vertSquashRatio,&#13;
            sw * vertSquashRatio, sh * vertSquashRatio,&#13;
            dx, dy, dw, dh );&#13;
    }&#13;
&#13;
    presenter.sendEndAnimationEvent = function () {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': '',&#13;
            'value': 'ended',&#13;
            'score': ''&#13;
        };&#13;
        &#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    };&#13;
&#13;
    presenter.endAnimationHandler = function () {&#13;
        if (presenter.configuration.animationState == presenter.ANIMATION_STATE.ENDED &amp;&amp;&#13;
            (!presenter.playerController.isWCAGOn() || !isSpeaking)) {&#13;
            presenter.sendEndAnimationEvent();&#13;
            if (presenter.playerController.isWCAGOn()) {&#13;
                presenter.stop();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function (playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.speak = function(data, callback) {&#13;
        var tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
&#13;
        if (tts &amp;&amp; presenter.playerController.isWCAGOn()) {&#13;
            tts.speakWithCallback(data, callback);&#13;
        }&#13;
    };&#13;
&#13;
    var delayedSpeakInterval = null; // only used by speakWithDelay, which is why they are here and not at the top of the file&#13;
    var delayedSpeakTimeout = null;&#13;
    //This method works like speak, except that it waits for TTS to be idle instead of interrupting it&#13;
    presenter.speakWithDelay = function (data, callback) {&#13;
        presenter.stopDelayedTTS();&#13;
&#13;
        function setSpeakInterval (data, callback) {&#13;
            delayedSpeakInterval = setInterval(function () {&#13;
                var speechSynthSpeaking = false;&#13;
                var responsiveVoiceSpeaking = false;&#13;
&#13;
                // Detect if TTS is idle&#13;
                if ('speechSynthesis' in window) {&#13;
                    speechSynthSpeaking = window.speechSynthesis.speaking;&#13;
                }&#13;
                if (window.responsiveVoice) {&#13;
                    responsiveVoiceSpeaking = window.responsiveVoice.isPlaying();&#13;
                }&#13;
&#13;
                if (!speechSynthSpeaking &amp;&amp; !responsiveVoiceSpeaking) {&#13;
                    // If TTS is idle, pass data to TTS and break the loop&#13;
                    clearInterval(delayedSpeakInterval);&#13;
                    delayedSpeakInterval = null;&#13;
                    var tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
                    if (tts &amp;&amp; presenter.playerController.isWCAGOn()) {&#13;
                        tts.speakWithCallback(data, callback);&#13;
                    }&#13;
                }&#13;
            }, 200);&#13;
        }&#13;
&#13;
        /*&#13;
        * The timeout is used to ensure that if animation is triggered by another addon,&#13;
        * that addon has the opportunity to use TTS first, since animation acts as feedback&#13;
        */&#13;
        delayedSpeakTimeout = setTimeout(function(){ setSpeakInterval(data, callback); }, 300);&#13;
    };&#13;
&#13;
    presenter.stopDelayedTTS = function() {&#13;
        if(delayedSpeakTimeout) {&#13;
            clearTimeout(delayedSpeakTimeout);&#13;
            delayedSpeakTimeout = null;&#13;
        }&#13;
         if(delayedSpeakInterval) {&#13;
            clearInterval(delayedSpeakInterval);&#13;
            delayedSpeakInterval = null;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.keyboardController = function(keycode, isShiftKeyDown, event) {&#13;
&#13;
        var keys = {&#13;
            ENTER: 13,&#13;
            SPACE: 32&#13;
        };&#13;
&#13;
        var enter = function() {&#13;
            event.preventDefault();&#13;
            presenter.stopDelayedTTS();&#13;
            if(!isShiftKeyDown) {&#13;
                presenter.speak([window.TTSUtils.getTextVoiceObject(presenter.configuration.altTextPreview, presenter.configuration.lang)]);&#13;
            }&#13;
        };&#13;
&#13;
        var space = function() {&#13;
            event.preventDefault();&#13;
            presenter.stopDelayedTTS();&#13;
            if (presenter.configuration.animationState == presenter.ANIMATION_STATE.PLAYING ||&#13;
                presenter.configuration.animationState == presenter.ANIMATION_STATE.ENDED ||&#13;
                isSpeaking) {&#13;
                presenter.stop();&#13;
                presenter.speak([window.TTSUtils.getTextVoiceObject(presenter.configuration.speechTexts.stop)]);&#13;
                isSpeaking = false;&#13;
            } else {&#13;
                presenter.stop();&#13;
                presenter.play();&#13;
            }&#13;
        };&#13;
&#13;
        var mapping = {};&#13;
        mapping[keys.ENTER] = enter;&#13;
        mapping[keys.SPACE] = space;&#13;
&#13;
        try {&#13;
            mapping[keycode]();&#13;
        } catch (er) {&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isEnterable = function() {return false};&#13;
&#13;
    presenter.markerWCAG = {}; // This is a marker identifying the addon as supporting WCAG to the editor&#13;
&#13;
    /**&#13;
     *&#13;
     * @param configuration {object}&#13;
     * @param configuration.image source image&#13;
     * @param configuration.sourceX {number} source x position&#13;
     * @param configuration.sourceY {number} source y position&#13;
     * @param configuration.sourceWidth {number} source width&#13;
     * @param configuration.sourceHeight {number} source height&#13;
     * @param configuration.destinationWidth {number} destination width&#13;
     * @param configuration.destinationHeight {number} destination height&#13;
     * @param configuration.destinationX {number} where source should be placed in destination x position&#13;
     * @param configuration.destinationY {number} where source should be placed in destination y position&#13;
     * @constructor&#13;
     */&#13;
    presenter.ImageWrapper = function (configuration) {&#13;
        this.image = configuration.image;&#13;
        this.sourceX = configuration.sourceX;&#13;
        this.sourceY = configuration.sourceY;&#13;
        this.sourceWidth = configuration.sourceWidth;&#13;
        this.sourceHeight = configuration.sourceHeight;&#13;
        this.destinationWidth = configuration.destinationWidth;&#13;
        this.destinationHeight = configuration.destinationHeight;&#13;
        this.destinationX = configuration.destinationX;&#13;
        this.destinationY = configuration.destinationY;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>