<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Standard_Shapes" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Shape" nameLabel="Standard_Shapes_property_shape" type="{Line, Square, Rectangle, Circle, Ellipse}"/>
		<property name="Rotation angle" nameLabel="Standard_Shapes_property_rotation_angle" type="string"/>
		<property name="Stroke width" nameLabel="Standard_Shapes_property_stroke_width" type="string"/>
		<property name="Stroke color" nameLabel="Standard_Shapes_property_stroke_color" type="string"/>
		<property name="Corners rounding" nameLabel="Standard_Shapes_property_corners_rounding" type="boolean"/>
		<property name="Line ending" nameLabel="Standard_Shapes_property_line_ending" type="{None, Circles, Arrows, None - Arrow, None - Circle, Circle - Arrow}"/>
		<property name="Stroke opacity" nameLabel="Standard_Shapes_property_stroke_opacity" type="string"/>
		<property name="Fill color" nameLabel="Standard_Shapes_property_fill_color" type="string"/>
		<property name="printable" nameLabel="printable_name_label" type="{No, Don't randomize, Randomize}"/>
	</model>
<css>.standardshapes-wrapper {&#13;
    border: 0 solid black;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    /*overflow: hidden;*/&#13;
}&#13;
</css><view>&lt;div class="standardshapes-wrapper"&gt;&#13;
&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="standardshapes-wrapper"&gt;&#13;
&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonStandard_Shapes_create(){&#13;
    var presenter = function() {};&#13;
&#13;
    presenter.SHAPES = {&#13;
        LINE: 'Line',&#13;
        SQUARE: 'Square',&#13;
        RECTANGLE: 'Rectangle',&#13;
        CIRCLE: 'Circle',&#13;
        ELLIPSE: 'Ellipse'&#13;
    };&#13;
&#13;
    presenter.LINE_ENDING = {&#13;
        NONE: 'None',&#13;
        CIRCLES: 'Circles',&#13;
        ARROWS: 'Arrows',&#13;
        NONE_AND_ARROW: 'None - Arrow',&#13;
        NONE_AND_CIRCLE: 'None - Circle',&#13;
        CIRCLE_AND_ARROW: 'Circle - Arrow'&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'R01': "Rotation angle must be between 0 and 360 degrees!",&#13;
        'R02': "Rotation angle is not a number!",&#13;
        'ST1': "Stroke width must be a positive number",&#13;
        'ST2': "Stroke width is not a number!",&#13;
        'ST3': "Stroke color must be in RGB format (hexadecimal) and start with #",&#13;
        'ST4': "Stroke opacity must be a positive number between 0 and 1",&#13;
        'ST5': "Stroke opacity is not a number!",&#13;
        'F01': "Stroke color must be in RGB format (hexadecimal) and start with #",&#13;
        'RU1': "Addon dimensions are too small to draw line with endings (or stroke is too thick)!",&#13;
        'RU2': "Addon dimensions are too small to draw line with circle ending!",&#13;
        'RU3': "Addon dimensions are too small to draw line with circle-arrow ending!"&#13;
    };&#13;
&#13;
    function rotatePoint(x, y, angle) {&#13;
        return {&#13;
            x: x * Math.cos(angle) - y * Math.sin(angle),&#13;
            y: x * Math.sin(angle) + y * Math.cos(angle)&#13;
        };&#13;
    }&#13;
&#13;
    // Angle is counted in radians&#13;
    function rotatePoints(points, angle) {&#13;
        var rotatedPoints = [];&#13;
&#13;
        for (var i = 0; i &lt; points.length; i++) {&#13;
            var x = points[i].x;&#13;
            var y = points[i].y;&#13;
&#13;
            rotatedPoints.push(rotatePoint(x, y, angle));&#13;
        }&#13;
&#13;
        return rotatedPoints;&#13;
    }&#13;
&#13;
    function convertToRadians(degrees) {&#13;
        return degrees * Math.PI / 180;&#13;
    }&#13;
&#13;
    function translatePoint(x, y, xOffset, yOffset) {&#13;
        return {&#13;
            x: x + xOffset,&#13;
            y: y + yOffset&#13;
        };&#13;
    }&#13;
&#13;
    function translatePoints(points, xOffset, yOffset) {&#13;
        var translatedPoints = [];&#13;
&#13;
        for (var i = 0; i &lt; points.length; i++) {&#13;
            var x = points[i].x;&#13;
            var y = points[i].y;&#13;
&#13;
            translatedPoints.push(translatePoint(x, y, xOffset, yOffset));&#13;
        }&#13;
&#13;
        return translatedPoints;&#13;
    }&#13;
&#13;
    function calculateScale(points, width, height) {&#13;
        var farLeftX = 0;&#13;
        var farRightX = 0;&#13;
        var bottomY = 0;&#13;
        var topY = 0;&#13;
&#13;
        for (var i = 0; i &lt; points.length; i++) {&#13;
            if (points[i].x &lt; farLeftX) {&#13;
                farLeftX = points[i].x;&#13;
            }&#13;
            if (points[i].y &lt; bottomY) {&#13;
                bottomY = points[i].y;&#13;
            }&#13;
&#13;
            if (points[i].x &gt; farRightX) {&#13;
                farRightX = points[i].x;&#13;
            }&#13;
            if (points[i].y &gt; topY) {&#13;
                topY = points[i].y;&#13;
            }&#13;
        }&#13;
&#13;
        var widthAfterRotation = Math.abs(farLeftX) + Math.abs(farRightX);&#13;
        var heightAfterRotation = Math.abs(bottomY) + Math.abs(topY);&#13;
&#13;
        return Math.min(width / widthAfterRotation, height / heightAfterRotation);&#13;
    }&#13;
&#13;
    function getScale(width, height, angle) {&#13;
        var points = [];&#13;
        points[0] = {x:0, y:0};&#13;
        points[1] = {x:width, y:0};&#13;
        points[2] = {x:width, y:height};&#13;
        points[3] = {x:0, y:height};&#13;
&#13;
        var xOffset = -1 * width / 2;&#13;
        var yOffset = -1 * height / 2;&#13;
&#13;
        var translatedPoints = translatePoints(points, xOffset, yOffset);&#13;
        var rotatedPoints = rotatePoints(translatedPoints, convertToRadians(angle));&#13;
&#13;
        return calculateScale(rotatedPoints, width, height);&#13;
    }&#13;
&#13;
    function drawShape(model, wrapper, width, height, angle) {&#13;
        var scale = getScale(width, height, angle);&#13;
        var length = Math.min(width, height);&#13;
        // Ugly fix for SVG elements that are smaller than 20px to position it's elements properly&#13;
        var paper = new Raphael(wrapper, width &lt; 20 ? 20 : width, height &lt; 20 ? 20 : height);&#13;
&#13;
        switch (model.Shape) {&#13;
            case presenter.SHAPES.SQUARE:&#13;
                presenter.drawRectangle(paper, length, length, angle, scale);&#13;
                break;&#13;
            case presenter.SHAPES.RECTANGLE:&#13;
                presenter.drawRectangle(paper, width, height, angle, scale);&#13;
                break;&#13;
            case presenter.SHAPES.CIRCLE:&#13;
                presenter.drawEllipse(paper, length, length, angle, 1);&#13;
                break;&#13;
            case presenter.SHAPES.ELLIPSE:&#13;
                presenter.drawEllipse(paper, width, height, angle, scale);&#13;
                break;&#13;
            default:&#13;
                presenter.drawLine(paper, width, height, angle, scale);&#13;
        }&#13;
    }&#13;
&#13;
    function presenterLogic(view, model) {&#13;
        presenter.$view = $(view);&#13;
        var containerDimensions = DOMOperationsUtils.getOuterDimensions(presenter.$view);&#13;
        var containerDistances = DOMOperationsUtils.calculateOuterDistances(containerDimensions);&#13;
        presenter.$view.css({&#13;
            width : (presenter.$view.width() - containerDistances.horizontal) + 'px',&#13;
            height : (presenter.$view.height() - containerDistances.vertical) + 'px'&#13;
        });&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
        var canvasWrapper = presenter.$view.find('.standardshapes-wrapper:first')[0];&#13;
        var wrapperDimensions = DOMOperationsUtils.getOuterDimensions(canvasWrapper);&#13;
        var wrapperDistances = DOMOperationsUtils.calculateOuterDistances(wrapperDimensions);&#13;
&#13;
        var canvasWrapperWidth = presenter.$view.width() - wrapperDistances.horizontal;&#13;
        var canvasWrapperHeight = presenter.$view.height() - wrapperDistances.vertical;&#13;
        $(canvasWrapper).css({&#13;
            width : (canvasWrapperWidth &lt; 1 ? model.Width : canvasWrapperWidth) + 'px',&#13;
            height : (canvasWrapperHeight &lt; 1 ? model.Height : canvasWrapperHeight) + 'px'&#13;
        });&#13;
&#13;
        var angle = parseInt(presenter.configuration.rotation);&#13;
        drawShape(model, canvasWrapper, canvasWrapperWidth, canvasWrapperHeight, angle);&#13;
    }&#13;
&#13;
    presenter.applyStyles = function(element) {&#13;
        element.attr({&#13;
            'stroke-width': presenter.configuration.strokeWidth,&#13;
            'stroke': presenter.configuration.strokeColor,&#13;
            'stroke-opacity': presenter.configuration.strokeOpacity,&#13;
            'fill': presenter.configuration.fillColor,&#13;
            'fill-rule': 'evenodd'&#13;
        });&#13;
&#13;
        if (presenter.configuration.cornersRoundings) {&#13;
            element.attr('stroke-linejoin', 'round');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.applyLineStyles = function(element) {&#13;
        presenter.applyStyles(element);&#13;
        element.attr('fill', presenter.configuration.strokeColor);&#13;
    };&#13;
&#13;
&#13;
  /*  presenter.drawRectangle = function (paper, width, height, angle, scale) {&#13;
        var rectangle = paper.rect(presenter.configuration.strokeWidth / 2, presenter.configuration.strokeWidth / 2, width - presenter.configuration.strokeWidth, height - presenter.configuration.strokeWidth);&#13;
        presenter.applyStyles(rectangle);&#13;
        rectangle.transform("r" + angle + "s" + scale);&#13;
    };&#13;
    */&#13;
    // corner radius적&#13;
	presenter.drawRectangle = function (paper, width, height, angle, scale) {&#13;
        var rectangle;&#13;
        /*if (presenter.configuration.cornersRoundings) {&#13;
            rectangle = paper.rect(presenter.configuration.strokeWidth / 2, presenter.configuration.strokeWidth / 2, width - presenter.configuration.strokeWidth, height - presenter.configuration.strokeWidth, 20);&#13;
        }else{&#13;
            rectangle = paper.rect(presenter.configuration.strokeWidth / 2, presenter.configuration.strokeWidth / 2, width - presenter.configuration.strokeWidth, height - presenter.configuration.strokeWidth);&#13;
        }*/&#13;
&#13;
        if (presenter.configuration.cornersRoundings) {&#13;
&#13;
        	var radius = parseInt(presenter.configuration.arcSize)/2;&#13;
        	if( radius &lt; 0 ){&#13;
            	radius = height / 10 * 1.5;&#13;
            	radius = Math.min(150, radius);&#13;
            }&#13;
            //var radius = 15;&#13;
            rectangle = paper.rect(presenter.configuration.strokeWidth / 2, presenter.configuration.strokeWidth / 2, width - presenter.configuration.strokeWidth, height - presenter.configuration.strokeWidth, radius);&#13;
        }else{&#13;
            rectangle = paper.rect(presenter.configuration.strokeWidth / 2, presenter.configuration.strokeWidth / 2, width - presenter.configuration.strokeWidth, height - presenter.configuration.strokeWidth);&#13;
        }&#13;
        presenter.applyStyles(rectangle);&#13;
        rectangle.transform("r" + angle + "s" + scale);&#13;
    };&#13;
&#13;
    presenter.drawEllipse = function (paper, width, height, angle, scale) {&#13;
        var rectangle = paper.ellipse(width / 2, height / 2, (width - presenter.configuration.strokeWidth) / 2, (height - presenter.configuration.strokeWidth) / 2);&#13;
        presenter.applyStyles(rectangle);&#13;
        rectangle.transform("r" + angle + "s" + scale);&#13;
    };&#13;
&#13;
    function transformShape(paper, element, scale, angle, width, height) {&#13;
        var roundedScale = Math.round(scale * 100) / 100; // Rounding scale to two decimal places&#13;
        var cx = parseInt(width / 2, 10);&#13;
        var cy = parseInt(height / 2, 10);&#13;
&#13;
        element.transform("r" + angle + "," + cx + "," + cy);&#13;
        element.transform("...s" + roundedScale + "," + roundedScale + "," + cx + "," + cy);&#13;
    }&#13;
&#13;
    function calculateLinePoints(width, height) {&#13;
        return [&#13;
            { x: 0, y: 0 },&#13;
            { x: width, y: 0 },&#13;
            { x: width, y: height },&#13;
            { x: 0, y: height}&#13;
        ];&#13;
    }&#13;
&#13;
    function calculateArrowPoints(lineEnding, width, height, arrowHeight) {&#13;
        var points = [];&#13;
&#13;
        switch(lineEnding) {&#13;
            case presenter.LINE_ENDING.ARROWS:&#13;
                points.push({&#13;
                    x: presenter.configuration.strokeWidth,&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: parseInt(arrowHeight, 10),&#13;
                    y: presenter.configuration.strokeWidth&#13;
                });&#13;
                points.push({&#13;
                    x: parseInt(arrowHeight, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: presenter.configuration.strokeWidth&#13;
                });&#13;
                points.push({&#13;
                    x: width - presenter.configuration.strokeWidth,&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: height - presenter.configuration.strokeWidth&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: parseInt(arrowHeight, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: parseInt(arrowHeight, 10),&#13;
                    y: height - presenter.configuration.strokeWidth&#13;
                });&#13;
                break;&#13;
            case presenter.LINE_ENDING.NONE_AND_ARROW:&#13;
                points.push({&#13;
                    x: 0,&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: presenter.configuration.strokeWidth + 2&#13;
                });&#13;
                points.push({&#13;
                    x: width - presenter.configuration.strokeWidth,&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: height - presenter.configuration.strokeWidth - 2&#13;
                });&#13;
                points.push({&#13;
                    x: width - parseInt(arrowHeight, 10),&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                points.push({&#13;
                    x: 0,&#13;
                    y: parseInt(height / 2, 10)&#13;
                });&#13;
                break;&#13;
        }&#13;
&#13;
        return points;&#13;
    }&#13;
&#13;
    function calculateCirclePoints(lineEnding, width, height, horizontalAxis) {&#13;
        var points = {};&#13;
&#13;
        switch(lineEnding) {&#13;
            case presenter.LINE_ENDING.CIRCLES:&#13;
                points.pointA = {&#13;
                    x: 2 * horizontalAxis + (presenter.configuration.strokeWidth / 2) + 1.5,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                points.pointB = {&#13;
                    x: width - 2 * horizontalAxis - (presenter.configuration.strokeWidth / 2) - 1.5,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                points.pointC = {&#13;
                    x: width - 2 * horizontalAxis - (presenter.configuration.strokeWidth / 2) - 1.5,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                points.pointD = {&#13;
                    x: 2 * horizontalAxis + (presenter.configuration.strokeWidth / 2) + 1.5,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                break;&#13;
            case presenter.LINE_ENDING.NONE_AND_CIRCLE:&#13;
                points.pointA = {&#13;
                    x: 0,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                points.pointB = {&#13;
                    x: width - 2 * horizontalAxis - (presenter.configuration.strokeWidth / 2) - 1.5,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                points.pointC = {&#13;
                    x: width - 2 * horizontalAxis - (presenter.configuration.strokeWidth / 2) - 1.5,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
                points.pointD = {&#13;
                    x: 0,&#13;
                    y: parseInt(height / 2, 10)&#13;
                };&#13;
        }&#13;
&#13;
        return points;&#13;
    }&#13;
&#13;
    function calculateCircleAndArrowPoints(width, height, arrowHeight) {&#13;
        var points = {};&#13;
&#13;
        points.pointA = {&#13;
            x: parseInt(height + presenter.configuration.strokeWidth / 2, 10),&#13;
            y: parseInt(height / 2 + 1, 10)&#13;
        };&#13;
        points.pointB = {&#13;
            x: width - parseInt(arrowHeight, 10),&#13;
            y: parseInt(height / 2 + 1, 10)&#13;
        };&#13;
        points.pointC = {&#13;
            x: width - parseInt(arrowHeight, 10),&#13;
            y: presenter.configuration.strokeWidth&#13;
        };&#13;
        points.pointD = {&#13;
            x: width - presenter.configuration.strokeWidth,&#13;
            y: parseInt(height / 2, 10)&#13;
        };&#13;
        points.pointE = {&#13;
            x: width - parseInt(arrowHeight, 10),&#13;
            y: parseInt(height - presenter.configuration.strokeWidth, 10)&#13;
        };&#13;
        points.pointF = {&#13;
            x: width - parseInt(arrowHeight, 10),&#13;
            y: parseInt(height / 2 + 1, 10)&#13;
        };&#13;
        points.pointG = {&#13;
            x: parseInt(height + presenter.configuration.strokeWidth / 2, 10),&#13;
            y: parseInt(height / 2 + 1, 10)&#13;
        };&#13;
&#13;
        return points;&#13;
    }&#13;
&#13;
    function drawLineFromPoints(points) {&#13;
        var pathString = "M" + points[0].x + "," + points[0].y;&#13;
        for (var i = 1; i &lt; points.length; i++) {&#13;
            pathString += "L" + points[i].x + "," + points[i].y;&#13;
        }&#13;
        pathString += "L" + points[0].x + "," + points[0].y + "Z";&#13;
&#13;
        return pathString;&#13;
    }&#13;
&#13;
    presenter.drawLine = function (paper, width, height, angle, scale) {&#13;
        var base = height - 2 * presenter.configuration.strokeWidth;&#13;
        var arrowHeight = parseInt(base * Math.sqrt(3) / 2, 10);&#13;
        var spareSpace = width - 2 * arrowHeight - 2 * presenter.configuration.strokeWidth;&#13;
&#13;
        if (presenter.configuration.lineEnding !== presenter.LINE_ENDING.NONE) {&#13;
            if (4 * presenter.configuration.strokeWidth + 2 &gt; height) {&#13;
                DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, 'RU1');&#13;
                return;&#13;
            }&#13;
        }&#13;
&#13;
        if (arrowHeight * 2 + presenter.configuration.strokeWidth &lt;= height) {&#13;
            arrowHeight--;&#13;
        } else if (spareSpace &lt; 2 * presenter.configuration.strokeWidth) {&#13;
            arrowHeight = parseInt(width / 2 - 4 * presenter.configuration.strokeWidth, 10);&#13;
        }&#13;
&#13;
        var radius = parseInt(height / 2, 10);&#13;
        var horizontalAxis = radius - (presenter.configuration.strokeWidth + 1) * 0.5;&#13;
        var verticalAxis = horizontalAxis + 0.5;&#13;
&#13;
        var points = [];&#13;
        var pathString;&#13;
&#13;
        switch(presenter.configuration.lineEnding) {&#13;
            case presenter.LINE_ENDING.NONE:&#13;
                points = calculateLinePoints(width, height);&#13;
                pathString = drawLineFromPoints(points);&#13;
&#13;
                break;&#13;
            case presenter.LINE_ENDING.ARROWS:&#13;
                points = calculateArrowPoints(presenter.LINE_ENDING.ARROWS, width, height, arrowHeight);&#13;
                pathString = drawLineFromPoints(points);&#13;
&#13;
                break;&#13;
            case presenter.LINE_ENDING.NONE_AND_ARROW:&#13;
                points = calculateArrowPoints(presenter.LINE_ENDING.NONE_AND_ARROW, width, height, arrowHeight);&#13;
                pathString = drawLineFromPoints(points);&#13;
&#13;
                break;&#13;
            case presenter.LINE_ENDING.CIRCLES:&#13;
                if (4 * radius &gt; width - 1) {&#13;
                    DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, 'RU1');&#13;
                    return;&#13;
                }&#13;
&#13;
                points = calculateCirclePoints(presenter.LINE_ENDING.CIRCLES, width, height, horizontalAxis);&#13;
&#13;
                pathString = "M" + points.pointA.x + "," + points.pointA.y + "L" + points.pointB.x + "," + points.pointB.y;&#13;
                pathString += "A" + horizontalAxis + " " + verticalAxis + " 90 1 0 " + points.pointC.x + " " + (points.pointC.y - 1);&#13;
                pathString += "L" + points.pointC.x + "," + points.pointC.y;&#13;
                pathString += "L" + points.pointD.x + "," + points.pointD.y;&#13;
                pathString += "A" + horizontalAxis + " " + verticalAxis + " 90 1 1 " + points.pointA.x + " " + (points.pointA.y - 1);&#13;
                pathString += "L" + points.pointA.x + "," + points.pointA.y;&#13;
                pathString += "Z";&#13;
&#13;
                break;&#13;
            case presenter.LINE_ENDING.NONE_AND_CIRCLE:&#13;
                if (2 * radius &gt; width - 1) {&#13;
                    DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, 'RU2');&#13;
                    return;&#13;
                }&#13;
&#13;
                points = calculateCirclePoints(presenter.LINE_ENDING.NONE_AND_CIRCLE, width, height, horizontalAxis);&#13;
&#13;
                pathString = "M" + points.pointA.x + "," + points.pointA.y + "L" + points.pointB.x + "," + points.pointB.y;&#13;
                pathString += "A" + horizontalAxis + " " + verticalAxis + " 90 1 0 " + points.pointC.x + " " + (points.pointC.y - 1);&#13;
                pathString += "L" + points.pointC.x + "," + points.pointC.y;&#13;
                pathString += "L" + points.pointD.x + "," + points.pointD.y;&#13;
                pathString += "Z";&#13;
                break;&#13;
            case presenter.LINE_ENDING.CIRCLE_AND_ARROW:&#13;
                if (2 * radius + arrowHeight &gt; width - 1) {&#13;
                    DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.ERROR_CODES, 'RU3');&#13;
                    return;&#13;
                }&#13;
&#13;
                points = calculateCircleAndArrowPoints(width, height, arrowHeight);&#13;
&#13;
                pathString = "M" + points.pointA.x + "," + points.pointA.y + "L" + points.pointB.x + "," + points.pointB.y;&#13;
                pathString += "L" + points.pointC.x + "," + points.pointC.y;&#13;
                pathString += "L" + points.pointD.x + "," + points.pointD.y;&#13;
                pathString += "L" + points.pointE.x + "," + points.pointE.y;&#13;
                pathString += "L" + points.pointF.x + "," + points.pointF.y;&#13;
                pathString += "L" + points.pointG.x + "," + points.pointG.y;&#13;
                pathString += "A" + horizontalAxis + " " + verticalAxis + " 90 1 1 " + points.pointA.x + " " + (points.pointA.y - 1);&#13;
                pathString += "L" + points.pointA.x + "," + points.pointA.y;&#13;
                pathString += "Z";&#13;
                break;&#13;
        }&#13;
&#13;
        var path = paper.path(pathString);&#13;
        presenter.applyLineStyles(path);&#13;
        transformShape(paper, path, scale, angle, width, height);&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenterLogic(view, model);&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.run = function(view, model){&#13;
        presenterLogic(view, model);&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var shape = model.Shape ? model.Shape : presenter.SHAPES.LINE;&#13;
&#13;
        var rotation = model["Rotation angle"];&#13;
        if (!rotation) {&#13;
            rotation = 0;&#13;
        } else {&#13;
            rotation = parseFloat(rotation);&#13;
            if (isNaN(rotation)) {&#13;
                return { isError: true, errorCode: 'R02' };&#13;
            }&#13;
&#13;
            if (rotation &lt; 0 || rotation &gt; 360) {&#13;
                return { isError: true, errorCode: 'R01' };&#13;
            }&#13;
        }&#13;
&#13;
        var strokeWidth = model["Stroke width"];&#13;
        if (!strokeWidth) {&#13;
            strokeWidth = 1;&#13;
        } else {&#13;
            strokeWidth = parseFloat(strokeWidth);&#13;
            if (isNaN(strokeWidth)) {&#13;
                return { isError: true, errorCode: 'ST2' };&#13;
            }&#13;
&#13;
            if (strokeWidth &lt;= 0) {&#13;
                return { isError: true, errorCode: 'ST1' };&#13;
            }&#13;
        }&#13;
&#13;
        var strokeColor = model["Stroke color"];&#13;
        var regExp = new RegExp("#[0-9a-fA-F]+");&#13;
        var colorMatch;&#13;
&#13;
        if (!strokeColor) {&#13;
            strokeColor = "#000";&#13;
        } else {&#13;
            if (strokeColor.length &lt; 4 || strokeColor.length &gt; 7) {&#13;
                return { isError: true, errorCode: 'ST3' };&#13;
            }&#13;
&#13;
            colorMatch = strokeColor.match(regExp);&#13;
            if (!colorMatch || colorMatch === null || colorMatch.length &lt; 1) {&#13;
                return { isError: true, errorCode: 'ST3' };&#13;
            }&#13;
            if (colorMatch[0].length &lt; strokeColor.length) {&#13;
                return { isError: true, errorCode: 'ST3' };&#13;
            }&#13;
        }&#13;
&#13;
        var fillColor = model["Fill color"];&#13;
        if (!fillColor) {&#13;
            fillColor = "#FFF";&#13;
        } else {&#13;
            if (fillColor.length &lt; 4 || fillColor.length &gt; 7) {&#13;
                return { isError: true, errorCode: 'F01' };&#13;
            }&#13;
&#13;
            colorMatch = fillColor.match(regExp);&#13;
            if (!colorMatch || colorMatch === null || colorMatch.length &lt; 1) {&#13;
                return { isError: true, errorCode: 'F01' };&#13;
            }&#13;
            if (colorMatch[0].length &lt; fillColor.length) {&#13;
                return { isError: true, errorCode: 'F01' };&#13;
            }&#13;
        }&#13;
&#13;
        var cornersRoundings = model["Corners rounding"];&#13;
        if (!cornersRoundings) {&#13;
            cornersRoundings = false;&#13;
        } else {&#13;
            cornersRoundings = cornersRoundings === 'True';&#13;
        }&#13;
&#13;
        var arcSize = model["ArcSize"];&#13;
&#13;
        var strokeOpacity = model["Stroke opacity"];&#13;
        if (!strokeOpacity) {&#13;
            strokeOpacity = 1;&#13;
        } else {&#13;
            strokeOpacity = parseFloat(strokeOpacity);&#13;
            if (isNaN(strokeOpacity)) {&#13;
                return { isError: true, errorCode: 'ST5' };&#13;
            }&#13;
&#13;
            if (strokeOpacity &lt; 0 || strokeOpacity &gt; 1) {&#13;
                return { isError: true, errorCode: 'ST4' };&#13;
            }&#13;
        }&#13;
&#13;
        var lineEnding = model["Line ending"];&#13;
        if (!lineEnding) {&#13;
            lineEnding = presenter.LINE_ENDING.NONE;&#13;
        }&#13;
&#13;
        var isVisibleByDefault = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            shape: shape,&#13;
            rotation: rotation,&#13;
            strokeWidth: strokeWidth,&#13;
            strokeColor: strokeColor,&#13;
            fillColor: fillColor,&#13;
            cornersRoundings: cornersRoundings,&#13;
            strokeOpacity: strokeOpacity,&#13;
            lineEnding: lineEnding,&#13;
            isVisibleByDefault: isVisibleByDefault,&#13;
            isVisible: isVisibleByDefault,&#13;
            arcSize: arcSize&#13;
        };&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        var isVisible = JSON.parse(state).isVisible;&#13;
&#13;
        presenter.configuration.isVisible = isVisible;&#13;
        presenter.setVisibility(isVisible);&#13;
    };&#13;
&#13;
    presenter.getPrintableHTML = function (model, showAnswers) {&#13;
        var $printableView = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $printableView.addClass("printable_addon_Standard_Shapes");&#13;
        $printableView.css("height", model.Height + "px");&#13;
        $printableView.css("width", model.Width + "px");&#13;
        var $wrapper = $("&lt;div class=\"standardshapes-wrapper\"&gt;&lt;/div&gt;");&#13;
        $printableView.append($wrapper);&#13;
        $printableView.css("visibility", "hidden");&#13;
        $('body').append($printableView);&#13;
        presenterLogic($printableView[0], model);&#13;
        $printableView.detach();&#13;
        $printableView.css("visibility", "");&#13;
        return $printableView[0].outerHTML;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>