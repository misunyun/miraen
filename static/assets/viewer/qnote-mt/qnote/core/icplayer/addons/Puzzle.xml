<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Puzzle" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Columns" nameLabel="Puzzle_property_columns" type="string"/>
		<property name="Rows" nameLabel="Puzzle_property_rows" type="string"/>
		<property isDefault="true" name="Image" nameLabel="Puzzle_property_image" type="image"/>
		<property displayName="Is Not Activity" name="isNotActivity" nameLabel="Puzzle_property_is_not_activity" type="boolean"/>
	</model>
<css>.puzzle-container {&#13;
    border: 2px solid black;&#13;
    border-bottom-width: 1px;&#13;
    border-right-width: 1px;&#13;
    overflow: hidden;&#13;
    position: relative;&#13;
}&#13;
&#13;
.mark {&#13;
    position: absolute;&#13;
    z-index: 0;&#13;
    width: 35px;&#13;
    height: 34px;&#13;
}&#13;
&#13;
.mark.wrong {&#13;
    background-image: url('resources/puzzle-mark-wrong.png');&#13;
    z-index: 5;&#13;
}&#13;
&#13;
.mark.correct {&#13;
    background-image: url('resources/puzzle-mark-correct.png');&#13;
    z-index: 5;&#13;
}&#13;
&#13;
.puzzle {&#13;
    border: 1px solid black;&#13;
    border-top-width: 0;&#13;
    border-left-width: 0;&#13;
    z-index: 1;&#13;
    float: left;&#13;
    cursor: pointer;&#13;
    position: absolute;&#13;
}&#13;
&#13;
.selected {&#13;
    border-color: orange;&#13;
    z-index: 3;&#13;
}&#13;
&#13;
.hovered-over-by-other {&#13;
    opacity: 0.8;&#13;
}&#13;
&#13;
.being-hovered {&#13;
    z-index: 3;&#13;
}&#13;
</css><view>&lt;div class="puzzle-container"&gt;&#13;
    &lt;div&gt;&#13;
        &lt;img alt="Image" src="" style="visibility: hidden" /&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;img width="100%" height="100%"/&gt;&#13;
</preview><presenter>function AddonPuzzle_create() {&#13;
    var presenter = function () {};&#13;
&#13;
    /* Global variables */&#13;
    var board = []; // Array that will hold the 2-dimentional representation of the board.&#13;
    var indexBoard = []; // board storing marks&#13;
    var savedBoard = [];&#13;
&#13;
    var intPuzzleWidth = 0;&#13;
    var intPuzzleHeight = 0;&#13;
&#13;
    var animation = false;&#13;
    var clickNumber = 0; //Check if this is first or second click&#13;
&#13;
    //Keep data from first click&#13;
    var PieceOld;&#13;
    var PiecePos;&#13;
    var PiecePos2;&#13;
&#13;
    var DragStartPos;&#13;
    var DraggedPiece;&#13;
    var hoverClass = "being-hovered";&#13;
    var hoveredOverByOtherClass = "hovered-over-by-other";&#13;
&#13;
    var puzzleWidth = 0;&#13;
    var puzzleOuterWidth = 0;&#13;
    var puzzleHeight = 0;&#13;
    var puzzleOuterHeight = 0;&#13;
    var leftOffset = 0;&#13;
    var topOffset = 0;&#13;
&#13;
    var puzzle = null;&#13;
&#13;
    var Container;&#13;
    var jImg;&#13;
    var mark;&#13;
&#13;
    var playerController;&#13;
    var eventBus;&#13;
&#13;
    presenter.previousScore = 0;&#13;
    presenter.previousErrors = 0;&#13;
    presenter.isPreview = false;&#13;
&#13;
    function getElementDimensions(element) {&#13;
        element = $(element);&#13;
&#13;
        return {&#13;
            border: {&#13;
                top: parseInt(element.css('border-top-width'), 10),&#13;
                bottom: parseInt(element.css('border-bottom-width'), 10),&#13;
                left: parseInt(element.css('border-left-width'), 10),&#13;
                right: parseInt(element.css('border-right-width'), 10)&#13;
            },&#13;
            margin: {&#13;
                top: parseInt(element.css('margin-top'), 10),&#13;
                bottom: parseInt(element.css('margin-bottom'), 10),&#13;
                left: parseInt(element.css('margin-left'), 10),&#13;
                right: parseInt(element.css('margin-right'), 10)&#13;
            },&#13;
            padding: {&#13;
                top: parseInt(element.css('padding-top'), 10),&#13;
                bottom: parseInt(element.css('padding-bottom'), 10),&#13;
                left: parseInt(element.css('padding-left'), 10),&#13;
                right: parseInt(element.css('padding-right'), 10)&#13;
            }&#13;
        };&#13;
    }&#13;
&#13;
    function calculateOuterDistance(elementDimensions) {&#13;
        var top = elementDimensions.border.top;&#13;
        top += elementDimensions.margin.top;&#13;
        top += elementDimensions.padding.top;&#13;
&#13;
        var bottom = elementDimensions.border.bottom;&#13;
        bottom += elementDimensions.margin.bottom;&#13;
        bottom += elementDimensions.padding.bottom;&#13;
&#13;
        var left = elementDimensions.border.left;&#13;
        left += elementDimensions.margin.left;&#13;
        left += elementDimensions.padding.left;&#13;
&#13;
        var right = elementDimensions.border.right;&#13;
        right += elementDimensions.margin.right;&#13;
        right += elementDimensions.padding.right;&#13;
&#13;
        return {&#13;
            vertical: top + bottom,&#13;
            horizontal: left + right,&#13;
            top: top,&#13;
            bottom: bottom,&#13;
            left: left,&#13;
            right: right,&#13;
            paddingLeft: elementDimensions.padding.left,&#13;
            paddingTop: elementDimensions.padding.top&#13;
        };&#13;
    }&#13;
&#13;
    function getOuterDistances() {&#13;
        var containerDimensions = getElementDimensions(Container);&#13;
        var containerDistances = calculateOuterDistance(containerDimensions);&#13;
&#13;
        var puzzle = $(document.createElement("div"));&#13;
        puzzle.addClass('puzzle');&#13;
        $(Container).append(puzzle);&#13;
        var puzzleDimensions = getElementDimensions(puzzle);&#13;
        var puzzleDistances = calculateOuterDistance(puzzleDimensions);&#13;
        $(puzzle).remove();&#13;
&#13;
        return {&#13;
            container: containerDistances,&#13;
            puzzle: puzzleDistances&#13;
        };&#13;
    }&#13;
&#13;
    function getMarkDimensions() {&#13;
        var tempMark = $(document.createElement('div'));&#13;
        $(tempMark).addClass('mark').addClass('correct');&#13;
        $(Container).append(tempMark);&#13;
&#13;
        var markWidth = $(tempMark).width();&#13;
        var markHeight = $(tempMark).height();&#13;
&#13;
        $(tempMark).remove();&#13;
&#13;
        return {&#13;
            width: markWidth,&#13;
            height: markHeight&#13;
        };&#13;
    }&#13;
&#13;
    function addBorderClasses() {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            h, v;&#13;
&#13;
        for (h = 0; h &lt; columns; h++) {&#13;
            $(board[0][h]).addClass('top');&#13;
            $(board[rows - 1][h]).addClass('bottom');&#13;
        }&#13;
&#13;
        for (v = 0; v &lt; rows; v++) {&#13;
            $(board[v][0]).addClass('left');&#13;
            $(board[v][columns - 1]).addClass('right');&#13;
        }&#13;
    }&#13;
&#13;
    function InitPuzzleBoard() {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns;&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            board[row] = [];&#13;
            indexBoard[row] = [];&#13;
            for (var col = 0; col &lt; columns; col++) {&#13;
                mark = $(document.createElement('div'));&#13;
                mark.addClass('mark');&#13;
                mark.attr("position", row + "-" + col);&#13;
                indexBoard[row][col] = mark;&#13;
&#13;
                puzzle = $(document.createElement("div"));&#13;
                puzzle.addClass('puzzle');&#13;
                puzzle.attr("position", row + "-" + col);&#13;
                puzzle.attr("href", "javascript:void( 0 );").click(clickHandler);&#13;
                board[row][col] = puzzle;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function InitPuzzle(width, height) {&#13;
        var outerDistances = getOuterDistances();&#13;
        var markDimensions = getMarkDimensions();&#13;
        var containerWidth = width - outerDistances.container.horizontal;&#13;
        var containerHeight = height - outerDistances.container.vertical;&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns;&#13;
&#13;
        puzzleWidth = parseInt(containerWidth / columns - outerDistances.puzzle.horizontal, 10);&#13;
        puzzleOuterWidth = puzzleWidth + outerDistances.puzzle.horizontal;&#13;
        puzzleHeight = parseInt(containerHeight / rows - outerDistances.puzzle.vertical, 10);&#13;
        puzzleOuterHeight = puzzleHeight + outerDistances.puzzle.vertical;&#13;
&#13;
        topOffset = outerDistances.container.paddingTop;&#13;
        leftOffset = outerDistances.container.paddingLeft;&#13;
&#13;
        var markHorizontalOffset = (puzzleOuterWidth - markDimensions.width) / 2;&#13;
        var markVerticalOffset = (puzzleOuterHeight - markDimensions.height) / 2;&#13;
&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var col = 0; col &lt; columns; col++) {&#13;
                mark = indexBoard[row][col];&#13;
                mark.css({&#13;
                    top: ((puzzleHeight * row + markVerticalOffset) + "px"),&#13;
                    left: ((puzzleWidth * col + markHorizontalOffset) + "px")&#13;
                });&#13;
                indexBoard[row][col] = mark;&#13;
                Container.append(mark);&#13;
&#13;
                puzzle = board[row][col];&#13;
                puzzle.css({&#13;
                    backgroundImage: "url( '" + jImg.attr("src") + "' )",&#13;
                    backgroundSize: width + "px " + height + "px",&#13;
                    backgroundRepeat: "no-repeat",&#13;
                    backgroundPosition: (&#13;
                        (col * -puzzleWidth) + "px " +&#13;
                            (row * -puzzleHeight) + "px"&#13;
                        ),&#13;
                    top: ((puzzleOuterHeight * row + topOffset) + "px"),&#13;
                    left: ((puzzleOuterWidth * col + leftOffset) + "px"),&#13;
                    width: puzzleWidth + 'px',&#13;
                    height: puzzleHeight + 'px'&#13;
                });&#13;
                board[row][col] = puzzle;&#13;
                Container.append(puzzle);&#13;
&#13;
                // first add it to DOM, then apply draggable, so that it won't add position: relative to element&#13;
                addDraggableDroppable(puzzle);&#13;
            }&#13;
        }&#13;
&#13;
        Container.css({&#13;
            width: (puzzleOuterWidth * columns) + 'px',&#13;
            height: (puzzleOuterHeight * rows) + 'px'&#13;
        });&#13;
&#13;
        addBorderClasses();&#13;
        Shuffle();&#13;
    }&#13;
&#13;
    function addDraggableDroppable(puzzle) {&#13;
        puzzle.draggable({&#13;
            delay: 150, // to give more time before drag starts, to prevent drags when clicking&#13;
            // don't use container or revert, as those options are bugged in subtle ways&#13;
            start: function(event,ui) {&#13;
                // clear state if it was clicked before&#13;
                clickNumber = 0;&#13;
&#13;
                // remove class selected, so that when user clicks on piece, and then starts to drag, it won't&#13;
                if (PieceOld)&#13;
                    PieceOld.removeClass('selected');&#13;
&#13;
                // this prevents clickHandler from being called, because jquery would call it in such situation:&#13;
                // user is dragging element, and lifts mouse button, and *pointer is still over element when drag stops*&#13;
                ui.helper.off("click");&#13;
&#13;
                DraggedPiece = ui.helper;&#13;
                DraggedPiece.addClass( hoverClass );&#13;
&#13;
                DragStartPos = presenter.getPiecePositionData(DraggedPiece);&#13;
&#13;
                ui.position.left = 0;&#13;
                ui.position.top = 0;&#13;
            },&#13;
            drag : function(event, ui) {&#13;
                const scale = getScale();&#13;
                const changeLeft = ui.position.left - ui.originalPosition.left;  // find change in left&#13;
                const newLeft = ui.originalPosition.left + changeLeft / scale.X; // adjust new left by our zoomScale&#13;
&#13;
                const changeTop = ui.position.top - ui.originalPosition.top;  // find change in top&#13;
                const newTop = ui.originalPosition.top + changeTop / scale.Y; // adjust new top by our zoomScale&#13;
&#13;
                ui.position.left = newLeft;&#13;
                ui.position.top = newTop;&#13;
            },&#13;
            stop: function(event,ui) {&#13;
&#13;
                if (DraggedPiece) {&#13;
                    // revert position&#13;
                    DraggedPiece.animate({&#13;
                        left: (DragStartPos.left + "px"),&#13;
                        top: (DragStartPos.top + "px")&#13;
                        }, 200,&#13;
                        function() { ui.helper.removeClass( hoverClass ); }&#13;
                    );&#13;
                    DraggedPiece = null;&#13;
                    DragStartPos = null;&#13;
                } else {&#13;
                    // it was dropped on other puzzle before, but we still need to clear hover&#13;
                    ui.helper.removeClass( hoverClass );&#13;
                }&#13;
&#13;
                sendEvents(puzzle);&#13;
&#13;
                // bringing it back here directly would make the click be called on puzzle (see comment in start), so we want&#13;
                // to do it in next browser update cycle&#13;
                setTimeout(&#13;
                    function() { ui.helper.attr("href", "javascript:void( 0 );").click(clickHandler); }&#13;
                    ,  0 );&#13;
            }&#13;
        });&#13;
&#13;
        puzzle.droppable({&#13;
            activate: function (event, ui) {&#13;
                const scale = getScale();&#13;
                // add marker to currently dragged element to scale its proportions&#13;
                if (presenter.$view.find( "." + hoverClass ).length &gt; 0 &amp;&amp; scale.X !== 1 &amp;&amp; scale.Y !== 1) {&#13;
                    $.ui.ddmanager.current.useScaledProportions = true;&#13;
                }&#13;
            },&#13;
            drop: function (event, ui) {&#13;
                if (!DragStartPos)&#13;
                    return;&#13;
&#13;
                var DraggedOnPiece = $(this);&#13;
                DraggedOnPiece.removeClass(hoveredOverByOtherClass);&#13;
&#13;
                var DragEndPos = presenter.getPiecePositionData(DraggedOnPiece);&#13;
&#13;
                board[DragEndPos.row][DragEndPos.col].animate({&#13;
                    left: ((puzzleOuterWidth * DragStartPos.col + leftOffset) + "px"),&#13;
                    top: ((puzzleOuterHeight * DragStartPos.row + topOffset) + "px")&#13;
                }, 200);&#13;
&#13;
                board[DragStartPos.row][DragStartPos.col].animate({&#13;
                    left: ((puzzleOuterWidth * DragEndPos.col + leftOffset) + "px"),&#13;
                    top: ((puzzleOuterHeight * DragEndPos.row + topOffset) + "px")&#13;
                }, 200);&#13;
&#13;
                var temp = board[DragStartPos.row][DragStartPos.col];&#13;
                board[DragStartPos.row][DragStartPos.col] = DraggedOnPiece;&#13;
                board[DragEndPos.row][DragEndPos.col] = temp;&#13;
&#13;
                replaceBorderClasses(board[DragStartPos.row][DragStartPos.col], board[DragEndPos.row][DragEndPos.col]);&#13;
&#13;
                DraggedPiece = null;&#13;
                DragStartPos = null;&#13;
            },&#13;
            over: function (event, ui) {&#13;
                $(this).addClass(hoveredOverByOtherClass);&#13;
            },&#13;
            // Triggered when an accepted draggable is dragged out of the droppable&#13;
            out: function (event, ui) {&#13;
                $(this).removeClass(hoveredOverByOtherClass);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    function getScale() {&#13;
        let $content = $("#content");&#13;
        if ($content.size() &gt; 0) {&#13;
            const contentElem = $content[0];&#13;
            const scaleX = contentElem.getBoundingClientRect().width / contentElem.offsetWidth;&#13;
            const scaleY = contentElem.getBoundingClientRect().height / contentElem.offsetHeight;&#13;
            return {X: scaleX, Y: scaleY};&#13;
        } else if (playerController) {&#13;
            const scale = playerController.getScaleInformation();&#13;
            return {X: scale.scaleX, Y: scale.scaleY};&#13;
        } else {&#13;
            return {X: 1.0, Y: 1.0};&#13;
        }&#13;
    }&#13;
&#13;
    presenter.getPiecePositionData = function(piece) {&#13;
        var Pos = {&#13;
            top: parseInt(piece.css("top")),&#13;
            left: parseInt(piece.css("left"))&#13;
        };&#13;
        Pos.row = Math.floor(((Pos.top - topOffset) / puzzleOuterHeight) + 0.5);&#13;
        Pos.col = Math.floor(((Pos.left - leftOffset) / puzzleOuterWidth) + 0.5);&#13;
        return Pos;&#13;
    };&#13;
&#13;
    /**&#13;
     * Fisher-Yates Shuffle algorithm: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle&#13;
     * Original algorithm is based on flatt, one-dimension array. For our purposes (working on two-dimension arrays)&#13;
     * firstly we have to flatten the structure.&#13;
     *&#13;
     * Additionally Knuth allows items to be shuffled multiple times - in our case each puzzle (array element) has to be&#13;
     * shuffled once, but the whole procedure should be repeated at least twice.&#13;
     */&#13;
&#13;
    presenter.getShuffleSequence = function (array) {&#13;
        var flatArray = [],&#13;
            shuffleSequence = [],&#13;
            row, column, counter, index;&#13;
&#13;
        for (row = 0; row &lt; array.length; row++) {&#13;
            for (column = 0; column &lt; array[row].length; column++) {&#13;
                flatArray.push({ row: row, column: column });&#13;
            }&#13;
        }&#13;
&#13;
        counter = flatArray.length - 1;&#13;
&#13;
        // While there are at least two elements in the array we generate next shuffle sequence. If array has only one&#13;
        // element we end the sequence (there is no sense in shuffling puzzle in place).&#13;
        while (counter &gt;= 2) {&#13;
            index = (Math.random() * counter) | 0;&#13;
&#13;
            shuffleSequence.push({&#13;
                row: { from: flatArray[counter].row, to: flatArray[index].row },&#13;
                column: { from: flatArray[counter].column, to: flatArray[index].column }&#13;
            });&#13;
&#13;
            flatArray.splice(index, 1);&#13;
            flatArray.splice(-1, 1);&#13;
&#13;
            counter -= 2;&#13;
        }&#13;
        return shuffleSequence;&#13;
    };&#13;
&#13;
    function Shuffle() {&#13;
        var i, iteration,&#13;
            shuffleSequence, shuffle,&#13;
            $firstPiece, $secondPiece;&#13;
&#13;
        animation = false; // Shuffling should be without animation&#13;
&#13;
&#13;
        for (iteration = 0; iteration &lt; 3; iteration++) {&#13;
            shuffleSequence = presenter.getShuffleSequence(board);&#13;
&#13;
            for (i = 0; i &lt; shuffleSequence.length; i++) {&#13;
                shuffle = shuffleSequence[i];&#13;
&#13;
                $firstPiece = board[shuffle.row.from][shuffle.column.from];&#13;
                $firstPiece.trigger({&#13;
                    type: "click",&#13;
                    triggered: true&#13;
                });&#13;
&#13;
&#13;
                $secondPiece = board[shuffle.row.to][shuffle.column.to];&#13;
                $secondPiece.trigger({&#13;
                    type: "click",&#13;
                    triggered: true&#13;
                });&#13;
            }&#13;
        }&#13;
&#13;
        animation = true;&#13;
    }&#13;
&#13;
    function elementHasClasses(element) {&#13;
        element = $(element);&#13;
&#13;
        return {&#13;
            top: element.hasClass('top'),&#13;
            bottom: element.hasClass('bottom'),&#13;
            left: element.hasClass('left'),&#13;
            right: element.hasClass('right')&#13;
        };&#13;
    }&#13;
&#13;
    function removeBorderClasses(element) {&#13;
        $(element).removeClass('top').removeClass('bottom').removeClass('left').removeClass('right');&#13;
    }&#13;
&#13;
    function applyBorderClasses(element, classes) {&#13;
        for (var className in classes) {&#13;
            if (classes[className]) {&#13;
                $(element).addClass(className);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function replaceBorderClasses(firstElement, secondElement) {&#13;
        var firstElementClasses = elementHasClasses(firstElement);&#13;
        var secondElementClasses = elementHasClasses(secondElement);&#13;
&#13;
        removeBorderClasses(firstElement);&#13;
        removeBorderClasses(secondElement);&#13;
&#13;
        applyBorderClasses(firstElement, secondElementClasses);&#13;
        applyBorderClasses(secondElement, firstElementClasses);&#13;
    }&#13;
&#13;
    function isSamePiece(piece1, piece2) {&#13;
        var piece1ID = $(piece1).attr('position'),&#13;
            piece2ID = $(piece2).attr('position');&#13;
&#13;
        return piece1ID == piece2ID;&#13;
    }&#13;
&#13;
    function clickHandler(event) {&#13;
        if(presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
        event.stopPropagation();&#13;
&#13;
        if (presenter.configuration.isErrorMode) return;&#13;
&#13;
        var Piece = $(this);&#13;
        // Check to see if we are in the middle of an animation.&#13;
        if (clickNumber == 0) {&#13;
            clickNumber = 1;&#13;
            PieceOld = $(this);&#13;
            PieceOld.addClass('selected');&#13;
            PiecePos = presenter.getPiecePositionData(Piece);&#13;
        } else {&#13;
            swapPieces(Piece, event);&#13;
        }&#13;
    }&#13;
&#13;
    function swapPieces(Piece,event) {&#13;
&#13;
        clickNumber = 0;&#13;
        PiecePos2 = presenter.getPiecePositionData(Piece);&#13;
        PieceOld.removeClass('selected');&#13;
&#13;
        if (isSamePiece(PieceOld, Piece)) return;&#13;
        if (!event.triggered) presenter.configuration.shouldCalcScore = true;&#13;
&#13;
        board[PiecePos2.row][PiecePos2.col] = PieceOld;&#13;
        board[PiecePos.row][PiecePos.col] = Piece;&#13;
&#13;
        if (animation) {&#13;
            //Animate change of places&#13;
            board[PiecePos.row][PiecePos.col].animate({&#13;
                left: ((puzzleOuterWidth * PiecePos.col + leftOffset) + "px"),&#13;
                top: ((puzzleOuterHeight * PiecePos.row + topOffset) + "px")&#13;
            }, 200);&#13;
&#13;
            board[PiecePos2.row][PiecePos2.col].animate({&#13;
                left: ((puzzleOuterWidth * PiecePos2.col + leftOffset) + "px"),&#13;
                top: ((puzzleOuterHeight * PiecePos2.row + topOffset) + "px")&#13;
            }, 200);&#13;
        } else {&#13;
            board[PiecePos.row][PiecePos.col].css({&#13;
                left: ((puzzleOuterWidth * PiecePos.col + leftOffset) + "px"),&#13;
                top: ((puzzleOuterHeight * PiecePos.row + topOffset) + "px")&#13;
            });&#13;
            board[PiecePos2.row][PiecePos2.col].css({&#13;
                left: ((puzzleOuterWidth * PiecePos2.col + leftOffset) + "px"),&#13;
                top: ((puzzleOuterHeight * PiecePos2.row + topOffset) + "px")&#13;
            });&#13;
        }&#13;
&#13;
        replaceBorderClasses(board[PiecePos.row][PiecePos.col], board[PiecePos2.row][PiecePos2.col]);&#13;
&#13;
        if (!event.triggered) {&#13;
            sendEvents(Piece);&#13;
        }&#13;
    }&#13;
&#13;
    function sendEvents(puzzle) {&#13;
        sendValueChangedEvent(puzzle);&#13;
        if (presenter.isAllOK()) {&#13;
            sendAllOKEvent();&#13;
        }&#13;
    }&#13;
&#13;
    function sendValueChangedEvent(puzzle) {&#13;
        var data = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': puzzle.attr("position"),&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
        eventBus.sendEvent('ValueChanged', data);&#13;
    }&#13;
&#13;
    function setNormalMode() {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            rowIndex, colIndex;&#13;
&#13;
        for (rowIndex = 0; rowIndex &lt; rows; rowIndex++) {&#13;
            for (colIndex = 0; colIndex &lt; columns; colIndex++) {&#13;
                indexBoard[rowIndex][colIndex].removeClass('wrong').removeClass('correct');&#13;
            }&#13;
        }&#13;
        presenter.setDraggableState("enable");&#13;
        presenter.configuration.isErrorMode = false;&#13;
    }&#13;
&#13;
    presenter.setDraggableState = function(state) {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns;&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var column = 0; column &lt; columns; column++) {&#13;
                var element = board[row][column];&#13;
                element.draggable( state );&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.reset = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        setNormalMode();&#13;
        Shuffle();&#13;
&#13;
        if (presenter.configuration.isVisibleByDefault) {&#13;
            presenter.show();&#13;
        } else {&#13;
            presenter.hide();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setMarkVisibility = function (isVisible) {&#13;
        // it will be called by createPreview, in which case indexBoard won't be created&#13;
        if (presenter.isPreview || indexBoard.length === 0) {&#13;
            return;&#13;
        }&#13;
&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            rowIndex, colIndex;&#13;
&#13;
        for (rowIndex = 0; rowIndex &lt; rows; rowIndex++) {&#13;
            for (colIndex = 0; colIndex &lt; columns; colIndex++) {&#13;
                indexBoard[rowIndex][colIndex].css("visibility", isVisible ? "visible" : "hidden");&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.prepareBoardFromSavedState = function (savedBoard) {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            index, rowIndex, colIndex,&#13;
            newBoard = [],&#13;
            puzzle, savedPuzzle;&#13;
&#13;
        animation = false;&#13;
&#13;
        for (rowIndex = 0; rowIndex &lt; rows; rowIndex++) {&#13;
            newBoard[rowIndex] = [];&#13;
        }&#13;
&#13;
        for (rowIndex = 0; rowIndex &lt; rows; rowIndex++) {&#13;
            for (colIndex = 0; colIndex &lt; columns; colIndex++) {&#13;
                puzzle = board[rowIndex][colIndex];&#13;
                for (index = 0; index &lt; savedBoard.length; index++) {&#13;
                    if (puzzle.attr("position") == savedBoard[index].position) {&#13;
                        savedPuzzle = savedBoard[index];&#13;
                        newBoard[savedPuzzle.row][savedPuzzle.col] = puzzle;&#13;
                        newBoard[savedPuzzle.row][savedPuzzle.col].css({&#13;
                            left: ((puzzleOuterWidth * savedPuzzle.col + leftOffset) + "px"),&#13;
                            top: ((puzzleOuterHeight * savedPuzzle.row + topOffset) + "px")&#13;
                        });&#13;
                        savedBoard.splice(index, 1);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        board = newBoard;&#13;
        animation = true;&#13;
    };&#13;
&#13;
    presenter.saveBoard = function () {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            rowIndex, colIndex,&#13;
            tmpBoard = [];&#13;
&#13;
&#13;
        for (rowIndex = 0; rowIndex &lt; rows; rowIndex++) {&#13;
            for (colIndex = 0; colIndex &lt; columns; colIndex++) {&#13;
                var card = {};&#13;
                card.row = rowIndex;&#13;
                card.col = colIndex;&#13;
                card.position = board[rowIndex][colIndex].attr("position");&#13;
                tmpBoard.push(card);&#13;
            }&#13;
        }&#13;
        savedBoard = tmpBoard;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (!presenter.isFullyLoaded()) {&#13;
            return "";&#13;
        }&#13;
&#13;
        presenter.saveBoard();&#13;
&#13;
        return JSON.stringify({&#13;
            visible: presenter.configuration.isVisible,&#13;
            board: savedBoard,&#13;
            shouldCalcScore: presenter.configuration.shouldCalcScore,&#13;
            score: presenter.getScore(),&#13;
            errors: presenter.getErrorCount()&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        if (!state) return;&#13;
&#13;
        var parsedState = JSON.parse(state);&#13;
&#13;
        if (parsedState.score) {&#13;
            presenter.previousScore = parsedState.score;&#13;
        }&#13;
&#13;
        if (parsedState.errors) {&#13;
            presenter.previousErrors = parsedState.errors;&#13;
        }&#13;
&#13;
        $.when(presenter['imageLoaded']).then(function () {&#13;
            presenter.prepareBoardFromSavedState(parsedState.board);&#13;
            presenter.configuration.shouldCalcScore = parsedState.shouldCalcScore;&#13;
            if (!parsedState.visible) {&#13;
                presenter.hide();&#13;
            } else {&#13;
                presenter.show();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.isPreview || presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
        return 1;&#13;
    };&#13;
&#13;
    presenter.getScore = function () {&#13;
        if (!presenter.isFullyLoaded()) {&#13;
            return presenter.previousScore;&#13;
        }&#13;
        if(presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            row, col;&#13;
&#13;
        for (row = 0; row &lt; rows; row++) {&#13;
            for (col = 0; col &lt; columns; col++) {&#13;
                if (board[row][col].attr("position") != indexBoard[row][col].attr("position")) {&#13;
                    return 0;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return presenter.configuration.shouldCalcScore ? 1 : 0;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (!presenter.isFullyLoaded()) {&#13;
            return presenter.previousErrors;&#13;
        }&#13;
        if(presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            errors = 0;&#13;
&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var col = 0; col &lt; columns; col++) {&#13;
                if (board[row][col].attr("position") != indexBoard[row][col].attr("position")) {&#13;
                    errors++;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return presenter.configuration.shouldCalcScore ? errors : 0;&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        setNormalMode();&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        if(presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.setDraggableState("disable");&#13;
        presenter.configuration.isErrorMode = true;&#13;
&#13;
        if (!presenter.isFullyLoaded()) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns,&#13;
            row, col;&#13;
&#13;
        for (row = 0; row &lt; rows; row++) {&#13;
            for (col = 0; col &lt; columns; col++) {&#13;
                var isEqual = board[row][col].attr("position") != indexBoard[row][col].attr("position");&#13;
                if (isEqual) { //wrong answer&#13;
                    indexBoard[row][col].addClass('wrong');&#13;
                } else {&#13;
                    indexBoard[row][col].addClass('correct');&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        playerController = controller;&#13;
    };&#13;
&#13;
    presenter.isFullyLoaded = function () {&#13;
        return presenter['imageLoadedDeferred'].state() != "pending";&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        Container = $($(view).find('.puzzle-container:first')[0]);&#13;
        intPuzzleWidth = model.Width;&#13;
        intPuzzleHeight = model.Height;&#13;
        var width = model.Width;&#13;
        var height = model.Height;&#13;
        presenter.$view = $(view);&#13;
        eventBus = playerController.getEventBus();&#13;
        eventBus.addEventListener('ShowAnswers', this);&#13;
        eventBus.addEventListener('HideAnswers', this);&#13;
        const upgradedModel = presenter.upgradeModel(model);&#13;
        presenter.configuration = presenter.validateModel(upgradedModel);&#13;
        presenter.isPreview = false;&#13;
        InitPuzzleBoard()&#13;
&#13;
        jImg = Container.find("img:first");&#13;
        jImg.attr('src', model.Image);&#13;
        jImg.attr('height', height);&#13;
        jImg.attr('width', width);&#13;
        jImg.load(function () {&#13;
            InitPuzzle(width, height);&#13;
            if (!presenter.configuration.isVisibleByDefault) {&#13;
                presenter.hide();&#13;
            }&#13;
            presenter['imageLoadedDeferred'].resolve();&#13;
            if (presenter.configuration.isErrorMode){&#13;
                presenter.setShowErrorsMode()&#13;
            }&#13;
        });&#13;
&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
        var isNotActivity = ModelValidationUtils.validateBoolean(model['isNotActivity']);&#13;
        LoadedPromise(this, {&#13;
            'image' : true&#13;
        });&#13;
        return {&#13;
            isValid: true,&#13;
            isErrorMode: false,&#13;
            isVisible: isVisible,&#13;
            isVisibleByDefault: isVisible,&#13;
            shouldCalcScore: false,&#13;
            columns: presenter.validatePuzzleDimension(model.Columns),&#13;
            rows: presenter.validatePuzzleDimension(model.Rows),&#13;
            isNotActivity: isNotActivity,&#13;
            addonID: model.ID&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validatePuzzleDimension = function (dimension) {&#13;
        var validatedRange = ModelValidationUtils.validateIntegerInRange(dimension, 10, 1);&#13;
&#13;
        return validatedRange.isValid ? validatedRange.value : 4;&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        return presenter.upgradeIsNotActivity(model);&#13;
    };&#13;
&#13;
    presenter.upgradeIsNotActivity = function (model) {&#13;
        const upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (upgradedModel['isNotActivity'] === undefined) {&#13;
            upgradedModel['isNotActivity'] = 'False';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.isPreview = true;&#13;
        var element = view.getElementsByTagName('img')[0];&#13;
        element.setAttribute('src', model.Image);&#13;
&#13;
        presenter.$view = $(view);&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (presenter.configuration.isErrorMode) return;&#13;
&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'getLoadedPromise': presenter.getLoadedPromise,&#13;
            'reset': presenter.reset&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
        presenter.setMarkVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
        presenter.setMarkVisibility(false);&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        return presenter.getMaxScore() === presenter.getScore() &amp;&amp; presenter.getErrorCount() === 0;&#13;
    };&#13;
&#13;
    function sendAllOKEvent() {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        eventBus.sendEvent('ValueChanged', eventData);&#13;
    }&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    function showCorrect() {&#13;
        var rows = presenter.configuration.rows,&#13;
            columns = presenter.configuration.columns;&#13;
&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var column = 0; column &lt; columns; column++) {&#13;
                var element = board[row][column],&#13;
                    position = element.attr("position"),&#13;
                    splittedPosition = position.split("-");&#13;
&#13;
                element.css({&#13;
                    left: ((puzzleOuterWidth * splittedPosition[1] + leftOffset) + "px"),&#13;
                    top: ((puzzleOuterHeight * splittedPosition[0] + topOffset) + "px")&#13;
                });&#13;
&#13;
                element.addClass("show-answers");&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if(presenter.configuration.isNotActivity) {&#13;
            return;&#13;
        }&#13;
        presenter.isShowAnswersActive = true;&#13;
        presenter.saveBoard();&#13;
        presenter.setWorkMode();&#13;
        showCorrect();&#13;
        presenter.setDraggableState("disable");&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        Container.find(".show-answers").removeClass("show-answers");&#13;
        $.when(presenter['imageLoaded']).then(function () {&#13;
            presenter.prepareBoardFromSavedState(savedBoard);&#13;
            presenter.setDraggableState("enable");&#13;
        });&#13;
&#13;
        presenter.isShowAnswersActive = false;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>