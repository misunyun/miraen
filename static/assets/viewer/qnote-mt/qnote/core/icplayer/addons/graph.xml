<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="graph" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
        <property displayName="Is not an activity" name="isNotActivity" nameLabel="graph_property_is_not_activity" type="boolean"/>
		<property isLocalized="true" name="X axis description" nameLabel="graph_property_x_axis_description" type="string"/>
		<property name="Show X axis bars descriptions" nameLabel="graph_property_show_x_axis_bars_descriptions" type="boolean"/>
		<property name="X axis bars descriptions" nameLabel="graph_property_x_axis_bars_descriptions" type="list">
			<property isLocalized="true" name="Description" nameLabel="graph_property_description" type="string"/>
		</property>
		<property name="Show X axis series descriptions" nameLabel="graph_property_show_x_axis_series_descriptions" type="boolean"/>
		<property name="X axis series descriptions" nameLabel="graph_property_x_axis_series_descriptions" type="list">
			<property isLocalized="true" name="Description" nameLabel="graph_property_description" type="string"/>
		</property>
		<property isLocalized="true" name="Y axis description" nameLabel="graph_property_y_axis_description" type="string"/>
		<property name="Y axis maximum value" nameLabel="graph_property_y_axis_maximum_value" type="string"/>
		<property name="Y axis minimum value" nameLabel="graph_property_y_axis_minimum_value" type="string"/>
		<property name="Y axis grid step" nameLabel="graph_property_y_axis_grid_step" type="string"/>
        <property name="Y axis values" nameLabel="graph_property_y_axis_values" type="string"/>
		<property name="Interactive" nameLabel="graph_property_interactive" type="boolean"/>
		<property name="Interactive step" nameLabel="graph_property_interactive_step" type="string"/>
		<property name="Data" nameLabel="graph_property_data" type="text"/>
		<property name="Answers" nameLabel="graph_property_answers" type="list">
			<property name="Answer" nameLabel="graph_property_answer" type="string"/>
		</property>
		<property name="Series colors" nameLabel="graph_property_series_colors" type="list">
			<property name="Color" nameLabel="graph_property_color" type="string"/>
		</property>
		<property name="Decimal separator" nameLabel="graph_property_decimal_separator" type="string"/>
	</model>
<css>.graph_container_outer {&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    bottom: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_container_outer div {&#13;
    position: absolute;&#13;
}&#13;
&#13;
.graph_container_inner {&#13;
    top: 10px;&#13;
    left: 10px;&#13;
    bottom: 10px;&#13;
    right: 10px;&#13;
    -ms-touch-action: none;&#13;
}&#13;
&#13;
.graph_axis_y_description {&#13;
    top: 0;&#13;
    left: 0;&#13;
}&#13;
&#13;
.graph_axis_x_description {&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_chart_outer {&#13;
    left: 0;&#13;
    bottom: 0;&#13;
}&#13;
&#13;
.graph_grid_description {&#13;
    text-align: right;&#13;
    color: #999;&#13;
    font-size: 75%;&#13;
}&#13;
&#13;
.graph_chart_inner {&#13;
    top: 0;&#13;
    bottom: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_axis_line {&#13;
    background: #000;&#13;
}&#13;
&#13;
.graph_axis_x_line {&#13;
    left: 0;&#13;
    height: 2px;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_axis_y_line {&#13;
    left: 0;&#13;
    width: 2px;&#13;
    bottom: 0;&#13;
    top: 0;&#13;
}&#13;
&#13;
.graph_axis_arrow {&#13;
    width: 0;&#13;
    height: 0;&#13;
    position: absolute;&#13;
}&#13;
&#13;
.graph_axis_y_arrow {&#13;
    border-left: 5px solid transparent;&#13;
    border-right: 5px solid transparent;&#13;
    border-bottom: 5px solid black;&#13;
    top: 0;&#13;
    left: -4px;&#13;
}&#13;
&#13;
.graph_axis_x_arrow {&#13;
    border-top: 5px solid transparent;&#13;
    border-bottom: 5px solid transparent;&#13;
    border-left: 5px solid black;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_grid_block {&#13;
    left: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_grid_block_above {&#13;
    border-top: 1px dotted #999;&#13;
}&#13;
&#13;
.graph_grid_block_below {&#13;
    border-bottom: 1px dotted #999;&#13;
}&#13;
&#13;
.graph_serie_container {&#13;
    position: relative  !important;&#13;
    float: left;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.graph_serie_element {&#13;
    top: 0;&#13;
    left: 0;&#13;
    bottom: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_column_container {&#13;
    position: relative !important;&#13;
    float: left;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.graph_value_container {&#13;
    width: 100%;&#13;
    bottom: 0;&#13;
}&#13;
&#13;
.graph_value_element {&#13;
    border-left: 1px solid #666;&#13;
    border-right: 1px solid #666;&#13;
    top: 0;&#13;
    left: 0;&#13;
    bottom: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
&#13;
.graph_value_element_positive {&#13;
    border-top: 1px solid #666;&#13;
}&#13;
&#13;
.graph_value_element_negative {&#13;
    border-bottom: 1px solid #666;&#13;
}&#13;
&#13;
.graph_value_element_invalid {&#13;
    border-left-color: #ff0000;&#13;
    border-right-color: #ff0000;&#13;
}&#13;
&#13;
.graph_value_element_positive_invalid {&#13;
    border-top-color: #ff0000;&#13;
}&#13;
&#13;
.graph_value_element_negative_invalid {&#13;
    border-bottom-color: #ff0000;&#13;
}&#13;
&#13;
.graph_value_element_valid {&#13;
    border-left-color: #00ff00;&#13;
    border-right-color: #00ff00;&#13;
}&#13;
&#13;
.graph_value_element_positive_valid {&#13;
    border-top-color: #00ff00;&#13;
}&#13;
&#13;
.graph_value_element_negative_valid {&#13;
    border-bottom-color: #00ff00;&#13;
}&#13;
&#13;
&#13;
.graph_grid, .graph_series, .graph_axises  {&#13;
    top: 0;&#13;
    left: 0;&#13;
    bottom: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_column_container_interactive {&#13;
    top: 0;&#13;
    left: 0;&#13;
    bottom: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_column_container_above {&#13;
    cursor: n-resize;&#13;
}&#13;
&#13;
.graph_value_element_interactive, .graph_column_container_below {&#13;
    cursor: s-resize;&#13;
}&#13;
&#13;
.graph_serie_description, .graph_column_description {&#13;
    text-align: center;&#13;
    color: #999;&#13;
    font-size: 75%;&#13;
    overflow: hidden;&#13;
    height: 16px;&#13;
    left: 0;&#13;
    right: 0;&#13;
}&#13;
&#13;
.graph_column_description {&#13;
    bottom: -20px;&#13;
}&#13;
</css><view/><preview/><presenter>function Addongraph_create(){&#13;
&#13;
    /*&#13;
    *KNOWN ISSUES:&#13;
    *       Invalid properties values (Data, Y grid step, Y max, Y min values):&#13;
    *           addon graph uses functions with errors - parseInt &amp; parseFloat. It creates situations where user could&#13;
    *           type in properties fields digits with strings, and graph still shows up as valid. Changing validation to&#13;
    *           be too much accurate can break backward compatibility&#13;
    *&#13;
    *       Answers greater than Y max / lower than Y min:&#13;
    *           Answers validation is invalid. It allows create graphs where answer is greater or lower than YMax/YMin.&#13;
    *           Changing this validation can break backward compatibility, graph addon have to allow such invalid situations.&#13;
    *&#13;
    *       Y grid step greater than Y max:&#13;
    *           Y grid step validation is also invalid. Allows situations where grid is greater then Y max, it should&#13;
    *           just show nothing, no grid &amp; no Y axis values.&#13;
    *&#13;
    *       Model validation flow:&#13;
    *          Logic of parsing &amp; validating properties requires some properties be checked and parsed at first.&#13;
    *          Don't changeflow of model validation.&#13;
    *&#13;
    */&#13;
    var presenter = function(){};&#13;
&#13;
    presenter.drawingXPosition  = null;&#13;
    presenter.absoluteRange     = null;&#13;
    presenter.chartInner        = null;&#13;
    presenter.axisXLine         = null;&#13;
    presenter.eventBus          = null;&#13;
    presenter.playerController  = null;&#13;
    presenter.errorMode         = false;&#13;
    presenter.isStarted         = false;&#13;
    presenter.isGradualShowAnswersActive = false;&#13;
    presenter.GSAcounter        = 0;&#13;
    presenter.currentData       = [];&#13;
&#13;
    presenter.$view             = null;&#13;
    presenter.configuration     = {};&#13;
    var minimumValueGraph;&#13;
&#13;
&#13;
    presenter.ERROR_MESSAGES = {&#13;
        DATA_ROW_NOT_ENOUGH_COLUMNS:      "Row %row% in data contains not enough columns, minimum amount of columns is 2 - first indicates X axis description, second and further contain values",&#13;
        DATA_ROW_MALFORMED:               "Row %row% is not valid CSV - check its syntax",&#13;
        DATA_ROW_VALUE_NOT_NUMERIC:       "Value \"%value%\" of column %column% of row %row% is not numeric",&#13;
        DATA_ROW_DIFFERENT_COLUMNS_COUNT: "Row %row% contains different amount of columns than previous rows",&#13;
        AXIS_Y_MAXIMUM_VALUE_NOT_NUMERIC: "Y axis maximum value is not numeric",&#13;
        AXIS_Y_MINIMUM_VALUE_NOT_NUMERIC: "Y axis minimum value is not numeric",&#13;
        AXIS_Y_MAXIMUM_VALUE_TOO_SMALL:   "Cannot fit graph into view container - Y axis maximum value of %range% is smaller than maximum value %value% passed with the data",&#13;
        AXIS_Y_MINIMUM_VALUE_TOO_BIG:     "Cannot fit graph into view container - Y axis minimum value of %range% is bigger than minimum value %value% passed with the data",&#13;
        AXIS_Y_DOES_NOT_INCLUDE_ZERO:     "Invalid Y axis minimum &amp; maximum value - graph should contain value of zero",&#13;
        AXIS_Y_GRID_STEP_NOT_NUMERIC:     "Y axis grid step is not numeric",&#13;
        SERIES_COLORS_AMOUNT_INVALID:     "Amount of Series colors is different that amount of columns in the data",&#13;
        INTERACTIVE_STEP_NOT_NUMERIC:     "Interactive step is not numeric",&#13;
        INTERACTIVE_STEP_NOT_POSITIVE:    "Interactive step is not a positive integer",&#13;
        ANSWER_NOT_NUMERIC:               "Answer \"%answer%\" is not numeric",&#13;
        ANSWERS_AMOUNT_INVALID:           "Amount of answers (%answers%) has to be equal amount of bars (%bars%)",&#13;
        AXIS_X_SERIES_DESCRIPTIONS_AMOUNT_INVALID: "Amount of X axis series descriptions (%descriptions%) has to be equal to amount of series (%series%)",&#13;
        AXIS_X_BARS_DESCRIPTIONS_AMOUNT_INVALID:   "Amount of X axis bars descriptions (%descriptions%) has to be equal to amount of bars (%bars%)",&#13;
        YAV_01: "Y axis values have to be float numbers.",&#13;
        YAV_02: "Cyclic value can't be zero number in Y axis values property.",&#13;
        YAV_03: "Y axis values can't be greater than Y maximum value.",&#13;
        YAV_04: "Y axis values can't be lower than Y minimum value.",&#13;
        YAV_05: "Cyclic value can't be negative number in Y axis values property.",&#13;
        YAV_06: "Y axis values can't have duplicated numbers"&#13;
    };&#13;
&#13;
    presenter.showErrorMessage = function(message, substitutions) {&#13;
        var errorContainer;&#13;
        if(typeof(substitutions) == 'undefined') {&#13;
            errorContainer = '&lt;p&gt;' + message + '&lt;/p&gt;';&#13;
        } else {&#13;
            var messageSubst = message;&#13;
            for(var key in substitutions) {&#13;
                messageSubst = messageSubst.replace('%' + key + '%', substitutions[key]);&#13;
            }&#13;
            errorContainer = '&lt;p&gt;' + messageSubst + '&lt;/p&gt;';&#13;
        }&#13;
&#13;
        presenter.$view.html(errorContainer);&#13;
    };&#13;
&#13;
    presenter.redrawGraphValue = function(valueContainer) {&#13;
        var currentValue = parseFloat(valueContainer.attr('current-value'));&#13;
        var valueElement = valueContainer.find('.graph_value_element');&#13;
&#13;
        if(currentValue &gt;= 0) {&#13;
            valueElement.removeClass('graph_value_element_negative').addClass('graph_value_element_positive');&#13;
            valueContainer.css({&#13;
                bottom: (presenter.drawingXPosition - Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                height: parseFloat(currentValue / presenter.absoluteRange) * 100 + '%',&#13;
                top: ''&#13;
            });&#13;
&#13;
        } else if (currentValue &lt; 0) {&#13;
            valueElement.removeClass('graph_value_element_positive').addClass('graph_value_element_negative');&#13;
            valueContainer.css({&#13;
                height: parseFloat(currentValue * -1 / presenter.absoluteRange) * 100 + '%',&#13;
                top: (presenter.chartInner.height() - presenter.drawingXPosition + Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                bottom: ''&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = presenter.playerController.getEventBus();&#13;
    };&#13;
&#13;
&#13;
    presenter.areAllOk = function(currentGridValues) {&#13;
        for (var i = 0; i &lt; currentGridValues.length; i++) {&#13;
            if (currentGridValues[i].indexOf(false) !== -1) {&#13;
                return false;&#13;
            }&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.sendOverallScoreEvent = function(direction, valueId, newValue, wasAllValidBeforeChange, wasThisValidBeforeChange, willAllBeValidAfterChange, willThisBeValidAfterChange) {&#13;
        var score =&#13;
            (wasAllValidBeforeChange    ? 'BEFORE_ALL_VALID '  : 'BEFORE_ALL_INVALID ') +&#13;
                (wasThisValidBeforeChange   ? 'BEFORE_THIS_VALID ' : 'BEFORE_THIS_INVALID ') +&#13;
                (willAllBeValidAfterChange  ? 'AFTER_ALL_VALID '   : 'AFTER_ALL_INVALID ') +&#13;
                (willThisBeValidAfterChange ? 'AFTER_THIS_VALID'   : 'AFTER_THIS_INVALID');&#13;
&#13;
        var parsedValue = '' + newValue;&#13;
        if (presenter.configuration.isDecimalSeparatorSet) {&#13;
            parsedValue = parsedValue.replace('.', presenter.configuration.decimalSeparator);&#13;
        }&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', {&#13;
            'source': presenter.configuration.ID,&#13;
            'item'  : valueId + ' ' + direction,&#13;
            'value' : parsedValue,&#13;
            'score' : score&#13;
        });&#13;
&#13;
        presenter.configuration.results[valueId.split(' ')[0]][valueId.split(' ')[1]] = willThisBeValidAfterChange;&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': valueId,&#13;
            'value': parsedValue,&#13;
            'score': willThisBeValidAfterChange ? '1' : '0'&#13;
        });&#13;
&#13;
        if (presenter.areAllOk(presenter.configuration.results)) {&#13;
            presenter.eventBus.sendEvent('ValueChanged', {&#13;
                'source': presenter.configuration.ID,&#13;
                'item': 'all',&#13;
                'value': '',&#13;
                'score': ''&#13;
            });&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.areAllBarsValid = function() {&#13;
        var r = true;&#13;
        presenter.$view.find('.graph_value_container').each(function(i, e) {&#13;
            if(presenter.configuration.answers[i] != parseFloat($(e).attr('current-value'))) {&#13;
                r = false;&#13;
            }&#13;
        });&#13;
&#13;
        return r;&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if( presenter.isShowAnswersActive){&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if( presenter.isGradualShowAnswersActive){&#13;
            presenter.gradualHideAnswers();&#13;
        }&#13;
&#13;
        presenter.errorMode = true;&#13;
        if (!presenter.isStarted || presenter.configuration.isNotActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
&#13;
        if(presenter.configuration.isInteractive) {&#13;
            presenter.$view.find('.graph_value_element_interactive, .graph_column_container_below, .graph_column_container_above').css('cursor', 'default');&#13;
&#13;
            presenter.$view.find('.graph_value_container').each(function(index, element) {&#13;
                if(presenter.configuration.answers[index] != parseFloat($(element).attr('current-value'))) {&#13;
                    $(element).find('.graph_value_element').addClass('graph_value_element_invalid');&#13;
                    $(element).find('.graph_value_element_positive').addClass('graph_value_element_positive_invalid');&#13;
                    $(element).find('.graph_value_element_negative').addClass('graph_value_element_negative_invalid');&#13;
                } else {&#13;
                    $(element).find('.graph_value_element').addClass('graph_value_element_valid');&#13;
                    $(element).find('.graph_value_element_positive').addClass('graph_value_element_positive_valid');&#13;
                    $(element).find('.graph_value_element_negative').addClass('graph_value_element_negative_valid');&#13;
                }&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        presenter.errorMode = false;&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
&#13;
        if(presenter.configuration.isInteractive) {&#13;
            presenter.$view.find('.graph_value_element_interactive, .graph_column_container_below, .graph_column_container_above').css('cursor', '');&#13;
&#13;
            var classesToRemove =&#13;
                [ 'graph_value_element_invalid', 'graph_value_element_positive_invalid', 'graph_value_element_negative_invalid',&#13;
                    'graph_value_element_valid',   'graph_value_element_positive_valid',   'graph_value_element_negative_valid' ];&#13;
&#13;
            for(var i = 0; i &lt; classesToRemove.length; i++) {&#13;
                presenter.$view.find('.' + classesToRemove[i]).removeClass(classesToRemove[i]);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.calcScore = function () {&#13;
        var score = 0;&#13;
        presenter.$view.find('.graph_value_container').each(function(index, element) {&#13;
            if(presenter.configuration.answers[index] == parseFloat($(element).attr('current-value'))) {&#13;
                score++&#13;
            }&#13;
        });&#13;
&#13;
        return score;&#13;
    };&#13;
&#13;
    presenter.getScore = function() {&#13;
        if (presenter.configuration.isNotActivity || !presenter.configuration.shouldCalcScore || !presenter.isStarted) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.calcScore();&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function() {&#13;
        if (presenter.configuration.isNotActivity) return 0;&#13;
&#13;
        return presenter.configuration.answers.length;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function() {&#13;
        if (presenter.configuration.isNotActivity || !presenter.configuration.shouldCalcScore || !presenter.isStarted) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        return presenter.getMaxScore() - presenter.getScore();&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore() &amp;&amp; presenter.getErrorCount() === 0;&#13;
    };&#13;
&#13;
    presenter.redrawValueContainers = function () {&#13;
        var valueContainers = presenter.$view.find('.graph_value_container');&#13;
        var currentValueContainer;&#13;
&#13;
        for (var i = 0; i &lt; presenter.configuration.data.length; i++) {&#13;
            for (var j = 0; j &lt; presenter.configuration.data[i].length; j++) {&#13;
                currentValueContainer = $(valueContainers[i * presenter.configuration.data[i].length + j]);&#13;
                currentValueContainer.attr('current-value', presenter.configuration.data[i][j]);&#13;
                presenter.redrawGraphValue(currentValueContainer);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.reset = function() {&#13;
        presenter.isStarted = false;&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        presenter.isShowAnswersActive = false;&#13;
        presenter.isGradualShowAnswersActive = false;&#13;
        presenter.currentData = [];&#13;
        presenter.GSAcounter = 0;&#13;
&#13;
        presenter.redrawValueContainers();&#13;
&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
&#13;
        presenter.setWorkMode();&#13;
&#13;
        presenter.removeShowAnswersClass();&#13;
    };&#13;
&#13;
    presenter.removeShowAnswersClass = function () {&#13;
        presenter.$view.find(".graph_value_container").each(function (index, element) {&#13;
            $(element).parent().find('.graph_column_container_interactive').removeClass("graph_column_container_show_answers");&#13;
            $(element).removeClass("graph_show_answers");&#13;
        });&#13;
    };&#13;
&#13;
&#13;
    presenter.getState = function() {&#13;
        var r = [];&#13;
        presenter.$view.find('.graph_value_container').each(function(index, element) {&#13;
            r.push(parseFloat($(element).attr('current-value')));&#13;
        });&#13;
        var state = {&#13;
            'r' : r,&#13;
            'isVisible' : presenter.configuration.isVisible,&#13;
            shouldCalcScore: presenter.configuration.shouldCalcScore,&#13;
            isStarted: presenter.isStarted&#13;
        };&#13;
        return JSON.stringify(state);&#13;
    };&#13;
&#13;
&#13;
    presenter.setState = function(stateString) {&#13;
        var state = JSON.parse(stateString),&#13;
            valueContainers = presenter.$view.find('.graph_value_container'),&#13;
            currentValueContainer,&#13;
            r = state.r, i,&#13;
            shouldCalcScore = state.shouldCalcScore;&#13;
&#13;
        for (i = 0; i &lt; r.length; i++) {&#13;
            currentValueContainer = $(valueContainers[i]);&#13;
            currentValueContainer.attr('current-value', parseFloat(r[i]));&#13;
            presenter.redrawGraphValue(currentValueContainer);&#13;
        }&#13;
&#13;
        presenter.setVisibility(state.isVisible);&#13;
        presenter.configuration.isVisible = state.isVisible;&#13;
        presenter.configuration.shouldCalcScore = shouldCalcScore;&#13;
        presenter.isStarted = state.isStarted;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
    };&#13;
&#13;
    presenter.getValue = function (index) {&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
&#13;
        var maxIndex = presenter.$view.find('.graph_column_container').length;&#13;
&#13;
        if (!ModelValidationUtils.validateIntegerInRange(index, maxIndex, 1).isValid) return;&#13;
&#13;
        var $column = presenter.$view.find('.graph_column_container:eq(' + (index - 1) + ') .graph_value_container');&#13;
&#13;
        return parseFloat($column.attr('current-value'));&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide' : presenter.hide,&#13;
            'getValue': presenter.getValue,&#13;
            'isAllOK': presenter.isAllOK&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    function prepareAndSendEvent(direction, changedBarIndex, currentValue, newValue, valueContainer) {&#13;
        var wasAllValidBeforeChange = presenter.areAllBarsValid();&#13;
        var wasThisValidBeforeChange = presenter.configuration.answers[changedBarIndex] == currentValue;&#13;
        var willAllBeValidAfterChange = presenter.areAllBarsValid();&#13;
        var willThisBeValidAfterChange = presenter.configuration.answers[changedBarIndex] == newValue;&#13;
&#13;
        presenter.sendOverallScoreEvent(direction,&#13;
            valueContainer.attr('value-id'),&#13;
            newValue,&#13;
            wasAllValidBeforeChange,&#13;
            wasThisValidBeforeChange,&#13;
            willAllBeValidAfterChange,&#13;
            willThisBeValidAfterChange&#13;
        );&#13;
    }&#13;
&#13;
    presenter.getProperPrecision = function (number1, number2) {&#13;
        var number1Precision = 0, number2Precision = 0;&#13;
&#13;
        if (('' + number1).split('.')[1]) {&#13;
            number1Precision = ('' + number1).split('.')[1].length;&#13;
        }&#13;
&#13;
        if (('' + number2).split('.')[1]) {&#13;
            number2Precision = ('' + number2).split('.')[1].length;&#13;
        }&#13;
&#13;
        return Math.max(number1Precision, number2Precision);&#13;
    };&#13;
&#13;
    presenter.increaseGraphValue = function(eventData) {&#13;
        eventData.stopPropagation();&#13;
&#13;
        if (presenter.shouldStopAction()) return;&#13;
&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        if (presenter.configuration.mouseData.wasDragged) {&#13;
            presenter.configuration.mouseData.wasDragged = false;&#13;
            return false;&#13;
        }&#13;
&#13;
        var valueContainer = $(eventData.target).parent().find('.graph_value_container');&#13;
&#13;
        var changedBarIndex = presenter.$view.find('.graph_series .graph_value_container').index(valueContainer),&#13;
            currentValue = parseFloat(valueContainer.attr('current-value')),&#13;
            minInteractivePoint = presenter.getMinimumInteractivePoint(valueContainer.attr('value-id')),&#13;
            newValue, newValuePrecision;&#13;
&#13;
        if (currentValue == presenter.configuration.axisYMinimumValue &amp;&amp; minInteractivePoint !== currentValue) {&#13;
            // Special case when current value is minimum and can not match with those calculated with interactive step&#13;
            newValue = minInteractivePoint;&#13;
            newValuePrecision = presenter.getProperPrecision(minInteractivePoint, presenter.configuration.interactiveStep);&#13;
        } else {&#13;
            newValue = currentValue + presenter.configuration.interactiveStep;&#13;
            newValuePrecision = presenter.getProperPrecision(currentValue, presenter.configuration.interactiveStep);&#13;
        }&#13;
&#13;
        if(newValue &gt; presenter.configuration.axisYMaximumValue) return;&#13;
&#13;
        valueContainer.attr('current-value', newValue.toFixed(newValuePrecision));&#13;
        presenter.redrawGraphValue(valueContainer);&#13;
&#13;
        if (currentValue === newValue) return;&#13;
&#13;
        prepareAndSendEvent("increase", changedBarIndex, currentValue, newValue, valueContainer);&#13;
    };&#13;
&#13;
    presenter.decreaseGraphValue = function(eventData) {&#13;
        eventData.stopPropagation();&#13;
&#13;
        if (presenter.shouldStopAction()) return;&#13;
&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        if (presenter.configuration.mouseData.wasDragged) {&#13;
            presenter.configuration.mouseData.wasDragged = false;&#13;
            return false;&#13;
        }&#13;
&#13;
        var valueContainer;&#13;
        if($(eventData.target).parent().hasClass('graph_value_container')) {&#13;
            // Clicked in bar&#13;
            valueContainer = $(eventData.target).parent();&#13;
        } else {&#13;
            // Clicked below bar&#13;
            valueContainer = $(eventData.target).parent().find('.graph_value_container');&#13;
        }&#13;
&#13;
        var changedBarIndex = presenter.$view.find('.graph_series .graph_value_container').index(valueContainer),&#13;
            currentValue = parseFloat(valueContainer.attr('current-value')),&#13;
            maxInteractivePoint = presenter.getMaximumInteractivePoint(valueContainer.attr('value-id')),&#13;
            newValue, newValuePrecision;&#13;
&#13;
        if (currentValue == presenter.configuration.axisYMaximumValue &amp;&amp; maxInteractivePoint !== currentValue) {&#13;
            // Special case when current value is maximum and can not match with those calculated with interactive step&#13;
            newValue = maxInteractivePoint;&#13;
            newValuePrecision = presenter.getProperPrecision(maxInteractivePoint, presenter.configuration.interactiveStep);&#13;
        } else {&#13;
            newValue = currentValue - presenter.configuration.interactiveStep;&#13;
            newValuePrecision = presenter.getProperPrecision(currentValue, presenter.configuration.interactiveStep);&#13;
        }&#13;
&#13;
        if(newValue &lt; presenter.configuration.axisYMinimumValue) return;&#13;
&#13;
        var splittedStep = presenter.configuration.axisYGridStep.toString().split('.'),&#13;
            precision;&#13;
        if(splittedStep[1]){&#13;
            precision = splittedStep[1].length;&#13;
            valueContainer.attr('current-value', newValue.toFixed(precision));&#13;
        }else{&#13;
            valueContainer.attr('current-value', newValue.toFixed(newValuePrecision));&#13;
        }&#13;
&#13;
        presenter.redrawGraphValue(valueContainer);&#13;
&#13;
        if (currentValue === newValue) return;&#13;
&#13;
        prepareAndSendEvent("decrease", changedBarIndex, currentValue, newValue, valueContainer);&#13;
    };&#13;
&#13;
    function getValueElement() {&#13;
        var $element;&#13;
&#13;
        if (presenter.configuration.mouseData.$element.hasClass('graph_value_element')) {&#13;
            $element = presenter.configuration.mouseData.$element;&#13;
        } else {&#13;
            $element = presenter.configuration.mouseData.$element.parent().find('.graph_value_element');&#13;
        }&#13;
&#13;
        return $element;&#13;
    }&#13;
&#13;
    function isAboveXAxis($element) {&#13;
        return $element.hasClass('graph_value_element_positive');&#13;
    }&#13;
&#13;
    function getColumnContainer($valueElement) {&#13;
        var containerClassName = '.graph_column_container_' + (isAboveXAxis($valueElement) ? 'above' : 'below');&#13;
        return $valueElement.parent().parent().find(containerClassName);&#13;
    }&#13;
&#13;
    function isMoreThanOneFingerGesture(event) {&#13;
        return (event.touches.length || event.changedTouches.length) &gt; 1;&#13;
    }&#13;
&#13;
    function mouseDownCallback (eventData) {&#13;
        if (presenter.shouldStopAction()) return;&#13;
&#13;
        presenter.configuration.mouseData.isMouseDown = true;&#13;
        presenter.configuration.mouseData.wasMouseDown = true;&#13;
        presenter.configuration.mouseData.wasDragged = false;&#13;
        presenter.configuration.mouseData.oldPosition.y = eventData.pageY;&#13;
        presenter.configuration.mouseData.$element = $(eventData.target);&#13;
&#13;
        var $container = getValueElement().parent();&#13;
&#13;
        presenter.configuration.mouseData.currentValue = parseFloat($container.attr('current-value'));&#13;
    }&#13;
&#13;
    function touchStartCallback (event) {&#13;
        if (isMoreThanOneFingerGesture(event)) {&#13;
            presenter.configuration.mouseData.wasDragged = true;&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        var touch = event.touches[0] || event.changedTouches[0];&#13;
        mouseDownCallback(touch);&#13;
    }&#13;
&#13;
    function columnContainerMouseDownCallback (eventData) {&#13;
        if (presenter.shouldStopAction()) return;&#13;
&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        presenter.configuration.mouseData.$element = $(eventData.target);&#13;
        var $element = getValueElement(), currentValue = parseFloat($element.parent().attr('current-value'));&#13;
&#13;
        if (currentValue === 0) {&#13;
            presenter.configuration.mouseData.wasMouseDown = true;&#13;
            presenter.configuration.mouseData.isMouseDown = true;&#13;
            presenter.configuration.mouseData.wasDragged = false;&#13;
            presenter.configuration.mouseData.oldPosition.y = eventData.pageY;&#13;
            presenter.configuration.mouseData.$element = $element;&#13;
            presenter.configuration.mouseData.currentValue = currentValue;&#13;
        }&#13;
    }&#13;
&#13;
    function columnContainerTouchStartCallback (event) {&#13;
        if (isMoreThanOneFingerGesture(event)) {&#13;
            presenter.configuration.mouseData.wasDragged = true;&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        var touch = event.touches[0] || event.changedTouches[0];&#13;
&#13;
        presenter.configuration.mouseData.isColumnContainerTouchTriggered = true;&#13;
        presenter.configuration.mouseData.isColumnContainerTriggerIncrease = $(touch.target).hasClass('graph_column_container_above');&#13;
        presenter.configuration.mouseData.columnContainerEventData = touch;&#13;
&#13;
        columnContainerMouseDownCallback(touch);&#13;
    }&#13;
&#13;
    presenter.whichPoint = function (position, maximumValue, containerHeight, step) {&#13;
        var snapPointsCount = Math.floor(maximumValue / step), halfOfValueHigh = (containerHeight / (maximumValue / step)) / 2;&#13;
&#13;
        if (position &lt; halfOfValueHigh) {&#13;
            return 0;&#13;
        } else if (position &gt;= containerHeight - halfOfValueHigh) {&#13;
            return maximumValue;&#13;
        } else {&#13;
            for (var i = 1; i &lt;= snapPointsCount; i++) {&#13;
                var snapPoint = 2 * halfOfValueHigh * i;&#13;
                if (position &gt;= snapPoint - halfOfValueHigh &amp;&amp; position &lt; snapPoint + halfOfValueHigh) return i * step;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getInitialData = function (valueID) {&#13;
        var series = parseInt(valueID.split(' ')[0], 10),&#13;
            index = parseInt(valueID.split(' ')[1], 10);&#13;
&#13;
        return parseFloat(presenter.configuration.data[series][index]);&#13;
    };&#13;
&#13;
    presenter.getMaximumInteractivePoint = function (valueID) {&#13;
        var initialData = presenter.getInitialData(valueID),&#13;
            interactiveStep = presenter.configuration.interactiveStep,&#13;
            maxYValue = presenter.configuration.axisYMaximumValue,&#13;
            maxPoint = initialData;&#13;
&#13;
        while (maxPoint + interactiveStep &lt;= maxYValue) {&#13;
            maxPoint += interactiveStep;&#13;
        }&#13;
&#13;
        return maxPoint&#13;
    };&#13;
&#13;
    presenter.getMinimumInteractivePoint = function (valueID) {&#13;
        var initialData = presenter.getInitialData(valueID),&#13;
            interactiveStep = presenter.configuration.interactiveStep,&#13;
            minYValue = presenter.configuration.axisYMinimumValue,&#13;
            minPoint = initialData;&#13;
&#13;
        while (minPoint - interactiveStep &gt;= minYValue) {&#13;
            minPoint -= interactiveStep;&#13;
        }&#13;
&#13;
        return minPoint&#13;
    };&#13;
&#13;
    function triggerColumnContainerClickHandler() {&#13;
        if (presenter.configuration.mouseData.isColumnContainerTriggerIncrease) {&#13;
            presenter.increaseGraphValue(presenter.configuration.mouseData.columnContainerEventData);&#13;
        } else {&#13;
            presenter.decreaseGraphValue(presenter.configuration.mouseData.columnContainerEventData);&#13;
        }&#13;
    }&#13;
&#13;
    function mouseUpCallback () {&#13;
        if (presenter.shouldStopAction()) return;&#13;
&#13;
        presenter.isStarted = true;&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
&#13;
        if (!presenter.configuration.mouseData.isMouseDown) {&#13;
            if (presenter.configuration.mouseData.isColumnContainerTouchTriggered) {&#13;
                triggerColumnContainerClickHandler();&#13;
            }&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.mouseData.isMouseDown = false;&#13;
        if (!presenter.configuration.mouseData.wasDragged) {&#13;
            if (presenter.configuration.mouseData.isColumnContainerTouchTriggered) {&#13;
                triggerColumnContainerClickHandler();&#13;
            }&#13;
            return;&#13;
        }&#13;
&#13;
        var $element = getValueElement();&#13;
        var $container = $element.parent(), height = $container.height();&#13;
&#13;
        var valueContainer = presenter.configuration.mouseData.$element.parent(),&#13;
            columnContainer = getColumnContainer($element),&#13;
            columnContainerHeight = columnContainer.height(),&#13;
            newValue;&#13;
&#13;
        var halfOfValueHigh;&#13;
        if (isAboveXAxis($element)) {&#13;
            halfOfValueHigh = (columnContainerHeight / presenter.configuration.axisYMaximumValue) / 2;&#13;
        } else {&#13;
            halfOfValueHigh = (columnContainerHeight / Math.abs(presenter.configuration.axisYMinimumValue)) / 2;&#13;
        }&#13;
&#13;
        if (height &lt; halfOfValueHigh) {&#13;
            newValue = 0;&#13;
        } else if (height &gt;= columnContainerHeight - halfOfValueHigh) {&#13;
            newValue = isAboveXAxis($element) ? presenter.configuration.axisYMaximumValue : presenter.configuration.axisYMinimumValue;&#13;
        } else {&#13;
            var maxValue = isAboveXAxis($element) ? presenter.configuration.axisYMaximumValue : Math.abs(presenter.configuration.axisYMinimumValue);&#13;
            newValue = presenter.whichPoint(height, maxValue, columnContainerHeight, presenter.configuration.interactiveStep);&#13;
            if (!isAboveXAxis($element)) {&#13;
                newValue = -1 * newValue;&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        var splittedStep = presenter.configuration.axisYGridStep.toString().split('.');&#13;
&#13;
        if(splittedStep[1]){&#13;
            var precision = splittedStep[1].length;&#13;
            $container.attr('current-value', newValue.toFixed(precision));&#13;
        }else{&#13;
            $container.attr('current-value', newValue);&#13;
        }&#13;
&#13;
        presenter.redrawGraphValue(valueContainer);&#13;
&#13;
        if (presenter.configuration.mouseData.currentValue !== newValue) {&#13;
            var direction = presenter.configuration.mouseData.currentValue &lt; newValue ? "increase" : "decrease";&#13;
            var changedBarIndex = presenter.$view.find('.graph_series .graph_value_container').index(valueContainer);&#13;
            prepareAndSendEvent(direction, changedBarIndex, presenter.configuration.mouseData.currentValue, newValue, $container);&#13;
        }&#13;
&#13;
        presenter.configuration.mouseData.isMouseDown = false;&#13;
        presenter.configuration.mouseData.oldPosition = { y:0 };&#13;
    }&#13;
&#13;
    function touchEndCallback (event) {&#13;
        if (isMoreThanOneFingerGesture(event)) {&#13;
            presenter.configuration.mouseData.wasDragged = true;&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        mouseUpCallback();&#13;
    }&#13;
&#13;
    function mouseMoveCallback (eventData) {&#13;
        if (presenter.shouldStopAction()) return;&#13;
        if (presenter.configuration.mouseData.isMouseDown !== true) return;&#13;
&#13;
        presenter.configuration.shouldCalcScore = true;&#13;
        presenter.configuration.mouseData.wasDragged = true;&#13;
&#13;
        var $element = getValueElement();&#13;
        var $container = $element.parent();&#13;
        var height = $container.height();&#13;
        var columnContainerHeight = getColumnContainer($element).height();&#13;
        var distance = presenter.configuration.mouseData.oldPosition.y - eventData.pageY;&#13;
&#13;
        if (!isAboveXAxis($element)) {&#13;
            distance = -1 * distance;&#13;
        }&#13;
&#13;
        presenter.configuration.mouseData.oldPosition.y = eventData.pageY;&#13;
&#13;
        $container.css('height', (height + distance) + 'px');&#13;
        if (height + distance &gt; columnContainerHeight) {&#13;
            $container.css('height', columnContainerHeight + 'px');&#13;
        }&#13;
&#13;
        if ($container.height() &lt; 1 &amp;&amp; minimumValueGraph &lt; 0) {&#13;
            if (isAboveXAxis($element)) {&#13;
                $container.css({&#13;
                    top: (presenter.chartInner.height() - presenter.drawingXPosition + Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                    bottom: ''&#13;
                });&#13;
                $element.removeClass('graph_value_element_positive').addClass('graph_value_element_negative');&#13;
            } else {&#13;
                $container.css({&#13;
                    bottom: (presenter.drawingXPosition - Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                    top: ''&#13;
                });&#13;
                $element.removeClass('graph_value_element_negative').addClass('graph_value_element_positive');&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function touchMoveCallback (event) {&#13;
        if (isMoreThanOneFingerGesture(event)) {&#13;
            presenter.configuration.mouseData.wasDragged = true;&#13;
            return;&#13;
        }&#13;
&#13;
        event.preventDefault();&#13;
&#13;
        var touch = event.touches[0] || event.changedTouches[0];&#13;
        mouseMoveCallback(touch);&#13;
    }&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        return presenter.upgradeAxisYValues(model);&#13;
    };&#13;
&#13;
    presenter.upgradeAxisYValues = function (model) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if(model["Y axis values"] == undefined) {&#13;
            upgradedModel["Y axis values"] = "";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        const events = ['ShowAnswers', 'GradualShowAnswers', 'HideAnswers', 'GradualHideAnswers'];&#13;
        presenter.initialize(view, model, false);&#13;
&#13;
        events.forEach(event =&gt; presenter.eventBus.addEventListener(event, this));&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        return presenter.$view.find(".graph_value_container").length;&#13;
    }&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.initialize(view, model, true);&#13;
    };&#13;
&#13;
    presenter.validateAxisYMaximumValue = function (model, isDecimalSeparatorSet, decimalSeparator) {&#13;
        // Y-axis maximum value&#13;
        var modelYAxisMaximumValue = model['Y axis maximum value'];&#13;
&#13;
        if (isDecimalSeparatorSet) {&#13;
            modelYAxisMaximumValue = modelYAxisMaximumValue.replace(decimalSeparator, '.');&#13;
        }&#13;
        var axisYMaximumValue = ModelValidationUtils.validateFloat(modelYAxisMaximumValue);&#13;
        if (!axisYMaximumValue.isValid) {&#13;
            return { isValid: false, errorCode: 'AXIS_Y_MAXIMUM_VALUE_NOT_NUMERIC' };&#13;
        }&#13;
&#13;
        return {isValid: true, value: axisYMaximumValue.parsedValue};&#13;
    };&#13;
&#13;
    presenter.validateAxisYMinimumValue = function (model, isDecimalSeparatorSet, decimalSeparator) {&#13;
        //Y-axis minimum value&#13;
        var modelYAxisMinimumValue = model['Y axis minimum value'];&#13;
        minimumValueGraph = model['Y axis minimum value'];&#13;
&#13;
        if (isDecimalSeparatorSet) {&#13;
            modelYAxisMinimumValue = modelYAxisMinimumValue.replace(decimalSeparator, '.');&#13;
        }&#13;
        var axisYMinimumValue = ModelValidationUtils.validateFloat(modelYAxisMinimumValue);&#13;
        if (!axisYMinimumValue.isValid) {&#13;
            return { isValid: false, errorCode: 'AXIS_Y_MINIMUM_VALUE_NOT_NUMERIC' };&#13;
        }&#13;
&#13;
        return {isValid: true, value: axisYMinimumValue.parsedValue};&#13;
    };&#13;
&#13;
    presenter.validateAxisYRange = function (axisYMaximumValue, axisYMinimumValue) {&#13;
        if((axisYMaximumValue &gt; 0 &amp;&amp; axisYMinimumValue &gt; 0) ||&#13;
            (axisYMaximumValue &lt; 0 &amp;&amp; axisYMinimumValue &lt; 0)) {&#13;
&#13;
            return { isValid: false, errorCode: 'AXIS_Y_DOES_NOT_INCLUDE_ZERO' };&#13;
        }&#13;
&#13;
        return {isValid: true};&#13;
    };&#13;
&#13;
    presenter.validateAxisYGridStep = function (model, isDecimalSeparatorSet, decimalSeparator) {&#13;
         var modelYAxisGridStep = model['Y axis grid step'];&#13;
        if (isDecimalSeparatorSet) {&#13;
            modelYAxisGridStep = modelYAxisGridStep.replace(decimalSeparator, '.');&#13;
        }&#13;
&#13;
        var axisYGridStep = ModelValidationUtils.validateFloat(modelYAxisGridStep);&#13;
        if(!axisYGridStep.isValid) {&#13;
            return { isValid: false, errorCode: 'AXIS_Y_GRID_STEP_NOT_NUMERIC' };&#13;
        }&#13;
&#13;
        return { isValid: true, value: axisYGridStep.parsedValue};&#13;
&#13;
    };&#13;
&#13;
    presenter.validateInteractiveStep = function (model, isDecimalSeparatorSet, decimalSeparator) {&#13;
        var isInteractive = ModelValidationUtils.validateBoolean(model['Interactive']);&#13;
        var interactiveStep;&#13;
&#13;
        if(isInteractive) {&#13;
            var modelInteractiveStep = model['Interactive step'];&#13;
            if (isDecimalSeparatorSet) {&#13;
                modelInteractiveStep = modelInteractiveStep.replace(decimalSeparator, '.');&#13;
            }&#13;
&#13;
            interactiveStep = ModelValidationUtils.validateFloat(modelInteractiveStep);&#13;
            if(!interactiveStep.isValid) {&#13;
                return { isValid: false, errorCode: 'INTERACTIVE_STEP_NOT_NUMERIC' };&#13;
            }&#13;
&#13;
            if(interactiveStep.parsedValue &lt;= 0) {&#13;
                return { isValid: false, errorCode: 'INTERACTIVE_STEP_NOT_POSITIVE' };&#13;
            }&#13;
&#13;
            interactiveStep = interactiveStep.parsedValue;&#13;
        }&#13;
&#13;
        return {isValid: true, interactiveStep: interactiveStep, isInteractive: isInteractive};&#13;
    };&#13;
&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var decimalSeparator = model["Decimal separator"];&#13;
        var isDecimalSeparatorSet = !ModelValidationUtils.isStringEmpty(decimalSeparator);&#13;
&#13;
        var validatedAxisYMaximumValue = presenter.validateAxisYMaximumValue(model, isDecimalSeparatorSet, decimalSeparator);&#13;
        if(!validatedAxisYMaximumValue.isValid) {&#13;
            return validatedAxisYMaximumValue;&#13;
        }&#13;
&#13;
        var validatedAxisYMinimumValue = presenter.validateAxisYMinimumValue(model, isDecimalSeparatorSet, decimalSeparator);&#13;
        if (!validatedAxisYMinimumValue.isValid) {&#13;
            return validatedAxisYMinimumValue;&#13;
        }&#13;
&#13;
        var validatedAxisYRange = presenter.validateAxisYRange(validatedAxisYMaximumValue.value, validatedAxisYMinimumValue.value);&#13;
        if (!validatedAxisYRange.isValid) {&#13;
            return validatedAxisYRange;&#13;
        }&#13;
&#13;
        // Y-axis grid step&#13;
        var validatedAxisYGridStep = presenter.validateAxisYGridStep(model, isDecimalSeparatorSet, decimalSeparator);&#13;
        if (!validatedAxisYGridStep.isValid) {&#13;
            return validatedAxisYGridStep;&#13;
        }&#13;
&#13;
        // Interactive (step) mode&#13;
        var validatedInteractiveStep = presenter.validateInteractiveStep(model, isDecimalSeparatorSet,&#13;
            decimalSeparator);&#13;
&#13;
        if (!validatedInteractiveStep.isValid) {&#13;
            return validatedInteractiveStep;&#13;
        }&#13;
        var isInteractive = validatedInteractiveStep.isInteractive;&#13;
&#13;
        var isNotActivity;&#13;
        try {&#13;
            isNotActivity = (model['isNotActivity'].toLowerCase() === 'true');&#13;
        } catch (_) {&#13;
            isNotActivity = false;&#13;
        }&#13;
        var parsedColors = presenter.parseColors(model);&#13;
&#13;
        var graphConfiguration = {&#13;
            "isDecimalSeparatorSet": isDecimalSeparatorSet,&#13;
            "decimalSeparator": decimalSeparator,&#13;
            "Series colors": parsedColors,&#13;
            "axisYMaximumValue": validatedAxisYMaximumValue.value,&#13;
            "axisYMinimumValue": validatedAxisYMinimumValue.value&#13;
        };&#13;
        // Data&#13;
        var validatedData = presenter.validateData(model, graphConfiguration);&#13;
&#13;
        if(!validatedData.isValid) {&#13;
            return validatedData&#13;
        }&#13;
&#13;
        var validatedAxisXBarsDescriptions = presenter.validateAxisXBarsDescriptions(model, validatedData.value.barsCount);&#13;
&#13;
        if(!validatedAxisXBarsDescriptions.isValid) {&#13;
            return validatedAxisXBarsDescriptions&#13;
        }&#13;
&#13;
        var validatedAxisXSeriesDescriptions = presenter.validateAxisXSeriesDescriptions(model, validatedData.value.validRows);&#13;
        if (!validatedAxisXSeriesDescriptions.isValid) {&#13;
            return validatedAxisXSeriesDescriptions;&#13;
        }&#13;
&#13;
        if (isInteractive) {&#13;
            var validatedAnswers = presenter.validateAnswers(model['Answers'], validatedData.value.barsCount);&#13;
            if (!validatedAnswers.isValid) {&#13;
                return validatedAnswers;&#13;
            }&#13;
            var results = presenter.parseResults(validatedData.value.parsedData, validatedAnswers.answers);&#13;
&#13;
        } else {&#13;
            var validatedAnswers = {answers: []};&#13;
            var results = [];&#13;
        }&#13;
&#13;
        var validatedAxisYValues = presenter.validateAxisYValues(model, validatedAxisYMaximumValue.value,&#13;
            validatedAxisYMinimumValue.value, isDecimalSeparatorSet);&#13;
&#13;
        if (!validatedAxisYValues.isValid) {&#13;
            return validatedAxisYValues;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            ID: model.ID,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
            isVisibleByDefault: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
            isNotActivity: isNotActivity,&#13;
            shouldCalcScore: false,&#13;
            decimalSeparator: decimalSeparator,&#13;
            isDecimalSeparatorSet: isDecimalSeparatorSet,&#13;
            axisYMaximumValue: validatedAxisYMaximumValue.value,&#13;
            axisYMinimumValue: validatedAxisYMinimumValue.value,&#13;
            axisYGridStep: validatedAxisYGridStep.value,&#13;
            data: validatedData.value.parsedData,&#13;
            isInteractive: isInteractive,&#13;
            interactiveStep: validatedInteractiveStep.interactiveStep,&#13;
            mouseData: {&#13;
                isMouseDown : false,&#13;
                oldPosition : { y : 0 },&#13;
                isMouseDragged : false&#13;
            },&#13;
            showXAxisBarsDescriptions: validatedAxisXBarsDescriptions.value.showXAxisBarsDescriptions,&#13;
            axisXBarsDescriptions: validatedAxisXBarsDescriptions.value.axisXBarsDescriptions,&#13;
            showXAxisSeriesDescriptions: validatedAxisXSeriesDescriptions.value.showXAxisSeriesDescriptions,&#13;
            axisXSeriesDescriptions: validatedAxisXSeriesDescriptions.value.axisXSeriesDescriptions,&#13;
            seriesColors: parsedColors,&#13;
            barsCount: validatedData.value.barsCount,&#13;
            columnsCount: validatedData.value.columnsCount,&#13;
            validRows: validatedData.value.validRows,&#13;
            results: results,&#13;
            answers: validatedAnswers.answers,&#13;
            axisYValues: {fixedValues: validatedAxisYValues.fixedValues, cyclicValues: validatedAxisYValues.cyclicValues}&#13;
        };&#13;
    };&#13;
&#13;
    presenter.parseResults = function (data, answers) {&#13;
        var results = [];&#13;
&#13;
        var k = 0;&#13;
        var i, j;&#13;
&#13;
        for (i=0; i &lt; data.length; i++) {&#13;
            var a = [];&#13;
            for (j = 0; j &lt; data[i].length; j++) {&#13;
                a.push(parseInt(answers[k++]) ===  parseInt(data[i][j]));&#13;
            }&#13;
&#13;
            results.push(a);&#13;
        }&#13;
&#13;
        return results;&#13;
    };&#13;
&#13;
    presenter.parseAxisXBarsDescriptions = function (model, showXAxisBarsDescriptions) {&#13;
        var i;&#13;
        var xAxisBarsDescriptions = [];&#13;
&#13;
        if (showXAxisBarsDescriptions &amp;&amp; typeof(model['X axis bars descriptions']) != 'undefined') {&#13;
            for (i = 0; i &lt; model['X axis bars descriptions'].length; i++) {&#13;
                xAxisBarsDescriptions.push(model['X axis bars descriptions'][i]['Description']);&#13;
            }&#13;
        }&#13;
&#13;
        return xAxisBarsDescriptions;&#13;
    };&#13;
&#13;
    presenter.parseAxisXSeriesDescriptions = function (model,showXAxisSeriesDescriptions) {&#13;
        var xAxisSeriesDescriptions = [];&#13;
        var i;&#13;
        if (showXAxisSeriesDescriptions &amp;&amp; typeof(model['X axis series descriptions']) != 'undefined') {&#13;
            for (i = 0; i &lt; model['X axis series descriptions'].length; i++) {&#13;
                xAxisSeriesDescriptions.push(model['X axis series descriptions'][i]['Description']);&#13;
            }&#13;
        }&#13;
&#13;
        return xAxisSeriesDescriptions;&#13;
    };&#13;
&#13;
    presenter.validateData = function(model, graphConfiguration) {&#13;
&#13;
        var parsedData = presenter.parseData(model, graphConfiguration.isDecimalSeparatorSet, graphConfiguration.decimalSeparator);&#13;
&#13;
        // Read data&#13;
        var currentValue;&#13;
        var maximumValue = null;&#13;
        var minimumValue = null;&#13;
        var row, column;&#13;
        var validRows = 0;&#13;
        var columnsCount = null;&#13;
        var barsCount = 0;&#13;
&#13;
        // Validate data and find maximum value&#13;
        for (row = 0; row &lt; parsedData.length; row++) {&#13;
            // Ensure that rows have valid syntax&#13;
            if (parsedData[row] === null) {&#13;
                return {isValid: false, errorCode: "DATA_ROW_MALFORMED", errorMessageSubstitutions: { row: row + 1 }};&#13;
            }&#13;
&#13;
            // Skip empty rows&#13;
            if (parsedData[row].length === 0) {&#13;
                continue;&#13;
            }&#13;
            validRows++;&#13;
            // Ensure that rows have valid amount of columns&#13;
            if (parsedData[row].length &lt; 1) {&#13;
                return {isValid: false, errorCode: "DATA_ROW_NOT_ENOUGH_COLUMNS", errorMessageSubstitutions: { row: row + 1 }};&#13;
            }&#13;
&#13;
            if (columnsCount === null) {&#13;
                columnsCount = parsedData[row].length;&#13;
            } else if (columnsCount != parsedData[row].length) {&#13;
                return {isValid: false, errorCode: "DATA_ROW_DIFFERENT_COLUMNS_COUNT", errorMessageSubstitutions:  { row: row + 1 }};&#13;
            }&#13;
&#13;
            // Save min/max value and ensure that data is numeric&#13;
            for (column = 0; column &lt; parsedData[row].length; column++) {&#13;
                currentValue = parseFloat(parsedData[row][column]);&#13;
&#13;
                if (isNaN(currentValue)) {&#13;
                    return {isValid: false, errorCode: "DATA_ROW_VALUE_NOT_NUMERIC", errorMessageSubstitutions: { row: row + 1, column: column, value: parsedData[row][column] }};&#13;
                }&#13;
&#13;
                if (maximumValue === null || currentValue &gt; maximumValue) {&#13;
                    maximumValue = currentValue;&#13;
                }&#13;
&#13;
                if (minimumValue === null || currentValue &lt; minimumValue) {&#13;
                    minimumValue = currentValue;&#13;
                }&#13;
&#13;
                parsedData[row][column] = currentValue;&#13;
            }&#13;
            // Count amount of bars&#13;
            barsCount += parsedData[row].length;&#13;
        }&#13;
&#13;
        if (graphConfiguration.axisYMaximumValue &lt; maximumValue) {&#13;
            return {isValid: false, errorCode: 'AXIS_Y_MAXIMUM_VALUE_TOO_SMALL', errorMessageSubstitutions: { value: maximumValue, range: graphConfiguration.axisYMaximumValue }};&#13;
        }&#13;
&#13;
        if (graphConfiguration.axisYMinimumValue &gt; minimumValue) {&#13;
            return {isValid: false, errorCode: "AXIS_Y_MINIMUM_VALUE_TOO_BIG", errorMessageSubstitutions:  { value: minimumValue, range: graphConfiguration.axisYMinimumValue}};&#13;
        }&#13;
&#13;
        if (graphConfiguration["Series colors"].length != columnsCount) {&#13;
            return {isValid: false, errorCode: "SERIES_COLORS_AMOUNT_INVALID"}&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {&#13;
                maximumValue: maximumValue,&#13;
                minimumValue: minimumValue,&#13;
                validRows: validRows,&#13;
                barsCount: barsCount,&#13;
                columnsCount: columnsCount,&#13;
                parsedData: parsedData&#13;
            }&#13;
        };&#13;
    };&#13;
&#13;
    presenter.parseColors = function(model) {&#13;
        var colors = [];&#13;
&#13;
        var i;&#13;
        for (i = 0; i &lt; model['Series colors'].length; i++) {&#13;
            colors.push(model['Series colors'][i]['Color']);&#13;
        }&#13;
&#13;
        return colors;&#13;
    };&#13;
&#13;
    presenter.parseData = function(model, isDecimalSeparatorSet, decimalSeparator) {&#13;
        var data = $.csv2Array(model['Data']);&#13;
&#13;
        try {&#13;
            if (isDecimalSeparatorSet) {&#13;
                for (var i= 0; i &lt; data.length; i++) {&#13;
                    for (var j= 0; j &lt; data[i].length; j++) {&#13;
                        data[i][j] = data[i][j].replace(decimalSeparator, '.');&#13;
                    }&#13;
                }&#13;
            }&#13;
        } catch ( _ ) {&#13;
            //when user inputs invalid csv syntax in data property, data is null&#13;
            //it creates error which shows popup in lesson &amp; editor&#13;
            //this error is validated in validateData&#13;
            return data&#13;
        }&#13;
&#13;
        return data;&#13;
    };&#13;
&#13;
    presenter.validateAxisXBarsDescriptions = function(model, barsCount) {&#13;
        var showXAxisBarsDescriptions = typeof(model['Show X axis bars descriptions']) != 'undefined' &amp;&amp;&#13;
            model['Show X axis bars descriptions'] === 'True';&#13;
&#13;
        var parsedXAxisBarsDescriptions = presenter.parseAxisXBarsDescriptions(model, showXAxisBarsDescriptions);&#13;
&#13;
        if (showXAxisBarsDescriptions &amp;&amp; parsedXAxisBarsDescriptions.length != barsCount) {&#13;
            return {isValid: false, errorCode: "AXIS_X_BARS_DESCRIPTIONS_AMOUNT_INVALID",&#13;
                errorMessageSubstitutions:{ bars: barsCount, descriptions: parsedXAxisBarsDescriptions.length }};&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {&#13;
                showXAxisBarsDescriptions: showXAxisBarsDescriptions,&#13;
                axisXBarsDescriptions: parsedXAxisBarsDescriptions&#13;
            }&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateAxisXSeriesDescriptions = function(model, validRows) {&#13;
        var showXAxisSeriesDescriptions = typeof(model['Show X axis series descriptions']) != 'undefined' &amp;&amp;&#13;
            model['Show X axis series descriptions'] === 'True';&#13;
        var parsedXAxisSeriesDescriptions = presenter.parseAxisXSeriesDescriptions(model, showXAxisSeriesDescriptions);&#13;
&#13;
        if (showXAxisSeriesDescriptions &amp;&amp; parsedXAxisSeriesDescriptions.length != validRows) {&#13;
            return {isValid: false, errorCode: "AXIS_X_SERIES_DESCRIPTIONS_AMOUNT_INVALID",&#13;
                errorMessageSubstitutions: { series: validRows, descriptions: parsedXAxisSeriesDescriptions.length }};&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {&#13;
                showXAxisSeriesDescriptions: showXAxisSeriesDescriptions,&#13;
                axisXSeriesDescriptions: parsedXAxisSeriesDescriptions&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isFloat = function (value) {&#13;
        value = value.trim();&#13;
        if (ModelValidationUtils.isStringEmpty(value)) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (value.charAt(0) == "+") {&#13;
            return false;&#13;
        }&#13;
&#13;
        var too_many_zeroes = /^0{2,}/;&#13;
        if (too_many_zeroes.test(value)) {&#13;
            return false;&#13;
        }&#13;
&#13;
        if ( value == "-0") {&#13;
            return false;&#13;
        }&#13;
&#13;
        if (value.charAt(0) == "-") {&#13;
            value = value.slice(1, value.length);&#13;
        }&#13;
&#13;
        var i, commas_number = 0;&#13;
        var digits = /[0-9]/;&#13;
&#13;
        for(i = 0; i &lt; value.length; i++) {&#13;
            if (value.charAt(i) == ".") {&#13;
                if (commas_number == 1) {&#13;
                    return false;&#13;
                }&#13;
                commas_number ++;&#13;
            } else {&#13;
                if (digits.test(value.charAt(i))) {&#13;
                    continue;&#13;
                } else {&#13;
                    return false;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.checkIfValueInAxisRange = function (value, yMax, yMin) {&#13;
        if (value &gt; yMax) {&#13;
            return {isValid: false, errorCode: "YAV_03"};&#13;
        }&#13;
&#13;
        if (value &lt; yMin) {&#13;
            return {isValid: false, errorCode: "YAV_04"};&#13;
        }&#13;
&#13;
        return {isValid: true, value: value};&#13;
    };&#13;
&#13;
    presenter.checkCyclicValue = function (value, yMax, yMin) {&#13;
        if (!presenter.isFloat(value)) {&#13;
            return {isValid: false, errorCode: "YAV_01"};&#13;
        }&#13;
&#13;
        value = parseFloat(value);&#13;
&#13;
        if (value == 0) {&#13;
            return {isValid: false, errorCode: "YAV_02"};&#13;
        }&#13;
&#13;
        if (value &lt; 0) {&#13;
            return {isValid: false, errorCode: "YAV_05"};&#13;
        }&#13;
&#13;
&#13;
        var validatedValue = presenter.checkIfValueInAxisRange(value, yMax, yMin);&#13;
&#13;
        return validatedValue;&#13;
    };&#13;
&#13;
    presenter.checkFixedValue = function (value, yMax, yMin) {&#13;
        if (!presenter.isFloat(value)) {&#13;
            return {isValid: false, errorCode: "YAV_01"};&#13;
        } else {&#13;
            var validatedValue = presenter.checkIfValueInAxisRange(parseFloat(value), yMax, yMin);&#13;
        }&#13;
&#13;
        return validatedValue;&#13;
    };&#13;
&#13;
    presenter.createAxisYValues = function (fixedValues, cyclicValues, yMax, yMin) {&#13;
        var values = [];&#13;
        var i;&#13;
&#13;
        if (fixedValues == undefined &amp;&amp; cyclicValues == undefined) {&#13;
            cyclicValues = [presenter.configuration.axisYGridStep];&#13;
        }&#13;
&#13;
        if (fixedValues != undefined) {&#13;
            for(i = 0; i &lt; fixedValues.length; i++) {&#13;
                values.push(fixedValues[i]);&#13;
            }&#13;
        }&#13;
&#13;
        if (cyclicValues != undefined) {&#13;
&#13;
            for(i = 0; i &lt; cyclicValues.length; i++) {&#13;
                var step = cyclicValues[i];&#13;
&#13;
                var splittedStep = step.toString().split('.');&#13;
&#13;
                var value;&#13;
                if(splittedStep[1]){&#13;
                    var commaLength = splittedStep[1].length;&#13;
                    for(value = step; value.toFixed(commaLength) &lt;= yMax; value += step) {&#13;
                        values.push(value.toFixed(commaLength));&#13;
                    }&#13;
                }else{&#13;
                    for(value = step; value &lt;= yMax; value += step) {&#13;
                        values.push(value);&#13;
                    }&#13;
                }&#13;
&#13;
                for(value = -step; value &gt;= yMin; value -= step) {&#13;
                    values.push(value);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return values;&#13;
    };&#13;
&#13;
    presenter.validateAxisYValues = function(model, yMax, yMin, isDecimalSeparatorSet) {&#13;
        var values = model["Y axis values"];&#13;
        var i;&#13;
&#13;
        var parsedAxisYValues = {isValid: true, fixedValues: undefined, cyclicValues: undefined};&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(values.trim())) {&#13;
            return parsedAxisYValues;&#13;
        }&#13;
&#13;
        values = values.split(";");&#13;
&#13;
        if(isDecimalSeparatorSet) {&#13;
            for(i = 0; i &lt; values.length; i++) {&#13;
                values[i] = values[i].replace(model["Decimal separator"], '.');&#13;
            }&#13;
        }&#13;
&#13;
        for(i = 0; i &lt; values.length; i++) {&#13;
            var value = values[i].trim();&#13;
            var endChar = value.length - 1;&#13;
            var validatedValue;&#13;
&#13;
            if(value.charAt(endChar) == "*") {&#13;
                validatedValue = presenter.checkCyclicValue(value.slice(0, endChar), yMax, yMin);&#13;
&#13;
                if (!validatedValue.isValid) {&#13;
                    return validatedValue;&#13;
                }&#13;
&#13;
                if (parsedAxisYValues.cyclicValues == undefined) {&#13;
                    parsedAxisYValues.cyclicValues = [];&#13;
                }&#13;
&#13;
                if (parsedAxisYValues.cyclicValues.indexOf(validatedValue.value) == -1) {&#13;
                    parsedAxisYValues.cyclicValues.push(validatedValue.value);&#13;
                    continue;&#13;
                }&#13;
&#13;
                return {isValid: false, errorCode: "YAV_06"};&#13;
&#13;
            } else {&#13;
                validatedValue = presenter.checkFixedValue(value, yMax, yMin);&#13;
&#13;
                if (!validatedValue.isValid) {&#13;
                    return validatedValue;&#13;
                }&#13;
&#13;
                if (parsedAxisYValues.fixedValues == undefined) {&#13;
                    parsedAxisYValues.fixedValues = [];&#13;
                }&#13;
&#13;
                if (parsedAxisYValues.fixedValues.indexOf(validatedValue.value) == -1) {&#13;
                    parsedAxisYValues.fixedValues.push(validatedValue.value);&#13;
                    continue;&#13;
                }&#13;
&#13;
                return {isValid: false, errorCode: "YAV_06"};&#13;
            }&#13;
        }&#13;
&#13;
        return parsedAxisYValues;&#13;
    };&#13;
&#13;
    presenter.validateAnswers = function (answers, barsCount) {&#13;
        var validatedAnswers = [], i;&#13;
&#13;
        for (i = 0; i &lt; answers.length; i++) {&#13;
            var answer = answers[i]['Answer'];&#13;
&#13;
            if (presenter.configuration.isDecimalSeparatorSet) {&#13;
                answer = answer.replace(presenter.configuration.decimalSeparator, '.');&#13;
            }&#13;
&#13;
            var parseAnswer = parseFloat(answer);&#13;
            if (isNaN(parseAnswer)) {&#13;
                return { isValid: false, errorCode: 'ANSWER_NOT_NUMERIC', errorMessageSubstitutions: { answer: i + 1 } };&#13;
            }&#13;
&#13;
            validatedAnswers.push(parseAnswer);&#13;
        }&#13;
&#13;
        if (validatedAnswers.length != barsCount) {&#13;
            return { isValid: false, errorCode: 'ANSWERS_AMOUNT_INVALID', errorMessageSubstitutions: { answers: validatedAnswers.length, bars: barsCount } };&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            answers: validatedAnswers&#13;
        };&#13;
    };&#13;
&#13;
    presenter.drawGrid = function (grid) {&#13;
        var axisYGridStep = presenter.configuration.axisYGridStep;&#13;
        var drawingGridStep = presenter.chartInner.height() * axisYGridStep / presenter.absoluteRange;&#13;
        var i;&#13;
&#13;
&#13;
        for (i = axisYGridStep; i &lt;= presenter.configuration.axisYMaximumValue; i += axisYGridStep) {&#13;
            var currentGridBlock = $('&lt;div class="graph_grid_block graph_grid_block_above"&gt;&lt;/div&gt;');&#13;
            grid.append(currentGridBlock);&#13;
            currentGridBlock.css({&#13;
                height: (drawingGridStep - parseInt(currentGridBlock.css('borderTopWidth'))) + 'px',&#13;
                bottom: presenter.drawingXPosition - drawingGridStep + (drawingGridStep * i / axisYGridStep)&#13;
            });&#13;
        }&#13;
&#13;
&#13;
        for (i = -1 * axisYGridStep; i &gt;= presenter.configuration.axisYMinimumValue; i -= axisYGridStep) {&#13;
            currentGridBlock = $('&lt;div class="graph_grid_block graph_grid_block_below"&gt;&lt;/div&gt;');&#13;
            grid.append(currentGridBlock);&#13;
            currentGridBlock.css({&#13;
                height: (drawingGridStep - parseInt(currentGridBlock.css('borderBottomWidth'))) + 'px',&#13;
                bottom: presenter.drawingXPosition + (drawingGridStep * i / axisYGridStep)&#13;
            });&#13;
        }&#13;
&#13;
        return grid;&#13;
    };&#13;
&#13;
    presenter.createGridDescriptions = function (innerContainer) {&#13;
        var gridDescription, gridDescriptionText;&#13;
        var maximumGridDescriptionWidth = null;&#13;
        var currentGridDescriptionWidth;&#13;
        var i;&#13;
&#13;
        var fixedValues = presenter.configuration.axisYValues.fixedValues;&#13;
        var cyclicValues = presenter.configuration.axisYValues.cyclicValues;&#13;
        var yMax = presenter.configuration.axisYMaximumValue;&#13;
        var yMin = presenter.configuration.axisYMinimumValue;&#13;
        var values = presenter.createAxisYValues(fixedValues, cyclicValues, yMax, yMin);&#13;
&#13;
&#13;
        for (i = 0; i &lt; values.length; i++) {&#13;
            gridDescription = $('&lt;div class="graph_grid_description"&gt;&lt;/div&gt;');&#13;
            gridDescription.addClass('graph_grid_description_' + ("" + values[i]).toString().replace('.', '_'));&#13;
            gridDescriptionText = "" + values[i];&#13;
            if (presenter.configuration.isDecimalSeparatorSet) {&#13;
                gridDescriptionText = gridDescriptionText.replace('.', presenter.configuration.decimalSeparator);&#13;
            }&#13;
            gridDescription.text(gridDescriptionText);&#13;
            innerContainer.append(gridDescription);&#13;
&#13;
            currentGridDescriptionWidth = gridDescription.width();&#13;
            if (maximumGridDescriptionWidth === null || currentGridDescriptionWidth &gt; maximumGridDescriptionWidth) {&#13;
                maximumGridDescriptionWidth = currentGridDescriptionWidth;&#13;
            }&#13;
        }&#13;
&#13;
        presenter.$view.find('.graph_grid_description').css('width', maximumGridDescriptionWidth + 'px');&#13;
&#13;
        return { maximumGridDescriptionWidth: maximumGridDescriptionWidth , axisYValues: values};&#13;
    };&#13;
&#13;
    presenter.positionAxisYValues = function (values, xAxisDescriptionMargin) {&#13;
        var i, containerHeight = presenter.chartInner.height();&#13;
&#13;
        for (i = 0; i &lt; values.length; i++) {&#13;
            //rescale every value to 0 - positive, and calculate what percentage of height they are&#13;
            var descriptionElementHeight = (values[i] - presenter.configuration.axisYMinimumValue) ;&#13;
            descriptionElementHeight = (descriptionElementHeight / presenter.absoluteRange) * containerHeight;&#13;
&#13;
            presenter.$view.find('.graph_grid_description_' + String(values[i]).toString().replace('.', '_')).each(function (index, element) {&#13;
                $(element).css({&#13;
                    bottom: (descriptionElementHeight - ($(element).height() / 2) + xAxisDescriptionMargin) + 'px'&#13;
                });&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    presenter.deleteCommands = function () {&#13;
        delete presenter.getMaxScore;&#13;
        delete presenter.getScore;&#13;
        delete presenter.setState;&#13;
        delete presenter.getState;&#13;
        delete presenter.getValue;&#13;
    };&#13;
&#13;
    presenter.initialize = function(view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        var upgradedModel = presenter.upgradeModel(model);&#13;
        var validatedModel = presenter.validateModel(upgradedModel);&#13;
&#13;
        presenter.configuration = validatedModel;&#13;
&#13;
        if (!validatedModel.isValid) {&#13;
            presenter.showErrorMessage(presenter.ERROR_MESSAGES[validatedModel.errorCode], validatedModel.errorMessageSubstitutions);&#13;
            presenter.deleteCommands();&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        if (isPreview) presenter.configuration.isInteractive = false;&#13;
&#13;
        presenter.drawGraph(view, model);&#13;
    };&#13;
&#13;
    presenter.drawGraph = function (view, model) {&#13;
        // Read data&#13;
        var i, j;&#13;
        var validRows = presenter.configuration.validRows;&#13;
        var columnsCount = presenter.configuration.columnsCount;&#13;
&#13;
        var showXAxisBarsDescriptions = presenter.configuration.showXAxisBarsDescriptions;&#13;
        var showXAxisSeriesDescriptions = presenter.configuration.showXAxisSeriesDescriptions;&#13;
&#13;
        var xAxisBarsDescriptions = presenter.configuration.axisXBarsDescriptions;&#13;
        var xAxisSeriesDescriptions = presenter.configuration.axisXSeriesDescriptions;&#13;
&#13;
&#13;
&#13;
        // Draw graph's containers&#13;
        var outerContainer = $('&lt;div class="graph_container_outer"&gt;&lt;/div&gt;');&#13;
        presenter.$view.append(outerContainer);&#13;
&#13;
        var innerContainer = $('&lt;div class="graph_container_inner"&gt;&lt;/div&gt;');&#13;
        outerContainer.append(innerContainer);&#13;
&#13;
        // Draw axis descriptions&#13;
        var axisYDescription = $('&lt;div class="graph_axis_description graph_axis_y_description"&gt;&lt;/div&gt;');&#13;
        axisYDescription.text(model['Y axis description']);&#13;
        innerContainer.append(axisYDescription);&#13;
&#13;
        var axisXDescription = $('&lt;div class="graph_axis_description graph_axis_x_description"&gt;&lt;/div&gt;');&#13;
        axisXDescription.text(model['X axis description']);&#13;
        innerContainer.append(axisXDescription);&#13;
&#13;
&#13;
        // Draw outer chart container and set its position using&#13;
        // Y axis description's height and X axis description's width&#13;
        // plus 4px margin&#13;
        var chartOuter = $('&lt;div class="graph_chart_outer"&gt;&lt;/div&gt;');&#13;
        chartOuter.css({&#13;
            top: (axisYDescription.height() + 4) + 'px',&#13;
            right: (axisXDescription.width() + 4) + 'px'&#13;
        });&#13;
        innerContainer.append(chartOuter);&#13;
&#13;
        // Create axis Y Values&#13;
        var gridDescriptionsObject = presenter.createGridDescriptions(innerContainer);&#13;
        var maximumGridDescriptionWidth = gridDescriptionsObject.maximumGridDescriptionWidth;&#13;
        var axisYValues = gridDescriptionsObject.axisYValues;&#13;
&#13;
        // Draw inner chart container and set its position using&#13;
        // Y axis descriptions' width plus 4px margin&#13;
        var xAxisDescriptionMargin = 0;&#13;
        if (showXAxisBarsDescriptions) {&#13;
            xAxisDescriptionMargin += 20;&#13;
        }&#13;
&#13;
        if (showXAxisSeriesDescriptions) {&#13;
            xAxisDescriptionMargin += 20;&#13;
        }&#13;
&#13;
        presenter.chartInner = $('&lt;div class="graph_chart_inner"&gt;&lt;/div&gt;');&#13;
        presenter.chartInner.css({&#13;
            left: (maximumGridDescriptionWidth + 4) + 'px',&#13;
            bottom: (xAxisDescriptionMargin) + 'px'&#13;
        });&#13;
        chartOuter.append(presenter.chartInner);&#13;
&#13;
&#13;
        // Calculate position of axis X, grid &amp; interactive step&#13;
        presenter.absoluteRange = presenter.configuration.axisYMaximumValue - presenter.configuration.axisYMinimumValue;&#13;
        var absoluteXPosition = presenter.absoluteRange - presenter.configuration.axisYMaximumValue;&#13;
&#13;
        presenter.drawingXPosition = presenter.chartInner.height() * absoluteXPosition / presenter.absoluteRange;&#13;
&#13;
        // Move Y axis descriptions to the right place and draw grid&#13;
        var grid = $('&lt;div class="graph_grid"&gt;&lt;/div&gt;');&#13;
        presenter.chartInner.append(grid);&#13;
&#13;
        grid = presenter.drawGrid(grid);&#13;
        presenter.positionAxisYValues(axisYValues, xAxisDescriptionMargin);&#13;
&#13;
        // Draw axis X&#13;
        presenter.axisXLine = $('&lt;div class="graph_axis_x_line graph_axis_line"&gt;&lt;/div&gt;');&#13;
        presenter.chartInner.append(presenter.axisXLine);&#13;
        presenter.axisXLine.css('bottom', (presenter.drawingXPosition - Math.round(presenter.axisXLine.height() / 2)) + 'px');&#13;
&#13;
        var axisXArrow = $('&lt;div class="graph_axis_x_arrow graph_axis_arrow"&gt;&lt;/div&gt;');&#13;
        presenter.chartInner.append(axisXArrow);&#13;
&#13;
&#13;
        // Prepare drawing of the graph itself&#13;
        var serieContainer;&#13;
        var serieElement;&#13;
        var columnContainer;&#13;
        var columnContainerBelow;&#13;
        var columnContainerAbove;&#13;
        var valueContainer;&#13;
        var valueElement;&#13;
        var columnDescription;&#13;
        var serieDescription;&#13;
&#13;
        var serieWidth = Math.round(parseInt(presenter.chartInner.width() / validRows));&#13;
&#13;
        // Adjust serieWidth to previous value that divides by columnsCount without rest&#13;
        while (serieWidth % columnsCount !== 0) {&#13;
            serieWidth--;&#13;
        }&#13;
&#13;
        var columnWidth = (100.0 / columnsCount) + '%';&#13;
&#13;
        var series = $('&lt;div class="graph_series"&gt;&lt;/div&gt;');&#13;
        presenter.axisXLine.before(series);&#13;
&#13;
&#13;
        for (i = 0; i &lt; presenter.configuration.data.length; i++) {&#13;
            // Skip empty rows&#13;
            if (presenter.configuration.data[i].length === 0) {&#13;
                continue;&#13;
            }&#13;
&#13;
            serieContainer = $('&lt;div class="graph_serie_container"&gt;&lt;/div&gt;');&#13;
            serieContainer.css('width', serieWidth);&#13;
&#13;
            serieElement = $('&lt;div class="graph_serie_element graph_serie_size"&gt;&lt;/div&gt;');&#13;
            serieContainer.append(serieElement);&#13;
&#13;
&#13;
            if (showXAxisSeriesDescriptions) {&#13;
                serieDescription = $('&lt;div class="graph_serie_description"&gt;&lt;/div&gt;');&#13;
                serieDescription.text(xAxisSeriesDescriptions[i]);&#13;
                serieElement.append(serieDescription);&#13;
&#13;
                if (showXAxisBarsDescriptions) {&#13;
                    serieDescription.css('bottom', '-40px');&#13;
                } else {&#13;
                    serieDescription.css('bottom', '-20px');&#13;
                }&#13;
            }&#13;
&#13;
&#13;
            for (j = 0; j &lt; presenter.configuration.data[i].length; j++) {&#13;
                columnContainer = $('&lt;div class="graph_column_container"&gt;&lt;/div&gt;');&#13;
                columnContainer.css('width', columnWidth);&#13;
&#13;
                if (presenter.configuration.isInteractive) {&#13;
                    columnContainerBelow = $('&lt;div class="graph_value_size graph_column_container_interactive graph_column_container_below"&gt;&lt;/div&gt;');&#13;
                    columnContainerAbove = $('&lt;div class="graph_value_size graph_column_container_interactive graph_column_container_above"&gt;&lt;/div&gt;');&#13;
                    columnContainer.append(columnContainerBelow);&#13;
                    columnContainer.append(columnContainerAbove);&#13;
                    columnContainerBelow.css('top', (presenter.chartInner.height() - presenter.drawingXPosition) + 'px');&#13;
                    columnContainerAbove.css('bottom', presenter.drawingXPosition + 'px');&#13;
&#13;
                    columnContainerAbove.click(presenter.increaseGraphValue);&#13;
                    columnContainerBelow.click(presenter.decreaseGraphValue);&#13;
                }&#13;
&#13;
                valueContainer = $('&lt;div class="graph_value_container"&gt;&lt;/div&gt;');&#13;
&#13;
                valueElement = $('&lt;div class="graph_value_element graph_value_size"&gt;&lt;/div&gt;');&#13;
                if (presenter.configuration.isInteractive) {&#13;
                    valueElement.addClass('graph_value_element_interactive');&#13;
                    valueElement.click(presenter.decreaseGraphValue);&#13;
                }&#13;
&#13;
                valueElement.css('backgroundColor', presenter.configuration.seriesColors[j]);&#13;
&#13;
                valueContainer.attr('current-value', presenter.configuration.data[i][j]);&#13;
                valueContainer.attr('value-id', i + ' ' + j);&#13;
                valueContainer.append(valueElement);&#13;
&#13;
                if (presenter.configuration.isInteractive) {&#13;
                    $(valueContainer).mousedown(mouseDownCallback);&#13;
                    valueContainer[0].ontouchstart = touchStartCallback;&#13;
                }&#13;
&#13;
                if (showXAxisBarsDescriptions) {&#13;
                    columnDescription = $('&lt;div class="graph_column_description graph_value_size"&gt;&lt;/div&gt;');&#13;
                    columnDescription.text(xAxisBarsDescriptions[i * columnsCount + j]);&#13;
                    columnContainer.append(columnDescription);&#13;
                }&#13;
&#13;
                presenter.redrawGraphValue(valueContainer);&#13;
                columnContainer.append(valueContainer);&#13;
&#13;
                if (presenter.configuration.isInteractive) {&#13;
                    $(columnContainer).mousedown(columnContainerMouseDownCallback);&#13;
                    columnContainer[0].ontouchstart = columnContainerTouchStartCallback;&#13;
                    $(columnContainer).mouseup(mouseUpCallback);&#13;
                    columnContainer[0].ontouchend = touchEndCallback;&#13;
                    $(columnContainer).mousemove(mouseMoveCallback);&#13;
                    columnContainer[0].ontouchmove = touchMoveCallback;&#13;
                }&#13;
&#13;
                serieElement.append(columnContainer);&#13;
            }&#13;
&#13;
            series.append(serieContainer);&#13;
        }&#13;
&#13;
        // Move axis X description &amp; arrow to right place&#13;
        axisXDescription.css('bottom', (presenter.drawingXPosition - Math.round(axisXDescription.height() / 2) + xAxisDescriptionMargin) + 'px');&#13;
        axisXArrow.css('bottom', (presenter.drawingXPosition - parseInt(axisXArrow.css('borderLeftWidth'))) + 'px');&#13;
&#13;
        // Draw axis Y&#13;
        var axisYLine = $('&lt;div class="graph_axis_y_line graph_axis_line"&gt;&lt;/div&gt;');&#13;
        presenter.chartInner.append(axisYLine);&#13;
&#13;
        var axisYArrow = $('&lt;div class="graph_axis_y_arrow graph_axis_arrow"&gt;&lt;/div&gt;');&#13;
        presenter.chartInner.append(axisYArrow);&#13;
&#13;
        // Move axis Y description &amp; arrow to right place&#13;
        var axisYDescriptionLeft = parseInt(presenter.chartInner.css('left')) - Math.round(axisYDescription.width() / 2);&#13;
        if (axisYDescriptionLeft &lt; 0) {&#13;
            axisYDescriptionLeft = 0;&#13;
        }&#13;
        axisYDescription.css('left', axisYDescriptionLeft + 'px');&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, eventData) {&#13;
        switch (eventName) {&#13;
            case 'GradualShowAnswers':&#13;
                presenter.gradualShowAnswers(eventData);&#13;
                break;&#13;
&#13;
            case 'ShowAnswers':&#13;
                presenter.showAnswers();&#13;
                break;&#13;
&#13;
            case 'HideAnswers':&#13;
                presenter.hideAnswers();&#13;
                break;&#13;
&#13;
            case 'GradualHideAnswers':&#13;
                presenter.gradualHideAnswers();&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (presenter.configuration.isNotActivity) return;&#13;
&#13;
        if (presenter.errorMode){&#13;
            presenter.setWorkMode();&#13;
        }&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
        presenter.currentData = [];&#13;
        presenter.setCurrentState();&#13;
&#13;
        presenter.$view.find(".graph_value_container").each(function (index, element) {&#13;
            presenter.addAnswerToGraph(index, element);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (presenter.configuration.isNotActivity || !presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.$view.find(".graph_value_container").each(function (index, element) {&#13;
            presenter.removeAnswerFromGraph(index, element);&#13;
        });&#13;
&#13;
        presenter.isShowAnswersActive = false;&#13;
    };&#13;
&#13;
    presenter.gradualShowAnswers = function (eventData) {&#13;
        if (eventData.moduleID !== presenter.configuration.ID) return;&#13;
&#13;
        if (presenter.errorMode){&#13;
            presenter.setWorkMode();&#13;
        }&#13;
&#13;
        let itemIndex = parseInt(eventData.item, 10);&#13;
        const graphAnswers = presenter.$view.find(".graph_value_container");&#13;
        presenter.isGradualShowAnswersActive = true;&#13;
&#13;
        itemIndex = itemIndex &lt; presenter.GSAcounter ? presenter.GSAcounter : itemIndex;&#13;
&#13;
        presenter.setCurrentState();&#13;
        presenter.addAnswerToGraph(itemIndex, $(graphAnswers[itemIndex]));&#13;
&#13;
        presenter.GSAcounter = ++itemIndex;&#13;
        presenter.isGradualShowAnswersActive = true;&#13;
    }&#13;
    &#13;
    presenter.gradualHideAnswers = function () {&#13;
        if (presenter.configuration.isNotActivity || !presenter.isGradualShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.$view.find(".graph_value_container").each(function (index, element) {&#13;
            presenter.removeAnswerFromGraph(index, element);&#13;
        });&#13;
&#13;
        presenter.isGradualShowAnswersActive = false;&#13;
        presenter.currentData = [];&#13;
        presenter.GSAcounter = 0;&#13;
    }&#13;
&#13;
    presenter.setCurrentState = function () {&#13;
        presenter.$view.find(".graph_value_container").each(function (index, element) {&#13;
            presenter.currentData[index] = $(element).attr("current-value");&#13;
        });&#13;
    }&#13;
&#13;
    presenter.shouldStopAction = function () {&#13;
        return presenter.isDisplayingAnswers() || presenter.errorMode;&#13;
    }&#13;
&#13;
    presenter.isDisplayingAnswers = function () {&#13;
        return presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive;&#13;
    }&#13;
&#13;
    presenter.addAnswerToGraph = function (index, element) {&#13;
        const currentValue = presenter.configuration.answers[index],&#13;
            valueContainer = $(element),&#13;
            $columnContainer = valueContainer.parent('').find('.graph_column_container_interactive');&#13;
        if(currentValue &gt;= 0) {&#13;
            valueContainer.css({&#13;
                bottom: (presenter.drawingXPosition - Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                height: parseFloat(currentValue / presenter.absoluteRange) * 100 + '%',&#13;
                top: ''&#13;
            });&#13;
        } else {&#13;
            valueContainer.css({&#13;
                height: parseFloat(currentValue * -1 / presenter.absoluteRange) * 100 + '%',&#13;
                top: (presenter.chartInner.height() - presenter.drawingXPosition + Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                bottom: ''&#13;
            });&#13;
        }&#13;
        $columnContainer.addClass('graph_column_container_show_answers');&#13;
        valueContainer.addClass('graph_show_answers');&#13;
    }&#13;
&#13;
    presenter.removeAnswerFromGraph = function (index, element) {&#13;
        const currentValue = presenter.currentData[index],&#13;
            valueContainer = $(element),&#13;
            $columnContainer = valueContainer.parent('').find('.graph_column_container_interactive');&#13;
&#13;
        if(currentValue &gt;= 0) {&#13;
            valueContainer.css({&#13;
                bottom: (presenter.drawingXPosition - Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                height: parseFloat(currentValue / presenter.absoluteRange) * 100 + '%',&#13;
                top: ''&#13;
            });&#13;
        } else if (currentValue &lt; 0) {&#13;
            valueContainer.css({&#13;
                height: parseFloat(currentValue * -1 / presenter.absoluteRange) * 100 + '%',&#13;
                top: (presenter.chartInner.height() - presenter.drawingXPosition + Math.round(presenter.axisXLine.height() / 2)) + 'px',&#13;
                bottom: ''&#13;
            });&#13;
        }&#13;
        $columnContainer.removeClass('graph_column_container_show_answers');&#13;
        valueContainer.removeClass('graph_show_answers');&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>