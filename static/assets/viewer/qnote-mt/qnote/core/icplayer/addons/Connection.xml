<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Connection" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property displayName="Is not an activity" name="isNotActivity" nameLabel="Connection_property_is_not_activity" type="boolean"/>
        <property name="Single connection mode" nameLabel="Connection_property_single_connection_mode" type="boolean"/>
        <property isDefault="true" name="Left column" nameLabel="Connection_property_left_column" type="list">
            <property name="id" nameLabel="Connection_property_id" type="string"/>
            <property isLocalized="true" name="content" nameLabel="Connection_property_content" type="html"/>
            <property name="connects to" nameLabel="Connection_property_connects_to" type="string"/>
            <property name="additional class" nameLabel="Connection_property_additional_class" type="string"/>
        </property>
        <property name="Right column" nameLabel="Connection_property_right_column" type="list">
            <property name="id" nameLabel="Connection_property_id" type="string"/>
            <property isLocalized="true" name="content" nameLabel="Connection_property_content" type="html"/>
            <property name="connects to" nameLabel="Connection_property_connects_to" type="string"/>
            <property name="additional class" nameLabel="Connection_property_additional_class" type="string"/>
        </property>
        <property name="Columns width" nameLabel="Connection_property_columns_width" type="list">
            <property name="left" nameLabel="Connection_property_left" type="string"/>
            <property name="middle" nameLabel="Connection_property_middle" type="string"/>
            <property name="right" nameLabel="Connection_property_right" type="string"/>
        </property>
        <property name="initialConnections" nameLabel="Connection_property_initial_connection" type="list">
            <property name="from" nameLabel="Connection_property_initial_connection_from" type="string"/>
            <property name="to" nameLabel="Connection_property_initial_connection_to" type="string"/>
            <property name="isDisabled" nameLabel="Connection_property_initial_connection_is_disabled" type="boolean"/>
        </property>
        <property name="Default connection color" nameLabel="Connection_property_default_connection_color" type="string"/>
        <property name="Correct connection color" nameLabel="Connection_property_correct_connection_color" type="string"/>
        <property name="disabledConnectionColor" nameLabel="Connection_property_disabled_connection_color" type="string"/>
        <property name="Incorrect connection color" nameLabel="Connection_property_incorrect_connection_color" type="string"/>
        <property name="Connection thickness" nameLabel="Connection_property_connection_thickness" type="string"/>
        <property name="Random order left column" nameLabel="Connection_property_random_order_left_column" type="boolean"/>
        <property name="Random order right column" nameLabel="Connection_property_random_order_right_column" type="boolean"/>
        <property name="Show answers line color" nameLabel="Connection_property_show_answers_line_color" type="string"/>
        <property displayName="Block wrong answers" name="blockWrongAnswers" nameLabel="Connection_property_block_wrong_answers" type="boolean"/>
        <property displayName="Remove dragged element" name="removeDraggedElement" nameLabel="Connection_property_remove_dragged_element" type="boolean"/>

        <property displayName="Lang attribute" name="langAttribute" nameLabel="Connection_property_lang_attribute" type="string"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="Connection_property_speech_texts" type="staticlist">

            <property name="Connected" nameLabel="Connection_connected" type="staticrow">
                <property name="Connected" nameLabel="Connection_connected" type="string"/>
            </property>

            <property name="Disconnected" nameLabel="Connection_disconnected" type="staticrow">
                <property name="Disconnected" nameLabel="Connection_disconnected" type="string"/>
            </property>

            <property name="ConnectedTo" nameLabel="Connection_connected_to" type="staticrow">
                <property name="Connected to" nameLabel="Connection_connected_to" type="string"/>
            </property>

            <property name="Selected" nameLabel="Connection_selected" type="staticrow">
                <property name="Selected" nameLabel="Connection_selected" type="string"/>
            </property>

            <property name="Deselected" nameLabel="Connection_deselected" type="staticrow">
                <property name="Deselected" nameLabel="Connection_deselected" type="string"/>
            </property>

            <property name="Correct" nameLabel="Connection_correct" type="staticrow">
                <property name="Correct" nameLabel="Connection_correct" type="string"/>
            </property>

            <property name="Wrong" nameLabel="Connection_wrong" type="staticrow">
                <property name="Wrong" nameLabel="Connection_wrong" type="string"/>
            </property>
        </property>
        <property name="printable" nameLabel="printable_name_label" type="{No, Don't randomize, Randomize}"/>
        <property name="Orientations" nameLabel="Connection_orientations_list" type="list">
            <property name="Layout" nameLabel="Connection_orientation_layout" type="string"/>
            <property name="Orientation" nameLabel="Connection_orientation_name" type="{Vertical, Horizontal}"/>
        </property>
    </model>
<css>.connectionContainer {&#13;
    height: 100%;&#13;
    width: 100%;&#13;
    padding: 0px;&#13;
    border-collapse:collapse;&#13;
    border-spacing: 0px;&#13;
    direction: ltr;&#13;
}&#13;
&#13;
.connectionContainer .connectionLeftColumn {&#13;
    width: 33%;&#13;
    height: 100%;&#13;
    padding: 0px;&#13;
}&#13;
&#13;
.connectionContainer .connectionMiddleColumn {&#13;
    width: 34%;&#13;
    height: 100%;&#13;
    padding: 0px;&#13;
    overflow: hidden;&#13;
    overflow-x: visible;&#13;
}&#13;
&#13;
.connectionContainer .connectionRightColumn {&#13;
    width: 33%;&#13;
    height: 100%;&#13;
    padding: 0px;&#13;
}&#13;
&#13;
.connectionContainer .connectionTopRow {&#13;
    width: 100%;&#13;
    height: 33%;&#13;
    padding: 0px;&#13;
}&#13;
&#13;
.connectionContainer .connectionMiddleRow {&#13;
    width: 100%;&#13;
    height: 33%;&#13;
    padding: 0px;&#13;
    overflow: hidden;&#13;
    overflow-y: visible;&#13;
}&#13;
&#13;
.connectionContainer .connectionBottomRow {&#13;
    width: 100%;&#13;
    height: 33%;&#13;
    padding: 0px;&#13;
}&#13;
&#13;
.connectionContainer .connections {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.connectionContainer .connectionItem {&#13;
    width: 100%;&#13;
    padding: 0px;&#13;
    border-collapse:collapse;&#13;
    border-spacing: 0px;&#13;
    border: solid 1px black;&#13;
}&#13;
&#13;
.connectionContainer .connectionMiddleRow &gt; td {&#13;
    display: flex;&#13;
}&#13;
&#13;
.connectionContainer .answerItem {&#13;
    width: 100%;&#13;
    padding: 0px;&#13;
}&#13;
&#13;
.connectionContainer .content {&#13;
    height: 100%;&#13;
    width: 100%;&#13;
    border-collapse:collapse;&#13;
    border-spacing: 0px;&#13;
}&#13;
&#13;
.connectionContainer .content .connectionItemWrapper {&#13;
    padding: 0px;&#13;
}&#13;
&#13;
.connectionContainer .connectionTopRow .content .connectionItemWrapper {&#13;
    vertical-align: bottom;&#13;
}&#13;
&#13;
.connectionContainer .connectionBottomRow .content .connectionItemWrapper {&#13;
    vertical-align: top;&#13;
}&#13;
&#13;
.connection_line {&#13;
    position: absolute;&#13;
    height:2px;&#13;
}&#13;
&#13;
.correctAnswerDiv::before {&#13;
    content: "\2714";&#13;
}&#13;
&#13;
.inCorrectAnswerDiv::before {&#13;
    content: "\2716";&#13;
}&#13;
</css><view>&lt;table class="connectionContainer"&gt;&lt;/table&gt;&#13;
</view><preview>&lt;table class="connectionContainer"&gt;&lt;/table&gt;&#13;
</preview><presenter>function AddonConnection_create() {&#13;
&#13;
    function getTextVoiceObject(text, lang) {&#13;
        return {text: text, lang: lang};&#13;
    }&#13;
&#13;
    var presenter = function () {&#13;
    };&#13;
&#13;
    var playerController;&#13;
    var eventBus;&#13;
    var addonID;&#13;
    var isWCAGOn = false;&#13;
    var currentLayoutName = "";&#13;
&#13;
    presenter.uniqueIDs = [];&#13;
    presenter.elements = [];&#13;
    presenter.lastClickTime = 0;&#13;
    presenter.lastEvent = null;&#13;
    presenter.disabledConnections = [];&#13;
    presenter.keyboardControllerObject = null;&#13;
    presenter.speechTexts = {};&#13;
    presenter.columnSizes = {};&#13;
    presenter.lineStackSA = [];&#13;
&#13;
    presenter.isShowAnswersActive = false;&#13;
    presenter.isGradualShowAnswersActive = false;&#13;
    presenter.GSAcounter = 0;&#13;
    presenter.isCheckActive = false;&#13;
    presenter.initialState = null;&#13;
    presenter.isHorizontal = false;&#13;
&#13;
    presenter.mathJaxLoaders = {&#13;
        runLoaded: false,&#13;
        setStateLoaded: true,&#13;
    };&#13;
&#13;
    presenter.PRINTABLE_STATE_MODE = {&#13;
        EMPTY: 0,&#13;
        SHOW_ANSWERS: 1,&#13;
        SHOW_USER_ANSWERS: 2,&#13;
        CHECK_ANSWERS: 3&#13;
    };&#13;
&#13;
    presenter.printableState = null;&#13;
    presenter.printableParserID = "";&#13;
    presenter.printableParserCallback = null;&#13;
    presenter.printableClassNames = [];&#13;
    presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.EMPTY;&#13;
&#13;
    presenter.CSS_CLASSES = {&#13;
        CONNECTION_CONTAINER: "connectionContainer",&#13;
        CONNECTIONS_LEFT_COLUMN: "connectionLeftColumn",&#13;
        CONNECTIONS_MIDDLE_COLUMN: "connectionMiddleColumn",&#13;
        CONNECTIONS_RIGHT_COLUMN: "connectionRightColumn",&#13;
        CONNECTIONS_TOP_ROW: "connectionTopRow",&#13;
        CONNECTIONS_MIDDLE_ROW: "connectionMiddleRow",&#13;
        CONNECTIONS_BOTTOM_ROW: "connectionBottomRow",&#13;
        CONTENT: "content",&#13;
        CONNECTIONS: "connections",&#13;
        CONNECTION_ITEM: "connectionItem",&#13;
        CONNECTION_ITEM_WRAPPER: "connectionItemWrapper",&#13;
        ICON: "icon",&#13;
        ICON_WRAPPER: "iconWrapper",&#13;
        INNER: "inner",&#13;
        INNER_WRAPPER: "innerWrapper",&#13;
        SELECTED: "selected",&#13;
    };&#13;
&#13;
    var deferredCommandQueue = window.DecoratorUtils.DeferredSyncQueue(checkIsMathJaxLoaded);&#13;
&#13;
    function checkIsMathJaxLoaded() {&#13;
        return presenter.mathJaxLoaders.runLoaded&#13;
            &amp;&amp; presenter.mathJaxLoaders.setStateLoaded&#13;
    }&#13;
&#13;
    var connections;&#13;
    var selectedItem = null;&#13;
&#13;
    presenter.lineStack = new LineStack(true);&#13;
    presenter.correctConnections = new LineStack(false);&#13;
    var isSelectionPossible = true;&#13;
    var isRTL = false;&#13;
&#13;
&#13;
    var CORRECT_ITEM_CLASS = 'connectionItem-correct';&#13;
    var WRONG_ITEM_CLASS = 'connectionItem-wrong';&#13;
&#13;
    presenter.ERROR_MESSAGES = {&#13;
        'ID not unique': 'One or more IDs are not unique.',&#13;
        'One or two not exist': 'Provided id for initial value doesn\'t exists',&#13;
        'Are from the same column': 'Provided ids for initial value are in the same column',&#13;
        'Are from the same row': 'Provided ids for initial value are in the same row',&#13;
        'Orientation layout duplication': 'More than one orientation has been assigned for at least one layout.'&#13;
    };&#13;
&#13;
    presenter.ELEMENT_SIDE = {&#13;
        LEFT: 0,&#13;
        RIGHT: 1&#13;
    };&#13;
&#13;
    function isEnabledOrMultiLineMode(element) {&#13;
        if (!presenter.configuration.isSingleConnectionMode) {&#13;
            return true;&#13;
        }&#13;
&#13;
        var elementId = convertId($(element).attr('id'));&#13;
&#13;
        for (var i = 0; i &lt; presenter.configuration.initialConnections.length; i++) {&#13;
            var initialValue = presenter.configuration.initialConnections[i];&#13;
&#13;
            if (initialValue.from === elementId || initialValue.to === elementId) {&#13;
                return !initialValue.isDisabled;&#13;
            }&#13;
        }&#13;
&#13;
        return true;&#13;
    }&#13;
&#13;
    function convertId(id) {&#13;
        id = id.toString();&#13;
&#13;
        return id.substr(id.indexOf('-') + 1);&#13;
    }&#13;
&#13;
    function convertIds(id1, id2) {&#13;
        return {&#13;
            id1: convertId(id1),&#13;
            id2: convertId(id2)&#13;
        };&#13;
    }&#13;
&#13;
    function isOneOfValuesEmpty(initialValue) {&#13;
        return initialValue.from.trim() === "" &amp;&amp; initialValue.to.trim() === "";&#13;
    }&#13;
&#13;
    presenter.getCurrentActivatedElement = function () {&#13;
        return $('.keyboard_navigation_active_element');&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        let upgradedModel = presenter.upgradeFrom_01(model);&#13;
        upgradedModel = presenter.upgradeStartValues(upgradedModel);&#13;
        upgradedModel = presenter.upgradeOrientations(upgradedModel);&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeStartValues = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (upgradedModel['initialConnections'] === undefined) {&#13;
            upgradedModel['initialConnections'] = [];&#13;
            upgradedModel['disabledConnectionColor'] = "";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeFrom_01 = function (model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (!upgradedModel["Columns width"]) {&#13;
            upgradedModel["Columns width"] = [&#13;
                {&#13;
                    left: "",&#13;
                    middle: "",&#13;
                    right: ""&#13;
                }&#13;
            ];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeOrientations = function (model) {&#13;
        const upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (upgradedModel["Orientations"] === undefined) {&#13;
            upgradedModel["Orientations"] = [];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    function LineStack(sendEvents) {&#13;
        this.stack = [];&#13;
        this.ids = [];&#13;
        this.sendEvents = sendEvents;&#13;
        this.shouldFireEvent = true;&#13;
&#13;
        this.setSendEvents = function (value) {&#13;
            this.sendEvents = value;&#13;
        };&#13;
&#13;
        this.push = function (line) {&#13;
            var pair = [], score, i;&#13;
            for (i = 0; i &lt; presenter.elements.length; i++) {&#13;
                if (presenter.elements[i].element.get(0) == line.from.get(0) || presenter.elements[i].element.get(0) == line.to.get(0)) {&#13;
                    pair.push(presenter.elements[i].id);&#13;
                    if (pair.length == 2) {&#13;
                        break;&#13;
                    }&#13;
                }&#13;
            }&#13;
            this.ids.push(pair);&#13;
            this.stack.push(line);&#13;
&#13;
            if (this.sendEvents) {&#13;
                score = presenter.correctConnections.hasLine(line).length &gt; 0 ? 1 : 0;&#13;
                presenter.sendEvent(pair[0], pair[1], 1, score);&#13;
                if (score == 0 &amp;&amp; presenter.configuration.blockWrongAnswers) {&#13;
                    this.shouldFireEvent = false;&#13;
                    this.remove(line);&#13;
                }&#13;
            }&#13;
        };&#13;
&#13;
        this.length = function () {&#13;
            return this.stack.length;&#13;
        };&#13;
&#13;
        this.get = function (i) {&#13;
            return this.stack[i];&#13;
        };&#13;
&#13;
        this.remove = function (line) {&#13;
            function getID(element) {&#13;
                // innerWrapper -&gt; td -&gt; tr -&gt; tbody -&gt; table (which has id attribute)&#13;
                var rawID = $(element).find('.innerWrapper').parent().parent().parent().parent().attr('id');&#13;
                return rawID.split('connection-')[1];&#13;
            }&#13;
&#13;
            var linePosition = this.stack.indexOf(line);&#13;
            this.stack.splice(linePosition, 1);&#13;
            var lineFromID = getID(line.from);&#13;
            var lineToID = getID(line.to);&#13;
            var pair = [lineFromID, lineToID];&#13;
            var score;&#13;
&#13;
            for (var i = 0; i &lt; this.ids.length; i++) {&#13;
                if ((this.ids[i][0] == pair[0] &amp;&amp; this.ids[i][1] == pair[1]) ||&#13;
                    (this.ids[i][0] == pair[1] &amp;&amp; this.ids[i][1] == pair[0])) {&#13;
                    this.ids.splice(i, 1);&#13;
                    break;&#13;
                }&#13;
            }&#13;
&#13;
            if (this.sendEvents &amp;&amp; this.shouldFireEvent) {&#13;
                score = presenter.correctConnections.hasLine(line).length &gt; 0 ? 1 : 0;&#13;
                presenter.sendEvent(pair[0], pair[1], 0, score);&#13;
            }&#13;
            this.shouldFireEvent = true;&#13;
        };&#13;
&#13;
        this.clear = function () {&#13;
            this.ids.splice(0, this.ids.length);&#13;
            this.stack.splice(0, this.stack.length);&#13;
        };&#13;
&#13;
        this.hasLine = function (line) {&#13;
            for (var i = 0, stackLength = this.stack.length; i &lt; stackLength; i++) {&#13;
                if ((this.stack[i].from.get(0) == line.from.get(0) &amp;&amp; this.stack[i].to.get(0) == line.to.get(0)) ||&#13;
                    (this.stack[i].from.get(0) == line.to.get(0) &amp;&amp; this.stack[i].to.get(0) == line.from.get(0))) {&#13;
                    return [this.stack[i]];&#13;
                }&#13;
            }&#13;
            return [];&#13;
        };&#13;
&#13;
        this.hasPair = function (pair) {&#13;
            for (var i = 0; i &lt; this.ids.length; i++) {&#13;
                if (this.ids[i][0] == pair[0] &amp;&amp; this.ids[i][1] == pair[1] ||&#13;
                    this.ids[i][1] == pair[0] &amp;&amp; this.ids[i][0] == pair[1]) {&#13;
                    return true;&#13;
                }&#13;
            }&#13;
            return false;&#13;
        };&#13;
&#13;
        this.isItemUsed = function (line) {&#13;
            var lines = [];&#13;
            for (var i = 0; i &lt; this.stack.length; i++) {&#13;
                if ((this.stack[i].from.get(0) == line.from.get(0) || this.stack[i].to.get(0) == line.to.get(0)) ||&#13;
                    (this.stack[i].from.get(0) == line.to.get(0) || this.stack[i].to.get(0) == line.from.get(0))) {&#13;
                    lines.push(this.stack[i])&#13;
                }&#13;
            }&#13;
            return lines;&#13;
        };&#13;
&#13;
        this.getDisabledCount = function () {&#13;
            return this.stack.filter(function (stackElement) {&#13;
                return stackElement.isDisabled();&#13;
            }).length;&#13;
        };&#13;
    }&#13;
&#13;
    function Line(from, to) {&#13;
        this.from = from;&#13;
        this.to = to;&#13;
&#13;
        this.connects = function (element) {&#13;
            return from.get(0) == element.get(0) || to.get(0) == element.get(0);&#13;
        };&#13;
&#13;
        this.otherSide = function (element) {&#13;
            if (from.get(0) == element.get(0)) {&#13;
                return to;&#13;
            }&#13;
            return from;&#13;
        };&#13;
&#13;
        this.isDisabled = function () {&#13;
            var ids = convertIds($(this.from).attr('id'), $(this.to).attr('id'));&#13;
&#13;
            for (var i = 0; i &lt; presenter.configuration.initialConnections.length; i++) {&#13;
                var initialValue = presenter.configuration.initialConnections[i];&#13;
&#13;
                var initialValues = [initialValue.from, initialValue.to];&#13;
&#13;
                if (initialValue.isDisabled) {&#13;
                    if ($.inArray(ids.id1, initialValues) &gt; -1 &amp;&amp; $.inArray(ids.id2, initialValues) &gt; -1) {&#13;
                        return true;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            return false;&#13;
        };&#13;
    }&#13;
&#13;
    presenter.showErrorMessage = function (view, errorCode) {&#13;
        return $(view).html(presenter.ERROR_MESSAGES[errorCode]);&#13;
    };&#13;
&#13;
    presenter.parseDefinitionLinks = function () {&#13;
        $.each(presenter.$view.find('.' + presenter.CSS_CLASSES.INNER_WRAPPER), function (index, element) {&#13;
            const sanitizedLink = window.xssUtils.sanitize(presenter.textParser.parse($(element).html()));&#13;
            $(element).html(sanitizedLink);&#13;
        });&#13;
&#13;
        presenter.textParser.connectLinks(presenter.$view);&#13;
    };&#13;
&#13;
    presenter.parseAddonGaps = function (model) {&#13;
        //This method is only needed in preview, in normal mode text parser will handle addon gaps&#13;
        for (var i = 0; i &lt; model["Left column"].length; i++) {&#13;
            var el = model["Left column"][i];&#13;
            el.content = parseAddonGapsInContent(el.content);&#13;
        }&#13;
        for (var i = 0; i &lt; model["Right column"].length; i++) {&#13;
            var el = model["Right column"][i];&#13;
            el.content = parseAddonGapsInContent(el.content);&#13;
        }&#13;
        return model;&#13;
    };&#13;
&#13;
    function parseAddonGapsInContent (text) {&#13;
        return text.replace(/\\addon{([^\s-]*?)}/g, '&lt;div id="addonGap-$1"&gt;$1&lt;/div&gt;');&#13;
    }&#13;
&#13;
    presenter.removeNonVisibleInnerHTML = function () {&#13;
        presenter.removeNonVisibleInnerHTMLForRoot(presenter.$view);&#13;
&#13;
    };&#13;
&#13;
    presenter.removeNonVisibleInnerHTMLForRoot = function ($root) {&#13;
        $.each($root.find('.' + presenter.CSS_CLASSES.INNER_WRAPPER), function (index, element) {&#13;
            var newInnerHtml = $(element).html().replace(/\\alt{([^{}|]*?)\|[^{}|]*?}(\[[a-zA-Z0-9_\- ]*?\])*/g, '$1'); // replace \alt{a|b}[c] with a&#13;
            $(element).html(newInnerHtml.replace(/\\alt{([^|{}]*?)\|[^|{}]*?}/g, '$1')); // replace \alt{a|b} with a&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.registerMathJax();&#13;
&#13;
        playerController = controller;&#13;
&#13;
        presenter.textParser = new TextParserProxy(controller.getTextParser());&#13;
    };&#13;
&#13;
    presenter.registerMathJax = function AddonConnection_registerMathJax() {&#13;
        var mathJaxDeferred = new jQuery.Deferred();&#13;
        presenter.mathJaxProcessEndedDeferred = mathJaxDeferred;&#13;
        presenter.mathJaxProcessEnded = mathJaxDeferred.promise();&#13;
&#13;
        MathJax.Hub.Register.MessageHook("End Process", function (message) {&#13;
            if ($(message[1]).hasClass('ic_page')) {&#13;
                presenter.mathJaxProcessEndedDeferred.resolve();&#13;
            }&#13;
            if ($(message[1]).hasClass('ic_popup_page')) {&#13;
                presenter.mathJaxProcessEndedDeferred.resolve();&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setLengthOfSideObjects = function (view) {&#13;
        const $firstSide = $(view).find("." + presenter.getFirstSideCSSClassName() + ":first");&#13;
        const $middleSide = $(view).find("." + presenter.getMiddleSideCSSClassName() + ":first");&#13;
        const $secondSide = $(view).find("." + presenter.getSecondSideCSSClassName() + ":first");&#13;
&#13;
        let firstSideLength, middleSideLength, secondSideLength;&#13;
        if (presenter.isHorizontal) {&#13;
            firstSideLength = "auto";&#13;
            middleSideLength = "auto";&#13;
            secondSideLength = "auto";&#13;
        } else {&#13;
            firstSideLength = presenter.configuration.columnsWidth.left;&#13;
            middleSideLength = presenter.configuration.columnsWidth.middle;&#13;
            secondSideLength = presenter.configuration.columnsWidth.right;&#13;
&#13;
            if (!firstSideLength) firstSideLength = "auto";&#13;
            if (!middleSideLength) middleSideLength = "auto";&#13;
            if (!secondSideLength) secondSideLength = "auto";&#13;
        }&#13;
&#13;
        const propertyName = presenter.isHorizontal ? "height" : "width";&#13;
        $firstSide.css(propertyName, firstSideLength);&#13;
        $middleSide.css(propertyName, middleSideLength);&#13;
        $secondSide.css(propertyName, secondSideLength);&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        addonID = model.ID;&#13;
&#13;
        presenter.initialize(view, model, false);&#13;
&#13;
        presenter.parseDefinitionLinks();&#13;
    };&#13;
&#13;
    presenter.setEventBus = function (wrappedEventBus) {&#13;
        eventBus = wrappedEventBus;&#13;
&#13;
        var events = ['ShowAnswers', 'HideAnswers', 'GradualShowAnswers', 'GradualHideAnswers'];&#13;
        for (var i = 0; i &lt; events.length; i++) {&#13;
            eventBus.addEventListener(events[i], this);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        model = presenter.parseAddonGaps(model);&#13;
        presenter.lineStack = new LineStack(false);&#13;
        presenter.initialize(view, model, true);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.isVisible = true;&#13;
    };&#13;
&#13;
    function getSpeechTextProperty(rawValue, defaultValue) {&#13;
        var value = rawValue.trim();&#13;
&#13;
        if (value === undefined || value === null || value === '') {&#13;
            return defaultValue;&#13;
        }&#13;
&#13;
        return value;&#13;
    }&#13;
&#13;
    function setSpeechTexts(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            connected: 'connected',&#13;
            disconnected: 'disconnected',&#13;
            connectedTo: 'connected to',&#13;
            selected: 'selected',&#13;
            deselected: 'deselected',&#13;
            correct: 'correct',&#13;
            wrong: 'wrong'&#13;
        };&#13;
&#13;
        if (!speechTexts) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            connected: getSpeechTextProperty(speechTexts['Connected']['Connected'], presenter.speechTexts.connected),&#13;
            disconnected: getSpeechTextProperty(speechTexts['Disconnected']['Disconnected'], presenter.speechTexts.disconnected),&#13;
            connectedTo: getSpeechTextProperty(speechTexts['ConnectedTo']['Connected to'], presenter.speechTexts.connectedTo),&#13;
            selected: getSpeechTextProperty(speechTexts['Selected']['Selected'], presenter.speechTexts.selected),&#13;
            deselected: getSpeechTextProperty(speechTexts['Deselected']['Deselected'], presenter.speechTexts.deselected),&#13;
            correct: getSpeechTextProperty(speechTexts['Correct']['Correct'], presenter.speechTexts.correct),&#13;
            wrong: getSpeechTextProperty(speechTexts['Wrong']['Wrong'], presenter.speechTexts.wrong)&#13;
        };&#13;
    }&#13;
&#13;
    presenter.addDisabledElementsFromInitialValues = function () {&#13;
        presenter.configuration.initialConnections.forEach(function (initialValue) {&#13;
            if (initialValue.isDisabled) {&#13;
                presenter.disabledConnections.push({&#13;
                    id1: initialValue.from,&#13;
                    id2: initialValue.to&#13;
                });&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
&#13;
    presenter.getInitialValues = function (model) {&#13;
        var modelValidator = new ModelValidator();&#13;
        var validated = modelValidator.validate(model, [&#13;
            ModelValidators.List("initialConnections", [&#13;
                ModelValidators.String("from", {default: "", trim: false}),&#13;
                ModelValidators.String("to", {default: "", trim: false}),&#13;
                ModelValidators.Boolean("isDisabled", {default: false})&#13;
            ]),&#13;
            ModelValidators.String("disabledConnectionColor", {default: "", trim: true})&#13;
        ]);&#13;
&#13;
        return {&#13;
            initialConnections: validated.value.initialConnections,&#13;
            disabledConnectionColor: validated.value.disabledConnectionColor&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateInitialConnection = function (initialValue) {&#13;
        function containsID(array, idToFind, toReturn) {&#13;
            for (var i = 0; i &lt; array.length; i++) {&#13;
                if (array[i].id === idToFind) {&#13;
                    return toReturn;&#13;
                }&#13;
            }&#13;
&#13;
            return false;&#13;
        }&#13;
&#13;
        function areFromDifferentCols() {&#13;
            var fromColumn = containsID(presenter.model['Left column'], initialValue.from, "LEFT") ||&#13;
                containsID(presenter.model['Right column'], initialValue.from, "RIGHT");&#13;
&#13;
            var toColumn = containsID(presenter.model['Left column'], initialValue.to, "LEFT") ||&#13;
                containsID(presenter.model['Right column'], initialValue.to, "RIGHT");&#13;
&#13;
            return fromColumn !== toColumn;&#13;
        }&#13;
&#13;
        function bothExists() {&#13;
            var fromExists = containsID(presenter.model['Left column'], initialValue.from, true) ||&#13;
                containsID(presenter.model['Right column'], initialValue.from, true);&#13;
&#13;
            var toExists = containsID(presenter.model['Left column'], initialValue.to, true) ||&#13;
                containsID(presenter.model['Right column'], initialValue.to, true);&#13;
&#13;
            return fromExists &amp;&amp; toExists;&#13;
        }&#13;
&#13;
        if (!isOneOfValuesEmpty(initialValue)) {&#13;
            if (!bothExists()) {&#13;
                return getErrorObject("One or two not exist");&#13;
            } else if (!areFromDifferentCols()) {&#13;
                const errorCode = presenter.isHorizontal ? "Are from the same row" : "Are from the same column";&#13;
                return getErrorObject(errorCode);&#13;
            }&#13;
        }&#13;
&#13;
        return getValidObject(initialValue);&#13;
    };&#13;
&#13;
    presenter.validateInitialConnections = function (initialConnections) {&#13;
        for (let validatedInitialValue, i = 0; i &lt; initialConnections.length; i++) {&#13;
            validatedInitialValue = presenter.validateInitialConnection(initialConnections[i]);&#13;
            if (!validatedInitialValue.isValid) {&#13;
                return validatedInitialValue;&#13;
            }&#13;
        }&#13;
&#13;
        return getValidObject(initialConnections);&#13;
    };&#13;
&#13;
    /**&#13;
     * @param initialValue {{from: string, to: string}}&#13;
     */&#13;
    presenter.drawInitialValue = function (initialValue) {&#13;
        if (!isOneOfValuesEmpty(initialValue)) {&#13;
            pushConnection(new Line(getElementById(initialValue.from), getElementById(initialValue.to)), false);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawInitialValues = function () {&#13;
        this.lineStack.setSendEvents(false);&#13;
&#13;
        if (!presenter.lineStack.length()) {&#13;
            presenter.configuration.initialConnections.forEach(presenter.drawInitialValue);&#13;
        }&#13;
&#13;
        presenter.redraw();&#13;
&#13;
        this.lineStack.setSendEvents(true);&#13;
    };&#13;
&#13;
    presenter.initialize = function (view, model, isPreview) {&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.model = model;&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_MESSAGES, presenter.configuration.errorCode);&#13;
            return false;&#13;
        }&#13;
&#13;
        presenter.chooseOrientation(model, isPreview);&#13;
        presenter.setUpViewBody(presenter.view);&#13;
        connections = presenter.$view.find('.' + presenter.CSS_CLASSES.CONNECTIONS + ':first');&#13;
&#13;
        presenter.isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
        presenter.isVisibleByDefault = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
        presenter.setVisibility(presenter.isVisible || isPreview);&#13;
        isRTL = presenter.$view.css('direction').toLowerCase() === 'rtl';&#13;
&#13;
        presenter.loadElements(view, model);&#13;
&#13;
        const $connectionContainer = $("." + presenter.CSS_CLASSES.CONNECTION_CONTAINER);&#13;
        if (isPreview) {&#13;
            waitForLoad($connectionContainer, () =&gt; {&#13;
                presenter.initializeView(view, model);&#13;
                presenter.drawConfiguredConnections();&#13;
            })&#13;
            presenter.removeNonVisibleInnerHTML();&#13;
        } else {&#13;
            presenter.mathJaxProcessEnded.then(function () {&#13;
                waitForLoad($connectionContainer, () =&gt; {&#13;
                    presenter.initializeView(view, model);&#13;
                    presenter.drawInitialValues();&#13;
                    presenter.addDisabledElementsFromInitialValues();&#13;
                    presenter.mathJaxLoaders.runLoaded = true;&#13;
                    deferredCommandQueue.resolve();&#13;
                })&#13;
                presenter.registerListeners(presenter.view);&#13;
            });&#13;
        }&#13;
&#13;
        setSpeechTexts(model["speechTexts"]);&#13;
        presenter.gatherCorrectConnections();&#13;
        presenter.buildKeyboardController();&#13;
    };&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        const validatedOrientations = presenter.validateOrientations(model["Orientations"]);&#13;
        if (!validatedOrientations.isValid) {&#13;
            return validatedOrientations;&#13;
        }&#13;
&#13;
        const initialValues = presenter.getInitialValues(model);&#13;
        const validatedInitialConnections = presenter.validateInitialConnections(initialValues.initialConnections)&#13;
        if (!validatedInitialConnections.isValid) {&#13;
            return validatedInitialConnections;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            addonID: model["ID"],&#13;
            langTag: model["langAttribute"],&#13;
            isNotActivity: ModelValidationUtils.validateBoolean(model["isNotActivity"] || "False"),&#13;
            blockWrongAnswers: ModelValidationUtils.validateBoolean(model.blockWrongAnswers),&#13;
            removeDraggedElement: ModelValidationUtils.validateBoolean(model.removeDraggedElement),&#13;
            isTabindexEnabled: ModelValidationUtils.validateBoolean(model["Is Tabindex Enabled"]),&#13;
            connectionThickness: getModelValue(model, "Connection thickness", "1px"),&#13;
            defaultConnectionColor: getModelValue(model, "Default connection color", "#000"),&#13;
            correctConnectionColor: getModelValue(model, "Correct connection color", "#0d0"),&#13;
            incorrectConnectionColor: getModelValue(model, "Incorrect connection color", "#d00"),&#13;
            showAnswersLineColor: getModelValue(model, "Show answers line color", "#0d0"),&#13;
            isSingleConnectionMode: model["Single connection mode"].toLowerCase() === "true",&#13;
            orientations: validatedOrientations.value,&#13;
            initialConnections: initialValues.initialConnections,&#13;
            disabledConnectionColor: initialValues.disabledConnectionColor,&#13;
            columnsWidth: model["Columns width"][0],&#13;
        };&#13;
    };&#13;
&#13;
    function getModelValue(model, modelKey, defaultValue) {&#13;
        return model[modelKey] != '' ? model[modelKey] : defaultValue;&#13;
    }&#13;
&#13;
    presenter.validateOrientations = function (orientations) {&#13;
        const usedLayoutNames = [];&#13;
        for (let orientationConfig, i = 0; i &lt; orientations.length; i++) {&#13;
            orientationConfig = orientations[i];&#13;
            if (usedLayoutNames.includes(orientationConfig.Layout)) {&#13;
                return getErrorObject("Orientation layout duplication");&#13;
            }&#13;
            usedLayoutNames.push(orientationConfig.Layout);&#13;
        }&#13;
        return getValidObject(orientations);&#13;
    }&#13;
&#13;
    function getValidObject(value) {&#13;
        return {&#13;
            isValid: true,&#13;
            value: value&#13;
        }&#13;
    }&#13;
&#13;
    function getErrorObject(errorCode, itemIndex = undefined) {&#13;
        return {&#13;
            isValid: false,&#13;
            errorCode: errorCode,&#13;
            itemIndex: itemIndex&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setCurrentLayoutName = function(layoutName) {&#13;
        currentLayoutName = layoutName;&#13;
    }&#13;
&#13;
    presenter.chooseOrientation = function (model, isPreview) {&#13;
        presenter.isHorizontal = false;&#13;
        if (!playerController &amp;&amp; !isPreview) {&#13;
            return;&#13;
        }&#13;
&#13;
        for (let orientationConfig, i = 0; i &lt; model["Orientations"].length; i++) {&#13;
            orientationConfig = model["Orientations"][i];&#13;
            if (orientationConfig.Layout === currentLayoutName) {&#13;
                presenter.isHorizontal = orientationConfig.Orientation === "Horizontal";&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     * Expand the view with a body consisting of three empty objects (objects without elements):&#13;
     * 1. Object in which the elements from the first side will be placed (left column/top row).&#13;
     * 2. Object for creating connections (middle column/middle row).&#13;
     * 3. Object in which the elements from the second side will be placed (right column/bottom row).&#13;
     * If isHorizontal then sides are created as rows, otherwise as columns.&#13;
     * @return undefined&#13;
    **/&#13;
    presenter.setUpViewBody = function (view) {&#13;
        $(view).attr("lang", presenter.configuration.langTag);&#13;
&#13;
        const elementToExpand = view.getElementsByClassName(presenter.CSS_CLASSES.CONNECTION_CONTAINER)[0];&#13;
        const viewBody = presenter.isHorizontal ? createEmptyHorizontalViewBody() : createEmptyVerticalViewBody();&#13;
        elementToExpand.append(viewBody);&#13;
&#13;
        presenter.setLengthOfSideObjects(view);&#13;
    }&#13;
&#13;
    function createEmptyHorizontalViewBody() {&#13;
        const viewBody = document.createElement("tbody");&#13;
&#13;
        appendHorizontalViewBodyTopRow(viewBody);&#13;
        appendHorizontalViewBodyMiddleRow(viewBody);&#13;
        appendHorizontalViewBodyBottomRow(viewBody);&#13;
&#13;
        return viewBody;&#13;
    }&#13;
&#13;
    function appendHorizontalViewBodyTopRow(view) {&#13;
        const cellContent = createCellContent();&#13;
        const row = createHorizontalViewBodyRow(presenter.CSS_CLASSES.CONNECTIONS_TOP_ROW, cellContent);&#13;
        view.append(row);&#13;
    }&#13;
&#13;
    function appendHorizontalViewBodyMiddleRow(view) {&#13;
        const cellContent = createCellCanvas();&#13;
        const row = createHorizontalViewBodyRow(presenter.CSS_CLASSES.CONNECTIONS_MIDDLE_ROW, cellContent);&#13;
        view.append(row);&#13;
    }&#13;
&#13;
    function appendHorizontalViewBodyBottomRow(view) {&#13;
        const cellContent = createCellContent();&#13;
        const row = createHorizontalViewBodyRow(presenter.CSS_CLASSES.CONNECTIONS_BOTTOM_ROW, cellContent);&#13;
        view.append(row);&#13;
    }&#13;
&#13;
    function createHorizontalViewBodyRow(className, content) {&#13;
        const row = document.createElement("tr");&#13;
        row.classList.add(className);&#13;
&#13;
        const cell = document.createElement("td");&#13;
        cell.append(content);&#13;
        row.append(cell);&#13;
        return row;&#13;
    }&#13;
&#13;
    function createEmptyVerticalViewBody() {&#13;
        const viewBody = document.createElement("tbody");&#13;
&#13;
        const sharedRow = document.createElement("tr");&#13;
        viewBody.append(sharedRow);&#13;
&#13;
        appendHorizontalViewBodyLeftColumn(sharedRow);&#13;
        appendHorizontalViewBodyMiddleColumn(sharedRow);&#13;
        appendHorizontalViewBodyBottomColumn(sharedRow);&#13;
&#13;
        return viewBody;&#13;
    }&#13;
&#13;
    function appendHorizontalViewBodyLeftColumn(view) {&#13;
        const cellContent = createCellContent();&#13;
        const column = createVerticalViewBodyColumn(presenter.CSS_CLASSES.CONNECTIONS_LEFT_COLUMN, cellContent);&#13;
        view.append(column);&#13;
    }&#13;
&#13;
    function appendHorizontalViewBodyMiddleColumn(view) {&#13;
        const cellContent = createCellCanvas();&#13;
        const column = createVerticalViewBodyColumn(presenter.CSS_CLASSES.CONNECTIONS_MIDDLE_COLUMN, cellContent);&#13;
        view.append(column);&#13;
    }&#13;
&#13;
    function appendHorizontalViewBodyBottomColumn(view) {&#13;
        const cellContent = createCellContent();&#13;
        const column = createVerticalViewBodyColumn(presenter.CSS_CLASSES.CONNECTIONS_RIGHT_COLUMN, cellContent);&#13;
        view.append(column);&#13;
    }&#13;
&#13;
    function createVerticalViewBodyColumn(className, content) {&#13;
        const cell = document.createElement("td");&#13;
        cell.classList.add(className);&#13;
        cell.append(content);&#13;
        return cell;&#13;
    }&#13;
&#13;
    function createCellCanvas() {&#13;
        const canvas = document.createElement("canvas");&#13;
        canvas.classList.add(presenter.CSS_CLASSES.CONNECTIONS);&#13;
        return canvas;&#13;
    }&#13;
&#13;
    function createCellContent() {&#13;
        const content = document.createElement("table");&#13;
        content.classList.add(presenter.CSS_CLASSES.CONTENT);&#13;
&#13;
        const contentBody = document.createElement("tbody");&#13;
        content.append(contentBody);&#13;
&#13;
        return content;&#13;
    }&#13;
&#13;
    presenter.buildKeyboardController = function () {&#13;
        var elements = [];&#13;
        for (var i = 0; i &lt; presenter.elements.length; i++) {&#13;
            elements.push($(presenter.elements[i].element));&#13;
        }&#13;
&#13;
        presenter.keyboardControllerObject = new ConnectionKeyboardController(elements, 2);&#13;
        presenter.keyboardControllerObject.selectEnabled(true);&#13;
    };&#13;
&#13;
    function getElementById(id) {&#13;
        for (var i = 0; i &lt; presenter.elements.length; i++) {&#13;
            if (presenter.elements[i].id == id) {&#13;
                return presenter.elements[i].element;&#13;
            }&#13;
        }&#13;
&#13;
        return -1;&#13;
    }&#13;
&#13;
    presenter.establishElementSide = function (elementID, modelLeftSide, modelRightSide) {&#13;
        var i, arrayLength;&#13;
&#13;
        for (i = 0, arrayLength = modelLeftSide.length; i &lt; arrayLength; i += 1) {&#13;
            if (modelLeftSide[i].id === elementID) {&#13;
                return presenter.ELEMENT_SIDE.LEFT;&#13;
            }&#13;
        }&#13;
&#13;
        for (i = 0, arrayLength = modelRightSide.length; i &lt; arrayLength; i += 1) {&#13;
            if (modelRightSide[i].id === elementID) {&#13;
                return presenter.ELEMENT_SIDE.RIGHT;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createEventData = function (source, elementFromID, elementToID, model, value, score) {&#13;
        var leftColumn = model["Left column"];&#13;
        var rightColumn = model["Right column"];&#13;
&#13;
        var fromElementSide = presenter.establishElementSide(elementFromID, leftColumn, rightColumn);&#13;
        var itemStr = "";&#13;
        switch (fromElementSide) {&#13;
            case presenter.ELEMENT_SIDE.LEFT:&#13;
                itemStr = elementFromID + '-' + elementToID;&#13;
                break;&#13;
            case presenter.ELEMENT_SIDE.RIGHT:&#13;
                itemStr = elementToID + '-' + elementFromID;&#13;
                break;&#13;
        }&#13;
&#13;
        return {&#13;
            'source': source,&#13;
            'item': itemStr,&#13;
            'value': value.toString(),&#13;
            'score': score.toString()&#13;
        };&#13;
    };&#13;
&#13;
    presenter.sendEvent = function (fromID, toID, value, score) {&#13;
        if (!presenter.isShowingAnswers()) {&#13;
            var eventData = presenter.createEventData(addonID, fromID, toID, presenter.model, value, score);&#13;
            eventBus.sendEvent('ValueChanged', eventData);&#13;
            if (presenter.isAllOK()) {&#13;
                sendAllOKEvent();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    function sendAllOKEvent() {&#13;
        var eventData = {&#13;
            'source': addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        eventBus.sendEvent('ValueChanged', eventData);&#13;
    }&#13;
&#13;
    function clickLogic(element) {&#13;
        if (basicClickLogic(element)) {&#13;
            presenter.redraw();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.getFirstSideCSSClassName = function () {&#13;
        return presenter.isHorizontal&#13;
            ? presenter.CSS_CLASSES.CONNECTIONS_TOP_ROW&#13;
            : presenter.CSS_CLASSES.CONNECTIONS_LEFT_COLUMN;&#13;
    };&#13;
&#13;
    presenter.getMiddleSideCSSClassName = function () {&#13;
        return presenter.isHorizontal&#13;
            ? presenter.CSS_CLASSES.CONNECTIONS_MIDDLE_ROW&#13;
            : presenter.CSS_CLASSES.CONNECTIONS_MIDDLE_COLUMN;&#13;
    };&#13;
&#13;
    presenter.getSecondSideCSSClassName = function () {&#13;
        return presenter.isHorizontal&#13;
            ? presenter.CSS_CLASSES.CONNECTIONS_BOTTOM_ROW&#13;
            : presenter.CSS_CLASSES.CONNECTIONS_RIGHT_COLUMN;&#13;
    };&#13;
&#13;
    function basicClickLogic(element) {&#13;
        if (!isEnabledOrMultiLineMode(element)) {&#13;
            return false;&#13;
        }&#13;
&#13;
        // workaround for android webView&#13;
        // http://code.google.com/p/android/issues/detail?id=38808&#13;
        var current = new Date().getTime();&#13;
        var delta = current - presenter.lastClickTime;&#13;
        if (!isSelectionPossible || delta &lt; 50) return;&#13;
        presenter.lastClickTime = current;&#13;
        if (!$(element).hasClass(presenter.CSS_CLASSES.SELECTED) &amp;&amp; selectedItem == null) { // first element selected&#13;
            $(element).parent().find('.connectionItem').removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
            $(element).addClass(presenter.CSS_CLASSES.SELECTED);&#13;
            selectedItem = $(element);&#13;
            return;&#13;
        }&#13;
        if (selectedItem != null &amp;&amp; $(element).get(0) == selectedItem.get(0)) { // clicking the selected element again&#13;
            $(element).removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
            selectedItem = null;&#13;
            return;&#13;
        }&#13;
        const firstSideClassName = presenter.getFirstSideCSSClassName();&#13;
        const secondSideClassName = presenter.getSecondSideCSSClassName();&#13;
        if (selectedItem != null &amp;&amp;&#13;
            ($(element).parents(`.${firstSideClassName}`).get(0) == selectedItem.parents(`.${firstSideClassName}`).get(0) ||&#13;
                $(element).parents(`.${secondSideClassName}`).get(0) == selectedItem.parents(`.${secondSideClassName}`).get(0))) {&#13;
            // element clicked in the same column&#13;
            var linesToSwitch = [];&#13;
            if (presenter.configuration.isSingleConnectionMode) {&#13;
                for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
                    if (presenter.lineStack.get(i).connects(selectedItem)) {&#13;
                        linesToSwitch.push(presenter.lineStack.get(i))&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            selectedItem.removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
            if (linesToSwitch.length == 0) {&#13;
                $(element).addClass(presenter.CSS_CLASSES.SELECTED);&#13;
                selectedItem = $(element);&#13;
                return;&#13;
            } else {&#13;
                for (i in linesToSwitch) {&#13;
                    presenter.lineStack.remove(linesToSwitch[i]);&#13;
                    pushConnection(new Line($(element), linesToSwitch[i].otherSide(selectedItem)), false);&#13;
                }&#13;
            }&#13;
        } else {&#13;
            if (presenter.checkIfConnectionDisabled($(element).attr('id'), selectedItem.attr('id'))) {&#13;
                return;&#13;
            }&#13;
            var line = new Line($(element), selectedItem);&#13;
            var shouldDraw = true;&#13;
&#13;
            if (presenter.configuration.isSingleConnectionMode) {&#13;
                var usedInLines = presenter.lineStack.isItemUsed(line);&#13;
                if (usedInLines.length === 2) {&#13;
                    shouldDraw = false&#13;
                }&#13;
            }&#13;
            if (shouldDraw) {&#13;
                pushConnection(line, false);&#13;
            }&#13;
        }&#13;
&#13;
        selectedItem.removeClass('selected');&#13;
        selectedItem = null;&#13;
        return true;&#13;
    }&#13;
&#13;
    presenter.drawTempLine = function (x, y) {&#13;
        if (presenter.$view.find('#connection_line_tmp').length &gt; 0) {&#13;
            presenter.$view.find('#connection_line_tmp').remove();&#13;
        }&#13;
        var m, angle, d, transform,&#13;
            x1 = parseInt(presenter.iconLeft, 10),&#13;
            y1 = parseInt(presenter.iconTop, 10);&#13;
&#13;
        m = (y - y1) / (x - x1);&#13;
        angle = (Math.atan(m)) * 180 / (Math.PI);&#13;
        d = Math.sqrt(((x - x1) * (x - x1)) + ((y - y1) * (y - y1)));&#13;
        if (x &gt;= x1) {&#13;
            transform = (360 + angle) % 360;&#13;
        } else {&#13;
            transform = 180 + angle;&#13;
        }&#13;
&#13;
        var div = $('&lt;div&gt;');&#13;
        div.attr('id', 'connection_line_tmp');&#13;
        div.attr('class', 'connection_line');&#13;
        div.attr('style', 'left: ' + x1 + 'px; top: ' + y1 + 'px');&#13;
        presenter.$view.prepend(div);&#13;
        presenter.$view.find('#connection_line_tmp').css({&#13;
            'left': x1,&#13;
            'top': y1,&#13;
            'width': d,&#13;
            'background-color': presenter.configuration.defaultConnectionColor,&#13;
            'transform': 'rotate(' + transform + 'deg)',&#13;
            'transform-origin': '0px 0px',&#13;
            '-ms-transform': 'rotate(' + transform + 'deg)',&#13;
            '-ms-transform-origin': '0px 0px',&#13;
            '-moz-transform': 'rotate(' + transform + 'deg)',&#13;
            '-moz-transform-origin': '0px 0px',&#13;
            '-webkit-transform': 'rotate(' + transform + 'deg)',&#13;
            '-webkit-transform-origin': '0px 0px',&#13;
            '-o-transform': 'rotate(' + transform + 'deg)',&#13;
            '-o-transform-origin': '0px 0px'&#13;
        });&#13;
    };&#13;
&#13;
    presenter.registerListeners = function (view) {&#13;
        presenter.$connectionContainer = $(view).find('.' + presenter.CSS_CLASSES.CONNECTION_CONTAINER);&#13;
        presenter.$connectionContainer.click(function (e) {&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
        });&#13;
&#13;
        const $firstSide = $(view).find('.' + this.getFirstSideCSSClassName());&#13;
        $firstSide.click(function (e) {&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
        });&#13;
&#13;
        const $secondSide = $(view).find('.' + this.getSecondSideCSSClassName());&#13;
        $secondSide.click(function (e) {&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
        });&#13;
&#13;
        const $item = $(view).find('.' + presenter.CSS_CLASSES.CONNECTION_ITEM);&#13;
        $item.on('touchstart', function (e) {&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
            presenter.lastEvent = e;&#13;
        });&#13;
&#13;
        let scale = playerController.getScaleInformation();&#13;
        let draggedElementColumn;&#13;
&#13;
        var android_ver = MobileUtils.getAndroidVersion(window.navigator.userAgent);&#13;
        if (["4.1.1", "4.2.2", "4.4.2"].indexOf(android_ver) === -1 || window.navigator.userAgent.indexOf('Chrome') &gt; 0) {&#13;
            $item.each(function () {&#13;
                var e = $(this);&#13;
                e.draggable({&#13;
                    revert: presenter.configuration.removeDraggedElement ? true : "invalid",&#13;
                    opacity: presenter.configuration.removeDraggedElement ? 1 : 0.7,&#13;
                    helper: presenter.configuration.removeDraggedElement ? "original" : "clone",&#13;
                    cursorAt: {&#13;
                        left: Math.round(e.find('.inner').width() / 2),&#13;
                        top: Math.round(e.find('.inner').height() / 2)&#13;
                    },&#13;
                    start: function (event, ui) {&#13;
                        if (!isEnabledOrMultiLineMode(this)) {&#13;
                            event.preventDefault();&#13;
                            return false;&#13;
                        }&#13;
                        ui.helper.css("visibility", "hidden");&#13;
                        ui.helper.find(".inner_addon").css("display","none");&#13;
                        var $iconWrapper = $(e).find("." + presenter.CSS_CLASSES.ICON_WRAPPER);&#13;
                        scale = playerController.getScaleInformation();&#13;
&#13;
                        let height = $iconWrapper.height();&#13;
                        !presenter.isHorizontal &amp;&amp; (height /= 2);&#13;
                        let width = $iconWrapper.width();&#13;
                        presenter.isHorizontal &amp;&amp; (width /= 2);&#13;
                        presenter.iconTop = $iconWrapper.position().top / scale.scaleY + height;&#13;
                        presenter.iconLeft = $iconWrapper.position().left / scale.scaleX + width;&#13;
&#13;
                        if (!isSelectionPossible) {&#13;
                            event.stopPropagation();&#13;
                            event.preventDefault();&#13;
                            return;&#13;
                        }&#13;
                        $item.removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
                        selectedItem = null;&#13;
                        ui.helper.zIndex(100);&#13;
                        clickLogic(this);&#13;
                        if (presenter.configuration.removeDraggedElement) {&#13;
                            ui.helper.find('.icon').hide();&#13;
                            ui.helper.removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
                        } else {&#13;
                            ui.helper.find('.icon').remove();&#13;
                            ui.helper.width($(this).find('.inner').width());&#13;
                            ui.helper.height($(this).find('.inner').height());&#13;
                        }&#13;
                        if ($(this).parents('.' + presenter.getFirstSideCSSClassName()).length) {&#13;
                            draggedElementColumn = 'left';&#13;
                        } else {&#13;
                            draggedElementColumn = 'right';&#13;
                        }&#13;
                    },&#13;
                    drag: function (event, ui) {&#13;
                        presenter.mouseSX = parseInt(event.pageX, 10) - parseInt(presenter.$view.offset().left, 10);&#13;
                        presenter.mouseSY = parseInt(event.pageY, 10) - parseInt(presenter.$view.offset().top, 10);&#13;
&#13;
                        presenter.drawTempLine(presenter.mouseSX / scale.scaleX, presenter.mouseSY / scale.scaleY);&#13;
                    },&#13;
                    stop: function (event, ui) {&#13;
                        ui.helper.zIndex(0);&#13;
                        if (presenter.configuration.removeDraggedElement) {&#13;
                            ui.helper.find('.icon').show();&#13;
                        } else {&#13;
                            ui.helper.remove();&#13;
                        }&#13;
                        presenter.redraw();&#13;
                        if (presenter.$view.find('#connection_line_tmp').length &gt; 0) {&#13;
                            presenter.$view.find('#connection_line_tmp').remove();&#13;
                        }&#13;
                    }&#13;
                });&#13;
&#13;
                e.droppable({&#13;
                    tolerance: "pointer",&#13;
                    drop: function (event, ui) {&#13;
                        $(this).removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
                        basicClickLogic(this);&#13;
                        ui.draggable.removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
                        if (presenter.lastEvent) {&#13;
                            presenter.lastEvent.type = "touchend";&#13;
                        }&#13;
                    },&#13;
                    over: function (event, ui) {&#13;
                        var elementColumn;&#13;
                        if ($(this).parents('.' + presenter.getFirstSideCSSClassName()).length) {&#13;
                            elementColumn = 'left';&#13;
                        } else {&#13;
                            elementColumn = 'right';&#13;
                        }&#13;
                        if (elementColumn != draggedElementColumn) {&#13;
                            $(this).addClass(presenter.CSS_CLASSES.SELECTED);&#13;
                        }&#13;
                    },&#13;
                    out: function (event, ui) {&#13;
                        $(this).removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
                    }&#13;
                });&#13;
            });&#13;
        } else {&#13;
            $item.on('mouseleave', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
&#13;
            $item.on('mouseenter', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
&#13;
            $item.on('mouseup', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
&#13;
            $item.on('mousedown', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
&#13;
            $item.on('mouseover', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
&#13;
            $item.on('mouseout', function (e) {&#13;
                e.stopPropagation();&#13;
            });&#13;
        }&#13;
        $item.on('touchend', function (e) {&#13;
            e.preventDefault();&#13;
            e.stopPropagation();&#13;
            if (presenter.lastEvent.type != e.type) {&#13;
                presenter.isClicked = false;&#13;
                clickLogic(this);&#13;
                presenter.isClicked = true;&#13;
            }&#13;
        });&#13;
&#13;
        $item.click(function (e) {&#13;
            e.stopPropagation();&#13;
            if (!presenter.isClicked) {&#13;
                clickLogic(this);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    function isAnswersEqualToCorrectResults (userAnswers, correctAnswers) {&#13;
        if (userAnswers == null || correctAnswers == null) return false;&#13;
        if (userAnswers.length !== correctAnswers.length) return false;&#13;
&#13;
        var userAnswersParsed = [];&#13;
        var correctAnswersParsed = []&#13;
        userAnswers.forEach(function(element, index) {&#13;
            userAnswersParsed.push(element.join(':'));&#13;
        }, userAnswers);&#13;
        correctAnswers.forEach(function(element, index) {&#13;
            correctAnswersParsed.push(element.id + ':' + element.answer);&#13;
        }, correctAnswers);&#13;
      &#13;
        userAnswersParsed.sort();&#13;
        correctAnswersParsed.sort();&#13;
      &#13;
        for (var i = 0; i &lt; userAnswersParsed.length; ++i) {&#13;
          if (userAnswersParsed[i] !== correctAnswersParsed[i]) {&#13;
            return false;&#13;
          }&#13;
        }&#13;
        return true;&#13;
      }&#13;
&#13;
    function appendAnswerDiv (column, elementId, answerDiv) {&#13;
        var element = $('&lt;table class="answerItem" id="connection-' + elementId + '"&gt;&lt;/div&gt;');&#13;
        var row = $('&lt;tr&gt;&lt;/tr&gt;');&#13;
        var innerElement = $('&lt;td class="inner"&gt;&lt;/td&gt;');&#13;
        var newRow = $('&lt;tr&gt;&lt;/tr&gt;');&#13;
        var newCell = $('&lt;td class="connectionItemWrapper"&gt;&lt;/td&gt;');&#13;
        innerElement.append(answerDiv);&#13;
        row.append(innerElement);&#13;
        element.append(row);&#13;
        newCell.append(element);&#13;
        newRow.append(newCell);&#13;
        column.append(newRow);&#13;
    }&#13;
&#13;
    presenter.addAnswersElements = function (view, model, correctAnswers) {&#13;
        // left side&#13;
        userAnswers = []&#13;
        if (presenter.printableState.id.length &gt; 0) {&#13;
            for (var i = 0; i &lt; presenter.printableState.id.length; i++) {&#13;
                var pair = presenter.printableState.id[i].split(':');&#13;
                userAnswers.push(pair);&#13;
            }&#13;
        }&#13;
&#13;
        var leftAnswerColumn = $(view).find('.answersLeftColumn:first').find('.content:first');&#13;
        var rightAnswerColumn = $(view).find('.answersRightColumn:first').find('.content:first');&#13;
        &#13;
        // Left answer column&#13;
        for (var i = 0; i &lt; model["Left column"].length; i++) {&#13;
            var element = presenter.elements[i];&#13;
            var leftId = element.id;&#13;
            var userConnectionsWithLeftId = userAnswers.filter((userAnswer) =&gt; {&#13;
                return(userAnswer[0] == leftId);&#13;
            })&#13;
            if (userConnectionsWithLeftId.length == 0) {&#13;
                var emptyAnswer = [`${leftId}`, ''];&#13;
                userConnectionsWithLeftId.push(emptyAnswer);&#13;
            }&#13;
            var correctConnectionsWithLeftId = correctAnswers.filter((correctAnswer) =&gt; {&#13;
                return(correctAnswer.id == leftId);&#13;
            });&#13;
            var answerDiv = isAnswersEqualToCorrectResults(userConnectionsWithLeftId, correctConnectionsWithLeftId) ?&#13;
                    $('&lt;div class="correctAnswerDiv"&gt;&lt;/div&gt;') :&#13;
                    $('&lt;div class="inCorrectAnswerDiv"&gt;&lt;/div&gt;');&#13;
            appendAnswerDiv(leftAnswerColumn, leftId, answerDiv);&#13;
        }&#13;
        // Right answer column&#13;
        for (var i = 0; i &lt; model["Right column"].length; i++) {&#13;
            var rightId = model["Right column"][i].id;&#13;
            var userConnectionsWithRightId = userAnswers.filter((userAnswer) =&gt; {&#13;
                return(userAnswer[1] == rightId);&#13;
            })&#13;
            var correctConnectionsWithRightId = correctAnswers.filter((correctAnswer) =&gt; {&#13;
                return(correctAnswer.answer == rightId);&#13;
            })&#13;
            var answerDiv = isAnswersEqualToCorrectResults(userConnectionsWithRightId, correctConnectionsWithRightId) ?&#13;
                $('&lt;div class="correctAnswerDiv"&gt;&lt;/div&gt;') :&#13;
                $('&lt;div class="inCorrectAnswerDiv"&gt;&lt;/div&gt;');&#13;
            appendAnswerDiv(rightAnswerColumn, rightId, answerDiv);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isIDUnique = function (id) {&#13;
        if (id == '') return true;&#13;
        if ($.inArray(id, presenter.uniqueIDs) &lt; 0) {&#13;
            presenter.uniqueIDs.push(id);&#13;
            return true;&#13;
        } else {&#13;
            return false;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.loadElements = function (view, model) {&#13;
        loadElementsToFirstSide(view, model);&#13;
        loadElementsToSecondSide(view, model);&#13;
    };&#13;
&#13;
    function loadElementsToFirstSide(view, model) {&#13;
        loadElementsToSide(view, model, true);&#13;
    }&#13;
&#13;
    function loadElementsToSecondSide(view, model) {&#13;
        loadElementsToSide(view, model, false);&#13;
    }&#13;
&#13;
    function loadElementsToSide(view, model, isFirstSide) {&#13;
        const parentToLoadElements = findParentToLoadElements(view, isFirstSide);&#13;
&#13;
        const itemsModelKey = isFirstSide ? "Left column" : "Right column";&#13;
        const itemsModel = model[itemsModelKey];&#13;
        const itemsInOneSideNumber = itemsModel.length;&#13;
        presenter.columnSizes[itemsModelKey] = model[itemsModelKey].length;&#13;
&#13;
        const isRandomOrderKey = isFirstSide ? "Random order left column" : "Random order right column";&#13;
        const isRandomOrder = ModelValidationUtils.validateBoolean(model[isRandomOrderKey]);&#13;
&#13;
        let rowToLoad;&#13;
        const orderedIndexes = getOrderedIndexes(itemsInOneSideNumber, isRandomOrder);&#13;
        for (let nextIndex, i = 0; i &lt; itemsInOneSideNumber; i++) {&#13;
            nextIndex = orderedIndexes[i];&#13;
            if (!presenter.isIDUnique(itemsModel[nextIndex]["id"])) {&#13;
                return presenter.showErrorMessage("ID not unique");&#13;
            }&#13;
&#13;
            if (!presenter.isHorizontal || i === 0) {&#13;
                rowToLoad = document.createElement("tr");&#13;
                parentToLoadElements.append(rowToLoad);&#13;
            }&#13;
&#13;
            loadElement(itemsModel[nextIndex], rowToLoad, isFirstSide);&#13;
        }&#13;
    }&#13;
&#13;
    function findParentToLoadElements(view, isFirstSide) {&#13;
        let parentClassName = presenter.isHorizontal&#13;
            ? (isFirstSide&#13;
                ? presenter.CSS_CLASSES.CONNECTIONS_TOP_ROW&#13;
                : presenter.CSS_CLASSES.CONNECTIONS_BOTTOM_ROW)&#13;
            : (isFirstSide&#13;
                ? presenter.CSS_CLASSES.CONNECTIONS_LEFT_COLUMN&#13;
                : presenter.CSS_CLASSES.CONNECTIONS_RIGHT_COLUMN&#13;
            );&#13;
        return $(view)&#13;
            .find('.' + parentClassName + ':first')&#13;
            .find('.' + presenter.CSS_CLASSES.CONTENT + ':first')&#13;
            .find('tbody:first')[0];&#13;
    }&#13;
&#13;
    function getOrderedIndexes(size, isRandomOrder) {&#13;
        let orderedIndexes = [];&#13;
        if (isRandomOrder) {&#13;
            let counter = 0;&#13;
            while (counter &lt; size) {&#13;
                let nextIndex = nextInt(size);&#13;
                if (orderedIndexes.includes(nextIndex)) {&#13;
                    continue;&#13;
                }&#13;
                orderedIndexes.push(nextIndex);&#13;
                counter++;&#13;
            }&#13;
        } else {&#13;
            for (let i = 0; i &lt; size; i++) {&#13;
                orderedIndexes.push(i);&#13;
            }&#13;
        }&#13;
        return orderedIndexes;&#13;
    }&#13;
&#13;
    function nextInt(upperBound) {&#13;
        if (presenter.printableController) {&#13;
            return presenter.printableController.nextInt(upperBound);&#13;
        }&#13;
        return Math.floor((Math.random() * upperBound))&#13;
    }&#13;
&#13;
    function loadElement(itemModel, parentElement, isFirstSide) {&#13;
        const newCell = document.createElement("td");&#13;
        newCell.classList.add(presenter.CSS_CLASSES.CONNECTION_ITEM_WRAPPER);&#13;
        parentElement.append(newCell);&#13;
&#13;
        const newItem = createConnectionItem(itemModel, isFirstSide);&#13;
        newCell.append(newItem);&#13;
    }&#13;
&#13;
    function createConnectionItem(itemModel, isFirstSection) {&#13;
        const item = document.createElement("table");&#13;
        item.classList.add(presenter.CSS_CLASSES.CONNECTION_ITEM);&#13;
        item.id = "connection-" + itemModel["id"];&#13;
&#13;
        const itemBody = document.createElement("tbody");&#13;
        item.append(itemBody);&#13;
&#13;
        const contentCell = createConnectionItemContentCell(itemModel["content"], itemModel["additional class"]);&#13;
        const iconCell = createConnectionItemIconCell();&#13;
        if (presenter.isHorizontal) {&#13;
            const contentRow = document.createElement("tr");&#13;
            contentRow.append(contentCell);&#13;
            const iconRow = document.createElement("tr");&#13;
            iconRow.append(iconCell);&#13;
            if (isFirstSection) {&#13;
                itemBody.append(contentRow);&#13;
                itemBody.append(iconRow);&#13;
            } else {&#13;
                itemBody.append(iconRow);&#13;
                itemBody.append(contentRow);&#13;
            }&#13;
        } else {&#13;
            const sharedRow = document.createElement("tr");&#13;
            itemBody.append(sharedRow);&#13;
            if (isFirstSection) {&#13;
                sharedRow.append(contentCell);&#13;
                sharedRow.append(iconCell);&#13;
            } else {&#13;
                sharedRow.append(iconCell);&#13;
                sharedRow.append(contentCell);&#13;
            }&#13;
        }&#13;
&#13;
        presenter.elements.push({&#13;
            element: $(item),&#13;
            id: itemModel["id"],&#13;
            connects: itemModel["connects to"]&#13;
        });&#13;
&#13;
        return item;&#13;
    }&#13;
&#13;
    function createConnectionItemContentCell(content, additionalClassName) {&#13;
        const contentElement = document.createElement("td");&#13;
        contentElement.classList.add(presenter.CSS_CLASSES.INNER);&#13;
&#13;
        const contentWrapper = document.createElement("div");&#13;
        contentWrapper.classList.add(presenter.CSS_CLASSES.INNER_WRAPPER);&#13;
&#13;
        //리소스가 상대 경우인경우 도메인 경로 붙여주시&#13;
        try{&#13;
            var contentLower = content.toLowerCase();&#13;
            if( contentLower.indexOf("&lt;img") &gt; -1 &amp;&amp; contentLower.indexOf("http") &lt; 0){&#13;
                var src = content.slice(content.indexOf("src")).split('"')[1];&#13;
                console.log("content23423432", src);&#13;
                content = content.replace(src, presenter.model.pageURL + src);&#13;
            }&#13;
        }catch(e){&#13;
        }&#13;
&#13;
        contentWrapper.style.direction = isRTL ? "rtl" : "ltr";&#13;
        contentWrapper.innerHTML = content;&#13;
        !!additionalClassName &amp;&amp; contentWrapper.classList.add(additionalClassName);&#13;
        presenter.configuration.isTabindexEnabled &amp;&amp; contentWrapper.setAttribute("tabindex", 0);&#13;
        contentElement.append(contentWrapper);&#13;
&#13;
        return contentElement;&#13;
    }&#13;
&#13;
    function createConnectionItemIconCell() {&#13;
        const iconElement = document.createElement("td");&#13;
        iconElement.classList.add(presenter.CSS_CLASSES.ICON);&#13;
&#13;
        const iconWrapper = document.createElement("div");&#13;
        iconWrapper.classList.add(presenter.CSS_CLASSES.ICON_WRAPPER);&#13;
        iconElement.append(iconWrapper);&#13;
&#13;
        return iconElement;&#13;
    }&#13;
&#13;
    presenter.initializeView = function (view, model) {&#13;
        const $firstSideElement = $(view).find("." + this.getFirstSideCSSClassName() + ":first");&#13;
        const firstSideSize = {&#13;
            height: $firstSideElement.outerHeight(true),&#13;
            width: $firstSideElement.outerWidth(true),&#13;
        };&#13;
&#13;
        const $secondSideElement = $(view).find("." + this.getSecondSideCSSClassName() + ":first");&#13;
        const secondSideSize = {&#13;
            height: $secondSideElement.outerHeight(true),&#13;
            width: $secondSideElement.outerWidth(true),&#13;
        };&#13;
&#13;
        let height = model["Height"];// leftColumnHeight &gt; rightColumnHeight ? leftColumnHeight : rightColumnHeight;&#13;
        let width = model["Width"];&#13;
        if (presenter.isHorizontal) {&#13;
            height -= (firstSideSize.height + secondSideSize.height);&#13;
        } else {&#13;
            width -= (firstSideSize.width + secondSideSize.width);&#13;
        }&#13;
&#13;
        presenter.height = height;&#13;
        presenter.width = width;&#13;
&#13;
        const context = connections[0].getContext('2d');&#13;
        context.canvas.width = width;&#13;
        context.canvas.height = height;&#13;
        connections.css({&#13;
            width: width + "px",&#13;
            height: height + "px"&#13;
        });&#13;
        connections.translateCanvas({&#13;
            x: 0.5, y: 0.5&#13;
        });&#13;
    };&#13;
&#13;
    presenter.gatherCorrectConnections = function () {&#13;
        presenter.correctConnections.clear();&#13;
        var elements = presenter.elements;&#13;
        for (var i = 0, elementsLength = elements.length; i &lt; elementsLength; i++) {&#13;
            var connects = elements[i]['connects'].split(',');&#13;
            for (var j = 0; j &lt; connects.length; j++) {&#13;
                if (connects[j] != "" &amp;&amp;&#13;
                    $.inArray(connects[j], presenter.uniqueIDs) &gt;= 0) {&#13;
                    var pair = [elements[i]['id'], connects[j]];&#13;
                    var line = new Line(&#13;
                        getElementById(pair[0]),&#13;
                        getElementById(pair[1])&#13;
                    );&#13;
                    if (!presenter.correctConnections.hasPair(pair)) {&#13;
                        presenter.correctConnections.push(line);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawConfiguredConnections = function () {&#13;
        for (var i = 0; i &lt; presenter.correctConnections.length(); i++) {&#13;
            pushConnection(presenter.correctConnections.get(i), true)&#13;
        }&#13;
        presenter.redraw();&#13;
    };&#13;
&#13;
    presenter.getElementSnapPoint = function AddonConnection_getElementSnapPoint($element) {&#13;
        const offset = $element.offset();&#13;
        const scale = playerController ? playerController.getScaleInformation() : { scaleX: 1, scaleY: 1 };&#13;
        const isFirstSideElement = $element.parents('.' + presenter.getFirstSideCSSClassName()).length &gt; 0;&#13;
&#13;
        let snapPoint;&#13;
        if (presenter.isHorizontal) {&#13;
            const elementWidth = $element.outerWidth() * scale.scaleX;&#13;
            const elementHeight = $element.outerHeight(true) * scale.scaleY;&#13;
            if (isFirstSideElement) {&#13;
                snapPoint = [offset.left + elementWidth / 2, offset.top + elementHeight];&#13;
            } else {&#13;
                snapPoint = [offset.left + elementWidth / 2, offset.top];&#13;
            }&#13;
        } else {&#13;
            const elementWidth = $element.outerWidth(true) * scale.scaleX;&#13;
            const elementHeight = $element.outerHeight() * scale.scaleY;&#13;
            if (isFirstSideElement) {&#13;
                snapPoint = [offset.left + elementWidth, offset.top + elementHeight / 2];&#13;
            } else {&#13;
                snapPoint = [offset.left, offset.top + elementHeight / 2];&#13;
            }&#13;
        }&#13;
&#13;
        // snapPoint[0] is x offset, [1] is y offset&#13;
        snapPoint[0] /= scale.scaleX;&#13;
        snapPoint[1] /= scale.scaleY;&#13;
&#13;
        return snapPoint;&#13;
    };&#13;
&#13;
    function pushConnection(line, isPreview) {&#13;
        var addLine = true, linesToRemove = [], existingLines;&#13;
        if (presenter.configuration.isSingleConnectionMode) {&#13;
            existingLines = presenter.lineStack.isItemUsed(line);&#13;
            if (existingLines.length &gt; 0) {&#13;
                if (!isPreview) {&#13;
                    linesToRemove.push.apply(linesToRemove, existingLines)&#13;
                }&#13;
                if (presenter.lineStack.hasLine(line).length &gt; 0) {&#13;
                    addLine = false&#13;
                }&#13;
            }&#13;
        } else {&#13;
            existingLines = presenter.lineStack.hasLine(line);&#13;
            if (existingLines.length &gt; 0) {&#13;
                if (!isPreview) {&#13;
                    linesToRemove.push.apply(linesToRemove, existingLines);&#13;
                }&#13;
                addLine = false;&#13;
            }&#13;
        }&#13;
        for (var i = 0; i &lt; linesToRemove.length; i++) {&#13;
            presenter.lineStack.remove(linesToRemove[i]);&#13;
        }&#13;
        if (addLine) {&#13;
            presenter.lineStack.push(line);&#13;
        }&#13;
        readConnected(addLine);&#13;
    }&#13;
&#13;
    presenter.redraw = function AddonConnection_redraw() {&#13;
        connections.width = connections.width;&#13;
&#13;
        var android_ver = MobileUtils.getAndroidVersion(window.navigator.userAgent);&#13;
        if (["4.1.1", "4.1.2", "4.2.2", "4.3", "4.4.2"].indexOf(android_ver) !== -1) {&#13;
            presenter.$view.find('.' + presenter.CSS_CLASSES.CONNECTIONS).remove();&#13;
            var canvas2 = $('&lt;canvas&gt;&lt;/canvas&gt;');&#13;
            canvas2.addClass(presenter.CSS_CLASSES.CONNECTIONS);&#13;
            presenter.$view.find('.' + presenter.getMiddleSideCSSClassName()).append(canvas2);&#13;
&#13;
            var context = canvas2[0].getContext('2d');&#13;
            context.canvas.width = presenter.width;&#13;
            context.canvas.height = presenter.height;&#13;
            canvas2.css({&#13;
                width: presenter.width + 'px',&#13;
                height: presenter.height + 'px'&#13;
            });&#13;
            canvas2.translateCanvas({&#13;
                x: 0.5, y: 0.5&#13;
            });&#13;
&#13;
            connections = presenter.$view.find('.' + presenter.CSS_CLASSES.CONNECTIONS);&#13;
        } else {&#13;
            connections.clearCanvas();&#13;
        }&#13;
&#13;
        for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
            drawLine(presenter.lineStack.get(i), presenter.configuration.defaultConnectionColor)&#13;
        }&#13;
    };&#13;
&#13;
    presenter.redrawShowAnswers = function AddonConnection_redrawShowAnswers() {&#13;
        connections.clearCanvas();&#13;
        for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
            drawLine(presenter.lineStack.get(i), presenter.configuration.showAnswersLineColor);&#13;
        }&#13;
    };&#13;
&#13;
    function drawLine(line, color) {&#13;
        if (line.isDisabled() &amp;&amp; presenter.configuration.disabledConnectionColor !== "") {&#13;
            color = presenter.configuration.disabledConnectionColor;&#13;
        }&#13;
&#13;
        var from = presenter.getElementSnapPoint(line.from);&#13;
        var to = presenter.getElementSnapPoint(line.to);&#13;
        var canvasOffset = connections.offset();&#13;
        var scale = playerController ? playerController.getScaleInformation() : { scaleX: 1, scaleY: 1 };&#13;
&#13;
        canvasOffset.left /= scale.scaleX;&#13;
        canvasOffset.top /= scale.scaleY;&#13;
&#13;
        connections.drawLine({&#13;
            strokeStyle: color,&#13;
            strokeWidth: presenter.configuration.connectionThickness,&#13;
            x1: to[0] - canvasOffset.left,&#13;
            y1: to[1] - canvasOffset.top,&#13;
            x2: from[0] - canvasOffset.left,&#13;
            y2: from[1] - canvasOffset.top&#13;
        });&#13;
    }&#13;
&#13;
    presenter.isShowingAnswers = function AddonConnection_isShowingAnswers(){&#13;
        return presenter.isGradualShowAnswersActive || presenter.isShowAnswersActive;&#13;
    }&#13;
&#13;
    presenter.setShowErrorsMode = deferredCommandQueue.decorate(&#13;
        function () {&#13;
            presenter.isCheckActive = true;&#13;
            if (presenter.isShowAnswersActive) {&#13;
                presenter.hideAnswers();&#13;
            }&#13;
            if (presenter.configuration.isNotActivity) return 0;&#13;
&#13;
            connections.clearCanvas();&#13;
            for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
                var line = presenter.lineStack.get(i);&#13;
                if (presenter.correctConnections.hasLine(line).length &gt; 0) {&#13;
                    drawLine(presenter.lineStack.get(i), presenter.configuration.correctConnectionColor);&#13;
                    var fromElementCorrect = presenter.$view.find('#' + presenter.lineStack.get(i).from[0].id);&#13;
                    var toElementCorrect = presenter.$view.find('#' + presenter.lineStack.get(i).to[0].id);&#13;
                    $(fromElementCorrect).addClass(CORRECT_ITEM_CLASS);&#13;
                    $(toElementCorrect).addClass(CORRECT_ITEM_CLASS);&#13;
                } else {&#13;
                    drawLine(presenter.lineStack.get(i), presenter.configuration.incorrectConnectionColor);&#13;
                    var fromElementIncorrect = presenter.$view.find('#' + presenter.lineStack.get(i).from[0].id);&#13;
                    var toElementIncorrect = presenter.$view.find('#' + presenter.lineStack.get(i).to[0].id);&#13;
                    $(fromElementIncorrect).addClass(WRONG_ITEM_CLASS);&#13;
                    $(toElementIncorrect).addClass(WRONG_ITEM_CLASS);&#13;
                }&#13;
            }&#13;
            presenter.$view.find('.' + presenter.CSS_CLASSES.CONNECTION_ITEM).each(function () {&#13;
                if ($(this).hasClass(CORRECT_ITEM_CLASS) &amp;&amp; $(this).hasClass(WRONG_ITEM_CLASS)) {&#13;
                    $(this).removeClass(CORRECT_ITEM_CLASS);&#13;
                }&#13;
            });&#13;
            presenter.$connectionContainer&#13;
                .find('.' + presenter.CSS_CLASSES.SELECTED)&#13;
                .removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
            selectedItem = null;&#13;
            isSelectionPossible = false;&#13;
        }&#13;
    );&#13;
&#13;
    presenter.setWorkMode = deferredCommandQueue.decorate(&#13;
        function () {&#13;
            presenter.isCheckActive = false;&#13;
            presenter.gatherCorrectConnections();&#13;
            presenter.redraw();&#13;
            presenter.$view.find('.' + presenter.CSS_CLASSES.CONNECTION_ITEM).each(function () {&#13;
                $(this).removeClass(CORRECT_ITEM_CLASS);&#13;
                $(this).removeClass(WRONG_ITEM_CLASS);&#13;
            });&#13;
            isSelectionPossible = true;&#13;
        }&#13;
    );&#13;
&#13;
    presenter.reset = deferredCommandQueue.decorate(&#13;
        function (onlyWrongAnswers) {&#13;
            if (!presenter.configuration.isValid) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (presenter.isShowAnswersActive) {&#13;
                presenter.hideAnswers();&#13;
            }&#13;
&#13;
            presenter.keyboardControllerObject.selectEnabled(true);&#13;
&#13;
            if (!onlyWrongAnswers) {&#13;
                presenter.lineStack.clear();&#13;
            } else {&#13;
                this.lineStack.setSendEvents(false);&#13;
                var linesToRemove = [];&#13;
                for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
                    var line = presenter.lineStack.get(i);&#13;
                    if (presenter.correctConnections.hasLine(line).length === 0) {&#13;
                        linesToRemove.push(line)&#13;
                    }&#13;
                }&#13;
&#13;
                linesToRemove.forEach(function (line) {&#13;
                    presenter.lineStack.remove(line);&#13;
                });&#13;
                this.lineStack.setSendEvents(true);&#13;
            }&#13;
&#13;
            isSelectionPossible = true;&#13;
            presenter.$connectionContainer&#13;
                .find('.' + presenter.CSS_CLASSES.SELECTED)&#13;
                .removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
            presenter.$view.find('.' + presenter.CSS_CLASSES.CONNECTION_ITEM).each(function () {&#13;
                $(this).removeClass(CORRECT_ITEM_CLASS);&#13;
                $(this).removeClass(WRONG_ITEM_CLASS);&#13;
            });&#13;
&#13;
            presenter.redraw();&#13;
            presenter.setVisibility(presenter.isVisibleByDefault);&#13;
            presenter.isVisible = presenter.isVisibleByDefault;&#13;
            presenter.disabledConnections = [];&#13;
            if (!onlyWrongAnswers) {&#13;
                presenter.addDisabledElementsFromInitialValues();&#13;
                presenter.drawInitialValues();&#13;
            }&#13;
        }&#13;
    );&#13;
&#13;
    // that method can return false results when called before mathjax is loaded, but cannot be moved to aysnc queue&#13;
    presenter.getErrorCount = function () {&#13;
        if (presenter.configuration.isNotActivity) return 0;&#13;
&#13;
        var errors = 0;&#13;
        for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
            var line = presenter.lineStack.get(i);&#13;
            if (presenter.correctConnections.hasLine(line).length == 0) {&#13;
                errors++;&#13;
            }&#13;
        }&#13;
        return errors;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function () {&#13;
        if (presenter.configuration.isNotActivity) return 0;&#13;
&#13;
        return presenter.correctConnections.length() - presenter.correctConnections.getDisabledCount();&#13;
    };&#13;
&#13;
    // that method can return false results when called before mathjax is loaded, but cannot be moved to aysnc queue&#13;
    presenter.getScore = function () {&#13;
        if (presenter.configuration.isNotActivity) return 0;&#13;
&#13;
        var score = 0;&#13;
        for (var i = 0; i &lt; presenter.lineStack.length(); i++) {&#13;
            var line = presenter.lineStack.get(i);&#13;
            if (presenter.correctConnections.hasLine(line).length &gt; 0) {&#13;
                if (!line.isDisabled()) {&#13;
                    score++;&#13;
                }&#13;
            }&#13;
        }&#13;
        return score;&#13;
    };&#13;
&#13;
    presenter.gradualShowAnswers = function (itemIndex) {&#13;
        presenter.keyboardControllerObject.selectEnabled(false);&#13;
        presenter.addCurrentAnswersToTemporary();&#13;
&#13;
        presenter.lineStack.clear();&#13;
        presenter.redraw();&#13;
&#13;
        while(itemIndex &lt; presenter.GSAcounter || !presenter.elementIsShowAnswersViable(itemIndex)) {&#13;
            itemIndex++;&#13;
        }&#13;
        presenter.addCorrectAnswersToLineStack(itemIndex + 1);&#13;
        presenter.GSAcounter = itemIndex + 1;&#13;
&#13;
        presenter.redrawShowAnswers();&#13;
        presenter.lineStack.clear();&#13;
        isSelectionPossible = false;&#13;
&#13;
        presenter.restoreConnectionFromTemporary();&#13;
    }&#13;
&#13;
    presenter.gradualHideAnswers = function () {&#13;
        presenter.isGradualShowAnswersActive = false;&#13;
        presenter.keyboardControllerObject.selectEnabled(true);&#13;
        presenter.redraw();&#13;
        isSelectionPossible = true;&#13;
        presenter.GSAcounter = 0;&#13;
    }&#13;
&#13;
    presenter.elementIsShowAnswersViable = function(index) {&#13;
        var viableElement = false;&#13;
        var connects = presenter.elements[index].connects;&#13;
        for(var i = 0; i &lt; connects.length; i++) {&#13;
            if(connects[i] !== "" &amp;&amp; $.inArray(connects[i], presenter.uniqueIDs) &gt;= 0) {&#13;
                viableElement = true;&#13;
                break;&#13;
            }&#13;
        }&#13;
        return viableElement;&#13;
    }&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        var counter = 0;&#13;
        for (var i = 0; i &lt; presenter.elements.length; i++) {&#13;
            if (presenter.elementIsShowAnswersViable(i)) counter++;&#13;
        }&#13;
        return counter;&#13;
    }&#13;
&#13;
    presenter.getState = function () {&#13;
        // this is needed because run/setState method waits for MathJax process to be finished&#13;
        // if getState is called before MathJax EndProcess callback then state would be lost&#13;
        // this fix that problem&#13;
        if (!presenter.mathJaxLoaders.setStateLoaded &amp;&amp; presenter.initialState !== null) {&#13;
            return presenter.initialState;&#13;
        }&#13;
&#13;
        var id = [];&#13;
        for (var i = 0; i &lt; presenter.lineStack.ids.length; i++) {&#13;
            id.push(presenter.lineStack.ids[i].join(':'))&#13;
        }&#13;
        return JSON.stringify({&#13;
            id: id,&#13;
            isVisible: presenter.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        var hookExecuted = false;&#13;
        presenter.initialState = state;&#13;
        presenter.mathJaxLoaders.setStateLoaded = false;&#13;
&#13;
        presenter.mathJaxProcessEnded.then(function () {&#13;
            if (state !== '' &amp;&amp; !hookExecuted) {&#13;
                presenter.lineStack.setSendEvents(false);&#13;
                presenter.lineStack.clear();&#13;
&#13;
                var parsedState = JSON.parse(state);&#13;
                var id;&#13;
                if (typeof parsedState.isVisible !== "undefined") {&#13;
                    id = parsedState.id;&#13;
                    presenter.setVisibility(parsedState.isVisible);&#13;
                    presenter.isVisible = parsedState.isVisible;&#13;
                } else {&#13;
                    id = parsedState;&#13;
                }&#13;
                for (var i = 0; i &lt; id.length; i++) {&#13;
                    var pair = id[i].split(':');&#13;
                    pushConnection(new Line(getElementById(pair[0]), getElementById(pair[1])), false);&#13;
                }&#13;
&#13;
                presenter.lineStack.setSendEvents(true);&#13;
                presenter.redraw();&#13;
                presenter.mathJaxLoaders.setStateLoaded = true;&#13;
                deferredCommandQueue.resolve();&#13;
            }&#13;
            presenter.initialState = null;&#13;
            hookExecuted = true;&#13;
        });&#13;
    };&#13;
&#13;
    presenter.validateAdditionalClass = function (view, additionalClass) {&#13;
        var additionalClassElements = $(view).find('.' + additionalClass);&#13;
        var isAdditionalClass = $(view).find('.' + additionalClass).length &gt; 0;&#13;
&#13;
        if (!isAdditionalClass) {&#13;
            return {isPresent: false, count: 0};&#13;
        }&#13;
&#13;
        return {isPresent: true, count: additionalClassElements.length};&#13;
    };&#13;
&#13;
    presenter.validateView = function (view, searchingKeyword) {&#13;
        var validatedAdditionalClass = presenter.validateAdditionalClass(view, searchingKeyword);&#13;
        if (!validatedAdditionalClass.isPresent) {&#13;
            return {isPresent: false, count: validatedAdditionalClass.count};&#13;
        }&#13;
        return {isPresent: true, count: validatedAdditionalClass.count};&#13;
    };&#13;
&#13;
    presenter.getElementById = function (id) {&#13;
        return getElementById(id);&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore() &amp;&amp; presenter.getErrorCount() === 0;&#13;
    };&#13;
&#13;
    presenter.isOK = function (source) {&#13;
        var selectedDestinations = getConnectedPoints(source);&#13;
        var correctDestinations = getCorrectPoints(source);&#13;
        var isCorrect = isSameArrays(selectedDestinations, correctDestinations);&#13;
&#13;
        return {&#13;
            value: isCorrect,&#13;
            source: source,&#13;
            selectedDestinations: selectedDestinations,&#13;
            correctDestinations: correctDestinations&#13;
        };&#13;
    };&#13;
&#13;
    function getConnectedPoints(source) {&#13;
        var connectedPoints = [];&#13;
&#13;
        var selectedLines = presenter.lineStack.ids;&#13;
        for (var index = 0; index &lt; selectedLines.length; index++) {&#13;
            var selectedLinePoints = selectedLines[index];&#13;
            if (hasArrayElement(selectedLinePoints, source)) {&#13;
                var selectedDestinationPoint = selectedLinePoints[0] === source ? selectedLinePoints[1] : selectedLinePoints[0];&#13;
                connectedPoints.push(selectedDestinationPoint);&#13;
            }&#13;
        }&#13;
&#13;
        return connectedPoints;&#13;
    }&#13;
&#13;
    function getCorrectPoints(source) {&#13;
        var correctPoints = [];&#13;
&#13;
        var correctLines = presenter.elements;&#13;
        for (var index = 0; index &lt; correctLines.length; index++) {&#13;
            var correctLine = correctLines[index];&#13;
            var correctLinePoints = correctLine.connects.split(',');&#13;
            if (correctLine.id === source) {&#13;
                correctPoints = correctPoints.concat(correctLinePoints);&#13;
            }&#13;
            if (hasArrayElement(correctLinePoints, source)) {&#13;
                correctPoints.push(correctLine.id)&#13;
            }&#13;
        }&#13;
&#13;
        correctPoints = removeDuplicates(correctPoints);&#13;
        correctPoints = correctPoints.filter(function (value) {&#13;
            return value !== ";"&#13;
        });&#13;
&#13;
        return correctPoints;&#13;
    }&#13;
&#13;
    function removeDuplicates(correctPoints) {&#13;
        correctPoints = correctPoints.filter(function (value, index, arr) {&#13;
            return arr.indexOf(value) === index;&#13;
        });&#13;
        return correctPoints;&#13;
    }&#13;
&#13;
    function isSameArrays(selectedDestinations, correctDestinations) {&#13;
        var serializedSelectedDestinations = selectedDestinations.sort().join(',');&#13;
        var serializedCorrectDestinations = correctDestinations.sort().join(',');&#13;
&#13;
        return serializedSelectedDestinations === serializedCorrectDestinations;&#13;
    }&#13;
&#13;
    function hasArrayElement(array, element) {&#13;
        for (var arrayIndex = 0; arrayIndex &lt; array.length; arrayIndex++)&#13;
            if (array[arrayIndex] === element)&#13;
                return true;&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.isSelected = function (leftIndex, rightIndex) {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        var leftElement = getElementById(leftIndex);&#13;
        var rightElement = getElementById(rightIndex);&#13;
        var line = new Line(leftElement, rightElement);&#13;
        return (presenter.lineStack.hasLine(line).length &gt; 0);&#13;
    };&#13;
&#13;
    presenter.isAttempted = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        return (presenter.lineStack.stack.length &gt; 0)&#13;
    };&#13;
&#13;
&#13;
    presenter.markAsCorrect = function (leftIndex, rightIndex) {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        var leftElement = getElementById(leftIndex);&#13;
        var rightElement = getElementById(rightIndex);&#13;
        var line = new Line(leftElement, rightElement);&#13;
        presenter.correctConnections.push(line);&#13;
        if (presenter.lineStack.hasLine(line))&#13;
            drawLine(line, presenter.configuration.correctConnectionColor);&#13;
&#13;
    };&#13;
&#13;
    presenter.markAsWrong = function (leftIndex, rightIndex) {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        var leftElement = getElementById(leftIndex);&#13;
        var rightElement = getElementById(rightIndex);&#13;
        var line = new Line(leftElement, rightElement);&#13;
        if (presenter.correctConnections.hasLine(line))&#13;
            presenter.correctConnections.remove(line);&#13;
        if (presenter.lineStack.hasLine(line))&#13;
            drawLine(line, presenter.configuration.incorrectConnectionColor);&#13;
&#13;
    };&#13;
&#13;
    presenter.isSelectedCommand = function (params) {&#13;
        presenter.isSelected(params[0], params[1]);&#13;
    };&#13;
&#13;
    presenter.markAsCorrectCommand = function (params) {&#13;
        presenter.markAsCorrect(params[0], params[1]);&#13;
    };&#13;
&#13;
    presenter.markAsWrongCommand = function (params) {&#13;
        presenter.markAsWrong(params[0], params[1]);&#13;
    };&#13;
&#13;
    presenter.isAttemptedCommand = function () {&#13;
        return presenter.isAttempted();&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (!isSelectionPossible) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'isOK': presenter.isOK,&#13;
            'isSelected': presenter.isSelectedCommand,&#13;
            'markAsCorrect': presenter.markAsCorrectCommand,&#13;
            'markAsWrong': presenter.markAsWrongCommand,&#13;
            'isAttempted': presenter.isAttemptedCommand,&#13;
            'showAnswers': presenter.showAnswers,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'hideAnswers': presenter.hideAnswers,&#13;
            'disable': presenter.disableCommand,&#13;
            'enable': presenter.enableCommand&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.disableCommand = function (params) {&#13;
        if (params.length === 2) {&#13;
            presenter.disable(params[0], params[1]);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.disable = function (id1, id2) {&#13;
        presenter.disabledConnections.push({id1: id1, id2: id2});&#13;
    };&#13;
&#13;
    presenter.enableCommand = function (params) {&#13;
        if (params.length === 2) {&#13;
            presenter.enable(params[0], params[1]);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.enable = function (id1, id2) {&#13;
        var convertedIds = convertIds(id1, id2);&#13;
        id1 = convertedIds.id1;&#13;
        id2 = convertedIds.id2;&#13;
&#13;
        for (var i = 0; i &lt; presenter.disabledConnections.length; i++) {&#13;
            if ((presenter.disabledConnections[i].id1 == id1 &amp;&amp; presenter.disabledConnections[i].id2 == id2) ||&#13;
                (presenter.disabledConnections[i].id1 == id2 &amp;&amp; presenter.disabledConnections[i].id2 == id1)) {&#13;
                presenter.disabledConnections.splice(i, 1);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.checkIfConnectionDisabled = function (id1, id2) {&#13;
        var convertedIds = convertIds(id1, id2);&#13;
        id1 = convertedIds.id1;&#13;
        id2 = convertedIds.id2;&#13;
&#13;
        for (var i = 0; i &lt; presenter.disabledConnections.length; i++) {&#13;
            if ((presenter.disabledConnections[i].id1 == id1 &amp;&amp; presenter.disabledConnections[i].id2 == id2) ||&#13;
                (presenter.disabledConnections[i].id1 == id2 &amp;&amp; presenter.disabledConnections[i].id2 == id1)) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, data) {&#13;
        if (eventName === "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        } else if (eventName === "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        } else if (eventName === "GradualShowAnswers") {&#13;
            if (!presenter.isGradualShowAnswersActive) {&#13;
                presenter.isGradualShowAnswersActive = true;&#13;
            }&#13;
            if (data.moduleID === addonID) {&#13;
                presenter.gradualShowAnswers(parseInt(data.item, 10));&#13;
            }&#13;
        } else if (eventName === "GradualHideAnswers") {&#13;
            presenter.gradualHideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.addCurrentAnswersToTemporary =function () {&#13;
        presenter.tmpElements = [];&#13;
        for (var elem = 0; elem &lt; presenter.lineStack.ids.length; elem++) {&#13;
            presenter.tmpElements.push(presenter.lineStack.ids[elem].join(':'))&#13;
        }&#13;
    }&#13;
&#13;
    presenter.addCorrectAnswersToLineStack = function (length) {&#13;
        for (var i = 0; i &lt; length; i++) {&#13;
            var connects = presenter.elements[i]['connects'].split(',');&#13;
            for (var j = 0; j &lt; connects.length; j++) {&#13;
                if (connects[j] !== "" &amp;&amp; $.inArray(connects[j], presenter.uniqueIDs) &gt;= 0) {&#13;
                    var pair = [presenter.elements[i]['id'], connects[j]];&#13;
                    var line = new Line(&#13;
                        getElementById(pair[0]),&#13;
                        getElementById(pair[1])&#13;
                    );&#13;
                    presenter.lineStack.push(line);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.lineStackSA = {&#13;
            stack: presenter.lineStack ? presenter.lineStack.stack.concat([]) : []&#13;
        };&#13;
    }&#13;
&#13;
    presenter.restoreConnectionFromTemporary = function () {&#13;
        for (var element = 0; element &lt; presenter.tmpElements.length; element++) {&#13;
            var pairs = presenter.tmpElements[element].split(':');&#13;
            pushConnection(new Line(getElementById(pairs[0]), getElementById(pairs[1])), false);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.showAnswers = deferredCommandQueue.decorate(&#13;
        function () {&#13;
            if (presenter.configuration.isNotActivity) {&#13;
                return;&#13;
            }&#13;
&#13;
            presenter.keyboardControllerObject.selectEnabled(false);&#13;
            presenter.isShowAnswersActive = true;&#13;
            presenter.addCurrentAnswersToTemporary();&#13;
&#13;
            presenter.lineStack.clear();&#13;
            presenter.redraw();&#13;
&#13;
            presenter.addCorrectAnswersToLineStack(presenter.elements.length)&#13;
&#13;
            presenter.redrawShowAnswers();&#13;
            presenter.lineStack.clear();&#13;
            isSelectionPossible = false;&#13;
&#13;
            presenter.restoreConnectionFromTemporary();&#13;
        }&#13;
    );&#13;
&#13;
    presenter.hideAnswers = deferredCommandQueue.decorate(&#13;
        function () {&#13;
            if (presenter.configuration.isNotActivity || !presenter.isShowAnswersActive) {&#13;
                return;&#13;
            }&#13;
            presenter.keyboardControllerObject.selectEnabled(true);&#13;
            presenter.redraw();&#13;
            presenter.isShowAnswersActive = false;&#13;
            isSelectionPossible = true;&#13;
        }&#13;
    );&#13;
&#13;
    presenter.keyboardController = function (keycode, isShiftDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftDown, event);&#13;
    };&#13;
&#13;
    function ConnectionKeyboardController(elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
    }&#13;
&#13;
    presenter.getTextToSpeechOrNull = function (playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function (isOn) {&#13;
        isWCAGOn = isOn;&#13;
    };&#13;
&#13;
    function readConnected(isDrawing) {&#13;
        var tts = presenter.getTextToSpeechOrNull(playerController);&#13;
        if (tts &amp;&amp; presenter.$view.hasClass('ic_active_module')) {&#13;
            speak([getTextVoiceObject(&#13;
                isDrawing ? presenter.speechTexts.connected : presenter.speechTexts.disconnected&#13;
            )]);&#13;
        }&#13;
    }&#13;
&#13;
    function getConnections($element) {&#13;
        var element = $element[0];&#13;
        var result = [];&#13;
        var lines = presenter.isShowingAnswers() ? presenter.lineStackSA : presenter.lineStack;&#13;
&#13;
        for (var i = 0; i &lt; lines.stack.length; i++) {&#13;
            var line = lines.stack[i];&#13;
&#13;
            if (element === line.from[0]) {&#13;
                result.push(line.to);&#13;
            }&#13;
&#13;
            if (element === line.to[0]) {&#13;
                result.push(line.from);&#13;
            }&#13;
        }&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    function getConnectionsInfo(connections) {&#13;
        var result = [];&#13;
&#13;
        for (var i = 0; i &lt; connections.length; i++) {&#13;
&#13;
            result = result.concat(window.TTSUtils.getTextVoiceArrayFromElement(connections[i], presenter.configuration.langTag));&#13;
&#13;
            if (connections[i].hasClass(CORRECT_ITEM_CLASS) &amp;&amp; presenter.isCheckActive) {&#13;
                result.push(getTextVoiceObject(presenter.speechTexts.correct));&#13;
            }&#13;
&#13;
            if (connections[i].hasClass(WRONG_ITEM_CLASS) &amp;&amp; presenter.isCheckActive) {&#13;
                result.push(getTextVoiceObject(presenter.speechTexts.wrong));&#13;
            }&#13;
        }&#13;
&#13;
        return result;&#13;
    }&#13;
&#13;
    function readActivatedElementConnections() {&#13;
        var tts = presenter.getTextToSpeechOrNull(playerController);&#13;
        if (tts) {&#13;
            var $active = presenter.getCurrentActivatedElement();&#13;
            var connections = getConnections($active);&#13;
            var TextVoiceArray = window.TTSUtils.getTextVoiceArrayFromElement($active, presenter.configuration.langTag);&#13;
&#13;
            if ($active.hasClass(presenter.CSS_CLASSES.SELECTED) &amp;&amp; !presenter.isShowingAnswers()) {&#13;
                TextVoiceArray.push(getTextVoiceObject(presenter.speechTexts.selected, ''));&#13;
            }&#13;
&#13;
            if (connections.length) {&#13;
                TextVoiceArray.push(getTextVoiceObject(presenter.speechTexts.connectedTo, ''));&#13;
                TextVoiceArray = TextVoiceArray.concat(getConnectionsInfo(connections));&#13;
            }&#13;
&#13;
            speak(TextVoiceArray);&#13;
        }&#13;
    }&#13;
&#13;
    function speak(data) {&#13;
        var tts = presenter.getTextToSpeechOrNull(playerController);&#13;
&#13;
        if (tts &amp;&amp; isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    }&#13;
&#13;
    ConnectionKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    ConnectionKeyboardController.prototype.constructor = ConnectionKeyboardController;&#13;
&#13;
    ConnectionKeyboardController.prototype.nextRow = function (event) {&#13;
        event.preventDefault();&#13;
        var new_position_index = this.keyboardNavigationCurrentElementIndex + 1;&#13;
        if (new_position_index &gt;= this.keyboardNavigationElementsLen || new_position_index &lt; 0) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex;&#13;
        }&#13;
        if (new_position_index === presenter.columnSizes['Left column']) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex;&#13;
        }&#13;
        this.markCurrentElement(new_position_index);&#13;
        readActivatedElementConnections();&#13;
    };&#13;
&#13;
    ConnectionKeyboardController.prototype.previousRow = function (event) {&#13;
        event.preventDefault();&#13;
        var new_position_index = this.keyboardNavigationCurrentElementIndex - 1;&#13;
        if (new_position_index &gt;= this.keyboardNavigationElementsLen || new_position_index &lt; 0) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex&#13;
        }&#13;
        if (new_position_index === presenter.columnSizes['Left column'] - 1) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex;&#13;
        }&#13;
        this.markCurrentElement(new_position_index);&#13;
        readActivatedElementConnections();&#13;
    };&#13;
&#13;
    function indexesInTheSameColumn(index1, index2) {&#13;
        var leftColumnSize = presenter.columnSizes['Left column'];&#13;
&#13;
        return (index1 &lt; leftColumnSize &amp;&amp; index2 &lt; leftColumnSize) || (index1 &gt;= leftColumnSize &amp;&amp; index2 &gt;= leftColumnSize);&#13;
    }&#13;
&#13;
    ConnectionKeyboardController.prototype.nextElement = function () {&#13;
        var new_position_index = this.keyboardNavigationCurrentElementIndex + presenter.columnSizes['Left column'];&#13;
&#13;
        if (new_position_index &gt;= this.keyboardNavigationElementsLen) {&#13;
            new_position_index = this.keyboardNavigationElementsLen - 1;&#13;
        }&#13;
&#13;
        if (indexesInTheSameColumn(new_position_index, this.keyboardNavigationCurrentElementIndex)) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex;&#13;
        }&#13;
&#13;
        this.markCurrentElement(new_position_index);&#13;
        readActivatedElementConnections();&#13;
    };&#13;
&#13;
    ConnectionKeyboardController.prototype.previousElement = function () {&#13;
        var new_position_index = this.keyboardNavigationCurrentElementIndex - presenter.columnSizes['Right column'];&#13;
&#13;
        if (new_position_index &lt; 0) {&#13;
            new_position_index = 0;&#13;
        }&#13;
&#13;
        if (indexesInTheSameColumn(new_position_index, this.keyboardNavigationCurrentElementIndex)) {&#13;
            new_position_index = this.keyboardNavigationCurrentElementIndex;&#13;
        }&#13;
&#13;
        this.markCurrentElement(new_position_index);&#13;
        readActivatedElementConnections();&#13;
    };&#13;
&#13;
    ConnectionKeyboardController.prototype.enter = function (event) {&#13;
        if (event.shiftKey || event.ctrlKey) {&#13;
            Object.getPrototypeOf(ConnectionKeyboardController.prototype).escape.call(this);&#13;
        } else {&#13;
            Object.getPrototypeOf(ConnectionKeyboardController.prototype).enter.call(this);&#13;
            readActivatedElementConnections();&#13;
        }&#13;
    };&#13;
&#13;
    ConnectionKeyboardController.prototype.select = function (event) {&#13;
        event.preventDefault();&#13;
        if (presenter.getCurrentActivatedElement().hasClass(presenter.CSS_CLASSES.SELECTED)) {&#13;
            speak([getTextVoiceObject(presenter.speechTexts.deselected)]);&#13;
        }&#13;
&#13;
        Object.getPrototypeOf(ConnectionKeyboardController.prototype).select.call(this);&#13;
&#13;
        if (presenter.getCurrentActivatedElement().hasClass(presenter.CSS_CLASSES.SELECTED)) {&#13;
            speak([getTextVoiceObject(presenter.speechTexts.selected)]);&#13;
        }&#13;
    };&#13;
&#13;
&#13;
    presenter.__internal__ = {&#13;
        Line: Line&#13;
    };&#13;
&#13;
    function drawSVGLine(svg, firstID, secondID, correctLine, model) {&#13;
        var leftSize = model["Left column"].length;&#13;
&#13;
        var isFirstIDInLeftColumn = false;&#13;
        var isFirstIDInRightColumn = false;&#13;
        var isSecondIDInLeftColumn = false;&#13;
        var isSecondIDInRightColumn = false;&#13;
&#13;
        for (var i = 0; i &lt; presenter.elements.length; i++) {&#13;
            if (presenter.elements[i].id == firstID) {&#13;
                if (i &lt; leftSize) {&#13;
                    isFirstIDInLeftColumn = true;&#13;
                } else {&#13;
                    isFirstIDInRightColumn = true;&#13;
                }&#13;
            }&#13;
            if (presenter.elements[i].id == secondID) {&#13;
                if (i &lt; leftSize) {&#13;
                    isSecondIDInLeftColumn = true;&#13;
                } else {&#13;
                    isSecondIDInRightColumn = true;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        if (&#13;
            (!isFirstIDInLeftColumn &amp;&amp; !isFirstIDInRightColumn)&#13;
            ||&#13;
            (!isSecondIDInLeftColumn &amp;&amp; !isSecondIDInRightColumn)) {&#13;
            return;&#13;
        }&#13;
        if (!isFirstIDInLeftColumn &amp;&amp; !isSecondIDInRightColumn&#13;
            &amp;&amp; isFirstIDInRightColumn &amp;&amp; isSecondIDInLeftColumn) {&#13;
            var tmp = secondID;&#13;
            secondID = firstID;&#13;
            firstID = tmp;&#13;
        }&#13;
&#13;
        drawSVGLineLeftToRight(svg, firstID, secondID, correctLine, model);&#13;
&#13;
    }&#13;
&#13;
    function drawSVGLineLeftToRight(svg, leftID, rightID, correctLine, model) {&#13;
        var leftSize = model["Left column"].length;&#13;
        var leftTotalSize = 0;&#13;
        var rightTotalSize = 0;&#13;
        var leftPos = 0;&#13;
        var rightPos = 0;&#13;
&#13;
        for (var i = 0; i &lt; presenter.elements.length; i++) {&#13;
&#13;
            if (presenter.elements[i].id == leftID) {&#13;
                leftPos = leftTotalSize + presenter.elements[i].element.closest('tr').outerHeight(true) / 2;&#13;
            } else if (presenter.elements[i].id == rightID) {&#13;
                rightPos = rightTotalSize + presenter.elements[i].element.closest('tr').outerHeight(true) / 2;&#13;
            }&#13;
&#13;
            if (i &lt; leftSize) {&#13;
                leftTotalSize += presenter.elements[i].element.closest('tr').outerHeight(true);&#13;
            } else {&#13;
                rightTotalSize += presenter.elements[i].element.closest('tr').outerHeight(true);&#13;
            }&#13;
        }&#13;
        var leftY = 100.0 * leftPos / leftTotalSize + "%";&#13;
        var rightY = 100.0 * rightPos / rightTotalSize + "%";&#13;
        var $line = correctLine&#13;
            ? $('&lt;line class="correctConnectionLine" x1="0" x2="100%" style="stroke: rgb(0, 0, 0); stroke-width: 1;" /&gt;')&#13;
            : $('&lt;line class="inCorrectConnectionLine" x1="0" x2="100%" style="stroke: rgb(0, 0, 0); stroke-width: 1;" stroke-dasharray="4" /&gt;');&#13;
        $line.attr('y1', leftY);&#13;
        $line.attr('y2', rightY);&#13;
        svg.append($line);&#13;
    }&#13;
&#13;
    presenter.setPrintableController = function (controller) {&#13;
        presenter.printableController = controller;&#13;
    };&#13;
&#13;
    presenter.setPrintableState = function(state) {&#13;
        if (state === null || ModelValidationUtils.isStringEmpty(state))&#13;
            return;&#13;
        presenter.printableState = JSON.parse(state);&#13;
    };&#13;
&#13;
    presenter.isPrintableAsync = function() {&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.setPrintableAsyncCallback = function(id, callback) {&#13;
        presenter.printableParserID = id;&#13;
        presenter.printableParserCallback = callback;&#13;
    };&#13;
&#13;
    function getCorrectAnswersObject(model) {&#13;
        var correctAnswers = [];&#13;
        var idx = 0;&#13;
        for (var i = 0; i &lt; model["Left column"].length; i++) {&#13;
            var element = presenter.elements[i];&#13;
            var id = element.id;&#13;
            var correctAnswersValues = element.connects.split(',');&#13;
            if (correctAnswersValues.length == 0) {&#13;
                correctAnswers[idx] = {&#13;
                    'id': id,&#13;
                    'answer': null&#13;
                };&#13;
                idx++;&#13;
            } else {&#13;
                correctAnswersValues.forEach(function (answer) {&#13;
                    correctAnswers[idx] = {&#13;
                        'id': id,&#13;
                        'answer': answer&#13;
                    };&#13;
                    idx++;&#13;
                });&#13;
            }&#13;
        }&#13;
        return correctAnswers;&#13;
    }&#13;
&#13;
    function isPrintableShowAnswersStateMode () {&#13;
        return presenter.printableStateMode === presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS;&#13;
    }&#13;
    function isPrintableShowUserAnswersStateMode () {&#13;
        return presenter.printableStateMode === presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS;&#13;
    }&#13;
    function isPrintableCheckAnswersStateMode () {&#13;
        return presenter.printableStateMode === presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS;&#13;
    }&#13;
&#13;
    function chosePrintableStateMode(showAnswers) {&#13;
        if (presenter.printableState) {&#13;
            if (showAnswers)&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS;&#13;
            else&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS;&#13;
        } else {&#13;
            if (showAnswers)&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS;&#13;
            else&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.EMPTY;&#13;
        }&#13;
    }&#13;
&#13;
    function isCorrectConnection (correctAnswers, connection) {&#13;
        for (var i = 0; i &lt; correctAnswers.length; i++) {&#13;
            var answer = correctAnswers[i];&#13;
            if (answer.id == connection[0] &amp;&amp; answer.answer == connection[1]) return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.getPrintableHTML = function (model, showAnswers) {&#13;
        chosePrintableStateMode(showAnswers);&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.model = model;&#13;
        const root = createPrintableBaseView(model);&#13;
        const $root = $(root);&#13;
&#13;
        presenter.configuration = presenter.validateModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(root, presenter.ERROR_MESSAGES, presenter.configuration.errorCode);&#13;
            return $root[0].outerHTML;&#13;
        }&#13;
&#13;
        presenter.chooseOrientation(model, false);&#13;
        const connectionContainer = createPrintableConnectionContainer();&#13;
        root.append(connectionContainer);&#13;
        presenter.setLengthOfSideObjects(root);&#13;
&#13;
        const $printableWrapper = wrapInPrintableLessonTemplate($root);&#13;
&#13;
        presenter.loadElements(root, model);&#13;
        this.removeNonVisibleInnerHTMLForRoot($root);&#13;
&#13;
        const correctAnswers = getCorrectAnswersObject(model);&#13;
        const connectionsInformation = getPrintableConnectionsInformation(correctAnswers);&#13;
        isPrintableCheckAnswersStateMode() &amp;&amp; this.addAnswersElements(root, model, correctAnswers);&#13;
&#13;
        $printableWrapper.css("visibility", "hidden");&#13;
        let height;&#13;
        $("body").append($printableWrapper);&#13;
        waitForLoad($root, function(){&#13;
            $printableWrapper.css("visibility", "");&#13;
&#13;
            root.classList.add(...presenter.printableClassNames);&#13;
            if (connectionsInformation.length &gt; 0) {&#13;
                const connectionsSVG = $root.find("svg");&#13;
                for (let connection, i = 0; i &lt; connectionsInformation.length; i++) {&#13;
                    connection = connectionsInformation[i];&#13;
                    drawSVGLine(connectionsSVG, connection.from, connection.to, connection.correct, model);&#13;
                }&#13;
            }&#13;
&#13;
            root.classList.remove(...presenter.printableClassNames);&#13;
            $printableWrapper.detach();&#13;
            height = getPrintableTableHeight($root);&#13;
            $root.css("height", height+"px");&#13;
            const parsedView = root.outerHTML;&#13;
            $root.remove();&#13;
            $printableWrapper.remove();&#13;
            presenter.printableParserCallback(parsedView);&#13;
        });&#13;
&#13;
        const $clone = $root.clone();&#13;
        $clone.attr("id", presenter.printableParserID);&#13;
        $clone.css("visibility", "");&#13;
        const result = $clone[0].outerHTML;&#13;
        $clone.remove();&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.setPrintableClassNames = function (classNames) {&#13;
        presenter.printableClassNames = classNames;&#13;
    }&#13;
&#13;
    function wrapInPrintableLessonTemplate($view) {&#13;
        const $lessonTemplate = $(presenter.printableController.getLessonTemplate());&#13;
        const $placeholder = $lessonTemplate.find("#printable_placeholder");&#13;
        const $placeholderParent = $placeholder.parent();&#13;
        $placeholderParent.append($view);&#13;
        $placeholder.remove();&#13;
        return $lessonTemplate;&#13;
    }&#13;
&#13;
    function createPrintableBaseView(model) {&#13;
        const view = document.createElement("div");&#13;
        view.id = model.ID;&#13;
        view.classList.add("printable_addon_Connection");&#13;
        view.style.maxWidth = model.Width + "px";&#13;
        return view;&#13;
    }&#13;
&#13;
    function createPrintableConnectionContainer() {&#13;
        const isCheckAnswers = isPrintableCheckAnswersStateMode();&#13;
&#13;
        const connectionContainer = document.createElement("table");&#13;
        connectionContainer.classList.add("connectionContainer");&#13;
&#13;
        const connectionContainerBody = document.createElement("tbody");&#13;
        connectionContainer.append(connectionContainerBody);&#13;
&#13;
        const tr = document.createElement("tr");&#13;
        connectionContainerBody.append(tr);&#13;
&#13;
        isCheckAnswers &amp;&amp; tr.append(createPrintableColumn("answersLeftColumn"));&#13;
        tr.append(createPrintableColumn(presenter.getFirstSideCSSClassName()));&#13;
        tr.append(createPrintableConnectionMiddleColumn());&#13;
        tr.append(createPrintableColumn(presenter.getSecondSideCSSClassName()));&#13;
        isCheckAnswers &amp;&amp; tr.append(createPrintableColumn("answersRightColumn"));&#13;
&#13;
        return connectionContainer;&#13;
    }&#13;
&#13;
    function createPrintableColumn(className) {&#13;
        const cellContent = createCellContent();&#13;
        return createVerticalViewBodyColumn(className, cellContent);&#13;
    }&#13;
&#13;
    function createPrintableConnectionMiddleColumn() {&#13;
        const column = document.createElement("td");&#13;
        column.classList.add(presenter.getMiddleSideCSSClassName());&#13;
&#13;
        const content = document.createElement("svg");&#13;
        content.classList.add(presenter.CSS_CLASSES.CONNECTIONS);&#13;
&#13;
        column.append(content);&#13;
        return column;&#13;
    }&#13;
&#13;
    function getPrintableConnectionsInformation(correctAnswers) {&#13;
        const information = [];&#13;
&#13;
        if (isPrintableShowAnswersStateMode()) {&#13;
            for (let i = 0; i &lt; correctAnswers.length; i++) {&#13;
                if (correctAnswers[i].answer) {&#13;
                    information.push({&#13;
                        from: correctAnswers[i].id,&#13;
                        to: correctAnswers[i].answer,&#13;
                        correct: true&#13;
                    });&#13;
                }&#13;
            }&#13;
            return information;&#13;
        }&#13;
&#13;
        if (isPrintableShowUserAnswersStateMode()) {&#13;
            for (let i = 0; i &lt; presenter.printableState.id.length; i++) {&#13;
                const pair = presenter.printableState.id[i].split(':');&#13;
                information.push({&#13;
                    from: pair[0],&#13;
                    to: pair[1],&#13;
                    correct: true&#13;
                });&#13;
            }&#13;
            return information;&#13;
        }&#13;
&#13;
        if (isPrintableCheckAnswersStateMode()) {&#13;
            for (let i = 0; i &lt; presenter.printableState.id.length; i++) {&#13;
                const pair = presenter.printableState.id[i].split(':');&#13;
                information.push({&#13;
                    from: pair[0],&#13;
                    to: pair[1],&#13;
                    correct: isCorrectConnection(correctAnswers, pair)&#13;
                });&#13;
            }&#13;
            return information;&#13;
        }&#13;
        return information;&#13;
    }&#13;
&#13;
    function waitForLoad($element, callback) {&#13;
        var $imgs = $element.find('img');&#13;
        var loadCounter = $imgs.length + 2;&#13;
        var continuedParsing = false;&#13;
        var isReady = false;&#13;
&#13;
        var loadCallback = function(){&#13;
            loadCounter -= 1;&#13;
            if (loadCounter &lt; 1 &amp;&amp; isReady &amp;&amp; !continuedParsing) {&#13;
                continuedParsing = true;&#13;
                if (timeout) clearTimeout(timeout);&#13;
                callback();&#13;
            }&#13;
        };&#13;
&#13;
        $imgs.each(function(){&#13;
            var $this = $(this);&#13;
            if (this.complete &amp;&amp; this.naturalHeight !== 0) {&#13;
                loadCallback();&#13;
            } else {&#13;
                $this.load(loadCallback);&#13;
            }&#13;
        });&#13;
&#13;
        $element.ready(function(){&#13;
            isReady = true;&#13;
            loadCallback();&#13;
        });&#13;
&#13;
        var timeout = setTimeout(function(){&#13;
            if (loadCounter &gt; 0 || isReady == false) {&#13;
                isReady = true;&#13;
                loadCounter = 0;&#13;
                loadCallback();&#13;
            }&#13;
        }, 15000);&#13;
&#13;
        var args = [];&#13;
        args.push("Typeset", MathJax.Hub, $element[0]);&#13;
        args.push(loadCallback);&#13;
        MathJax.Hub.Queue(args);&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
&#13;
function getPrintableTableHeight($table) {&#13;
        var $outerLessonWrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $outerLessonWrapper.css("position", "absolute");&#13;
        $outerLessonWrapper.css("visibility", "hidden");&#13;
        $outerLessonWrapper.addClass("printable_lesson");&#13;
&#13;
        var $outerPageWrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $outerPageWrapper.addClass("printable_page");&#13;
        $outerLessonWrapper.append($outerPageWrapper);&#13;
&#13;
        var $outerModuleWrapper = $("&lt;div&gt;&lt;/div&gt;");&#13;
        $outerModuleWrapper.addClass("printable_module");&#13;
        $outerModuleWrapper.addClass("printable_addon_Connection");&#13;
        $outerPageWrapper.append($outerModuleWrapper);&#13;
&#13;
		$outerModuleWrapper.append($table);&#13;
&#13;
		$("body").append($outerLessonWrapper);&#13;
		var height = $table[0].getBoundingClientRect().height;&#13;
		$outerLessonWrapper.remove();&#13;
		$table.remove();&#13;
		return height;&#13;
    }&#13;
&#13;
AddonConnection_create.__supported_player_options__ = {&#13;
    resetInterfaceVersion: 2&#13;
};&#13;
</presenter></addon>