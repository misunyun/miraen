<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="crossword" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property isLocalized="true" name="Crossword" nameLabel="crossword_property_crossword" type="text"/>
		<property name="Columns" nameLabel="crossword_property_columns" type="string"/>
		<property name="Rows" nameLabel="crossword_property_rows" type="string"/>
		<property name="Cell width" nameLabel="crossword_property_cell_width" type="string"/>
		<property name="Cell height" nameLabel="crossword_property_cell_height" type="string"/>
		<property name="Blank cells border color" nameLabel="crossword_property_blank_cells_border_color" type="string"/>
		<property name="Blank cells border style" nameLabel="crossword_property_blank_cells_border_style" type="{solid, dotted, dashed}"/>
		<property name="Blank cells border width" nameLabel="crossword_property_blank_cells_border_width" type="string"/>
		<property name="Letter cells border color" nameLabel="crossword_property_letter_cells_border_color" type="string"/>
		<property name="Letter cells border style" nameLabel="crossword_property_letter_cells_border_style" type="{solid, dotted, dashed}"/>
		<property name="Letter cells border width" nameLabel="crossword_property_letter_cells_border_width" type="string"/>
		<property name="Word numbers" nameLabel="crossword_property_word_numbers" type="{both, horizontal, vertical, none}"/>
		<property name="Marked column index" nameLabel="crossword_property_marked_column_index" type="string"/>
		<property name="Marked row index" nameLabel="crossword_property_marked_row_index" type="string"/>
        <property displayName="Block wrong answers" name="blockWrongAnswers" nameLabel="crossword_property_block_wrong_answers" type="boolean"/>
		<property displayName="Show all answers in gradual show answers mode" name="showAllAnswersInGradualShowAnswersMode" nameLabel="crossword_property_show_all_answers_in_gradual_show_answers_mode" type="boolean"/>
        <property displayName="Auto navigation" name="autoNavigation" nameLabel="crossword_property_auto_navigation" type="{Extended, Simple, Off}"/>
        <property displayName="Lang attribute" name="langAttribute" nameLabel="crossword_property_lang_attribute" type="string"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="crossword_property_speech_texts" type="staticlist">
			<property name="Cell" nameLabel="crossword_speech_text_cell" type="staticrow">
                <property name="Cell" nameLabel="crossword_speech_text_cell" type="string"/>
            </property>
            <property name="Across" nameLabel="crossword_speech_text_across" type="staticrow">
                <property name="Across" nameLabel="crossword_speech_text_across" type="string"/>
            </property>
            <property name="Down" nameLabel="crossword_speech_text_down" type="staticrow">
                <property name="Down" nameLabel="crossword_speech_text_down" type="string"/>
            </property>
            <property name="Correct" nameLabel="crossword_speech_text_correct" type="staticrow">
                <property name="Correct" nameLabel="crossword_speech_text_correct" type="string"/>
            </property>
            <property name="Wrong" nameLabel="crossword_speech_text_wrong" type="staticrow">
                <property name="Wrong" nameLabel="crossword_speech_text_wrong" type="string"/>
            </property>
			<property name="Empty" nameLabel="crossword_speech_text_empty" type="staticrow">
                <property name="Empty" nameLabel="crossword_speech_text_empty" type="string"/>
            </property>
            <property name="Disabled" nameLabel="crossword_speech_text_disabled" type="staticrow">
                <property name="Disabled" nameLabel="crossword_speech_text_disabled" type="string"/>
            </property>
			<property name="OutOf" nameLabel="crossword_speech_text_out_of" type="staticrow">
                <property name="OutOf" nameLabel="crossword_speech_text_out_of" type="string"/>
            </property>
		</property>
        <property name="printable" nameLabel="printable_name_label" type="{No, Don't randomize, Randomize}"/>
        <property name="isSplitInPrintBlocked" nameLabel="printable_block_split_label" type="boolean"/>
	</model>
<css>.crossword_container {&#13;
    position: absolute;&#13;
    top: 50%;&#13;
    left: 50%;&#13;
}&#13;
&#13;
.crossword_container .cell_container {&#13;
    float: left;&#13;
    position: relative;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_cell_container {&#13;
    float: left;&#13;
    position: relative;&#13;
}&#13;
&#13;
.crossword_container .cell {&#13;
    position: absolute;&#13;
    top: 0px;&#13;
    left: 0px;&#13;
    right: 0px;&#13;
    bottom: 0px;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_cell {&#13;
    position: absolute;&#13;
    top: 0px;&#13;
    left: 0px;&#13;
    right: 0px;&#13;
    bottom: 0px;&#13;
    display: flex;&#13;
    place-content: center;&#13;
}&#13;
&#13;
.crossword_container .cell_letter {&#13;
    background: white;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_cell_letter {&#13;
    background: white;&#13;
}&#13;
&#13;
.crossword_container .cell_valid {&#13;
    background: #00ff00;&#13;
}&#13;
&#13;
.crossword_container .cell_invalid {&#13;
    background: #aa0000;&#13;
}&#13;
&#13;
.crossword_container .cell_invalid input {&#13;
    color: #fff;&#13;
}&#13;
&#13;
.crossword_container .cell_container_blank {&#13;
    background: black;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_cell_container_blank {&#13;
    background: black;&#13;
}&#13;
&#13;
.crossword_container .cell_letter input {&#13;
    position: absolute;&#13;
    top: 0;&#13;
    left: 0;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    text-align: center;&#13;
    background: transparent;&#13;
    border: none;&#13;
    -webkit-appearance: none;&#13;
    text-transform: uppercase;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_cell_letter_content {&#13;
    text-align: center;&#13;
    background: transparent;&#13;
    border: none;&#13;
    -webkit-appearance: none;&#13;
    text-transform: uppercase;&#13;
    margin-top: auto;&#13;
    margin-bottom: auto;&#13;
    font-size: large;&#13;
}&#13;
&#13;
.crossword_container .cell .word_number {&#13;
    position: absolute;&#13;
    top: 2px;&#13;
    left: 2px;&#13;
    font-size: 6pt;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_cell .printable_word_number {&#13;
    position: absolute;&#13;
    top: 2px;&#13;
    left: 2px;&#13;
    font-size: 6pt;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_sign_valid {&#13;
    margin-top: auto;&#13;
    margin-bottom: auto;&#13;
    margin-left: 2px;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_sign_invalid {&#13;
    margin-top: auto;&#13;
    margin-bottom: auto;&#13;
    margin-left: 2px;&#13;
}&#13;
&#13;
.printable_crossword_container .printable_sign_valid::after {&#13;
    content: " \2714";&#13;
}&#13;
&#13;
.printable_crossword_container .printable_sign_invalid::after {&#13;
    content: " \2716";&#13;
}&#13;
</css><view/><preview/><presenter>function Addoncrossword_create(){&#13;
    var presenter = function() {};&#13;
&#13;
    var playerController;&#13;
    var eventBus;&#13;
    var originalFieldValue = "";&#13;
&#13;
    presenter.ID               = null;&#13;
    presenter.$view            = null;&#13;
    presenter.crossword        = null;&#13;
&#13;
    presenter.rowCount         = null;&#13;
    presenter.columnCount      = null;&#13;
    presenter.cellHeight       = null;&#13;
    presenter.cellWidth        = null;&#13;
    presenter.maxScore         = null;&#13;
    presenter.isVisible        = true;&#13;
    presenter.showAllAnswersInGradualShowAnswersMode;&#13;
    presenter.isGradualShowAnswersActive = false;&#13;
    presenter.blankCellsBorderStyle  = "solid";&#13;
    presenter.blankCellsBorderWidth  = 0;&#13;
    presenter.blankCellsBorderColor  = "transparent";&#13;
    presenter.letterCellsBorderStyle = "solid";&#13;
    presenter.letterCellsBorderWidth = 0;&#13;
    presenter.letterCellsBorderColor = "transparent";&#13;
    presenter.wordNumbersHorizontal = false;&#13;
    presenter.wordNumbersVertical = false;&#13;
    presenter.disableAutomaticWordNumbering = false;&#13;
    presenter.blockWrongAnswers = false;&#13;
    presenter.markedColumnIndex = 0;&#13;
    presenter.markedRowIndex = 0;&#13;
    presenter.maxTabIndex = 0;&#13;
    presenter.areUserAnswersSaved = false;&#13;
    presenter.correctAnswers = [];&#13;
&#13;
    presenter.printableController = null;&#13;
    presenter.printableState = null;&#13;
    presenter.printableStateMode = null;&#13;
    presenter.GSAcounter = null;&#13;
&#13;
    var enableMoveToNextField = false;&#13;
&#13;
    const DIRECTIONS = {&#13;
        NOT_SET: 0,&#13;
        HORIZONTAL: 1,&#13;
        VERTICAL: 2,&#13;
        TAB_INDEX: 3,&#13;
        NEXT_VERTICAL_ANSWER: 4&#13;
    }&#13;
    var currentDirection = DIRECTIONS.NOT_SET;&#13;
&#13;
    const AUTO_NAVIGATION_OPTIONS = {&#13;
        OFF: 0,&#13;
        SIMPLE: 1,&#13;
        EXTENDED: 2&#13;
    }&#13;
    var autoNavigationMode = null;&#13;
&#13;
    presenter.SPECIAL_KEYS = {&#13;
        BACKSPACE: 8,&#13;
        TAB: 9,&#13;
        ENTER: 13,&#13;
        SHIFT: 16,&#13;
        CTRL: 17,&#13;
        ESCAPE: 27,&#13;
        LEFT_ARROW: 37,&#13;
        UP_ARROW: 38,&#13;
        RIGHT_ARROW: 39,&#13;
        DOWN_ARROW: 40,&#13;
        DELETE: 46,&#13;
    };&#13;
&#13;
    presenter.numberOfConstantLetters = 0;&#13;
&#13;
    presenter.ERROR_MESSAGES = {&#13;
        ROWS_NOT_SPECIFIED:                          "Amount of rows is not specified",&#13;
        COLUMNS_NOT_SPECIFIED:                       "Amount of columns is not specified",&#13;
        INVALID_MARKED_COLUMN_INDEX:                 "Marked column index cannot be negative, use 0 to disable",&#13;
        INVALID_MARKED_ROW_INDEX:                    "Marked row index cannot be negative, use 0 to disable",&#13;
        CELL_WIDTH_NOT_SPECIFIED:                    "Cell width is not specified",&#13;
        CELL_HEIGHT_NOT_SPECIFIED:                   "Cell height is not specified",&#13;
        INVALID_BLANK_CELLS_BORDER_WIDTH:            "Blank cells border width must be greater on equal to 0",&#13;
        INVALID_LETTER_CELLS_BORDER_WIDTH:           "Letter cells border width must be greater on equal to 0",&#13;
        INVALID_AMOUNT_OF_ROWS_IN_CROSSWORD:         "Amount of lines (that act as rows) in the specified Crossword is different that amount of rows you have specified in Properties",&#13;
        INVALID_AMOUNT_OF_COLUMNS_IN_CROSSWORD:      "Amount of characters (that act as columns) in row %row% of specified Crossword is different that amount of columns you have specified in Properties",&#13;
        DOUBLED_EXCLAMATION_MARK:                    "You cannot type 2 exclamation marks in a row",&#13;
        LAST_CHARACTER_EXCLAMATION_MARK:             "You cannot type exclamation mark at the end of line",&#13;
        EXCLAMATION_MARK_BEFORE_EMPTY_FIELD:         "You cannot type exclamation mark before empty field",&#13;
        NOT_SUPPORTED_SELECTED_AUTO_NAVIGATION_MODE: "Selected auto navigation mode is not supported"&#13;
    };&#13;
&#13;
    presenter.VALIDATION_MODE = {&#13;
        COUNT_SCORE: 0,&#13;
        SHOW_ERRORS: 1,&#13;
        CHECK_ANSWERS: 2&#13;
    };&#13;
&#13;
    presenter.isModelValid = true;&#13;
&#13;
    presenter.isWCAGOn = false;&#13;
    presenter.keyboardControllerObject = null;&#13;
&#13;
    presenter.DEFAULT_TTS_PHRASES = {&#13;
        CELL: "cell",&#13;
        ACROSS: "across",&#13;
        DOWN: "down",&#13;
        CORRECT: "correct",&#13;
        WRONG: "wrong",&#13;
        EMPTY: "empty",&#13;
        DISABLED: "disabled",&#13;
        OUT_OFF: "out of",&#13;
    };&#13;
&#13;
    presenter.CSS_CLASSES = {&#13;
        CELL: 'cell',&#13;
        CELL_BLANK: 'cell_blank',&#13;
        CELL_LETTER: "cell_letter",&#13;
        CELL_VALID: "cell_valid",&#13;
        CELL_INVALID: "cell_invalid",&#13;
        PRINTABLE: "printable",&#13;
        PRINTABLE_ADDON: "printable_addon_crossword",&#13;
        PRINTABLE_CELL_LETTER_CONTENT: "printable_cell_letter_content",&#13;
        PRINTABLE_SIGN_VALID: "printable_sign_valid",&#13;
        PRINTABLE_SIGN_INVALID: "printable_sign_invalid",&#13;
        PRINTABLE_CELL_VALID: "printable_cell_valid",&#13;
        PRINTABLE_CELL_INVALID: "printable_cell_invalid",&#13;
    };&#13;
&#13;
    presenter.PRINTABLE_STATE_MODE = {&#13;
        EMPTY: 0,&#13;
        SHOW_ANSWERS: 1,&#13;
        SHOW_USER_ANSWERS: 2,&#13;
        CHECK_ANSWERS: 3&#13;
    };&#13;
&#13;
    presenter.showErrorMessage = function(message, substitutions) {&#13;
        var errorContainer;&#13;
        if(typeof(substitutions) == 'undefined') {&#13;
            errorContainer = '&lt;p&gt;' + message + '&lt;/p&gt;';&#13;
        } else {&#13;
            var messageSubst = message;&#13;
            for (var key in substitutions) {&#13;
                messageSubst = messageSubst.replace('%' + key + '%', substitutions[key]);&#13;
            }&#13;
            errorContainer = '&lt;p&gt;' + messageSubst + '&lt;/p&gt;';&#13;
        }&#13;
&#13;
        presenter.$view.html(errorContainer);&#13;
    };&#13;
&#13;
    presenter.prepareGrid = function(model) {&#13;
        const elementPath = "div." + (isInPrintableStateMode() ? presenter.CSS_CLASSES.PRINTABLE + "_" : "") + "crossword_container";&#13;
        presenter.tabIndexBase = ($(elementPath).length * 5000) + 5000;&#13;
        presenter.maxScore = 0;&#13;
        presenter.crossword = [];&#13;
&#13;
        var rows = model['Crossword'].split("\n");&#13;
        for(var i = 0; i &lt; presenter.rowCount; i++) {&#13;
            var r = [];&#13;
            var numberOfExclamationMarks = rows[i].match(/!/g) == null ? 0 : rows[i].match(/!/g).length;&#13;
            presenter.numberOfConstantLetters += numberOfExclamationMarks;&#13;
            for(var j = 0; j &lt; presenter.columnCount + numberOfExclamationMarks; j++) {&#13;
                if (rows[i][j] === '!') {&#13;
                    j++;&#13;
                    r.push('!' + rows[i][j].toUpperCase());&#13;
                } else {&#13;
                    r.push(rows[i][j].toUpperCase());&#13;
                }&#13;
            }&#13;
&#13;
            presenter.crossword.push(r);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isAnswerVisibleByDefault = function (answer) {&#13;
        return (answer.match(/!/g) || []).length * 2 === answer.length;&#13;
    }&#13;
&#13;
    presenter.prepareAnswerHorizontal = function (row, column) {&#13;
        const position = { x: column, y: row };&#13;
        let answer = "";&#13;
        for(let i = column; i &lt; presenter.columnCount; i++){&#13;
            if (presenter.crossword[row][i] == ' ') {&#13;
                break;&#13;
            }&#13;
            answer = answer + presenter.crossword[row][i];&#13;
        }&#13;
        let answerData = {&#13;
            answer,&#13;
            position,&#13;
            isHorizontal: true&#13;
        };&#13;
        if (!presenter.isAnswerVisibleByDefault(answer))&#13;
            presenter.correctAnswers.push(answerData);&#13;
    }&#13;
&#13;
    presenter.prepareAnswerVertical = function (row, column) {&#13;
        const position = { x: column, y: row };&#13;
        let answer = "";&#13;
        for (let i = row; i &lt; presenter.rowCount; i++){&#13;
            if (presenter.crossword[i][column] == ' '){&#13;
                break;&#13;
            }&#13;
            answer = answer + presenter.crossword[i][column];&#13;
        }&#13;
        let answerData = {&#13;
            answer,&#13;
            position,&#13;
            isHorizontal: false&#13;
        };&#13;
        if (!presenter.isAnswerVisibleByDefault(answer))&#13;
            presenter.correctAnswers.push(answerData);&#13;
    }&#13;
&#13;
    presenter.prepareCorrectAnswers = function() {&#13;
        presenter.correctAnswers = [];&#13;
&#13;
        for (let row = 0; row &lt; presenter.rowCount; row++) {&#13;
            for (let column = 0; column &lt; presenter.columnCount; column++){&#13;
                if(presenter.isHorizontalWordBegin(row, column)){&#13;
                    presenter.prepareAnswerHorizontal(row, column);&#13;
                }&#13;
                if(presenter.isVerticalWordBegin(row, column)){&#13;
                    presenter.prepareAnswerVertical(row, column);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.isHorizontalWordBegin = function(i, j) {&#13;
        if(!presenter.wordNumbersHorizontal) {&#13;
            return false;&#13;
        }&#13;
&#13;
        return (&#13;
            // Skip empty cells&#13;
            presenter.crossword[i][j] != ' ' &amp;&amp;&#13;
&#13;
                // We don't have a letter on the left&#13;
                (j === 0 ||  presenter.crossword[i][j-1] == ' ') &amp;&amp;&#13;
&#13;
                // We do have a letter on the right&#13;
                (presenter.columnCount &gt; j+1 &amp;&amp; presenter.crossword[i][j+1] != ' '));&#13;
    };&#13;
&#13;
    presenter.isVerticalWordBegin = function(i, j) {&#13;
        if(!presenter.wordNumbersVertical) {&#13;
            return false;&#13;
        }&#13;
&#13;
        return (&#13;
            // Skip empty cells&#13;
            presenter.crossword[i][j] != ' ' &amp;&amp;&#13;
&#13;
                // We don't have a letter above&#13;
                (i === 0 ||  presenter.crossword[i-1][j] == ' ') &amp;&amp;&#13;
&#13;
                // We do have a letter below&#13;
                (presenter.rowCount &gt; i+1 &amp;&amp; presenter.crossword[i+1][j] != ' '));&#13;
    };&#13;
&#13;
    function getPositionOfCellInputElement($cellInput) {&#13;
        return presenter.getPosition($cellInput.parent(''));&#13;
    }&#13;
&#13;
    presenter.getPosition = function($elem) {&#13;
        function getPositionFrom(classes, dim) {&#13;
            return classes.reduce(function(res, currentElem) {&#13;
                return res === null ? currentElem.match(new RegExp(dim + "(\\d+)")) : res;&#13;
            }, null)[1];&#13;
        }&#13;
&#13;
        var classes = $elem.attr('class').split(' ');&#13;
&#13;
        return {&#13;
            x: parseInt(getPositionFrom(classes, 'cell_column_'), 10),&#13;
            y: parseInt(getPositionFrom(classes, 'cell_row_'), 10)&#13;
        }&#13;
    };&#13;
&#13;
    var dictValues = function(dict) {&#13;
        var values = [];&#13;
        var keys = Object.keys(dict);&#13;
        keys.filter(function(key){&#13;
            values.push(dict[key])&#13;
        });&#13;
        return values;&#13;
    };&#13;
&#13;
    presenter.SPECIAL_KEYS_CODES = dictValues(presenter.SPECIAL_KEYS);&#13;
&#13;
    var validateSpecialKey = function(event) {&#13;
        if (presenter.SPECIAL_KEYS_CODES.indexOf(event.keyCode) &gt; -1 ||&#13;
            // Allow: dot&#13;
            (event.keyCode == 190) ||&#13;
            // Allow: Ctrl+A&#13;
            (event.keyCode == 65 &amp;&amp; event.ctrlKey === true) ||&#13;
            // Allow: end and home&#13;
            (event.keyCode &gt;= 35 &amp;&amp; event.keyCode &lt;= 36)) {&#13;
            // let it happen, don't do anything&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.onCellInputKeyDown = function(event) {&#13;
        if (event.keyCode === presenter.SPECIAL_KEYS.ENTER) {&#13;
            return;&#13;
        }&#13;
&#13;
        if ([&#13;
            presenter.SPECIAL_KEYS.BACKSPACE,&#13;
            presenter.SPECIAL_KEYS.LEFT_ARROW,&#13;
            presenter.SPECIAL_KEYS.RIGHT_ARROW,&#13;
            presenter.SPECIAL_KEYS.UP_ARROW,&#13;
            presenter.SPECIAL_KEYS.DOWN_ARROW,&#13;
            presenter.SPECIAL_KEYS.TAB,&#13;
        ].includes(event.keyCode)) {&#13;
            presenter.keyboardController(event.keyCode, event.shiftKey, event);&#13;
            return;&#13;
        }&#13;
&#13;
        var $cellInput = $(event.target);&#13;
        if (originalFieldValue.length == 0) {&#13;
            originalFieldValue = $cellInput.val();&#13;
        }&#13;
&#13;
        if (validateSpecialKey(event)) {&#13;
            return&#13;
        }&#13;
&#13;
        $cellInput.css('color', 'rgba(0,0,0,0.0)');&#13;
        enableMoveToNextField = true;&#13;
    };&#13;
&#13;
    presenter.onCellInputKeyUp = function(event) {&#13;
        var cellInput = event.target;&#13;
        var $cellInput = $(cellInput);&#13;
        $cellInput.css('color','');&#13;
&#13;
        if (validateSpecialKey(event)) {&#13;
            return&#13;
        }&#13;
&#13;
        if ($cellInput.val().length &gt; 1 &amp;&amp; originalFieldValue.length &gt; 0) {&#13;
            $cellInput.val($cellInput.val().replace(originalFieldValue,''));&#13;
        }&#13;
        originalFieldValue = '';&#13;
&#13;
        cellInput.value = cellInput.value.toUpperCase();&#13;
&#13;
        if (presenter.blockWrongAnswers) {&#13;
            var isCorrectValue&#13;
                = presenter.validateIsCorrectValueInCellInput(cellInput);&#13;
            if (!isCorrectValue) {&#13;
                presenter.keyboardControllerObject.speakWrong();&#13;
                enableMoveToNextField = false;&#13;
            }&#13;
        }&#13;
&#13;
        if ($cellInput.val() &amp;&amp; enableMoveToNextField) {&#13;
            handleAutoNavigationMove(cellInput);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onCellInputFocus = function(event) {&#13;
        event.target.select();&#13;
        var length = $(event.target).val().length;&#13;
        setCaretPosition(event.target, length + 1);&#13;
        if(length &gt; 1) {&#13;
            $(event.target).val($(event.target).val().substring(1, 2));&#13;
        }&#13;
        $(event.target).val($(event.target).val().toUpperCase());&#13;
    };&#13;
 &#13;
    presenter.onCellInputMouseUp = function(event) {&#13;
        event.preventDefault();&#13;
    };&#13;
&#13;
    presenter.onCellInputFocusOut = function(event) {&#13;
        var cellInput = event.target;&#13;
        var usersLetter = cellInput.value;&#13;
        var pos = getPositionOfCellInputElement($(cellInput));&#13;
        var correctLetter = presenter.crossword[pos.y][pos.x][0];&#13;
        var isOk = usersLetter === correctLetter;&#13;
        presenter.sendScoreEvent(pos, usersLetter, isOk);&#13;
        var score = isOk ? 1 : 0;&#13;
        if(score == 0 &amp;&amp; presenter.blockWrongAnswers){&#13;
            cellInput.value = "";&#13;
        }&#13;
        if (isOk) {&#13;
            const result = presenter.validateWord(pos);&#13;
            const isLetterInVerticalWord = result.verticalResult ?&#13;
                presenter.letterIsInWord(result.verticalResult.start, result.verticalResult.end, pos) : false;&#13;
            const isLetterInHorizontalWord = result.horizontalResult ?&#13;
                presenter.letterIsInWord(result.horizontalResult.start, result.horizontalResult.end, pos) : false;&#13;
&#13;
            if (result.horizontalResult &amp;&amp; isLetterInHorizontalWord) {&#13;
                presenter.sendCorrectWordEvent(result.horizontalResult.word, result.horizontalResult.item);&#13;
            }&#13;
            if (result.verticalResult &amp;&amp; isLetterInVerticalWord) {&#13;
                presenter.sendCorrectWordEvent(result.verticalResult.word, result.verticalResult.item);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.letterIsInWord = function (startPoint, endPoints, letterPosition) {&#13;
        const startCoordinates = startPoint.split(':');&#13;
        const endCoordinates = endPoints.split(':');&#13;
        const isInXAxis = +startCoordinates[0] &lt;= letterPosition.x &amp;&amp; +endCoordinates[0] &gt;= letterPosition.x;&#13;
        const isInYAxis = +startCoordinates[1] &lt;= letterPosition.y &amp;&amp; +endCoordinates[1] &gt;= letterPosition.y;&#13;
&#13;
        return isInXAxis &amp;&amp; isInYAxis;&#13;
    };&#13;
&#13;
    presenter.onCellClick = function(event) {&#13;
        presenter.resetDirection();&#13;
        event.stopPropagation();&#13;
    };&#13;
&#13;
    function handleAutoNavigationMove(currentCellInput) {&#13;
        enableMoveToNextField = false;&#13;
&#13;
        if (!presenter.isAutoNavigationInOffMode()) {&#13;
            presenter.analyzeDirectionOfMove(currentCellInput);&#13;
            presenter.updateDirectionOfMoveRelativeToAutoNavigationMode();&#13;
            presenter.moveInCurrentDirection(currentCellInput);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.validateIsCorrectValueInCellInput = function (currentCellInput) {&#13;
        var $currentCellInput = $(currentCellInput);&#13;
        var usersLetter = currentCellInput.value[0];&#13;
        var currentPosition = getPositionOfCellInputElement($currentCellInput);&#13;
&#13;
        var correctLetter = presenter.crossword[currentPosition.y][currentPosition.x][0];&#13;
        if (usersLetter !== correctLetter) {&#13;
            presenter.sendScoreEvent(currentPosition, usersLetter, false);&#13;
            currentCellInput.value = '';&#13;
            return false;&#13;
        }&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.isWordNumbersCorrect = function () {&#13;
        return presenter.wordNumbersHorizontal || presenter.wordNumbersVertical;&#13;
    }&#13;
&#13;
    presenter.isWordOrientationOnlyHorizontal = function () {&#13;
        return presenter.wordNumbersHorizontal &amp;&amp; !presenter.wordNumbersVertical;&#13;
    }&#13;
&#13;
    presenter.isWordOrientationOnlyVertical = function () {&#13;
        return presenter.wordNumbersVertical &amp;&amp; !presenter.wordNumbersHorizontal;&#13;
    }&#13;
&#13;
    presenter.getWordBeginCellAtColumn = function (i) {&#13;
        return presenter.$view.find(`.cell_word_begin_vertical.cell_column_${i}`);&#13;
    }&#13;
&#13;
    presenter.findNextColumn = function (currentPosition) {&#13;
        const nextColumnIndex = currentPosition.x + 1;&#13;
&#13;
        for (let i = nextColumnIndex; i &lt;= presenter.columnCount; i++) {&#13;
            const $nextColumnWordBeginCell = presenter.getWordBeginCellAtColumn(i);&#13;
&#13;
            if ($nextColumnWordBeginCell.length) {&#13;
                const position = presenter.getPosition($nextColumnWordBeginCell);&#13;
                if (isAnyOfBottomCellsEditable(position)) {&#13;
                    position.y =- 1;&#13;
                    return getNextBottomCellPosition(position);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.updateDirectionBasedOnWordOrientation = function () {&#13;
        if (presenter.isWordOrientationOnlyHorizontal()) {&#13;
            presenter.setHorizontalDirection();&#13;
        } else if (presenter.isWordOrientationOnlyVertical()) {&#13;
            presenter.setVerticalDirection();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.analyzeDirectionOfMove = function (currentCellInput) {&#13;
        var $currentCellInput = $(currentCellInput);&#13;
        var currentPosition = getPositionOfCellInputElement($currentCellInput);&#13;
&#13;
        var rightElementPosition = calculateRightElementPosition(currentPosition);&#13;
        var isRightCellNotBlank = isPositionOfNotBlankCell(rightElementPosition);&#13;
        var rightCellsEditable = isAnyOfRightCellsEditable(currentPosition);&#13;
&#13;
        var bottomElementPosition = calculateBottomElementPosition(currentPosition);&#13;
        var isBottomCellNotBlank = isPositionOfNotBlankCell(bottomElementPosition);&#13;
        var bottomCellsEditable = isAnyOfBottomCellsEditable(currentPosition);&#13;
&#13;
        var topElementPosition = calculateTopElementPosition(currentPosition);&#13;
        var isTopCellNotBlank = isPositionOfNotBlankCell(topElementPosition);&#13;
&#13;
        presenter.updateDirectionBasedOnWordOrientation();&#13;
&#13;
        if (presenter.isHorizontalDirection()) {&#13;
            if (!rightCellsEditable) {&#13;
                presenter.setTabIndexDirection();&#13;
            }&#13;
            return;&#13;
        }&#13;
        if (presenter.isVerticalDirection()) {&#13;
            if (!bottomCellsEditable) {&#13;
                if (presenter.isWordOrientationOnlyVertical()) {&#13;
                    presenter.setNextVerticalAnswerDirection();&#13;
                } else {&#13;
                    presenter.setTabIndexDirection();&#13;
                }&#13;
            }&#13;
            return;&#13;
        }&#13;
&#13;
        var rightCellInput = getCellInput(rightElementPosition);&#13;
        var bottomCellInput = getCellInput(bottomElementPosition);&#13;
&#13;
        if (bottomCellsEditable &amp;&amp; !isRightCellNotBlank) {&#13;
            presenter.setVerticalDirection();&#13;
        } else if (rightCellsEditable &amp;&amp; !isTopCellNotBlank &amp;&amp; !isBottomCellNotBlank) {&#13;
            presenter.setHorizontalDirection();&#13;
        } else if (bottomCellsEditable &amp;&amp; !isTopCellNotBlank &amp;&amp; isRightCellNotBlank) {&#13;
            presenter.setVerticalDirection();&#13;
        } else if (bottomCellsEditable&#13;
            &amp;&amp; (isRightCellNotBlank &amp;&amp; !isCellInputElementEmpty(rightCellInput))&#13;
            &amp;&amp; (isBottomCellNotBlank &amp;&amp; isCellInputElementEmpty(bottomCellInput))) {&#13;
            presenter.setVerticalDirection();&#13;
        } else if (rightCellsEditable) {&#13;
            presenter.setHorizontalDirection();&#13;
        } else {&#13;
            presenter.setTabIndexDirection();&#13;
        }&#13;
    };&#13;
&#13;
    function isAnyOfRightCellsEditable(position) {&#13;
        return !!getNextRightCellPosition(position);&#13;
    }&#13;
&#13;
    function getNextRightCellPositionOfCellInput(cellInput, includeConstantCells = false) {&#13;
        const position = getPositionOfCellInputElement($(cellInput));&#13;
        return getNextRightCellPosition(position, includeConstantCells);&#13;
    }&#13;
&#13;
    function getNextRightCellPosition(position, includeConstantCells = false) {&#13;
        const nextYPosition = position.y;&#13;
        var nextPosition;&#13;
        for (var nextXPosition = position.x + 1; nextXPosition &lt; presenter.columnCount; nextXPosition++) {&#13;
            nextPosition = {y: nextYPosition, x: nextXPosition};&#13;
            var isNextCellNotBlank = isPositionOfNotBlankCell(nextPosition);&#13;
            if (isNextCellNotBlank) {&#13;
                if (includeConstantCells || !isPositionOfConstantCell(nextPosition)) {&#13;
                    return nextPosition;&#13;
                }&#13;
            } else {&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function isAnyOfLeftCellsEditable(position) {&#13;
        return !!getNextLeftCellPosition(position);&#13;
    }&#13;
&#13;
    function getNextLeftCellPositionOfCellInput(cellInput, includeConstantCells = false) {&#13;
        const position = getPositionOfCellInputElement($(cellInput));&#13;
        return getNextLeftCellPosition(position, includeConstantCells);&#13;
    }&#13;
&#13;
    function getNextLeftCellPosition(position, includeConstantCells = false) {&#13;
        const nextYPosition = position.y;&#13;
        var nextPosition;&#13;
        for (var nextXPosition = position.x - 1; nextXPosition &gt;= 0; nextXPosition--) {&#13;
            nextPosition = {y: nextYPosition, x: nextXPosition};&#13;
            var isNextCellNotBlank = isPositionOfNotBlankCell(nextPosition);&#13;
            if (isNextCellNotBlank) {&#13;
                if (includeConstantCells || !isPositionOfConstantCell(nextPosition)) {&#13;
                    return nextPosition;&#13;
                }&#13;
            } else {&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function isAnyOfBottomCellsEditable(position) {&#13;
        return !!getNextBottomCellPosition(position);&#13;
    }&#13;
&#13;
    function getNextBottomCellPositionOfCellInput(cellInput, includeConstantCells = false) {&#13;
        const position = getPositionOfCellInputElement($(cellInput));&#13;
        return getNextBottomCellPosition(position, includeConstantCells);&#13;
    }&#13;
&#13;
    function getNextBottomCellPosition(position, includeConstantCells = false) {&#13;
        const nextXPosition = position.x;&#13;
        var nextPosition;&#13;
        for (var nextYPosition = position.y + 1; nextYPosition &lt; presenter.rowCount; nextYPosition++) {&#13;
            nextPosition = {y: nextYPosition, x: nextXPosition};&#13;
            var isNextCellNotBlank = isPositionOfNotBlankCell(nextPosition);&#13;
            if (isNextCellNotBlank) {&#13;
                if (includeConstantCells || !isPositionOfConstantCell(nextPosition)) {&#13;
                    return nextPosition;&#13;
                }&#13;
            } else {&#13;
                if (!presenter.isNextVerticalAnswerDirection())&#13;
                    return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function isAnyOfTopCellsEditable(position) {&#13;
        return !!getNextTopCellPosition(position);&#13;
    }&#13;
&#13;
    function getNextTopCellPositionOfCellInput(cellInput, includeConstantCells = false) {&#13;
        const position = getPositionOfCellInputElement($(cellInput));&#13;
        return getNextTopCellPosition(position, includeConstantCells);&#13;
    }&#13;
&#13;
    function getNextTopCellPosition(position, includeConstantCells = false) {&#13;
        const nextXPosition = position.x;&#13;
        var nextPosition;&#13;
        for (var nextYPosition = position.y - 1; nextYPosition &gt;= 0; nextYPosition--) {&#13;
            nextPosition = {y: nextYPosition, x: nextXPosition};&#13;
            var isNextCellNotBlank = isPositionOfNotBlankCell(nextPosition);&#13;
            if (isNextCellNotBlank) {&#13;
                if (includeConstantCells || !isPositionOfConstantCell(nextPosition)) {&#13;
                    return nextPosition;&#13;
                }&#13;
            } else {&#13;
                return;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getNextTabIndexEditableCellPositionOfCellInput(cellInput) {&#13;
        const newTabIndex = cellInput.tabIndex + 1;&#13;
        return getPositionOfCellInputElementWithTabIndex(newTabIndex);&#13;
    }&#13;
&#13;
    function getPreviousTabIndexEditableCellPositionOfCellInput(cellInput) {&#13;
        const newTabIndex = cellInput.tabIndex - 1;&#13;
        return getPositionOfCellInputElementWithTabIndex(newTabIndex);&#13;
    }&#13;
&#13;
    function getPositionOfCellInputElementWithTabIndex(tabIndex) {&#13;
        if (tabIndex &lt; presenter.tabIndexBase || tabIndex &gt;= presenter.maxTabIndex) {&#13;
            return;&#13;
        }&#13;
&#13;
        var newCellInputElement = findCellInputElement(tabIndex);&#13;
        var newPosition = getPositionOfCellInputElement($(newCellInputElement));&#13;
        if (!isPositionValid(newPosition)) {&#13;
            return;&#13;
        }&#13;
&#13;
        return newPosition;&#13;
    }&#13;
&#13;
    function findCellInputElement(tabIndex) {&#13;
        return presenter.$view.find('[tabindex=' + tabIndex + ']');&#13;
    }&#13;
&#13;
    presenter.updateDirectionOfMoveRelativeToAutoNavigationMode = function () {&#13;
        if (!presenter.isDirectionNotSet()&#13;
            &amp;&amp; (presenter.isAutoNavigationInOffMode()&#13;
                || (presenter.isAutoNavigationInSimpleMode()&#13;
                    &amp;&amp; (presenter.isTabIndexDirection()&#13;
                        || presenter.isNextVerticalAnswerDirection())))) {&#13;
            presenter.resetDirection();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.moveInCurrentDirection = function (currentCellInput) {&#13;
        if (presenter.isHorizontalDirection()) {&#13;
            moveInHorizontalDirection(currentCellInput);&#13;
        } else if (presenter.isVerticalDirection()) {&#13;
            moveInVerticalDirection(currentCellInput);&#13;
        } else if (presenter.isTabIndexDirection()) {&#13;
            moveInTabIndexDirection(currentCellInput);&#13;
        }  else if (presenter.isNextVerticalAnswerDirection()) {&#13;
            moveToNextVerticalAnswer(currentCellInput);&#13;
        }&#13;
    };&#13;
&#13;
    function moveInVerticalDirection(startingCellInput) {&#13;
        const customEvent = createKeyboardNavigationEventForMove(startingCellInput);&#13;
        moveToNextBottomCellInput(customEvent);&#13;
    }&#13;
&#13;
    function moveInHorizontalDirection(startingCellInput) {&#13;
        const customEvent = createKeyboardNavigationEventForMove(startingCellInput);&#13;
        moveToNextRightCellInput(customEvent);&#13;
    }&#13;
&#13;
    function moveInTabIndexDirection(startingCellInput) {&#13;
        const customEvent = createKeyboardNavigationEventForMove(startingCellInput);&#13;
        moveToNextEditableTabIndexCellInput(customEvent);&#13;
    }&#13;
&#13;
    function createKeyboardNavigationEventForMove(cellInput) {&#13;
        return {&#13;
            target: cellInput,&#13;
            preventDefault: function () {},&#13;
            stopPropagation: function () {},&#13;
        };&#13;
    }&#13;
&#13;
    function focusCellInputUsingPosition(nextPosition) {&#13;
        $(getCellInput(nextPosition)).focus();&#13;
    }&#13;
&#13;
    function moveToNextVerticalAnswer(currentCellInput) {&#13;
        const currentPosition = getPositionOfCellInputElement($(currentCellInput));&#13;
        const nextCellPosition = presenter.findNextColumn(currentPosition);&#13;
        if (!!nextCellPosition) {&#13;
            const nextCellInput = getCellInput(nextCellPosition);&#13;
            $(nextCellInput).focus();&#13;
        } else {&#13;
            blurCellInput(currentCellInput);&#13;
        }&#13;
    }&#13;
&#13;
    function blurCellInput(cellInput) {&#13;
        $(cellInput).blur();&#13;
    }&#13;
&#13;
    function calculateLeftElementPosition(oldPosition) {&#13;
        return {y: oldPosition.y, x: oldPosition.x - 1};&#13;
    }&#13;
&#13;
    function calculateRightElementPosition(oldPosition) {&#13;
        return {y: oldPosition.y, x: oldPosition.x + 1};&#13;
    }&#13;
&#13;
    function calculateTopElementPosition(oldPosition) {&#13;
        return {y: oldPosition.y - 1, x: oldPosition.x};&#13;
    }&#13;
&#13;
    function calculateBottomElementPosition(oldPosition) {&#13;
        return {y: oldPosition.y + 1, x: oldPosition.x};&#13;
    }&#13;
&#13;
    function isCellInputElementEmpty(element) {&#13;
        return !element.value;&#13;
    }&#13;
&#13;
    function isPositionOfConstantCell(position) {&#13;
        if (!isPositionValid(position)) {&#13;
            return false;&#13;
        }&#13;
        return _isPositionOfConstantCell(position);&#13;
    }&#13;
&#13;
    function _isPositionOfConstantCell(position) {&#13;
        return presenter.crossword[position.y][position.x][0].includes('!');&#13;
    }&#13;
&#13;
    function isPositionOfNotBlankCell(position) {&#13;
        if (!isPositionValid(position)) {&#13;
            return false;&#13;
        }&#13;
        return _isPositionOfNotBlankCell(position);&#13;
    }&#13;
&#13;
    function _isPositionOfNotBlankCell(position) {&#13;
        return presenter.crossword[position.y][position.x][0] !== ' ';&#13;
    }&#13;
&#13;
    function getCellInput(position) {&#13;
        if (!isPositionValid(position)) {&#13;
            return;&#13;
        }&#13;
        return presenter.$view.find(`.cell_row_${position.y}.cell_column_${position.x}`).find("input")[0];&#13;
    }&#13;
&#13;
    function getElementInput(element) {&#13;
        return $(element).find("input")[0];&#13;
    }&#13;
&#13;
    function isPositionValid(position) {&#13;
        return !!position&#13;
            &amp;&amp; position.y &gt;= 0 &amp;&amp; position.y &lt; presenter.rowCount&#13;
            &amp;&amp; position.x &gt;= 0 &amp;&amp; position.x &lt; presenter.columnCount;&#13;
    }&#13;
&#13;
    presenter.isDirectionNotSet = function () {&#13;
        return currentDirection === DIRECTIONS.NOT_SET;&#13;
    }&#13;
&#13;
    presenter.isHorizontalDirection = function () {&#13;
        return currentDirection === DIRECTIONS.HORIZONTAL;&#13;
    }&#13;
&#13;
    presenter.isVerticalDirection = function () {&#13;
        return currentDirection === DIRECTIONS.VERTICAL;&#13;
    }&#13;
&#13;
    presenter.isTabIndexDirection = function () {&#13;
        return currentDirection === DIRECTIONS.TAB_INDEX;&#13;
    }&#13;
&#13;
    presenter.isNextVerticalAnswerDirection = function () {&#13;
        return currentDirection === DIRECTIONS.NEXT_VERTICAL_ANSWER;&#13;
    }&#13;
&#13;
    presenter.resetDirection = function () {&#13;
        currentDirection = DIRECTIONS.NOT_SET;&#13;
    }&#13;
&#13;
    presenter.setHorizontalDirection = function () {&#13;
        currentDirection = DIRECTIONS.HORIZONTAL;&#13;
    }&#13;
&#13;
    presenter.setVerticalDirection = function () {&#13;
        currentDirection = DIRECTIONS.VERTICAL;&#13;
    }&#13;
&#13;
    presenter.setNextVerticalAnswerDirection = function () {&#13;
        currentDirection = DIRECTIONS.NEXT_VERTICAL_ANSWER&#13;
    }&#13;
&#13;
    presenter.setTabIndexDirection = function () {&#13;
        currentDirection = DIRECTIONS.TAB_INDEX;&#13;
    }&#13;
&#13;
    function setCaretPosition(elem, caretPos) {&#13;
        var range;&#13;
&#13;
        if (elem.createTextRange) {&#13;
            range = elem.createTextRange();&#13;
            range.move('character', caretPos);&#13;
            range.select();&#13;
        } else {&#13;
            elem.focus();&#13;
            if (elem.selectionStart !== undefined) {&#13;
                elem.setSelectionRange(caretPos, caretPos);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.createGrid = function() {&#13;
        var wordNumberCounter = 1;&#13;
&#13;
        var gridContainer = $('&lt;div&gt;&lt;/div&gt;');&#13;
        addClass(gridContainer, "crossword_container");&#13;
        let containerWidth = presenter.columnCount * presenter.cellWidth;&#13;
        let containerHeight = presenter.rowCount * presenter.cellHeight;&#13;
        let containerMarginLeft = Math.round(presenter.columnCount * presenter.cellWidth / 2);&#13;
        let containerMarginTop = Math.round(presenter.rowCount * presenter.cellHeight / 2);&#13;
        if (isInPrintableStateMode()) {&#13;
            gridContainer.css({&#13;
                width: containerWidth + 'px',&#13;
                height: containerHeight + 'px',&#13;
            });&#13;
        } else {&#13;
            gridContainer.css({&#13;
                width: containerWidth + 'px',&#13;
                height: containerHeight + 'px',&#13;
                marginLeft: -1 * containerMarginLeft + 'px',&#13;
                marginTop: -1 * containerMarginTop + 'px'&#13;
            });&#13;
        }&#13;
&#13;
        var tabIndexOffset = 0;&#13;
        for(var i = 0; i &lt; presenter.rowCount; i++) {&#13;
            for(var j = 0; j &lt; presenter.columnCount; j++) {&#13;
                var cellContainer = $('&lt;div&gt;&lt;/div&gt;');&#13;
                addClass(cellContainer, "cell_container");&#13;
                cellContainer.css({ width:  presenter.cellWidth + 'px',&#13;
                    height: presenter.cellHeight + 'px' });&#13;
&#13;
                var cell = $('&lt;div&gt;&lt;/div&gt;');&#13;
                addClass(cell, "cell");&#13;
                addClass(cell, 'cell_' + i + 'x' + j);&#13;
                addClass(cell, 'cell_row_' + i);&#13;
                addClass(cell, 'cell_column_' + j);&#13;
&#13;
                if (presenter.markedRowIndex &gt; 0 &amp;&amp; presenter.markedRowIndex == i+1) {&#13;
                    addClass(cell, "cell_row_marked");&#13;
                }&#13;
&#13;
                if (presenter.markedColumnIndex &gt; 0 &amp;&amp; presenter.markedColumnIndex == j+1) {&#13;
                    addClass(cell, "cell_column_marked");&#13;
                }&#13;
&#13;
                cellContainer.append(cell);&#13;
                if (presenter.crossword[i][j] == ' ') {&#13;
                    addClass(cell, "cell_blank");&#13;
                    addClass(cellContainer, "cell_container_blank");&#13;
                } else {&#13;
                    addClass(cell, "cell_letter");&#13;
                    addClass(cellContainer, "cell_container_letter");&#13;
&#13;
                    var input = $('&lt;input type="text" maxlength="2" size="1"/&gt;');&#13;
&#13;
                    if (presenter.crossword[i][j][0] === '!') {&#13;
                        input&#13;
                            .val(presenter.crossword[i][j][1])&#13;
                            .prop('disabled', true);&#13;
&#13;
                        addClass(cell, "cell_constant_letter");&#13;
                        cell.addClass("");&#13;
                    } else if (!isInPrintableStateMode()){&#13;
                        input&#13;
                            .attr('tabIndex', presenter.tabIndexBase + tabIndexOffset++)&#13;
                            .keyup(presenter.onCellInputKeyUp)&#13;
                            .keydown(presenter.onCellInputKeyDown)&#13;
                            .focus(presenter.onCellInputFocus)&#13;
                            .mouseup(presenter.onCellInputMouseUp)&#13;
                            .focusout(presenter.onCellInputFocusOut)&#13;
                            .click(presenter.onCellClick);&#13;
                    } else {&#13;
                        input&#13;
                            .prop('disabled', true)&#13;
                            .attr('tabIndex', presenter.tabIndexBase + tabIndexOffset++);&#13;
                    }&#13;
&#13;
                    if(presenter.preview) {&#13;
                        input.attr({&#13;
                            value: presenter.crossword[i][j].toUpperCase(),&#13;
                            disabled: true&#13;
                        });&#13;
                    }&#13;
&#13;
                    cell.append(input);&#13;
&#13;
                    var horizontalWordBegin = presenter.isHorizontalWordBegin(i, j);&#13;
                    var verticalWordBegin = presenter.isVerticalWordBegin(i, j);&#13;
&#13;
                    if (horizontalWordBegin) presenter.maxScore++;&#13;
                    if (verticalWordBegin) presenter.maxScore++;&#13;
&#13;
                    if (horizontalWordBegin || verticalWordBegin) {&#13;
                        addClass(cell, "cell_word_begin");&#13;
&#13;
                        if (horizontalWordBegin)&#13;
                            addClass(cell, "cell_word_begin_horizontal");&#13;
&#13;
                        if (verticalWordBegin)&#13;
                            addClass(cell, "cell_word_begin_vertical");&#13;
&#13;
                        if (!presenter.disableAutomaticWordNumbering) {&#13;
                            const sanitizedText = window.xssUtils.sanitize(wordNumberCounter++);&#13;
                            const wordNumber = $('&lt;div&gt;&lt;/div&gt;').html(sanitizedText);&#13;
                            addClass(wordNumber, "word_number");&#13;
&#13;
                            cell.append(wordNumber);&#13;
                        }&#13;
                    }&#13;
                }&#13;
&#13;
                presenter.maxTabIndex = presenter.tabIndexBase + tabIndexOffset;&#13;
&#13;
                // Cell borders&#13;
                var borderStyle;&#13;
                var borderWidth;&#13;
                var borderColor;&#13;
&#13;
                if(presenter.crossword[i][j] != ' ') {&#13;
                    borderStyle = presenter.letterCellsBorderStyle;&#13;
                    borderWidth = presenter.letterCellsBorderWidth;&#13;
                    borderColor = presenter.letterCellsBorderColor;&#13;
&#13;
                } else {&#13;
                    borderStyle = presenter.blankCellsBorderStyle;&#13;
                    borderWidth = presenter.blankCellsBorderWidth;&#13;
                    borderColor = presenter.blankCellsBorderColor;&#13;
                }&#13;
&#13;
                if(i === 0 || presenter.crossword[i-1][j] == ' ') { // Outer top border&#13;
                    cell.css({ borderTopStyle: borderStyle,&#13;
                        borderTopWidth: (borderWidth * 2) + 'px',&#13;
                        borderTopColor: borderColor,&#13;
                        top:            (borderWidth * -1) + 'px' });&#13;
                } else { // Inner top border&#13;
                    cell.css({ borderTopStyle: borderStyle,&#13;
                        borderTopWidth: borderWidth + 'px',&#13;
                        borderTopColor: borderColor });&#13;
                }&#13;
&#13;
                if(i === presenter.rowCount - 1 || presenter.crossword[i+1][j] == ' ') { // Outer bottom border&#13;
                    cell.css({ borderBottomStyle: borderStyle,&#13;
                        borderBottomWidth: (borderWidth * 2) + 'px',&#13;
                        borderBottomColor: borderColor,&#13;
                        bottom:            (borderWidth * -1) + 'px' });&#13;
                } else { // Inner bottom border&#13;
                    cell.css({ borderBottomStyle: borderStyle,&#13;
                        borderBottomWidth: borderWidth + 'px',&#13;
                        borderBottomColor: borderColor });&#13;
                }&#13;
&#13;
                if(j === 0 || presenter.crossword[i][j-1] == ' ') { // Outer left border&#13;
                    cell.css({ borderLeftStyle: borderStyle,&#13;
                        borderLeftWidth: (borderWidth * 2) + 'px',&#13;
                        borderLeftColor: borderColor,&#13;
                        left:            (borderWidth * -1) + 'px' });&#13;
                } else { // Inner left border&#13;
                    cell.css({ borderLeftStyle: borderStyle,&#13;
                        borderLeftWidth: borderWidth + 'px',&#13;
                        borderLeftColor: borderColor });&#13;
                }&#13;
&#13;
                if(j === presenter.columnCount - 1 || presenter.crossword[i][j+1] == ' ') { // Outer right border&#13;
                    cell.css({ borderRightStyle: borderStyle,&#13;
                        borderRightWidth: (borderWidth * 2) + 'px',&#13;
                        borderRightColor: borderColor,&#13;
                        right:            (borderWidth * -1) + 'px' });&#13;
                } else { // Inner right border&#13;
                    cell.css({ borderRightStyle: borderStyle,&#13;
                        borderRightWidth: borderWidth + 'px',&#13;
                        borderRightColor: borderColor });&#13;
                }&#13;
&#13;
                // Additional classes&#13;
                if(j == 0) {&#13;
                    addClass(cell, "cell_first_in_row");&#13;
                } else if(j == presenter.columnCount - 1) {&#13;
                    addClass(cell, "cell_last_in_row");&#13;
                }&#13;
&#13;
                if(i == 0) {&#13;
                    addClass(cell, "cell_first_in_column");&#13;
                } else if(i == presenter.rowCount - 1) {&#13;
                    addClass(cell, "cell_last_in_column");&#13;
                }&#13;
&#13;
                gridContainer.append(cellContainer);&#13;
            }&#13;
        }&#13;
&#13;
        presenter.updateMaxScore();&#13;
        presenter.$view.append(gridContainer);&#13;
    };&#13;
&#13;
    function returnErrorMessage(errorMessage, errorMessageSubstitutions) {&#13;
        return {&#13;
            isError: true,&#13;
            errorMessage: errorMessage,&#13;
            errorMessageSubstitutions: errorMessageSubstitutions&#13;
        }&#13;
    }&#13;
&#13;
    presenter.updateMaxScore = function () {&#13;
        presenter.maxScore -= presenter.getNumberOfExampleWords();&#13;
    }&#13;
&#13;
    presenter.getNumberOfExampleWords = function () {&#13;
        let exampleWordsCounter = 0;&#13;
        for (let i = 0; i &lt; presenter.rowCount; i++) {&#13;
            for (let j = 0; j &lt; presenter.columnCount; j++) {&#13;
                if (presenter.isHorizontalWordBegin(i, j)) {&#13;
                    let exampleLettersCounter = 0;&#13;
                    let letterCounter = 0;&#13;
&#13;
                    for (let k = j; k &lt; presenter.columnCount; k++) {&#13;
                        if (presenter.crossword[i][k] === ' ') {&#13;
                            break;&#13;
                        }&#13;
&#13;
                        if (presenter.crossword[i][k].match('![a-zA-Z]*?')) {&#13;
                            exampleLettersCounter++;&#13;
                        }&#13;
                        letterCounter++;&#13;
                    }&#13;
&#13;
                    if (letterCounter === exampleLettersCounter) {&#13;
                        exampleWordsCounter++;&#13;
                    }&#13;
                }&#13;
&#13;
                if (presenter.isVerticalWordBegin(i, j)) {&#13;
                    let exampleLettersCounter = 0;&#13;
                    let letterCounter = 0;&#13;
&#13;
                    for (let k = i; k &lt; presenter.rowCount; k++) {&#13;
                        if (presenter.crossword[k][j] === ' ') {&#13;
                            break;&#13;
                        }&#13;
&#13;
                        if (presenter.crossword[k][j].match('![a-zA-Z]*?')) {&#13;
                            exampleLettersCounter++;&#13;
                        }&#13;
                        letterCounter++;&#13;
                    }&#13;
&#13;
                    if (letterCounter === exampleLettersCounter) {&#13;
                        exampleWordsCounter++;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return exampleWordsCounter;&#13;
    }&#13;
&#13;
    presenter.readConfiguration = function(model) {&#13;
        if(typeof(model['Blank cells border color']) != "undefined" &amp;&amp; model['Blank cells border color'] !== "")&#13;
            presenter.blankCellsBorderColor = model['Blank cells border color'];&#13;
&#13;
        if(typeof(model['Blank cells border width']) != "undefined" &amp;&amp; model['Blank cells border width'] !== "")&#13;
            presenter.blankCellsBorderWidth = parseInt(model['Blank cells border width']);&#13;
&#13;
        if(typeof(model['Blank cells border style']) != "undefined" &amp;&amp; model['Blank cells border style'] !== "")&#13;
            presenter.blankCellsBorderStyle = model['Blank cells border style'];&#13;
&#13;
        if(typeof(model['Letter cells border color']) != "undefined" &amp;&amp; model['Letter cells border color'] !== "")&#13;
            presenter.letterCellsBorderColor = model['Letter cells border color'];&#13;
&#13;
        if(typeof(model['Letter cells border width']) != "undefined" &amp;&amp; model['Letter cells border width'] !== "")&#13;
            presenter.letterCellsBorderWidth = parseInt(model['Letter cells border width']);&#13;
&#13;
        if(typeof(model['Letter cells border style']) != "undefined" &amp;&amp; model['Letter cells border style'] !== "")&#13;
            presenter.letterCellsBorderStyle = model['Letter cells border style'];&#13;
&#13;
        if(typeof(model['Word numbers']) != "undefined") {&#13;
            if(model['Word numbers'] == "horizontal" || model['Word numbers'] == "both" || model['Word numbers'] === "")&#13;
                presenter.wordNumbersHorizontal = true;&#13;
&#13;
            if(model['Word numbers'] == "vertical" || model['Word numbers'] == "both" || model['Word numbers'] === "")&#13;
                presenter.wordNumbersVertical = true;&#13;
        }&#13;
&#13;
        if(typeof(model['Marked column index']) != "undefined" &amp;&amp; model['Marked column index'] !== "") {&#13;
            presenter.markedColumnIndex = parseInt(model['Marked column index']);&#13;
            if(presenter.markedColumnIndex &lt; 0) {&#13;
                return returnErrorMessage(presenter.ERROR_MESSAGES.INVALID_MARKED_COLUMN_INDEX)&#13;
            }&#13;
        }&#13;
&#13;
        if(typeof(model['Marked row index']) != "undefined" &amp;&amp; model['Marked row index'] !== "") {&#13;
            presenter.markedRowIndex = parseInt(model['Marked row index']);&#13;
            if(presenter.markedRowIndex &lt; 0) {&#13;
                return returnErrorMessage(presenter.ERROR_MESSAGES.INVALID_MARKED_ROW_INDEX);&#13;
            }&#13;
        }&#13;
&#13;
        presenter.disableAutomaticWordNumbering = model['Disable automatic word numberin'] == 'True';&#13;
&#13;
        if(presenter.blankCellsBorderWidth &lt; 0) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.INVALID_BLANK_CELLS_BORDER_WIDTH);&#13;
        }&#13;
&#13;
        if(presenter.letterCellsBorderWidth &lt; 0) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.INVALID_LETTER_CELLS_BORDER_WIDTH);&#13;
        }&#13;
&#13;
        if(parseInt(model['Columns']) &lt;= 0 || isNaN(parseInt(model['Columns'])) ) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.COLUMNS_NOT_SPECIFIED);&#13;
        }&#13;
&#13;
        if(parseInt(model['Rows']) &lt;= 0 || isNaN(parseInt(model['Rows']))) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.ROWS_NOT_SPECIFIED);&#13;
        }&#13;
&#13;
        if(parseInt(model['Cell width']) &lt;= 0 || isNaN(parseInt(model['Cell width'])) ) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.CELL_WIDTH_NOT_SPECIFIED);&#13;
        }&#13;
&#13;
        if(parseInt(model['Cell height']) &lt;= 0 || isNaN(parseInt(model['Cell height']))) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.CELL_HEIGHT_NOT_SPECIFIED);&#13;
        }&#13;
&#13;
        presenter.rowCount        = parseInt(model['Rows']);&#13;
        presenter.columnCount     = parseInt(model['Columns']);&#13;
        presenter.cellWidth       = parseInt(model['Cell width']);&#13;
        presenter.cellHeight      = parseInt(model['Cell height']);&#13;
&#13;
        var rows = model['Crossword'].split("\n");&#13;
        if(rows.length != presenter.rowCount) {&#13;
            return returnErrorMessage(presenter.ERROR_MESSAGES.INVALID_AMOUNT_OF_ROWS_IN_CROSSWORD);&#13;
        }&#13;
&#13;
        for(var i = 0; i &lt; rows.length; i++) {&#13;
            if(rows[i].replace(/!/g, "").length != presenter.columnCount) {&#13;
                return returnErrorMessage(presenter.ERROR_MESSAGES.INVALID_AMOUNT_OF_COLUMNS_IN_CROSSWORD, { row : i + 1 });&#13;
            }&#13;
&#13;
            var line = rows[i];&#13;
            var previous = line[0];&#13;
&#13;
            if (line.slice(-1) === '!') {&#13;
                return returnErrorMessage(presenter.ERROR_MESSAGES.LAST_CHARACTER_EXCLAMATION_MARK);&#13;
            }&#13;
&#13;
            for (var j=1; j&lt;line.length; j++) {&#13;
                if (previous === '!') {&#13;
                    switch (line[j]) {&#13;
                        case '!': return returnErrorMessage(presenter.ERROR_MESSAGES.DOUBLED_EXCLAMATION_MARK); break;&#13;
                        case ' ': return returnErrorMessage(presenter.ERROR_MESSAGES.EXCLAMATION_MARK_BEFORE_EMPTY_FIELD); break;&#13;
                        default: break;&#13;
                    }&#13;
                }&#13;
                previous = line[j];&#13;
            }&#13;
        }&#13;
&#13;
        presenter.blockWrongAnswers = presenter.isBlockWrongAnswers(model);&#13;
&#13;
        var autoNavigationPropertyResponse = readModelAutoNavigationMode(model);&#13;
        if (!!autoNavigationPropertyResponse) {&#13;
            return autoNavigationPropertyResponse;&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            isVisibleByDefault: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            langTag: model["langAttribute"],&#13;
        };&#13;
    };&#13;
&#13;
    function readModelAutoNavigationMode(model) {&#13;
        const selectedMode = model["autoNavigation"];&#13;
        if (selectedMode === "Off") {&#13;
            autoNavigationMode = AUTO_NAVIGATION_OPTIONS.OFF;&#13;
        } else if (selectedMode === "Simple") {&#13;
            autoNavigationMode = AUTO_NAVIGATION_OPTIONS.SIMPLE;&#13;
        } else if (selectedMode === "Extended") {&#13;
            autoNavigationMode = AUTO_NAVIGATION_OPTIONS.EXTENDED;&#13;
        } else {&#13;
            return returnErrorMessage(&#13;
                presenter.ERROR_MESSAGES.NOT_SUPPORTED_SELECTED_AUTO_NAVIGATION_MODE&#13;
            );&#13;
        }&#13;
    }&#13;
&#13;
    presenter.isAutoNavigationInOffMode = function () {&#13;
        return autoNavigationMode === AUTO_NAVIGATION_OPTIONS.OFF;&#13;
    }&#13;
&#13;
    presenter.isAutoNavigationInSimpleMode = function () {&#13;
        return autoNavigationMode === AUTO_NAVIGATION_OPTIONS.SIMPLE;&#13;
    }&#13;
&#13;
    presenter.isAutoNavigationInExtendedMode = function () {&#13;
        return autoNavigationMode === AUTO_NAVIGATION_OPTIONS.EXTENDED;&#13;
    }&#13;
&#13;
    presenter.destroyCommands = function () {&#13;
        delete presenter.executeCommand;&#13;
        delete presenter.isAllOK;&#13;
        delete presenter.isAttempted;&#13;
        delete presenter.getMaxScore;&#13;
        delete presenter.getScore;&#13;
        delete presenter.getErrorCount;&#13;
        delete presenter.setShowErrorsMode;&#13;
        delete presenter.setWorkMode;&#13;
        delete presenter.show;&#13;
        delete presenter.hide;&#13;
        delete presenter.reset;&#13;
        delete presenter.getState;&#13;
        delete presenter.setState;&#13;
        presenter.isModelValid = false;&#13;
    };&#13;
&#13;
    presenter.isBlockWrongAnswers = function (model) {&#13;
        return ModelValidationUtils.validateBoolean(model.blockWrongAnswers);&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function(model) {&#13;
        var upgradedModel = upgradeModelAddShowAllAnswersInGSAModeProperty(model);&#13;
        upgradedModel = upgradeModelAddAutoNavigationProperty(upgradedModel);&#13;
        upgradedModel = upgradeModelAddLangTagProperty(upgradedModel);&#13;
        return upgradeModelAddSpeechTextsProperty(upgradedModel);&#13;
    };&#13;
&#13;
    function upgradeModelAddShowAllAnswersInGSAModeProperty(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if(!upgradedModel['showAllAnswersInGradualShowAnswersMode']) {&#13;
            upgradedModel['showAllAnswersInGradualShowAnswersMode'] = false;&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    function upgradeModelAddAutoNavigationProperty(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if(!upgradedModel["autoNavigation"]) {&#13;
            upgradedModel["autoNavigation"] = "Extended";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    function upgradeModelAddLangTagProperty(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (upgradedModel["langAttribute"] === undefined) {&#13;
            upgradedModel["langAttribute"] =  '';&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    function upgradeModelAddSpeechTextsProperty(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if (!upgradedModel["speechTexts"]) {&#13;
            upgradedModel["speechTexts"] = {};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Cell"]) {&#13;
            upgradedModel["speechTexts"]["Cell"] = {Cell: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Across"]) {&#13;
            upgradedModel["speechTexts"]["Across"] = {Across: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Down"]) {&#13;
            upgradedModel["speechTexts"]["Down"] = {Down: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Correct"]) {&#13;
            upgradedModel["speechTexts"]["Correct"] = {Correct: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Wrong"]) {&#13;
            upgradedModel["speechTexts"]["Wrong"] = {Wrong: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Empty"]) {&#13;
            upgradedModel["speechTexts"]["Empty"] = {Empty: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["Disabled"]) {&#13;
            upgradedModel["speechTexts"]["Disabled"] = {Disabled: ""};&#13;
        }&#13;
        if (!upgradedModel["speechTexts"]["OutOf"]) {&#13;
            upgradedModel["speechTexts"]["OutOf"] = {OutOf: ""};&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.initializeLogic = function(view, model) {&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.$view = $(view);&#13;
        presenter.ID = model.ID;&#13;
        presenter.showAllAnswersInGradualShowAnswersMode = model.showAllAnswersInGradualShowAnswersMode;&#13;
&#13;
        presenter.configuration = presenter.readConfiguration(model);&#13;
        if(presenter.configuration.isError) {&#13;
            presenter.showErrorMessage(configuration.errorMessage, configuration.errorMessageSubstitutions);&#13;
            presenter.destroyCommands();&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.$view.find(".cell").live("blur", presenter.cellBlurEventHandler);&#13;
        presenter.prepareGrid(model);&#13;
        presenter.prepareCorrectAnswers();&#13;
        presenter.createGrid();&#13;
        presenter.setSpeechTexts(model["speechTexts"]);&#13;
        presenter.buildKeyboardController();&#13;
    };&#13;
&#13;
    presenter.validate = function(mode) {&#13;
        const classPrefix = '.' + (isInPrintableStateMode() ? presenter.CSS_CLASSES.PRINTABLE + '_' : '');&#13;
        let wordValid, k, l, score, markedCell;&#13;
        let filled = false;&#13;
&#13;
        if (presenter.isShowAnswersActive &amp;&amp; mode == presenter.VALIDATION_MODE.SHOW_ERRORS) {&#13;
            presenter.hideAnswers();&#13;
            for (let i = 0; i &lt; presenter.rowCount; i++) {&#13;
                for (let j = 0; j &lt; presenter.columnCount; j++) {&#13;
                    if (presenter.$view.find(classPrefix + 'cell_' + i + 'x' + j + ' input').val() != ''&#13;
                        &amp;&amp; typeof(presenter.$view.find(classPrefix + 'cell_' + i + 'x' + j + ' input').val()) !== "undefined"&#13;
                        &amp;&amp; presenter.crossword[i][j][0] !== '!') {&#13;
                        filled = true;&#13;
                    }&#13;
                }&#13;
            }&#13;
            if (!filled) {&#13;
                return;&#13;
            }&#13;
        }&#13;
&#13;
        if(mode == presenter.VALIDATION_MODE.SHOW_ERRORS) {&#13;
            presenter.$view.find(classPrefix + "cell_letter input").attr('disabled', true);&#13;
        } else if(mode == presenter.VALIDATION_MODE.COUNT_SCORE) {&#13;
            score = 0;&#13;
        }&#13;
&#13;
        for(i = 0; i &lt; presenter.rowCount; i++) {&#13;
            for(j = 0; j &lt; presenter.columnCount; j++) {&#13;
                if(presenter.isHorizontalWordBegin(i, j)) {&#13;
                    wordValid = true;&#13;
                    let exampleLettersCounter = 0;&#13;
                    let letterCounter = 0;&#13;
&#13;
                    for(k = j; k &lt; presenter.columnCount; k++) {&#13;
                        if(presenter.crossword[i][k] == ' ') {&#13;
                            break;&#13;
                        }&#13;
&#13;
                        if(presenter.crossword[i][k] != presenter.$view.find(classPrefix + 'cell_' + i + 'x' + k + " input").attr('value').toUpperCase()&#13;
                            &amp;&amp; presenter.crossword[i][k][0] !== '!') {&#13;
                            wordValid = false;&#13;
                        }&#13;
&#13;
                        if(presenter.crossword[i][k].match('![a-zA-Z]*?')) {&#13;
                            exampleLettersCounter++;&#13;
                        }&#13;
                        letterCounter++;&#13;
                    }&#13;
&#13;
                    if (wordValid &amp;&amp; letterCounter === exampleLettersCounter &amp;&amp; mode !== presenter.VALIDATION_MODE.CHECK_ANSWERS) {&#13;
                        wordValid = false;&#13;
                    }&#13;
&#13;
                    if(mode == presenter.VALIDATION_MODE.COUNT_SCORE &amp;&amp; wordValid) {&#13;
                        score++;&#13;
                    }&#13;
&#13;
                    if(mode === presenter.VALIDATION_MODE.SHOW_ERRORS || mode === presenter.VALIDATION_MODE.CHECK_ANSWERS) {&#13;
                        for(l = j; l &lt; k; l++) {&#13;
                            markedCell = presenter.$view.find(classPrefix + 'cell_' + i + 'x' + l);&#13;
                            if(!markedCell.hasClass(presenter.CSS_CLASSES.CELL_VALID))&#13;
                                markedCell.addClass(&#13;
                                    wordValid&#13;
                                        ? presenter.CSS_CLASSES.CELL_VALID&#13;
                                        : presenter.CSS_CLASSES.CELL_INVALID);&#13;
&#13;
                            if(wordValid &amp;&amp; markedCell.hasClass(presenter.CSS_CLASSES.CELL_INVALID))&#13;
                                markedCell.removeClass(presenter.CSS_CLASSES.CELL_INVALID);&#13;
                        }&#13;
                    }&#13;
                }&#13;
&#13;
                if(presenter.isVerticalWordBegin(i, j)) {&#13;
                    wordValid = true;&#13;
                    let exampleLettersCounter = 0;&#13;
                    let letterCounter = 0;&#13;
&#13;
                    for(k = i; k &lt; presenter.rowCount; k++) {&#13;
                        if(presenter.crossword[k][j] == ' ') {&#13;
                            break;&#13;
                        }&#13;
&#13;
                        if(presenter.crossword[k][j] != presenter.$view.find(classPrefix + 'cell_' + k + 'x' + j + " input").attr('value').toUpperCase() &amp;&amp; presenter.crossword[k][j][0] !== '!') {&#13;
                            wordValid = false;&#13;
                        }&#13;
&#13;
                         if(presenter.crossword[k][j].match('![a-zA-Z]*?')) {&#13;
                            exampleLettersCounter++;&#13;
                        }&#13;
                        letterCounter++;&#13;
                    }&#13;
&#13;
                    if (wordValid &amp;&amp; letterCounter === exampleLettersCounter &amp;&amp; mode !== presenter.VALIDATION_MODE.CHECK_ANSWERS) {&#13;
                        wordValid = false;&#13;
                    }&#13;
&#13;
                    if(mode == presenter.VALIDATION_MODE.COUNT_SCORE &amp;&amp; wordValid) {&#13;
                        score++;&#13;
                    }&#13;
&#13;
                    if(mode === presenter.VALIDATION_MODE.SHOW_ERRORS || mode === presenter.VALIDATION_MODE.CHECK_ANSWERS) {&#13;
                        for(l = i; l &lt; k; l++) {&#13;
                            markedCell = presenter.$view.find(classPrefix + 'cell_' + l + 'x' + j);&#13;
                            if(!markedCell.hasClass(presenter.CSS_CLASSES.CELL_VALID))&#13;
                                markedCell.addClass(&#13;
                                    wordValid&#13;
                                        ? presenter.CSS_CLASSES.CELL_VALID&#13;
                                        : presenter.CSS_CLASSES.CELL_INVALID);&#13;
&#13;
                            if(wordValid &amp;&amp; markedCell.hasClass(presenter.CSS_CLASSES.CELL_INVALID))&#13;
                                markedCell.removeClass(presenter.CSS_CLASSES.CELL_INVALID);&#13;
                        }&#13;
                    }&#13;
                }&#13;
&#13;
            }&#13;
        }&#13;
&#13;
        if(mode == presenter.VALIDATION_MODE.COUNT_SCORE) {&#13;
            return score;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if (!presenter.isAttempted()) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.validate(presenter.VALIDATION_MODE.CHECK_ANSWERS);&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        presenter.$view.find(".cell_letter:not(.cell_constant_letter) input").attr('disabled', false);&#13;
        presenter.$view.find('.' + presenter.CSS_CLASSES.CELL_VALID).removeClass(presenter.CSS_CLASSES.CELL_VALID);&#13;
        presenter.$view.find('.' + presenter.CSS_CLASSES.CELL_INVALID).removeClass(presenter.CSS_CLASSES.CELL_INVALID);&#13;
    };&#13;
&#13;
    presenter.cellBlurEventHandler = function () {&#13;
        if (presenter.isAllOK()) {&#13;
            presenter.sendAllOKEvent();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.preview = false;&#13;
        presenter.addonID = model.ID&#13;
        presenter.initializeLogic(view, model);&#13;
        if (!presenter.configuration.isError) {&#13;
            presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
       }&#13;
    };&#13;
&#13;
    presenter.setEventBus = function (wrappedEventBus) {&#13;
        eventBus = wrappedEventBus;&#13;
&#13;
        var events = ['ShowAnswers', 'HideAnswers', 'GradualShowAnswers', 'GradualHideAnswers'];&#13;
        for (var i = 0; i &lt; events.length; i++) {&#13;
            eventBus.addEventListener(events[i], this);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.preview = true;&#13;
        presenter.initializeLogic(view, model);&#13;
        if (!presenter.configuration.isError) {&#13;
            presenter.setVisibility(true);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.reset = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        resetCellsStates()&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.setWorkMode();&#13;
    };&#13;
&#13;
    function resetCellsStates() {&#13;
        for(var i = 0; i &lt; presenter.rowCount; i++) {&#13;
            for(var j = 0; j &lt; presenter.columnCount; j++) {&#13;
                if(presenter.crossword[i][j][0] !== '!') {&#13;
                    presenter.$view.find('.cell_' + i + 'x' + j + ' input').val('');&#13;
                }&#13;
                if(typeof(presenter.userAnswers) !== "undefined") {&#13;
                    presenter.userAnswers[i][j] = '';&#13;
                }&#13;
             }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.isVisible = isVisible;&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        if(presenter.isShowAnswersActive === true){&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        if(presenter.isShowAnswersActive === true){&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
&#13;
    presenter.isAttempted = function() {&#13;
        let classPrefix = "cell";&#13;
        if (isInPrintableStateMode()) {&#13;
            classPrefix = presenter.CSS_CLASSES.PRINTABLE + "_" + classPrefix;&#13;
        }&#13;
&#13;
        var countedConstantLetters = 0;&#13;
        jQuery.each(presenter.$view.find(`.${classPrefix} input`), function() {&#13;
            if (!ModelValidationUtils.isStringEmpty($(this).val())) countedConstantLetters++;&#13;
        });&#13;
&#13;
        return presenter.numberOfConstantLetters &lt; countedConstantLetters;&#13;
    };&#13;
&#13;
    presenter.getScore = function() {&#13;
        const restoreState = presenter.isShowAnswersActive;&#13;
        const wasGradualShowAnswersActive = presenter.isGradualShowAnswersActive;&#13;
&#13;
        if (presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        var score = presenter.validate(presenter.VALIDATION_MODE.COUNT_SCORE);&#13;
        var finalScore = presenter.isAttempted() ? score : 0;&#13;
        if (restoreState) {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (wasGradualShowAnswersActive) {&#13;
            this.restoreGradualShowAnswers();&#13;
        }&#13;
        return finalScore;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function() {&#13;
        return presenter.maxScore;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function() {&#13;
        const restoreState = presenter.isShowAnswersActive;&#13;
        const wasGradualShowAnswersActive = presenter.isGradualShowAnswersActive;&#13;
        if (presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        var score = presenter.validate(presenter.VALIDATION_MODE.COUNT_SCORE),&#13;
            errorCount = presenter.getMaxScore() - score;&#13;
        var finalErrorCount = presenter.isAttempted() ? errorCount : 0;&#13;
        if (restoreState) {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (wasGradualShowAnswersActive) {&#13;
            this.restoreGradualShowAnswers();&#13;
        }&#13;
        return finalErrorCount&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        var cells = getCellsStates();&#13;
        var isVisible = presenter.isVisible;&#13;
&#13;
        return JSON.stringify({&#13;
            cells : cells,&#13;
            isVisible : isVisible&#13;
        });&#13;
    };&#13;
&#13;
    function getCellsStates() {&#13;
        var s = [];&#13;
        var cell;&#13;
        for(var i = 0; i &lt; presenter.rowCount; i++) {&#13;
            for(var j = 0; j &lt; presenter.columnCount; j++) {&#13;
                cell = presenter.$view.find('.cell_' + i + 'x' + j + ' input').attr('value');&#13;
                if(typeof(cell) == "string")&#13;
                    cell = cell.replace("\"", "\\\"");&#13;
&#13;
                s.push(cell);&#13;
            }&#13;
        }&#13;
        return s;&#13;
    }&#13;
&#13;
    presenter.setState = function(state) {&#13;
        var parsedState = $.parseJSON(state.toString());&#13;
        if (parsedState.hasOwnProperty("cells")) {&#13;
            setCellsStates(parsedState.cells);&#13;
        } else {&#13;
            setCellsStates(parsedState);&#13;
        }&#13;
&#13;
        if (parsedState.hasOwnProperty("isVisible")) {&#13;
            if (typeof(parsedState.isVisible) === "boolean") {&#13;
                presenter.isVisible = parsedState.isVisible;&#13;
            } else {&#13;
                presenter.isVisible = presenter.configuration.isVisibleByDefault;&#13;
            }&#13;
            presenter.setVisibility(presenter.isVisible);&#13;
        }&#13;
    };&#13;
&#13;
    function setCellsStates(cellsStates) {&#13;
        var counter = 0;&#13;
        for(var i = 0; i &lt; presenter.rowCount; i++) {&#13;
            for(var j = 0; j &lt; presenter.columnCount; j++) {&#13;
                presenter.$view.find('.cell_' + i + 'x' + j + ' input').attr('value', cellsStates[counter]);&#13;
                counter++;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        playerController = controller;&#13;
    };&#13;
&#13;
    /**&#13;
     * @param controller (PrintableController)&#13;
     */&#13;
    presenter.setPrintableController = function (controller) {&#13;
        presenter.printableController = controller;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (presenter.configuration.isErrorMode) return;&#13;
&#13;
        var commands = {&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.isAllOK = function() {&#13;
        if (presenter.isWordNumbersCorrect()) {&#13;
            return presenter.getMaxScore() === presenter.getScore() &amp;&amp; presenter.getErrorCount() === 0;&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    function getEventObject(it, val, sc) {&#13;
        return {&#13;
            'source': presenter.ID,&#13;
            'item': '' + it,&#13;
            'value': '' + val,&#13;
            'score': '' + sc&#13;
        };&#13;
    }&#13;
&#13;
    presenter.sendAllOKEvent = function () {&#13;
        eventBus.sendEvent('ValueChanged', getEventObject('all', '', ''));&#13;
    };&#13;
&#13;
    presenter.sendCorrectWordEvent = function sendCorrectWordEvent (word, item) {&#13;
        eventBus.sendEvent('CorrectWord', getEventObject(item, word, ''));&#13;
    };&#13;
&#13;
    presenter.sendScoreEvent = function(pos, value, isOk) {&#13;
        var item = '[row][col]'.replace('col', pos.x + 1).replace('row', pos.y + 1);&#13;
        var score = isOk ? '1' : '0';&#13;
        eventBus.sendEvent('ValueChanged', getEventObject(item, value, score));&#13;
    };&#13;
&#13;
    presenter.validateWord = function validateWord(pos) {&#13;
        var max_x = pos.x;&#13;
        var max_y = pos.y;&#13;
        var i, k, horizontalResult = {&#13;
            word: '',&#13;
            item: 0,&#13;
            start: '',&#13;
            end: '',&#13;
        };&#13;
        var verticalResult = {...horizontalResult};&#13;
&#13;
        if (presenter.wordNumbersHorizontal) {&#13;
            for (i = 0; i &lt;= max_x; i++) {&#13;
                if (!presenter.isHorizontalWordBegin(max_y, i)) {&#13;
                    continue;&#13;
                }&#13;
                for (k = i; k &lt; presenter.columnCount; k++) {&#13;
                    if(presenter.crossword[max_y][k] === ' ') {&#13;
                        break;&#13;
                    }&#13;
                    if(presenter.crossword[max_y][k] !== presenter.$view.find('.cell_' + max_y + 'x' + k + " input").attr('value').toUpperCase() &amp;&amp; presenter.crossword[max_y][k][0] !== '!') {&#13;
                        horizontalResult.word = '';&#13;
                        break;&#13;
                    }&#13;
                    if (!horizontalResult.start) {&#13;
                        horizontalResult.start = `${k}:${max_y}`;&#13;
                    }&#13;
                    horizontalResult.end = `${k}:${max_y}`;&#13;
                    horizontalResult.word += presenter.crossword[max_y][k];&#13;
                }&#13;
                horizontalResult.item = presenter.$view.find('.cell_' + max_y + 'x' + i +' .word_number').text();&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.wordNumbersVertical) {&#13;
            for (i = 0; i &lt;= max_y; i++) {&#13;
                if (!presenter.isVerticalWordBegin(i, max_x)) {&#13;
                    continue;&#13;
                }&#13;
                for (k = i; k &lt; presenter.rowCount; k++) {&#13;
                    if(presenter.crossword[k][max_x] === ' ') {&#13;
                        break;&#13;
                    }&#13;
                    if(presenter.crossword[k][max_x] !== presenter.$view.find('.cell_' + k + 'x' + max_x + " input").attr('value').toUpperCase() &amp;&amp; presenter.crossword[k][max_x][0] !== '!') {&#13;
                        verticalResult.word = '';&#13;
                        break;&#13;
                    }&#13;
                    if (!verticalResult.start) {&#13;
                        verticalResult.start = `${max_x}:${k}`;&#13;
                    }&#13;
                    verticalResult.end = `${max_x}:${k}`;&#13;
                    verticalResult.word += presenter.crossword[k][max_x];&#13;
                }&#13;
                verticalResult.item = presenter.$view.find('.cell_' + i + 'x' + max_x +' .word_number').text();&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            verticalResult: verticalResult.word !== '' ? verticalResult : null,&#13;
            horizontalResult: horizontalResult.word !== '' ? horizontalResult : null,&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function() {&#13;
        if(presenter.showAllAnswersInGradualShowAnswersMode === "True") {&#13;
            return 1;&#13;
        }&#13;
        return presenter.correctAnswers.length;&#13;
    }&#13;
&#13;
    presenter.onEventReceived = function (eventName, data) {&#13;
        if (!presenter.isModelValid) return;&#13;
&#13;
        switch(eventName) {&#13;
            case "ShowAnswers":&#13;
                presenter.showAnswers();&#13;
                break;&#13;
&#13;
            case "GradualShowAnswers":&#13;
                presenter.gradualShowAnswers(data);&#13;
                break;&#13;
&#13;
            case "HideAnswers":&#13;
            case "GradualHideAnswers":&#13;
                presenter.hideAnswers();&#13;
                break;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (presenter.isWordNumbersCorrect()) {&#13;
            presenter.saveUserAnswers();&#13;
            if (presenter.isShowAnswersActive) {&#13;
                presenter.hideAnswers();&#13;
            }&#13;
            presenter.isShowAnswersActive = true;&#13;
            presenter.setWorkMode();&#13;
            presenter.$view.find(".cell_letter input").addClass('crossword_cell_show-answers');&#13;
&#13;
            presenter.replaceUserAnswersByModelAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (presenter.isWordNumbersCorrect() &amp;&amp; (presenter.isShowAnswersActive || presenter.isGradualShowAnswersActive)) {&#13;
            presenter.$view.find(".cell_letter input").removeClass('crossword_cell_show-answers');&#13;
            presenter.isShowAnswersActive = false;&#13;
            presenter.isGradualShowAnswersActive = false;&#13;
            if (!presenter.userAnswers) {&#13;
                presenter.areUserAnswersSaved = false;&#13;
                return;&#13;
            }&#13;
&#13;
            presenter.replaceAnswersBySavedUserAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.gradualShowAnswers = function (data) {&#13;
        if (data.moduleID !== presenter.addonID) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (!presenter.isWordNumbersCorrect()) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.isGradualShowAnswersActive = true;&#13;
        if (presenter.showAllAnswersInGradualShowAnswersMode === "True") {&#13;
            presenter.showAnswers();&#13;
        } else {&#13;
            presenter.$view.find(".cell_letter input").addClass('crossword_cell_show-answers');&#13;
            const itemIndex = parseInt(data.item, 10);&#13;
            presenter.GSAcounter = itemIndex;&#13;
            const answerData = presenter.correctAnswers[itemIndex];&#13;
&#13;
            if (itemIndex === 0) presenter.prepareCrosswordForGSA();&#13;
            presenter.fillRowGaps(answerData);&#13;
        }&#13;
    }&#13;
&#13;
    presenter.restoreGradualShowAnswers = function () {&#13;
        presenter.isGradualShowAnswersActive = true;&#13;
        if (presenter.showAllAnswersInGradualShowAnswersMode === "True") {&#13;
            presenter.showAnswers();&#13;
        } else {&#13;
            for (let i = 0; i &lt;= presenter.GSAcounter; i++) {&#13;
                presenter.$view.find(".cell_letter input").addClass('crossword_cell_show-answers');&#13;
                const answerData = presenter.correctAnswers[i];&#13;
&#13;
                if (i === 0) presenter.prepareCrosswordForGSA();&#13;
                presenter.fillRowGaps(answerData);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.saveUserAnswers = function () {&#13;
        if (presenter.areUserAnswersSaved) return;&#13;
&#13;
        presenter.areUserAnswersSaved = true;&#13;
        presenter.$view.find(".cell_letter input:enabled").attr('disabled', true);&#13;
        presenter.userAnswers = new Array(presenter.rowCount);&#13;
        for (let row = 0; row &lt; presenter.rowCount; row++) {&#13;
            presenter.userAnswers[row] = new Array(presenter.columnCount);&#13;
            for (let column = 0; column &lt; presenter.columnCount; column++) {&#13;
                presenter.userAnswers[row][column] = presenter.$view.find('.cell_' + row + 'x' + column + ' input')&#13;
                    .val();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.replaceUserAnswersByModelAnswers = function () {&#13;
        let classPrefix = "cell_";&#13;
        if (isInPrintableStateMode()) {&#13;
            classPrefix = presenter.CSS_CLASSES.PRINTABLE + "_" + classPrefix;&#13;
        }&#13;
&#13;
        for (let row = 0; row &lt; presenter.rowCount; row++) {&#13;
            for (let column = 0; column &lt; presenter.columnCount; column++) {&#13;
                let $cellInputs = presenter.$view.find(`.${classPrefix}${row}x${column} input`);&#13;
                $cellInputs.val(presenter.crossword[row][column].replaceAll("!",""));&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.replaceAnswersBySavedUserAnswers = function () {&#13;
        let classPrefix = "cell_";&#13;
        if (isInPrintableStateMode()) {&#13;
            classPrefix = presenter.CSS_CLASSES.PRINTABLE + "_" + classPrefix;&#13;
        }&#13;
&#13;
        for (let row = 0; row &lt; presenter.rowCount; row++) {&#13;
            for (let column = 0; column &lt; presenter.columnCount; column++) {&#13;
                if (!presenter.crossword[row][column][0].includes('!')) {&#13;
                    let $cellInputs = presenter.$view.find(`.${classPrefix}${row}x${column} input`);&#13;
                    $cellInputs.val(presenter.userAnswers[row][column]);&#13;
                    if (!isInPrintableStateMode()) {&#13;
                        $cellInputs.attr('disabled', false);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        presenter.areUserAnswersSaved = false;&#13;
    }&#13;
&#13;
    presenter.fillRowGaps = function (answerData) {&#13;
        const answer = answerData.answer.replaceAll("!","");&#13;
        const { x, y } = answerData.position;&#13;
&#13;
        if (answerData.isHorizontal) {&#13;
            for (let i = 0; i &lt; answer.length; i++) {&#13;
                presenter.$view.find('.cell_' + y + 'x' + (x + i) + ' input').val(answer.charAt(i));&#13;
            }&#13;
        } else {&#13;
            for (let i = 0; i &lt; answer.length; i++) {&#13;
                presenter.$view.find('.cell_' + (y + i) + 'x' + x + ' input').val(answer.charAt(i));&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.prepareCrosswordForGSA = function () {&#13;
        presenter.setWorkMode();&#13;
        presenter.saveUserAnswers();&#13;
    }&#13;
&#13;
    presenter.setSpeechTexts = function(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            Cell: presenter.DEFAULT_TTS_PHRASES.CELL,&#13;
            Across: presenter.DEFAULT_TTS_PHRASES.ACROSS,&#13;
            Down: presenter.DEFAULT_TTS_PHRASES.DOWN,&#13;
            Correct: presenter.DEFAULT_TTS_PHRASES.CORRECT,&#13;
            Wrong: presenter.DEFAULT_TTS_PHRASES.WRONG,&#13;
            Empty: presenter.DEFAULT_TTS_PHRASES.EMPTY,&#13;
            Disabled: presenter.DEFAULT_TTS_PHRASES.DISABLED,&#13;
            OutOf: presenter.DEFAULT_TTS_PHRASES.OUT_OFF,&#13;
        };&#13;
&#13;
        if (!speechTexts || $.isEmptyObject(speechTexts)) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            Cell: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Cell.Cell,&#13;
                presenter.speechTexts.Cell),&#13;
            Across: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Across.Across,&#13;
                presenter.speechTexts.Across),&#13;
            Down: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Down.Down,&#13;
                presenter.speechTexts.Down),&#13;
            Correct: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Correct.Correct,&#13;
                presenter.speechTexts.Correct),&#13;
            Wrong: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Wrong.Wrong,&#13;
                presenter.speechTexts.Wrong),&#13;
            Empty: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Empty.Empty,&#13;
                presenter.speechTexts.Empty),&#13;
            Disabled: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Disabled.Disabled,&#13;
                presenter.speechTexts.Disabled),&#13;
            OutOf: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.OutOf.OutOf,&#13;
                presenter.speechTexts.OutOf),&#13;
        };&#13;
    };&#13;
&#13;
    presenter.keyboardController = function(keycode, isShiftDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftDown, event);&#13;
    };&#13;
&#13;
    presenter.buildKeyboardController = function () {&#13;
        presenter.keyboardControllerObject&#13;
            = new CrosswordKeyboardController(&#13;
                presenter.getElementsForKeyboardNavigation(),&#13;
                presenter.columnCount&#13;
        );&#13;
    };&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        return presenter.$view.find(`.${presenter.CSS_CLASSES.CELL}`);&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function(isWCAGOn) {&#13;
        presenter.isWCAGOn = isWCAGOn;&#13;
    };&#13;
&#13;
    function CrosswordKeyboardController (elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
        this.updateMapping();&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    CrosswordKeyboardController.prototype.constructor = CrosswordKeyboardController;&#13;
&#13;
    CrosswordKeyboardController.prototype.exitWCAGMode = function () {&#13;
        KeyboardController.prototype.exitWCAGMode.call(this);&#13;
        presenter.setWCAGStatus(false);&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.updateMapping = function () {&#13;
        this.mapping[presenter.SPECIAL_KEYS.BACKSPACE] = this.executeBackspace;&#13;
        this.mapping[presenter.SPECIAL_KEYS.TAB] = this.nextTabIndexElement;&#13;
        this.shiftKeysMapping[presenter.SPECIAL_KEYS.TAB] = this.previousTabIndexElement;&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.enter = function (event) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
&#13;
        if (this.keyboardNavigationActive) {&#13;
            this.readCurrentElement();&#13;
            return;&#13;
        }&#13;
        this.keyboardNavigationActive = true;&#13;
        this.moveToFirstElement();&#13;
        this.readCurrentElementInShortForm();&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.moveToFirstElement = function () {&#13;
        var cellPosition;&#13;
        if (presenter.isWCAGOn) {&#13;
            cellPosition = presenter.correctAnswers[0]["position"];&#13;
        } else {&#13;
            var firstElement = findCellInputElement(presenter.tabIndexBase);&#13;
            cellPosition = getPositionOfCellInputElement($(firstElement));&#13;
        }&#13;
        if (!isPositionValid(cellPosition)) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.setTabIndexDirection();&#13;
        if (presenter.keyboardControllerObject.keyboardNavigationActive) {&#13;
            presenter.keyboardControllerObject.switchCellInputElement(cellPosition);&#13;
        } else {&#13;
            focusCellInputUsingPosition(cellPosition);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called tab&#13;
     @method nextTabIndexElement&#13;
    */&#13;
    CrosswordKeyboardController.prototype.nextTabIndexElement = function (event) {&#13;
        if (presenter.isAutoNavigationInExtendedMode()) {&#13;
            presenter.setTabIndexDirection();&#13;
        }&#13;
        moveToNextEditableTabIndexCellInput(event);&#13;
    };&#13;
&#13;
    function moveToNextEditableTabIndexCellInput(event, blurCurrentOnAbsenceOfNext = false) {&#13;
        _moveToCellInputWithGivenPosition(&#13;
            event,&#13;
            getNextTabIndexEditableCellPositionOfCellInput,&#13;
            blurCurrentOnAbsenceOfNext&#13;
        );&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called shift + tab&#13;
     @method previousTabIndexElement&#13;
    */&#13;
    CrosswordKeyboardController.prototype.previousTabIndexElement = function (event) {&#13;
        if (presenter.isAutoNavigationInExtendedMode()) {&#13;
            presenter.setTabIndexDirection();&#13;
        }&#13;
        moveToPreviousEditableTabIndexCellInput(event);&#13;
    };&#13;
&#13;
    function moveToPreviousEditableTabIndexCellInput(event, blurCurrentOnAbsenceOfNext = false) {&#13;
        _moveToCellInputWithGivenPosition(&#13;
            event,&#13;
            getPreviousTabIndexEditableCellPositionOfCellInput,&#13;
            blurCurrentOnAbsenceOfNext&#13;
        );&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called right arrow&#13;
     @method nextElement&#13;
    */&#13;
    CrosswordKeyboardController.prototype.nextElement = function (event) {&#13;
        if (presenter.isAutoNavigationInExtendedMode()&#13;
            || presenter.isAutoNavigationInSimpleMode()) {&#13;
            presenter.setHorizontalDirection();&#13;
        }&#13;
        moveToNextRightCellInput(event);&#13;
    };&#13;
&#13;
    function moveToNextRightCellInput(event, blurCurrentOnAbsenceOfNext = false) {&#13;
        _moveToCellInputWithGivenPosition(&#13;
            event,&#13;
            getNextRightCellPositionOfCellInput,&#13;
            blurCurrentOnAbsenceOfNext&#13;
        );&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called left arrow&#13;
     @method previousElement&#13;
    */&#13;
    CrosswordKeyboardController.prototype.previousElement = function (event) {&#13;
        if (presenter.isAutoNavigationInExtendedMode()&#13;
            || presenter.isAutoNavigationInSimpleMode()) {&#13;
            presenter.setHorizontalDirection();&#13;
        }&#13;
        moveToNextLeftCellInput(event);&#13;
    };&#13;
&#13;
    function moveToNextLeftCellInput(event, blurCurrentOnAbsenceOfNext = false) {&#13;
        _moveToCellInputWithGivenPosition(&#13;
            event,&#13;
            getNextLeftCellPositionOfCellInput,&#13;
            blurCurrentOnAbsenceOfNext&#13;
        );&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called down arrow&#13;
     @method nextRow&#13;
    */&#13;
    CrosswordKeyboardController.prototype.nextRow = function (event) {&#13;
        if (presenter.isAutoNavigationInExtendedMode()&#13;
            || presenter.isAutoNavigationInSimpleMode()) {&#13;
            presenter.setVerticalDirection();&#13;
        }&#13;
        moveToNextBottomCellInput(event);&#13;
    };&#13;
&#13;
    function moveToNextBottomCellInput(event, blurCurrentOnAbsenceOfNext = false) {&#13;
        _moveToCellInputWithGivenPosition(&#13;
            event,&#13;
            getNextBottomCellPositionOfCellInput,&#13;
            blurCurrentOnAbsenceOfNext&#13;
        );&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called up arrow&#13;
     @method previousRow&#13;
    */&#13;
    CrosswordKeyboardController.prototype.previousRow = function (event) {&#13;
        if (presenter.isAutoNavigationInExtendedMode()&#13;
            || presenter.isAutoNavigationInSimpleMode()) {&#13;
            presenter.setVerticalDirection();&#13;
        }&#13;
        moveToNextTopCellInput(event);&#13;
    };&#13;
&#13;
    function moveToNextTopCellInput(event, blurCurrentOnAbsenceOfNext = false) {&#13;
        _moveToCellInputWithGivenPosition(&#13;
            event,&#13;
            getNextTopCellPositionOfCellInput,&#13;
            blurCurrentOnAbsenceOfNext&#13;
        );&#13;
    }&#13;
&#13;
    function _moveToCellInputWithGivenPosition(event, getNewPosition, blurCurrentOnAbsenceOfNext = false) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
            event.stopPropagation();&#13;
        }&#13;
&#13;
        const currentCellInput = presenter.keyboardControllerObject.keyboardNavigationActive&#13;
            ? presenter.keyboardControllerObject.getCurrentInputElement()&#13;
            : event.target;&#13;
        const includeConstantCells = presenter.isWCAGOn;&#13;
        const nextCellPosition = getNewPosition(currentCellInput, includeConstantCells);&#13;
        if (!nextCellPosition) {&#13;
            if (blurCurrentOnAbsenceOfNext) {&#13;
                blurCellInput(currentCellInput);&#13;
            }&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.keyboardControllerObject.keyboardNavigationActive) {&#13;
            presenter.keyboardControllerObject.switchCellInputElement(nextCellPosition);&#13;
            presenter.keyboardControllerObject.readCurrentElementInShortForm();&#13;
        } else {&#13;
            focusCellInputUsingPosition(nextCellPosition);&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
     Action when was called backspace&#13;
     @method executeBackspace&#13;
    */&#13;
    CrosswordKeyboardController.prototype.executeBackspace = function (event) {&#13;
        handleBackspaceEvent(event);&#13;
    };&#13;
&#13;
    function handleBackspaceEvent(event) {&#13;
        if (event) {&#13;
            event.stopPropagation();&#13;
        }&#13;
&#13;
        var currentCellInput = presenter.keyboardControllerObject.keyboardNavigationActive&#13;
            ? presenter.keyboardControllerObject.getCurrentInputElement()&#13;
            : event.target;&#13;
        if (!$(currentCellInput).val()) {&#13;
            var nextCellPosition = getNextCellPositionForBackspaceAction(currentCellInput);&#13;
            if (!nextCellPosition) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (presenter.keyboardControllerObject.keyboardNavigationActive) {&#13;
                presenter.keyboardControllerObject.switchCellInputElement(nextCellPosition);&#13;
                if (!isPositionOfConstantCell(nextCellPosition)) {&#13;
                    $(presenter.keyboardControllerObject.getCurrentInputElement()).val('');&#13;
                }&#13;
                presenter.keyboardControllerObject.readCurrentElementInShortForm();&#13;
            } else {&#13;
                var $previousElement = $(getCellInput(nextCellPosition));&#13;
                $previousElement.focus();&#13;
                $previousElement.val('');&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getNextCellPositionForBackspaceAction(currentCellInput) {&#13;
        if (presenter.isTabIndexDirection() || presenter.isDirectionNotSet()) {&#13;
            const previousTabIndex = currentCellInput.tabIndex - 1;&#13;
            return getPositionOfCellInputElementWithTabIndex(previousTabIndex);&#13;
        }&#13;
&#13;
        const currentCellPosition = getPositionOfCellInputElement($(currentCellInput));&#13;
        if (presenter.isVerticalDirection()) {&#13;
            return getNextTopCellPosition(currentCellPosition, presenter.isWCAGOn);&#13;
        }&#13;
        return getNextLeftCellPosition(currentCellPosition, presenter.isWCAGOn);&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.switchCellInputElement = function (newPosition) {&#13;
        var newPositionIndex = this.calculateNewPositionIndex(newPosition);&#13;
        this.markCurrentElement(newPositionIndex);&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.calculateNewPositionIndex = function (newPosition) {&#13;
        var newPositionIndex = this.keyboardNavigationElements.toArray().findIndex(&#13;
            cellElement =&gt;&#13;
                $(cellElement).hasClass(`cell_row_${newPosition.y}`)&#13;
                &amp;&amp; $(cellElement).hasClass(`cell_column_${newPosition.x}`)&#13;
        );&#13;
&#13;
        if (newPositionIndex === -1) {&#13;
            newPositionIndex = this.keyboardNavigationCurrentElementIndex;&#13;
        } else if (newPositionIndex &gt;= this.keyboardNavigationElementsLen) {&#13;
            newPositionIndex = this.keyboardNavigationElementsLen;&#13;
        } else if (newPositionIndex &lt; 0) {&#13;
            newPositionIndex = this.keyboardNavigationElementsLen;&#13;
        }&#13;
        return newPositionIndex;&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.mark = function (element) {&#13;
        KeyboardController.prototype.mark.call(this, element);&#13;
        var inputCell = getElementInput(element);&#13;
        $(inputCell).focus();&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.unmark = function (element) {&#13;
        KeyboardController.prototype.unmark.call(this, element);&#13;
        var inputCell = getElementInput(element);&#13;
        $(inputCell).blur();&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.getTarget = function (element, willBeClicked) {&#13;
        return $(element);&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.getCurrentElementPosition = function () {&#13;
        return presenter.getPosition(this.getCurrentElement());&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.getCurrentElement = function () {&#13;
        return this.getTarget(this.keyboardNavigationCurrentElement, false);&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.getCurrentInputElement = function () {&#13;
        return $(this.getTarget(this.keyboardNavigationCurrentElement, false)).find("input")[0];&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.readCurrentElement = function () {&#13;
        var textVoiceObject = [];&#13;
        var cellInput = this.getCurrentInputElement();&#13;
        var currentPosition = getPositionOfCellInputElement($(cellInput));&#13;
&#13;
        this.addMessageAboutElementIndex(textVoiceObject, currentPosition);&#13;
&#13;
        if (presenter.wordNumbersHorizontal) {&#13;
            this.addMessageAboutHorizontalAnswer(textVoiceObject, currentPosition);&#13;
        }&#13;
&#13;
        if (presenter.wordNumbersVertical) {&#13;
            this.addMessageAboutVerticalAnswer(textVoiceObject, currentPosition);&#13;
        }&#13;
&#13;
        this.addMessageAboutValue(textVoiceObject, cellInput.value);&#13;
&#13;
        if (isPositionOfConstantCell(currentPosition)) {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Disabled);&#13;
        } else {&#13;
            this.addMessageAboutCorrectness(textVoiceObject);&#13;
        }&#13;
&#13;
        presenter.speak(textVoiceObject);&#13;
    };&#13;
&#13;
    CrosswordKeyboardController.prototype.readCurrentElementInShortForm = function () {&#13;
        var textVoiceObject = [];&#13;
        var cellInput = this.getCurrentInputElement();&#13;
        var currentPosition = getPositionOfCellInputElement($(cellInput));&#13;
&#13;
        this.addMessageAboutElementIndex(textVoiceObject, currentPosition);&#13;
        this.addMessageAboutValue(textVoiceObject, cellInput.value);&#13;
&#13;
        if (isPositionOfConstantCell(currentPosition)) {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Disabled);&#13;
        } else {&#13;
            this.addMessageAboutCorrectness(textVoiceObject);&#13;
        }&#13;
&#13;
        presenter.speak(textVoiceObject);&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.addMessageAboutElementIndex = function (textVoiceObject, position) {&#13;
        const alphabet = "ABCDEFGHIJKLMNOPRSTUWXYZ";&#13;
        const message = presenter.speechTexts.Cell&#13;
            + " " + alphabet[position.x % alphabet.length]&#13;
            + " " + (position.y + 1);&#13;
        pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, message);&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.addMessageAboutHorizontalAnswer = function (textVoiceObject, position) {&#13;
        var foundAnswer, trueLength, nextAnswer;&#13;
        for (var i = 0; i &lt; presenter.correctAnswers.length; i++) {&#13;
            nextAnswer = presenter.correctAnswers[i];&#13;
&#13;
            if (nextAnswer.isHorizontal) {&#13;
                trueLength = [...nextAnswer.answer].filter((x) =&gt; x !== '!').length;&#13;
                if (position.y === nextAnswer.position.y&#13;
                    &amp;&amp; nextAnswer.position.x &lt;= position.x&#13;
                    &amp;&amp; position.x &lt; nextAnswer.position.x + trueLength) {&#13;
                    foundAnswer = {...nextAnswer};&#13;
                    foundAnswer["id"] = i + 1;&#13;
                    foundAnswer["trueLength"] = trueLength;&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        if (foundAnswer) {&#13;
            const answerIDMessage = `${presenter.speechTexts.Across} ${foundAnswer.id}`;&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, answerIDMessage);&#13;
&#13;
            const relativePosition = position.x - foundAnswer.position.x + 1;&#13;
            const outOfMessage = `${relativePosition} ${presenter.speechTexts.OutOf} ${foundAnswer.trueLength}`;&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, outOfMessage);&#13;
        }&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.addMessageAboutVerticalAnswer = function (textVoiceObject, position) {&#13;
        var foundAnswer, trueLength, nextAnswer;&#13;
        for (var i = 0; i &lt; presenter.correctAnswers.length; i++) {&#13;
            nextAnswer = presenter.correctAnswers[i];&#13;
&#13;
            if (!nextAnswer.isHorizontal) {&#13;
                trueLength = [...nextAnswer.answer].filter((x) =&gt; x !== '!').length;&#13;
                if (position.x === nextAnswer.position.x&#13;
                    &amp;&amp; nextAnswer.position.y &lt;= position.y&#13;
                    &amp;&amp; position.y &lt; nextAnswer.position.y + trueLength) {&#13;
                    foundAnswer = {...nextAnswer};&#13;
                    foundAnswer["id"] = i + 1;&#13;
                    foundAnswer["trueLength"] = trueLength;&#13;
                    break;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        if (foundAnswer) {&#13;
            const answerIDMessage = `${presenter.speechTexts.Down} ${foundAnswer.id}`;&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, answerIDMessage);&#13;
&#13;
            const relativePosition = position.y - foundAnswer.position.y + 1;&#13;
            const outOfMessage = `${relativePosition} ${presenter.speechTexts.OutOf} ${foundAnswer.trueLength}`;&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, outOfMessage);&#13;
        }&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.addMessageAboutValue = function (textVoiceObject, value) {&#13;
        if (value) {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, value);&#13;
        } else {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Empty);&#13;
        }&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.addMessageAboutCorrectness = function (textVoiceObject) {&#13;
        var $cell = $(this.getCurrentElement());&#13;
        if ($cell.hasClass(presenter.CSS_CLASSES.CELL_VALID)) {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Correct);&#13;
        } else if ($cell.hasClass(presenter.CSS_CLASSES.CELL_INVALID)) {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Wrong);&#13;
        }&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.speakWrong = function () {&#13;
        var textVoiceObject = [];&#13;
&#13;
        pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Wrong);&#13;
&#13;
        presenter.speak(textVoiceObject);&#13;
    }&#13;
&#13;
    CrosswordKeyboardController.prototype.speakDisabled = function () {&#13;
        var textVoiceObject = [];&#13;
&#13;
        pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.Disabled);&#13;
&#13;
        presenter.speak(textVoiceObject);&#13;
    }&#13;
&#13;
    function pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, message) {&#13;
        pushMessageToTextVoiceObject(textVoiceObject, message, false);&#13;
    }&#13;
&#13;
    function pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, message) {&#13;
        pushMessageToTextVoiceObject(textVoiceObject, message, true);&#13;
    }&#13;
&#13;
    function pushMessageToTextVoiceObject(textVoiceObject, message, usePresenterLangTag = false) {&#13;
        if (usePresenterLangTag)&#13;
            textVoiceObject.push(window.TTSUtils.getTextVoiceObject(message, presenter.configuration.langTag));&#13;
        else&#13;
            textVoiceObject.push(window.TTSUtils.getTextVoiceObject(message));&#13;
    }&#13;
&#13;
    presenter.speak = function (data) {&#13;
        var tts = presenter.getTextToSpeechOrNull(playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function (playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    presenter.setPrintableState = function(state) {&#13;
        if (state === null || ModelValidationUtils.isStringEmpty(state))&#13;
            return;&#13;
&#13;
        presenter.printableState = JSON.parse(state);&#13;
    }&#13;
&#13;
    presenter.getPrintableHTML = function (model, showAnswers) {&#13;
        chosePrintableStateMode(showAnswers);&#13;
        const snapshot = createSnapshotOfVariables();&#13;
&#13;
        createPrintableBaseView(model);&#13;
        modifyViewAccordingToPrintableStateMode();&#13;
        const printableHTML = presenter.$view[0].outerHTML;&#13;
&#13;
        restoreSnapshotOfVariables(snapshot);&#13;
        presenter.printableStateMode = null;&#13;
&#13;
        return printableHTML;&#13;
    };&#13;
&#13;
    function createPrintableBaseView(model) {&#13;
        model = presenter.upgradeModel(model);&#13;
&#13;
        presenter.$view = $('&lt;div&gt;&lt;/div&gt;');&#13;
        presenter.$view.attr("id", model.ID);&#13;
        presenter.$view.addClass(presenter.CSS_CLASSES.PRINTABLE_ADDON);&#13;
&#13;
        presenter.printableConfiguration = presenter.readConfiguration(model);&#13;
        if (presenter.printableConfiguration.isError) {&#13;
            presenter.showErrorMessage(&#13;
                presenter.printableConfiguration.errorMessage,&#13;
                presenter.printableConfiguration.errorMessageSubstitutions&#13;
            );&#13;
            presenter.destroyCommands();&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.prepareGrid(model);&#13;
        presenter.prepareCorrectAnswers();&#13;
        presenter.createGrid();&#13;
    }&#13;
&#13;
    function chosePrintableStateMode(showAnswers) {&#13;
        if (presenter.printableState) {&#13;
            if (showAnswers)&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS;&#13;
            else&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS;&#13;
        } else {&#13;
            if (showAnswers)&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS;&#13;
            else&#13;
                presenter.printableStateMode = presenter.PRINTABLE_STATE_MODE.EMPTY;&#13;
        }&#13;
    }&#13;
&#13;
    function isInPrintableStateMode() {&#13;
        return presenter.printableStateMode !== null;&#13;
    }&#13;
&#13;
    function modifyViewAccordingToPrintableStateMode() {&#13;
        switch (presenter.printableStateMode) {&#13;
            case presenter.PRINTABLE_STATE_MODE.CHECK_ANSWERS:&#13;
                updateViewToCheckAnswersInPrintableStateMode();&#13;
                break;&#13;
            case presenter.PRINTABLE_STATE_MODE.SHOW_USER_ANSWERS:&#13;
                updateViewToShowUserAnswersInPrintableStateMode();&#13;
                break;&#13;
            case presenter.PRINTABLE_STATE_MODE.SHOW_ANSWERS:&#13;
                updateViewToShowAnswersInPrintableStateMode();&#13;
                break;&#13;
            case presenter.PRINTABLE_STATE_MODE.EMPTY:&#13;
                updateViewToEmptyStateInPrintableStateMode();&#13;
                break;&#13;
        }&#13;
        replaceInputElementsByPrintableDivs();&#13;
    }&#13;
&#13;
    function updateViewToCheckAnswersInPrintableStateMode() {&#13;
        setUserAnswersFromPrintableState();&#13;
        presenter.replaceAnswersBySavedUserAnswers();&#13;
&#13;
        if (!presenter.isAttempted()) {&#13;
            return;&#13;
        }&#13;
        validateForPrintable();&#13;
    }&#13;
&#13;
    function validateForPrintable() {&#13;
        presenter.validate(presenter.VALIDATION_MODE.SHOW_ERRORS);&#13;
        for (let row = 0; row &lt; presenter.rowCount; row++) {&#13;
            for (let column = 0; column &lt; presenter.columnCount; column++) {&#13;
                let $cell = presenter.$view.find(`.${presenter.CSS_CLASSES.PRINTABLE}_cell_${row}x${column}`);&#13;
                if ($cell.hasClass(presenter.CSS_CLASSES.CELL_VALID)) {&#13;
                    $cell.append(getPrintableGapSignHTML(true));&#13;
                    $cell.removeClass(presenter.CSS_CLASSES.CELL_VALID);&#13;
                    $cell.addClass(presenter.CSS_CLASSES.PRINTABLE_CELL_VALID);&#13;
                } else if ($cell.hasClass(presenter.CSS_CLASSES.CELL_INVALID)) {&#13;
                    $cell.append(getPrintableGapSignHTML(false));&#13;
                    $cell.removeClass(presenter.CSS_CLASSES.CELL_INVALID);&#13;
                    $cell.addClass(presenter.CSS_CLASSES.PRINTABLE_CELL_INVALID);&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getPrintableGapSignHTML(isCorrectAnswer) {&#13;
        const $sign = $("&lt;span&gt;&lt;/span&gt;");&#13;
        if (isCorrectAnswer) {&#13;
            $sign.addClass(presenter.CSS_CLASSES.PRINTABLE_SIGN_VALID);&#13;
        } else {&#13;
            $sign.addClass(presenter.CSS_CLASSES.PRINTABLE_SIGN_INVALID);&#13;
        }&#13;
        return $sign;&#13;
    }&#13;
&#13;
    function updateViewToShowUserAnswersInPrintableStateMode() {&#13;
        setUserAnswersFromPrintableState();&#13;
        presenter.replaceAnswersBySavedUserAnswers();&#13;
    }&#13;
&#13;
    function setUserAnswersFromPrintableState() {&#13;
        presenter.userAnswers = [];&#13;
&#13;
        let cells;&#13;
        if (presenter.printableState.hasOwnProperty("cells")) {&#13;
            cells = presenter.printableState.cells;&#13;
        } else {&#13;
            cells = presenter.printableState;&#13;
        }&#13;
        let counter = 0;&#13;
        for (let i = 0; i &lt; presenter.rowCount; i++) {&#13;
            let row = [];&#13;
            for (let j = 0; j &lt; presenter.columnCount; j++) {&#13;
                row.push(cells[counter]);&#13;
                counter++;&#13;
            }&#13;
            presenter.userAnswers.push(row);&#13;
        }&#13;
    }&#13;
&#13;
    function updateViewToShowAnswersInPrintableStateMode() {&#13;
        presenter.replaceUserAnswersByModelAnswers();&#13;
    }&#13;
&#13;
    function updateViewToEmptyStateInPrintableStateMode() {}&#13;
&#13;
    function replaceInputElementsByPrintableDivs() {&#13;
        presenter.$view.find(".printable_cell_letter input").replaceWith(function() {&#13;
            let $cellContent = $('&lt;div&gt;' + $(this).val() + '&lt;/div&gt;');&#13;
            $cellContent.addClass(presenter.CSS_CLASSES.PRINTABLE_CELL_LETTER_CONTENT);&#13;
            return $cellContent&#13;
        });&#13;
    }&#13;
&#13;
    function createSnapshotOfVariables() {&#13;
        return {&#13;
            crossword: presenter.crossword,&#13;
            rowCount: presenter.rowCount,&#13;
            columnCount: presenter.columnCount,&#13;
            cellHeight: presenter.cellHeight,&#13;
            cellWidth: presenter.cellWidth,&#13;
            blankCellsBorderStyle: presenter.blankCellsBorderStyle,&#13;
            blankCellsBorderWidth: presenter.blankCellsBorderWidth,&#13;
            blankCellsBorderColor: presenter.blankCellsBorderColor,&#13;
            letterCellsBorderStyle: presenter.letterCellsBorderStyle,&#13;
            letterCellsBorderWidth: presenter.letterCellsBorderWidth,&#13;
            letterCellsBorderColor: presenter.letterCellsBorderColor,&#13;
            wordNumbersHorizontal: presenter.wordNumbersHorizontal,&#13;
            wordNumbersVertical: presenter.wordNumbersVertical,&#13;
            showAllAnswersInGradualShowAnswersMode: presenter.showAllAnswersInGradualShowAnswersMode,&#13;
            disableAutomaticWordNumbering: presenter.disableAutomaticWordNumbering,&#13;
            blockWrongAnswers: presenter.blockWrongAnswers,&#13;
            isVisibleByDefault: presenter.isVisibleByDefault,&#13;
            markedColumnIndex: presenter.markedColumnIndex,&#13;
            markedRowIndex: presenter.markedRowIndex,&#13;
            autoNavigationMode: autoNavigationMode,&#13;
&#13;
            $view: presenter.$view,&#13;
            tabIndexBase: presenter.tabIndexBase,&#13;
            maxTabIndex: presenter.maxTabIndex,&#13;
            numberOfConstantLetters: presenter.numberOfConstantLetters,&#13;
            maxScore: presenter.maxScore,&#13;
            areUserAnswersSaved: presenter.areUserAnswersSaved,&#13;
            configuration: {...presenter.configuration},&#13;
            correctAnswers: [...presenter.correctAnswers]&#13;
        }&#13;
    }&#13;
&#13;
    function restoreSnapshotOfVariables(snapshot) {&#13;
        Object.keys(snapshot).forEach(function(key) {&#13;
            if (presenter.hasOwnProperty(key)) {&#13;
                presenter[key] = snapshot[key];&#13;
            } else {&#13;
                switch (key.toString()) {&#13;
                    case "autoNavigationMode":&#13;
                        autoNavigationMode = snapshot[key];&#13;
                        break;&#13;
                    default:&#13;
                        break;&#13;
                }&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    function addClass($element, className) {&#13;
        if (isInPrintableStateMode()) {&#13;
            className = presenter.CSS_CLASSES.PRINTABLE + "_" + className;&#13;
        }&#13;
        $element.addClass(className);&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>