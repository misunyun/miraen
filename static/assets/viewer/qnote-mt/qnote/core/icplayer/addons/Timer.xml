<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Timer" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="Mode" nameLabel="Timer_property_mode" type="{Timer, Stopwatch}"/>
        <property name="Time" nameLabel="Timer_property_time" type="string"/>
        <property name="Immediate start" nameLabel="Timer_property_immediate_start" type="boolean"/>
        <property name="Send event every second" nameLabel="Timer_property_send_event_every_second" type="boolean"/>
        <property name="Show hours" nameLabel="Timer_property_show_hours" type="boolean"/>
        <property name="Enable reset" nameLabel="Timer_property_enable_reset" type="boolean"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="Timer_property_speech_texts" type="staticlist">
            <property name="TimerStarted" nameLabel="Timer_property_timer_started" type="staticrow">
                    <property name="TimerStarted" nameLabel="Timer_property_timer_started" type="string"/>
            </property>
            <property name="TimerStopped" nameLabel="Timer_property_timer_stopped" type="staticrow">
                    <property name="TimerStopped" nameLabel="Timer_property_timer_stopped" type="string"/>
            </property>
            <property name="TimerEnded" nameLabel="Timer_property_timer_ended" type="staticrow">
                    <property name="TimerEnded" nameLabel="Timer_property_timer_ended" type="string"/>
            </property>
            <property name="StopwatchStarted" nameLabel="Timer_property_stopwatch_started" type="staticrow">
                    <property name="StopwatchStarted" nameLabel="Timer_property_stopwatch_started" type="string"/>
            </property>
            <property name="StopwatchStopped" nameLabel="Timer_property_stopwatch_stopped" type="staticrow">
                    <property name="StopwatchStopped" nameLabel="Timer_property_stopwatch_stopped" type="string"/>
            </property>
            <property name="Hours" nameLabel="Timer_property_hours" type="staticrow">
                    <property name="Hours" nameLabel="Timer_property_hours" type="string"/>
            </property>
            <property name="Minutes" nameLabel="Timer_property_minutes" type="staticrow">
                    <property name="Minutes" nameLabel="Timer_property_minutes" type="string"/>
            </property>
            <property name="Seconds" nameLabel="Timer_property_seconds" type="staticrow">
                    <property name="Seconds" nameLabel="Timer_property_seconds" type="string"/>
            </property>
        </property>
    </model>
<css>.timer-wrapper .separator:after{&#13;
    content: ':';&#13;
}&#13;
</css><view>&lt;div class="timer-wrapper"&gt;&#13;
    &lt;span class="hours"&gt;&lt;/span&gt;&#13;
    &lt;span class="separator hours-separator"&gt;&lt;/span&gt;&#13;
    &lt;span class="minutes"&gt;&lt;/span&gt;&#13;
    &lt;span class="separator minutes-separator"&gt;&lt;/span&gt;&#13;
    &lt;span class="seconds"&gt;&lt;/span&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="timer-wrapper"&gt;&#13;
    &lt;span class="hours"&gt;&lt;/span&gt;&#13;
    &lt;span class="separator hours-separator"&gt;&lt;/span&gt;&#13;
    &lt;span class="minutes"&gt;&lt;/span&gt;&#13;
    &lt;span class="separator minutes-separator"&gt;&lt;/span&gt;&#13;
    &lt;span class="seconds"&gt;&lt;/span&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonTimer_create(){&#13;
&#13;
	var presenter = function(){};&#13;
	presenter.keyboardControllerObject = null;&#13;
	presenter.isWCAGOn = false;&#13;
&#13;
	presenter.configuration = {&#13;
		isValid: true,&#13;
		mode: "",&#13;
		isFired: false,&#13;
		time: 0,&#13;
		alarmTime: 0,&#13;
		immediateStart: false,&#13;
		sendEvent: false,&#13;
		isVisible: false,&#13;
		showHours: false,&#13;
		enableReset: false,&#13;
		errorCode: "Z01",&#13;
		addonID: ""&#13;
	};&#13;
&#13;
	presenter.state = {&#13;
		isFired: false,&#13;
		isVisible: false,&#13;
		currentTime: 0,&#13;
		interval: null,&#13;
		nowStart: false,&#13;
		showHours: false&#13;
	};&#13;
&#13;
	presenter.ERROR_CODES = {&#13;
		"Z01": "None",&#13;
        "T01": "Wrong time"&#13;
    };&#13;
&#13;
	presenter.MODE = {&#13;
        'Timer': 'Timer',&#13;
		'Stopwatch': 'Stopwatch',&#13;
        DEFAULT: 'Timer'&#13;
    };&#13;
&#13;
	presenter.DEFAULT_TTS_PHRASES = {&#13;
        TIMER_STARTED: "Timer started",&#13;
        TIMER_STOPPED: "Timer stopped",&#13;
        TIMER_ENDED: "Timer ended",&#13;
        STOPWATCH_STARTED: "Stopwatch started",&#13;
        STOPWATCH_STOPPED: "Stopwatch stopped",&#13;
        HOURS: "Hours",&#13;
        MINUTES: "Minutes",&#13;
        SECONDS: "Seconds"&#13;
    };&#13;
&#13;
	presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = presenter.playerController.getEventBus();&#13;
    };&#13;
&#13;
	presenter.createEventData = function(value) {&#13;
        return {&#13;
            source : presenter.configuration.addonID,&#13;
            value : value&#13;
        };&#13;
    };&#13;
&#13;
	presenter.triggerEvent = function(value) {&#13;
        var eventData = presenter.createEventData(value);&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
		if (value === 'end') {&#13;
			presenter.readOnEnd();&#13;
		}&#13;
    };&#13;
&#13;
	presenter.executeCommand = function (name, params) {&#13;
&#13;
		var commands = {&#13;
			'start': presenter.start,&#13;
			'stop': presenter.stop,&#13;
			'show': presenter.show,&#13;
			'hide': presenter.hide,&#13;
			'reset': presenter.reset,&#13;
			'getTime': presenter.getTime,&#13;
			'addTime': presenter.addTime,&#13;
			'setTime': presenter.setTime,&#13;
			'showHoursPart': presenter.showHoursPart,&#13;
			'hideHoursPart': presenter.hideHoursPart&#13;
		};&#13;
&#13;
		Commands.dispatch(commands, name, params, presenter);&#13;
	};&#13;
&#13;
	presenter.start = function(shouldReadTTS = true) {&#13;
        presenter.countDown();&#13;
		presenter.state.nowStart = true;&#13;
		if (shouldReadTTS) {&#13;
			presenter.readOnStart();&#13;
		}&#13;
    };&#13;
&#13;
	presenter.stop = function(shouldReadTTS = true) {&#13;
        clearInterval(presenter.state.interval);&#13;
		presenter.state.isFired = false;&#13;
		presenter.state.nowStart = false;&#13;
		if (shouldReadTTS) {&#13;
			presenter.readOnStop();&#13;
		}&#13;
    };&#13;
&#13;
	presenter.show = function() {&#13;
		presenter.displayhhmmss(presenter.state.currentTime);&#13;
        presenter.setVisibility(true);&#13;
		if (presenter.state.showHours) {&#13;
			presenter.showHoursPart();&#13;
		}&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
		presenter.$view.find('.timer-wrapper .hours').css("visibility", "hidden");&#13;
		presenter.$view.find('.timer-wrapper .hours-separator').css("visibility", "hidden");&#13;
    };&#13;
&#13;
	presenter.updateVisibility = function() {&#13;
        (presenter.state.isVisible) ? presenter.show() : presenter.hide();&#13;
    };&#13;
&#13;
	presenter.reset = function() {&#13;
		if (presenter.configuration.enableReset) {&#13;
			clearInterval(presenter.state.interval);&#13;
			presenter.state.isFired = false;&#13;
			presenter.state.currentTime = presenter.configuration.time;&#13;
			presenter.displayhhmmss(presenter.state.currentTime);&#13;
			presenter.state.isVisible = presenter.configuration.isVisible;&#13;
			presenter.setVisibility(presenter.state.isVisible);&#13;
			presenter.state.nowStart = presenter.configuration.immediateStart;&#13;
			if (presenter.state.nowStart) {&#13;
				presenter.start();&#13;
			}&#13;
		}&#13;
    };&#13;
&#13;
	presenter.getTime = function() {&#13;
		var newTime = timeToHMMSS(presenter.state.currentTime);&#13;
		var time = (newTime.hours &gt; 0|| presenter.state.showHours) ? (newTime.hours +':') : ('');&#13;
		time += newTime.minutes+':'+newTime.seconds;&#13;
		return time;&#13;
    };&#13;
&#13;
	presenter.setTime = function(time) {&#13;
		var timeInSeconds = validateTime('Timer',time,false);&#13;
		if (timeInSeconds.isValid) {&#13;
			presenter.state.currentTime = timeInSeconds.time;&#13;
			presenter.displayhhmmss(presenter.state.currentTime);&#13;
		}&#13;
    };&#13;
&#13;
	presenter.addTime = function(time) {&#13;
		if (!isNaN(time)) {&#13;
			presenter.state.currentTime += parseInt(time);&#13;
			presenter.displayhhmmss(presenter.state.currentTime);&#13;
		}&#13;
    };&#13;
&#13;
	presenter.showHoursPart = function() {&#13;
        presenter.state.showHours = true;&#13;
		presenter.$view.find('.timer-wrapper .hours').css("visibility", "visible");&#13;
		presenter.$view.find('.timer-wrapper .hours-separator').css("visibility", "visible");&#13;
    };&#13;
&#13;
	presenter.hideHoursPart = function() {&#13;
        presenter.state.showHours = false;&#13;
		presenter.$view.find('.timer-wrapper .hours').css("visibility", "hidden");&#13;
		presenter.$view.find('.timer-wrapper .hours-separator').css("visibility", "hidden");&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.state.isVisible = isVisible;&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
	var validateTime = function (mode,time,isAlarm) {&#13;
		if ((mode === 'Timer' &amp;&amp; isAlarm === true) || (mode === 'Stopwatch' &amp;&amp; isAlarm === false) || (mode === 'Stopwatch' &amp;&amp; isAlarm === true &amp;&amp; time === '')) {&#13;
			return {&#13;
				time: 0,&#13;
				isValid: true&#13;
			}&#13;
		}&#13;
		var parts = time.split(':');&#13;
		var timeInSeconds;&#13;
&#13;
		if (parts.length !== 2 &amp;&amp; parts.length !== 3) {&#13;
			return {&#13;
				isValid: false,&#13;
				errorCode: "T01"&#13;
			}&#13;
		} else {&#13;
			$.each(parts, function(k,v){&#13;
				if(v !== parseInt(v) || v &lt; 0 || v &gt; 59) {&#13;
					return {&#13;
						isValid: false,&#13;
						errorCode: "T01"&#13;
					}&#13;
				}&#13;
			});&#13;
		}&#13;
		if (parts.length === 2) {&#13;
			timeInSeconds = parseInt(parts[0])*60 + parseInt(parts[1]);&#13;
		} else {&#13;
			timeInSeconds = parseInt(parts[0])*3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);&#13;
		}&#13;
		return {&#13;
			time: timeInSeconds,&#13;
			isValid: true&#13;
		};&#13;
	};&#13;
&#13;
	presenter.displayhhmmss = function (totalSeconds) {&#13;
		var newTime = timeToHMMSS(totalSeconds);&#13;
		presenter.$view.find('.timer-wrapper .hours').html(newTime.hours);&#13;
		presenter.$view.find('.timer-wrapper .minutes').html(newTime.minutes);&#13;
		presenter.$view.find('.timer-wrapper .seconds').html(newTime.seconds);&#13;
	};&#13;
&#13;
	var timeToHMMSS = function (totalSeconds) {&#13;
		var hour = Math.floor(totalSeconds / 3600);&#13;
		var minute = Math.floor((totalSeconds - (hour * 3600)) / 60);&#13;
		var second = totalSeconds - (hour * 3600) - (minute * 60);&#13;
		if (minute &lt; 10) {&#13;
			minute = '0' + minute;&#13;
		}&#13;
		if (second &lt; 10) {&#13;
			second = '0' + second;&#13;
		}&#13;
		return {&#13;
			hours: hour,&#13;
			minutes: minute,&#13;
			seconds: second&#13;
		}&#13;
	};&#13;
&#13;
	presenter.countDown = function () {&#13;
		if (!presenter.state.isFired) {&#13;
			presenter.state.isFired = true;&#13;
			presenter.state.interval = setInterval(function() {&#13;
				if (presenter.configuration.mode === 'Timer' &amp;&amp; presenter.state.currentTime &gt; 0) {&#13;
					presenter.state.currentTime--&#13;
				} else if (presenter.configuration.mode === 'Stopwatch') {&#13;
					presenter.state.currentTime++;&#13;
				}&#13;
				var newTime = timeToHMMSS(presenter.state.currentTime);&#13;
				if (presenter.state.isVisible) {&#13;
					presenter.displayhhmmss(presenter.state.currentTime);&#13;
				}&#13;
				if (presenter.configuration.sendEvent) {&#13;
					var eventTime = (newTime.hours &gt; 0) ? (newTime.hours +':') : ('');&#13;
					eventTime += newTime.minutes+':'+newTime.seconds;&#13;
					presenter.triggerEvent(eventTime);&#13;
				}&#13;
				if (presenter.configuration.mode === 'Timer' &amp;&amp; presenter.state.currentTime === 0) {&#13;
					presenter.triggerEvent('end');&#13;
					presenter.state.isFired = false;&#13;
					presenter.state.nowStart = false;&#13;
					clearInterval(presenter.state.interval);&#13;
				}&#13;
				if (presenter.configuration.mode === 'Stopwatch' &amp;&amp; presenter.configuration.alarmTime === presenter.state.currentTime) {&#13;
					presenter.triggerEvent('time');&#13;
				}&#13;
			}, 1000);&#13;
		}&#13;
	};&#13;
&#13;
	presenter.upgradeModel = function (model) {&#13;
		return presenter.upgradeModelWithSpeechTexts(model);&#13;
	};&#13;
&#13;
	presenter.upgradeModelWithSpeechTexts = function (model) {&#13;
		const upgradedModel = {};&#13;
		const defaultValue = {&#13;
			TimerStarted: {TimerStarted: ''},&#13;
			TimerStopped: {TimerStopped: ''},&#13;
			TimerEnded: {TimerEnded: ''},&#13;
			StopwatchStarted: {StopwatchStarted: ''},&#13;
			StopwatchStopped: {StopwatchStopped: ''},&#13;
			Hours: {Hours: ''},&#13;
			Minutes: {Minutes: ''},&#13;
			Seconds: {Seconds: ''}&#13;
		};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
		if (!upgradedModel.hasOwnProperty('speechTexts')) {&#13;
			upgradedModel['speechTexts'] = defaultValue;&#13;
		}&#13;
&#13;
		return upgradedModel;&#13;
	};&#13;
&#13;
	presenter.validateModel = function(model) {&#13;
		var mode = ModelValidationUtils.validateOption(presenter.MODE, model.Mode);&#13;
		var validatedTime = validateTime(mode,model['Time'],false);&#13;
		if (!validatedTime.isValid) {&#13;
			return {&#13;
				isValid: false,&#13;
				errorCode: validatedTime.errorCode&#13;
			};&#13;
		}&#13;
		var validatedAlarm = validateTime(mode,model['Time'],true);&#13;
		if (!validatedAlarm.isValid) {&#13;
			return {&#13;
				isValid: false,&#13;
				errorCode: validatedAlarm.errorCode&#13;
			};&#13;
		}&#13;
		return {&#13;
			isValid: true,&#13;
			mode: mode,&#13;
			isFired: false,&#13;
			time: validatedTime.time,&#13;
			alarmTime: validatedAlarm.time,&#13;
			immediateStart: ModelValidationUtils.validateBoolean(model['Immediate start']),&#13;
			sendEvent: ModelValidationUtils.validateBoolean(model['Send event every second']),&#13;
			isVisible: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
			showHours: ModelValidationUtils.validateBoolean(model["Show hours"]),&#13;
			enableReset: ModelValidationUtils.validateBoolean(model["Enable reset"]),&#13;
			addonID: model['ID']&#13;
		};&#13;
	};&#13;
&#13;
	presenter.initiate = function(view, model, isPreview) {&#13;
		const upgradedModel = presenter.upgradeModel(model);&#13;
		const validatedModel = presenter.validateModel(model);&#13;
		if (!validatedModel.isValid) {&#13;
			DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, validatedModel.errorCode);&#13;
			return;&#13;
		}&#13;
		presenter.configuration = validatedModel;&#13;
		presenter.view = view;&#13;
		presenter.$view = $(view);&#13;
		presenter.state.currentTime = presenter.configuration.time;&#13;
		presenter.state.nowStart = presenter.configuration.immediateStart;&#13;
		presenter.state.showHours = presenter.configuration.showHours;&#13;
		if (!presenter.state.showHours) {&#13;
			presenter.$view.find('.timer-wrapper .hours').css("visibility", "hidden");&#13;
			presenter.$view.find('.timer-wrapper .hours-separator').css("visibility", "hidden");&#13;
		}&#13;
        presenter.state.isVisible = presenter.configuration.isVisible;&#13;
		presenter.displayhhmmss(presenter.state.currentTime);&#13;
		if (!isPreview &amp;&amp; presenter.state.nowStart) {&#13;
			presenter.countDown();&#13;
		}&#13;
		presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved(event) {&#13;
            if (event.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
		presenter.setSpeechTexts(upgradedModel);&#13;
		presenter.buildKeyboardController();&#13;
	};&#13;
&#13;
	presenter.destroy = function (event) {&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        clearInterval(presenter.state.interval);&#13;
    };&#13;
&#13;
	presenter.run = function(view, model){&#13;
		presenter.initiate(view, model,false);&#13;
	};&#13;
&#13;
	presenter.createPreview = function(view, model){&#13;
		presenter.initiate(view, model,true);&#13;
	};&#13;
&#13;
	presenter.getErrorCount = function(){&#13;
		return 0;&#13;
	};&#13;
&#13;
	presenter.getMaxScore = function(){&#13;
		return 0;&#13;
	};&#13;
&#13;
	presenter.getScore = function(){&#13;
		return 0;&#13;
	};&#13;
&#13;
	presenter.getState = function(){&#13;
		return JSON.stringify({&#13;
            currentTime : presenter.state.currentTime,&#13;
            visible : presenter.state.isVisible,&#13;
			nowStart : presenter.state.nowStart,&#13;
			showHours : presenter.state.showHours&#13;
        });&#13;
	};&#13;
&#13;
	presenter.setState = function(state){&#13;
		var parsedState = JSON.parse(state);&#13;
		presenter.state.isVisible = parsedState.visible;&#13;
		presenter.state.showHours = parsedState.showHours;&#13;
		presenter.state.currentTime = parsedState.currentTime;&#13;
		presenter.displayhhmmss(presenter.state.currentTime);&#13;
		presenter.state.nowStart = parsedState.nowStart;&#13;
		if (presenter.state.nowStart) {&#13;
			presenter.start(false);&#13;
		} else {&#13;
			presenter.stop(false);&#13;
		}&#13;
		presenter.updateVisibility();&#13;
		if (presenter.state.isVisible &amp;&amp; presenter.state.showHours) {&#13;
			presenter.showHoursPart();&#13;
		}&#13;
	};&#13;
&#13;
	presenter.setWCAGStatus = function(isWCAGOn) {&#13;
        presenter.isWCAGOn = isWCAGOn;&#13;
    };&#13;
&#13;
	presenter.keyboardController = function (keycode, isShiftKeyDown, event) {&#13;
		presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
	};&#13;
	&#13;
	presenter.buildKeyboardController = function () {&#13;
		const elements = presenter.getElementsForKeyboardNavigation();&#13;
		presenter.keyboardControllerObject =&#13;
			new TimerKeyboardController(elements);&#13;
	};&#13;
&#13;
	presenter.setSpeechTexts = function (model) {&#13;
		const speechTexts = model['speechTexts'];&#13;
		presenter.speechTexts = {&#13;
			TimerStarted: presenter.DEFAULT_TTS_PHRASES.TIMER_STARTED,&#13;
			TimerStopped: presenter.DEFAULT_TTS_PHRASES.TIMER_STOPPED,&#13;
			TimerEnded: presenter.DEFAULT_TTS_PHRASES.TIMER_ENDED,&#13;
			StopwatchStarted: presenter.DEFAULT_TTS_PHRASES.STOPWATCH_STARTED,&#13;
			StopwatchStopped: presenter.DEFAULT_TTS_PHRASES.STOPWATCH_STOPPED,&#13;
			Hours: presenter.DEFAULT_TTS_PHRASES.HOURS,&#13;
			Minutes: presenter.DEFAULT_TTS_PHRASES.MINUTES,&#13;
			Seconds: presenter.DEFAULT_TTS_PHRASES.SECONDS,&#13;
		};&#13;
&#13;
		if(!speechTexts || $.isEmptyObject(speechTexts)) {&#13;
			return;&#13;
		}&#13;
&#13;
		presenter.speechTexts = {&#13;
			TimerStarted: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.TimerStarted.TimerStarted,&#13;
				presenter.speechTexts.TimerStarted&#13;
			),&#13;
			TimerStopped: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.TimerStopped.TimerStopped,&#13;
				presenter.speechTexts.TimerStopped&#13;
			),&#13;
			TimerEnded: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.TimerEnded.TimerEnded,&#13;
				presenter.speechTexts.TimerEnded&#13;
			),&#13;
			StopwatchStarted: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.StopwatchStarted.StopwatchStarted,&#13;
				presenter.speechTexts.StopwatchStarted&#13;
			),&#13;
			StopwatchStopped: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.StopwatchStopped.StopwatchStopped,&#13;
				presenter.speechTexts.StopwatchStopped&#13;
			),&#13;
			Hours: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.Hours.Hours,&#13;
				presenter.speechTexts.Hours&#13;
			),&#13;
			Minutes: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.Minutes.Minutes,&#13;
				presenter.speechTexts.Minutes&#13;
			),&#13;
			Seconds: TTSUtils.getSpeechTextProperty(&#13;
				speechTexts.Seconds.Seconds,&#13;
				presenter.speechTexts.Seconds&#13;
			),&#13;
		};&#13;
	};&#13;
&#13;
	presenter.getElementsForKeyboardNavigation = function () {&#13;
		return presenter.$view.find('.timer-wrapper');&#13;
	};&#13;
&#13;
	function TimerKeyboardController(elements) {&#13;
		KeyboardController.call(this, elements, 1);&#13;
	}&#13;
&#13;
	TimerKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
	TimerKeyboardController.prototype.constructor = TimerKeyboardController;&#13;
&#13;
	TimerKeyboardController.prototype.getCurrentElement = function () {&#13;
		return this.getTarget(this.keyboardNavigationCurrentElement, false);&#13;
	};&#13;
&#13;
	TimerKeyboardController.prototype.getTarget = function (element, willBeClicked) {&#13;
        return $(element);&#13;
    };&#13;
&#13;
	TimerKeyboardController.prototype.select = function (event) {&#13;
		if (event){&#13;
			event.preventDefault();&#13;
		}&#13;
&#13;
		this.selectAction();&#13;
	};&#13;
&#13;
	TimerKeyboardController.prototype.enter = function (event) {&#13;
		KeyboardController.prototype.enter.call(this, event);&#13;
		this.readCurrentElement();&#13;
	};&#13;
&#13;
	TimerKeyboardController.prototype.readCurrentElement = function () {&#13;
		presenter.speak(presenter.getTextToRead());&#13;
	};&#13;
&#13;
	presenter.readOnStart = function () {&#13;
		const textToRead = presenter.configuration.mode === 'Timer' ?&#13;
			presenter.speechTexts.TimerStarted : presenter.speechTexts.StopwatchStarted;&#13;
&#13;
		presenter.speak(textToRead, true);&#13;
	};&#13;
&#13;
&#13;
	presenter.readOnEnd = function () {&#13;
		presenter.speak(presenter.speechTexts.TimerEnded);&#13;
	};&#13;
&#13;
	presenter.readOnStop = function () {&#13;
		const textToRead = presenter.configuration.mode === 'Timer' ?&#13;
			presenter.speechTexts.TimerStopped : presenter.speechTexts.StopwatchStopped;&#13;
&#13;
		presenter.speak(textToRead, true);&#13;
	};&#13;
	&#13;
	presenter.speak = function (data, shouldRunWithOffset = false) {&#13;
		const tts = presenter.getTextToSpeechOrNull();&#13;
		const isWCAGActive = presenter.playerController.isWCAGOn();&#13;
		if (!(tts &amp;&amp; isWCAGActive)) { return; }&#13;
&#13;
		if (shouldRunWithOffset) {&#13;
			setTimeout(() =&gt; {&#13;
				presenter.waitForEndSpeaking(tts.speak, data);&#13;
			}, 400);&#13;
		} else {&#13;
			tts.speak(data);&#13;
		}&#13;
	};&#13;
&#13;
	presenter.waitForEndSpeaking = function(callback, data, timeout = 5000) {&#13;
        const startTime = Date.now();&#13;
&#13;
        let interval = setInterval(() =&gt; {&#13;
            if (!window.speechSynthesis.speaking) {&#13;
                clearInterval(interval);&#13;
                callback(data);&#13;
            } else if (Date.now() - startTime &gt; timeout) {&#13;
                clearInterval(interval);&#13;
            }&#13;
        }, 100);&#13;
    };&#13;
&#13;
	presenter.getTextToSpeechOrNull = function () {&#13;
		if (presenter.playerController) {&#13;
			return presenter.playerController.getModule('Text_To_Speech1');&#13;
		}&#13;
&#13;
		return null;&#13;
	};&#13;
&#13;
	presenter.getTextToRead = function () {&#13;
		if (presenter.state.currentTime === 0) {&#13;
			return `0 ${presenter.speechTexts.Seconds}`;&#13;
		}&#13;
&#13;
		const timerValues = presenter.getTime().split(':');&#13;
		let hours, minutes, seconds = 0;&#13;
		let text = '';&#13;
		if (timerValues.length &gt; 2) {&#13;
			hours = +timerValues[0];&#13;
			minutes = +timerValues[1];&#13;
			seconds = +timerValues[2];&#13;
		} else {&#13;
			minutes = +timerValues[0];&#13;
			seconds = +timerValues[1];&#13;
		}&#13;
&#13;
		if (hours &amp;&amp; +hours &gt; 0) {&#13;
			text += `${hours} ${presenter.speechTexts.Hours},`;&#13;
		}&#13;
&#13;
		if (minutes &amp;&amp; +minutes &gt; 0 || !text) {&#13;
			text += `${minutes} ${presenter.speechTexts.Minutes},`;&#13;
		}&#13;
&#13;
		if (seconds &amp;&amp; +seconds &gt; 0 || !text) {&#13;
			text += `${seconds} ${presenter.speechTexts.Seconds}`;&#13;
		}&#13;
&#13;
		return text;&#13;
	};&#13;
&#13;
	presenter.isSelectable = function(isWCAGOn) {&#13;
	    return isWCAGOn;&#13;
	}&#13;
&#13;
	return presenter;&#13;
}&#13;
</presenter></addon>