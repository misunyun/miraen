<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Magic_Boxes" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property isLocalized="true" name="Grid" nameLabel="Magic_Boxes_property_grid" type="text"/>
        <property isLocalized="true" name="Answers" nameLabel="Magic_Boxes_property_answers" type="text"/>
        <property displayName="Check By Words" name="CheckByWords" nameLabel="Magic_Boxes_property_check_by_words" type="boolean"/>
        <property displayName="Lang attribute" name="langAttribute" nameLabel="Magic_Boxes_property_lang_attribute" type="string"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="Magic_Boxes_property_speech_texts" type="staticlist">
            <property name="Cell" nameLabel="Magic_Boxes_property_speech_text_cell" type="staticrow">
                <property name="Cell" nameLabel="Magic_Boxes_property_speech_text_cell" type="string"/>
            </property>
            <property name="Selected" nameLabel="Magic_Boxes_property_speech_text_selected" type="staticrow">
                <property name="Selected" nameLabel="Magic_Boxes_property_speech_text_selected" type="string"/>
            </property>
            <property name="Deselected" nameLabel="Magic_Boxes_property_speech_text_deselected" type="staticrow">
                <property name="Deselected" nameLabel="Magic_Boxes_property_speech_text_deselected" type="string"/>
            </property>
            <property name="Correct" nameLabel="Magic_Boxes_property_speech_text_correct" type="staticrow">
                <property name="Correct" nameLabel="Magic_Boxes_property_speech_text_correct" type="string"/>
            </property>
            <property name="Wrong" nameLabel="Magic_Boxes_property_speech_text_wrong" type="staticrow">
                <property name="Wrong" nameLabel="Magic_Boxes_property_speech_text_wrong" type="string"/>
            </property>
        </property>
    </model>
<css>.magicGridWrapper {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    border: 1px solid black;&#13;
}&#13;
&#13;
.magicGrid {&#13;
    margin: 0;&#13;
    padding: 0;&#13;
    border: none;&#13;
}&#13;
&#13;
.selectable-element {&#13;
    float: left;&#13;
    font-size: 2em;&#13;
    font-family: "Verdana";&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    border-style: solid;&#13;
    border-color: white;&#13;
    border-width: 2px;&#13;
    text-align: center;&#13;
    color: black;&#13;
}&#13;
&#13;
.selectable-element-wrapper {&#13;
    float: left;&#13;
    font-size: 2em;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    border-style: solid;&#13;
    border-color: black;&#13;
    border-width: 1px;&#13;
    text-align: center;&#13;
}&#13;
&#13;
.selectable-element-selected {&#13;
    border-color: #65CDE5;&#13;
    background-color: #65CDE5;&#13;
    color: white;&#13;
}&#13;
&#13;
.selectable-element-selected-correct {&#13;
    border-color: green;&#13;
}&#13;
&#13;
.selectable-element-selected-uncorrect {&#13;
    border-color: red;&#13;
}&#13;
&#13;
.selectable-element-show-answers {&#13;
    border-color: blue;&#13;
}&#13;
</css><view>&lt;div class="magicGridWrapper"&gt;&#13;
    &lt;div class="magicGrid"&gt;&#13;
        &lt;!-- Here goes generated grid cells--&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="magicGridWrapper"&gt;&#13;
    &lt;div class="magicGrid"&gt;&#13;
        &lt;!-- Here goes generated grid cells--&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonMagic_Boxes_create() {&#13;
    var presenter = function() { };&#13;
&#13;
    var gridSelection = [];&#13;
    var goodSelections = [];&#13;
    var goodSelectionIndexes = [];&#13;
    var correctAnswers = [];&#13;
    var GSALetterCounter = 0;&#13;
    var usedGSAKeys = [];&#13;
    presenter.answerWords = {};&#13;
    presenter.GSAcorrectAnswerLocations = {};&#13;
    &#13;
&#13;
    var gridContainerWrapper;&#13;
    var gridContainer;&#13;
    var playerController;&#13;
    var eventBus;&#13;
    var maxScore;&#13;
&#13;
    presenter.isSelectionPossible = true;&#13;
&#13;
    presenter.isWCAGOn = false;&#13;
    presenter.keyboardControllerObject = null;&#13;
&#13;
    presenter.configuration = {&#13;
        rows: 0,&#13;
        columns: 0,&#13;
        gridElements: [],&#13;
        answers: [],&#13;
    };&#13;
&#13;
    presenter.ERROR_MESSAGES = {&#13;
        COLUMNS : "Inconsistent column size. Each row has to have same number of elements!",&#13;
        ROWS : "Inconsistent row definition. Whitespaces, semicolons and commas aren't alowed in grid!",&#13;
        ANSWERS_NOT_PROVIDED : "Answers section is missing or empty!",&#13;
        GRID_NOT_PROVIDED : "Grid definition missing or empty!"&#13;
    };&#13;
&#13;
    presenter.DEFAULT_TTS_PHRASES = {&#13;
        CELL: "Cell",&#13;
        SELECTED: "Selected",&#13;
        DESELECTED: "Deselected",&#13;
        CORRECT: "Correct",&#13;
        WRONG: "Wrong",&#13;
    };&#13;
&#13;
    presenter.CSS_CLASSES = {&#13;
        GRID_WRAPPER: "magicGridWrapper",&#13;
        ELEMENT_WRAPPER: "selectable-element-wrapper",&#13;
        ELEMENT: "selectable-element",&#13;
        SELECTED: "selectable-element-selected",&#13;
        CORRECT_SELECTED: "selectable-element-selected-correct",&#13;
        WRONG_SELECTED: "selectable-element-selected-uncorrect",&#13;
        SHOW_ANSWERS: "selectable-element-show-answers",&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        playerController = controller;&#13;
    };&#13;
&#13;
    function showErrorMessage(errorMessage) {&#13;
        var errorContainer = '&lt;p&gt;' + errorMessage + '&lt;/p&gt;';&#13;
        presenter.$view.html(errorContainer);&#13;
    }&#13;
&#13;
    function reverseString(text) {&#13;
        var splitedText = text.split("");&#13;
        var reversedText = splitedText.reverse();&#13;
&#13;
        return reversedText.join("");&#13;
    }&#13;
&#13;
    function initGridSelection() {&#13;
        for(var row = 0; row &lt; presenter.configuration.rows; row++) {&#13;
            gridSelection[row] = [];&#13;
            correctAnswers[row] = [];&#13;
            for(var column = 0; column &lt; presenter.configuration.columns; column++) {&#13;
                gridSelection[row][column] = false;&#13;
                correctAnswers[row][column] = false;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function clearCorrectAnswers() {&#13;
        for(var row = 0; row &lt; presenter.configuration.rows; row++) {&#13;
            correctAnswers[row] = [];&#13;
            for(var column = 0; column &lt; presenter.configuration.columns; column++) {&#13;
                correctAnswers[row][column] = false;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function getElementDimensions(element) {&#13;
        element = $(element);&#13;
        &#13;
        return {&#13;
            border:{&#13;
                top:parseFloat(element.css('border-top-width'), 10),&#13;
                bottom:parseFloat(element.css('border-bottom-width'), 10),&#13;
                left:parseFloat(element.css('border-left-width'), 10),&#13;
                right:parseFloat(element.css('border-right-width'), 10)&#13;
            },&#13;
            margin:{&#13;
                top:parseInt(element.css('margin-top'), 10),&#13;
                bottom:parseInt(element.css('margin-bottom'), 10),&#13;
                left:parseInt(element.css('margin-left'), 10),&#13;
                right:parseInt(element.css('margin-right'), 10)&#13;
            },&#13;
            padding:{&#13;
                top:parseInt(element.css('padding-top'), 10),&#13;
                bottom:parseInt(element.css('padding-bottom'), 10),&#13;
                left:parseInt(element.css('padding-left'), 10),&#13;
                right:parseInt(element.css('padding-right'), 10)&#13;
            }&#13;
        };&#13;
    }&#13;
&#13;
    function calculateInnerDistance(elementDimensions) {&#13;
        var vertical = elementDimensions.border.top + elementDimensions.border.bottom;&#13;
        vertical += elementDimensions.margin.top + elementDimensions.margin.bottom;&#13;
        vertical += elementDimensions.padding.top + elementDimensions.padding.top;&#13;
&#13;
        var horizontal = elementDimensions.border.left + elementDimensions.border.right;&#13;
        horizontal += elementDimensions.margin.left + elementDimensions.margin.right;&#13;
        horizontal += elementDimensions.padding.left + elementDimensions.padding.right;&#13;
&#13;
        return {&#13;
            vertical : vertical,&#13;
            horizontal : horizontal&#13;
        };&#13;
    }&#13;
&#13;
    function fixTouch (touch) {&#13;
        var winPageX = window.pageXOffset,&#13;
            winPageY = window.pageYOffset,&#13;
            x = touch.clientX,&#13;
            y = touch.clientY;&#13;
&#13;
        if (touch.pageY === 0 &amp;&amp; Math.floor(y) &gt; Math.floor(touch.pageY) ||&#13;
            touch.pageX === 0 &amp;&amp; Math.floor(x) &gt; Math.floor(touch.pageX)) {&#13;
            // iOS4 clientX/clientY have the value that should have been&#13;
            // in pageX/pageY. While pageX/page/ have the value 0&#13;
            x = x - winPageX;&#13;
            y = y - winPageY;&#13;
        } else if (y &lt; (touch.pageY - winPageY) || x &lt; (touch.pageX - winPageX) ) {&#13;
            // Some Android browsers have totally bogus values for clientX/Y&#13;
            // when scrolling/zooming a page. Detectable since clientX/clientY&#13;
            // should never be smaller than pageX/pageY minus page scroll&#13;
            x = touch.pageX - winPageX;&#13;
            y = touch.pageY - winPageY;&#13;
        }&#13;
&#13;
        return {&#13;
            x: x,&#13;
            y: y&#13;
        };&#13;
    }&#13;
&#13;
    function initGrid(model, preview) {&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
&#13;
        for(var row = 0; row &lt; rows; row++) {&#13;
            for(var column = 0; column &lt; columns; column++) {&#13;
                var wrapperElement = $(document.createElement('div'));&#13;
                wrapperElement.addClass(presenter.CSS_CLASSES.ELEMENT_WRAPPER);&#13;
&#13;
                var selectableElement = $(document.createElement('div'));&#13;
                selectableElement.addClass(presenter.CSS_CLASSES.ELEMENT);&#13;
                var rawChar = presenter.configuration.gridElements[row][column];&#13;
                var charToShow = isCharacterToCapitalize(rawChar) ? rawChar.toUpperCase() : rawChar;&#13;
                selectableElement.text(charToShow);&#13;
&#13;
                wrapperElement.append(selectableElement);&#13;
                gridContainer.append(wrapperElement);&#13;
            }&#13;
        }&#13;
&#13;
        var gridContainerWrapperDimensions = getElementDimensions(gridContainerWrapper);&#13;
        var gridContainerWrapperDistances = calculateInnerDistance(gridContainerWrapperDimensions);&#13;
&#13;
        var wrapperDimensions = getElementDimensions(gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT_WRAPPER}:first`)[0]);&#13;
        var wrapperDistances = calculateInnerDistance(wrapperDimensions);&#13;
&#13;
        var elementDimensions = getElementDimensions(gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:first`)[0]);&#13;
        var elementDistances = calculateInnerDistance(elementDimensions);&#13;
&#13;
        var wrapperWidth = parseInt((model.Width - gridContainerWrapperDistances.horizontal - (wrapperDistances.horizontal * columns)) / columns, 10);&#13;
        var wrapperHeight = parseInt((model.Height - gridContainerWrapperDistances.vertical - (wrapperDistances.vertical * rows)) / rows, 10);&#13;
&#13;
        var elementWidth = wrapperWidth - elementDistances.horizontal;&#13;
        var elementHeight = wrapperHeight - elementDistances.vertical;&#13;
&#13;
        var newContainerWrapperHeight = wrapperHeight * rows + wrapperDistances.vertical * rows;&#13;
        var newContainerWrapperWidth = wrapperWidth * columns + wrapperDistances.horizontal * columns;&#13;
&#13;
        var verticalGap = model.Height - newContainerWrapperHeight;&#13;
        var horizontalGap = model.Width - newContainerWrapperWidth;&#13;
&#13;
        gridContainerWrapper.css('height', model.Height + 'px');&#13;
        gridContainerWrapper.css('width', model.Width + 'px');&#13;
        gridContainer.css('height', model.Height + 'px');&#13;
        gridContainer.css('width', model.Width + 'px');&#13;
&#13;
        presenter.isMouseDown = false;&#13;
&#13;
        if (MobileUtils.isEventSupported('touchstart')) {&#13;
            var selectedIndex = null;&#13;
&#13;
            presenter.$view.find('.magicGrid').on('touchmove', function (e) {&#13;
                e.stopPropagation();&#13;
                e.preventDefault();&#13;
&#13;
                var client = fixTouch(e.originalEvent.touches[0] || e.originalEvent.changedTouches[0]);&#13;
&#13;
                var element = document.elementFromPoint(client.x, client.y);&#13;
                var index = $(element).parent().index();&#13;
                var selectedRow = parseInt(index / columns, 10);&#13;
                var selectedColumn = parseInt(index % columns, 10);&#13;
                if(index != selectedIndex &amp;&amp; $(element).parent().hasClass(presenter.CSS_CLASSES.ELEMENT_WRAPPER)){&#13;
                    selectionHandler(selectedRow, selectedColumn);&#13;
                    selectedIndex = index;&#13;
                }&#13;
            });&#13;
        }else{&#13;
            var $magicWrapper = presenter.$view.find(`.${presenter.CSS_CLASSES.GRID_WRAPPER}`);&#13;
            $magicWrapper.on('mousedown', function () {&#13;
                presenter.isMouseDown = true;&#13;
            });&#13;
&#13;
            $magicWrapper.on('mouseup', function () {&#13;
                presenter.isMouseDown = false;&#13;
            });&#13;
&#13;
            $magicWrapper.on('mouseleave', function () {&#13;
                presenter.isMouseDown = false;&#13;
            });&#13;
        }&#13;
&#13;
        gridContainer.find(`.${presenter.CSS_CLASSES.ELEMENT_WRAPPER}`).each(function() {&#13;
            var index = $(this).index();&#13;
            var selectedRow = parseInt(index / columns, 10);&#13;
            var selectedColumn = parseInt(index % columns, 10);&#13;
&#13;
            $(this).width(wrapperWidth + horizontalGap / columns);&#13;
            $(this).height(wrapperHeight + verticalGap / rows);&#13;
&#13;
            var selectableElement = $(this).find(`.${presenter.CSS_CLASSES.ELEMENT}:first`);&#13;
            selectableElement.width(elementWidth + horizontalGap / columns);&#13;
            selectableElement.height(elementHeight + verticalGap / rows);&#13;
            var lineHeight = selectedRow === rows -1 ? elementHeight + verticalGap : elementHeight;&#13;
            selectableElement.css('line-height', lineHeight + "px");&#13;
&#13;
            applySelectionStyle(selectedRow, selectedColumn);&#13;
            if (!preview) {&#13;
                if (MobileUtils.isEventSupported('touchstart')) {&#13;
                    function handler(e){&#13;
                        e.stopPropagation();&#13;
                        e.preventDefault();&#13;
                        selectionHandler(selectedRow, selectedColumn);&#13;
                        $(this).unbind('click');&#13;
                        setTimeout(function(){selectableElement.click(handler)}, 500);&#13;
                    }&#13;
&#13;
                    selectableElement.click(handler);&#13;
                }else{&#13;
                    presenter.wasMoved = false;&#13;
                    selectableElement.on('mousemove', function (e) {&#13;
                        e.preventDefault();&#13;
                        if(presenter.isMouseDown &amp;&amp; !presenter.wasMoved){&#13;
                            selectionHandler(selectedRow, selectedColumn);&#13;
                            presenter.wasMoved = true;&#13;
                        }&#13;
                    });&#13;
&#13;
                    selectableElement.on('mouseout', function (e) {&#13;
                        e.stopPropagation();&#13;
                        e.preventDefault();&#13;
                        presenter.wasMoved = false;&#13;
                    });&#13;
&#13;
                    selectableElement.on('mousedown', function (e) {&#13;
                        e.stopPropagation();&#13;
                        e.preventDefault();&#13;
                        presenter.isMouseDown = true;&#13;
                        selectionHandler(selectedRow, selectedColumn);&#13;
                        presenter.wasMoved = true;&#13;
                    });&#13;
&#13;
                    selectableElement.on('mouseup', function (e) {&#13;
                        e.stopPropagation();&#13;
                        e.preventDefault();&#13;
                        presenter.isMouseDown = false;&#13;
                    });&#13;
                }&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    function isCharacterToCapitalize (character) {&#13;
        return !(/\u00DF/.test(character));&#13;
    }&#13;
&#13;
    presenter.calculateScoreForEvent = function (prevScore, currentScore) {&#13;
        var score;&#13;
        if(currentScore &gt; prevScore){&#13;
            score = 1;&#13;
        }else{&#13;
            score = 0;&#13;
        }&#13;
&#13;
        return score;&#13;
    };&#13;
&#13;
    function selectionHandler(row, column) {&#13;
        var prevScore = presenter.getScore();&#13;
        if(presenter.isSelectionPossible) {&#13;
            gridSelection[row][column] = gridSelection[row][column] ? false : true;&#13;
            applySelectionStyle(row, column);&#13;
&#13;
            var item = (row+1) +"-"+ (column+1);&#13;
            var index = row * presenter.configuration.columns + column;&#13;
            var element = gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:eq(${index})`);&#13;
            var currentScore = presenter.getScore();&#13;
&#13;
            var eventData = presenter.createEventData(item, element.text(), presenter.calculateScoreForEvent(prevScore, currentScore));&#13;
            eventBus.sendEvent('ValueChanged', eventData);&#13;
&#13;
            if(presenter.isAllOK()){&#13;
                var allOKEventData = presenter.createAllOKEventData();&#13;
                eventBus.sendEvent('ValueChanged', allOKEventData);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function applySelectionStyle(row, column) {&#13;
        var index = row * presenter.configuration.columns + column;&#13;
        var element = gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:eq(${index})`);&#13;
&#13;
        if(gridSelection[row][column]) {// is selected&#13;
            if(!element.hasClass(presenter.CSS_CLASSES.SELECTED)) {&#13;
                element.addClass(presenter.CSS_CLASSES.SELECTED);&#13;
            }&#13;
        } else {&#13;
            if(element.hasClass(presenter.CSS_CLASSES.SELECTED)) {&#13;
                element.removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function applyAnswerStyles() {&#13;
        if(presenter.configuration.checkByWords){&#13;
            gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}`).each(function(index) {&#13;
                if($(this).hasClass(presenter.CSS_CLASSES.SELECTED)){&#13;
                    $(this).addClass(presenter.CSS_CLASSES.WRONG_SELECTED);&#13;
                }&#13;
            });&#13;
&#13;
            for (var i=0; i&lt;presenter.configuration.answers.length; i++){&#13;
                if(presenter.checkIfWordIsSelected(presenter.configuration.answers[i].toString())){&#13;
                    var word = presenter.configuration.answers[i].toString();&#13;
                    for(var j=0; j &lt; presenter.answerWords[word.toLowerCase()].column.length; j++){&#13;
                        var index = presenter.answerWords[word.toLowerCase()].row[j] * presenter.configuration.columns + presenter.answerWords[word.toLowerCase()].column[j];&#13;
                        var element = gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:eq(${index})`);&#13;
                        element.removeClass(presenter.CSS_CLASSES.WRONG_SELECTED);&#13;
                        element.addClass(presenter.CSS_CLASSES.CORRECT_SELECTED);&#13;
                    }&#13;
                }&#13;
            }&#13;
        }else{&#13;
            gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}`).each(function(index) {&#13;
                if(!$(this).hasClass(presenter.CSS_CLASSES.SELECTED)) {&#13;
                    return true; // jQeury equivalent of continue&#13;
                }&#13;
&#13;
                var className;&#13;
&#13;
                if(goodSelectionIndexes[index] != -1){&#13;
                    className = presenter.CSS_CLASSES.CORRECT_SELECTED;&#13;
                }else{&#13;
                    className = presenter.CSS_CLASSES.WRONG_SELECTED;&#13;
                }&#13;
&#13;
                $(this).addClass(className);&#13;
            });&#13;
        }&#13;
    }&#13;
&#13;
    function cleanAnswersStyles() {&#13;
        // Clearing correct/uncorrect styles which where set when user&#13;
        // pressed 'check answers' button.&#13;
        gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}`).each(function() {&#13;
            if($(this).hasClass(presenter.CSS_CLASSES.CORRECT_SELECTED)) {&#13;
                $(this).removeClass(presenter.CSS_CLASSES.CORRECT_SELECTED);&#13;
            }&#13;
            if($(this).hasClass(presenter.CSS_CLASSES.WRONG_SELECTED)) {&#13;
                $(this).removeClass(presenter.CSS_CLASSES.WRONG_SELECTED);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.reset = function() {&#13;
        if(presenter.isShowAnswersActive){&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.isSelectionPossible = true;&#13;
&#13;
        cleanAnswersStyles();&#13;
&#13;
        for(var row = 0; row &lt; presenter.configuration.rows; row++) {&#13;
            for(var column = 0; column &lt; presenter.configuration.columns; column++) {&#13;
                gridSelection[row][column] = false;&#13;
                applySelectionStyle(row, column);&#13;
            }&#13;
        }&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
        presenter.configuration.isVisible = presenter.isVisibleByDefault;&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if(presenter.isShowAnswersActive){&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.isSelectionPossible = false;&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
&#13;
        goodSelectionIndexes = presenter.convertSelectionToIndexes(goodSelections, rows, columns);&#13;
&#13;
        applyAnswerStyles();&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function() {&#13;
        cleanAnswersStyles();&#13;
&#13;
        for(var row = 0; row &lt; presenter.configuration.rows; row++) {&#13;
            for(var column = 0; column &lt; presenter.configuration.columns; column++) {&#13;
                applySelectionStyle(row, column);&#13;
            }&#13;
        }&#13;
&#13;
        presenter.isSelectionPossible = true;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function() {&#13;
        if(presenter.configuration.isError){&#13;
            return 0;&#13;
        }&#13;
&#13;
        return maxScore;&#13;
    };&#13;
&#13;
    presenter.getScore = function() {&#13;
        if(presenter.configuration.isError){&#13;
            return 0;&#13;
        }&#13;
&#13;
        if(presenter.configuration.checkByWords){&#13;
            return presenter.countScoreForWords().score;&#13;
        }else{&#13;
            return presenter.calculateScore(goodSelections, gridSelection).correct;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function() {&#13;
        if(presenter.configuration.isError){&#13;
            return 0;&#13;
        }&#13;
&#13;
        if(presenter.configuration.checkByWords){&#13;
            if(presenter.isAttempted()){&#13;
                return presenter.countScoreForWords().errors;&#13;
            }else{&#13;
                return 0;&#13;
            }&#13;
        }else{&#13;
            return presenter.calculateScore(goodSelections, gridSelection).errors;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.serializeGridSelection = function(gridSelection, rows, columns) {&#13;
        var serializedArray = '';&#13;
        var counter = 0;&#13;
&#13;
        for(var row = 0; row &lt; rows; row++) {&#13;
            for(var column = 0; column &lt; columns; column++) {&#13;
                if(gridSelection[row][column]) {&#13;
                    counter++;&#13;
                    var index = row * columns + column;&#13;
                    serializedArray += index.toString() + ',';&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        // Remove last comma separator&#13;
        if(counter !== 0) {&#13;
            serializedArray = serializedArray.substr(0, serializedArray.length - 1);&#13;
        }&#13;
&#13;
        return serializedArray;&#13;
    };&#13;
&#13;
    presenter.deserialiseGridSelection = function(serializedArray) {&#13;
        var deserialisedArray = [];&#13;
        if (serializedArray.length === 0) {&#13;
            return deserialisedArray;&#13;
        }&#13;
&#13;
        var splittedArray = serializedArray.split(',');&#13;
&#13;
        for(var i = 0; i &lt; splittedArray.length; i++) {&#13;
            var index = parseInt(splittedArray[i], 10);&#13;
            deserialisedArray.push(index);&#13;
        }&#13;
&#13;
        return deserialisedArray;&#13;
    };&#13;
&#13;
    presenter.getState = function() {&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
&#13;
        return JSON.stringify({&#13;
            serializeGridSelection: presenter.serializeGridSelection(gridSelection, rows, columns),&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function(state) {&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
        var row;&#13;
        var column;&#13;
&#13;
        initGridSelection();&#13;
&#13;
        var serializeGridSelection, parsedState;&#13;
        if (state.indexOf("}") &gt; -1 &amp;&amp; state.indexOf("{") &gt; -1){&#13;
            parsedState = JSON.parse(state);&#13;
            serializeGridSelection = parsedState.serializeGridSelection;&#13;
        }else{&#13;
            serializeGridSelection = state;&#13;
            parsedState = undefined;&#13;
        }&#13;
&#13;
        var dematerialisedState = presenter.deserialiseGridSelection(serializeGridSelection);&#13;
&#13;
        for(var i = 0; i &lt; dematerialisedState.length; i++) {&#13;
            row = parseInt(dematerialisedState[i] / columns, 10);&#13;
            column = parseInt(dematerialisedState[i] % columns, 10);&#13;
            gridSelection[row][column] = true;&#13;
        }&#13;
&#13;
        for(row = 0; row &lt; rows; row++) {&#13;
            for(column = 0; column &lt; columns; column++) {&#13;
                applySelectionStyle(row, column);&#13;
            }&#13;
        }&#13;
&#13;
        if(parsedState){&#13;
            if(parsedState.isVisible != undefined){&#13;
                presenter.setVisibility(parsedState.isVisible);&#13;
                presenter.configuration.isVisible = parsedState.isVisible;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.initializeCorrectAnswerLocations = function () {&#13;
        for(var i = 0; i&lt; presenter.configuration.answers.length; i++){&#13;
            presenter.answerWords[presenter.configuration.answers[i].toString().toLowerCase()] = {&#13;
                row : [],&#13;
                column : []&#13;
            };&#13;
            presenter.GSAcorrectAnswerLocations[presenter.configuration.answers[i].toString().toLowerCase()] = {&#13;
                row : [],&#13;
                column : []&#13;
            };&#13;
        }&#13;
    };&#13;
&#13;
    function presenterLogic(view, model, isPreview){&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
        gridContainerWrapper = presenter.$view.find(`.${presenter.CSS_CLASSES.GRID_WRAPPER}:first`);&#13;
        gridContainer = gridContainerWrapper.find(".magicGrid:first");&#13;
&#13;
        let upgradedModel = presenter.upgradeModel(model);&#13;
        presenter.configuration = presenter.validateModel(upgradedModel);&#13;
        presenter.setSpeechTexts(upgradedModel['speechTexts']);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        if(presenter.configuration.answers){&#13;
            presenter.initializeCorrectAnswerLocations();&#13;
        }&#13;
&#13;
        if(presenter.configuration.isError) {&#13;
            showErrorMessage(presenter.configuration.errorMessage);&#13;
        } else {&#13;
            initGridSelection();&#13;
            initGrid(model, isPreview);&#13;
            goodSelections = presenter.findGoodSelections(presenter.configuration.gridElements, presenter.configuration.answers);&#13;
&#13;
            if(presenter.configuration.checkByWords){&#13;
                maxScore = presenter.configuration.answers.length;&#13;
            }else{&#13;
                maxScore = presenter.calculateMaxScore(goodSelections);&#13;
            }&#13;
&#13;
            if (isPreview) {&#13;
                gridSelection = goodSelections;&#13;
                presenter.setWorkMode();&#13;
            } else {&#13;
                presenter.buildKeyboardController();&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.upgradeModel = function (model) {&#13;
        let upgradedModel = presenter.upgradeLangTag(model);&#13;
        return presenter.upgradeSpeechTexts(upgradedModel);&#13;
    };&#13;
&#13;
    presenter.upgradeLangTag = function (model) {&#13;
        return presenter.upgradeAttribute(model, "langAttribute", '');&#13;
    };&#13;
&#13;
    presenter.upgradeSpeechTexts = function (model) {&#13;
        const upgradedModel = presenter.upgradeAttribute(model, "speechTexts", {});&#13;
&#13;
        const modelSpeechTexts = upgradedModel["speechTexts"];&#13;
        const properties = ["Cell", "Selected", "Deselected", "Correct", "Wrong"];&#13;
        properties.forEach(name =&gt; {&#13;
            if (!modelSpeechTexts[name]) modelSpeechTexts[name] = {[name]: ""}&#13;
        })&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeAttribute = function (model, attrName, defaultValue) {&#13;
        var upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (model[attrName] === undefined) {&#13;
            upgradedModel[attrName] = defaultValue;&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.setSpeechTexts = function(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            Cell: presenter.DEFAULT_TTS_PHRASES.CELL,&#13;
            Selected: presenter.DEFAULT_TTS_PHRASES.SELECTED,&#13;
            Deselected: presenter.DEFAULT_TTS_PHRASES.DESELECTED,&#13;
            Correct: presenter.DEFAULT_TTS_PHRASES.CORRECT,&#13;
            Wrong: presenter.DEFAULT_TTS_PHRASES.WRONG,&#13;
        };&#13;
&#13;
        if (!speechTexts || $.isEmptyObject(speechTexts)) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            Cell: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Cell.Cell,&#13;
                presenter.speechTexts.Cell),&#13;
            Selected: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Selected.Selected,&#13;
                presenter.speechTexts.Selected),&#13;
            Deselected: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Deselected.Deselected,&#13;
                presenter.speechTexts.Deselected),&#13;
            Correct: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Correct.Correct,&#13;
                presenter.speechTexts.Correct),&#13;
            Wrong: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Wrong.Wrong,&#13;
                presenter.speechTexts.Wrong)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.run = function(view, model) {&#13;
        presenter.addonID = model.ID;&#13;
        presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.setEventBus = function (wrappedEventBus) {&#13;
        eventBus = wrappedEventBus;&#13;
&#13;
        eventBus.addEventListener('ShowAnswers', this);&#13;
        eventBus.addEventListener('HideAnswers', this);&#13;
        eventBus.addEventListener('GradualShowAnswers', this);&#13;
        eventBus.addEventListener('GradualHideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.isWordInRow = function(grid, row, word) {&#13;
        word = word.toLowerCase();&#13;
        var positions = [];&#13;
&#13;
        if (word.length &gt; grid[row].length) {&#13;
            return {&#13;
                wordFound: false,&#13;
                positions: positions&#13;
            };&#13;
        }&#13;
&#13;
        for (var i = 0; i &lt; (grid[row].length - word.length + 1); i++) {&#13;
            var gridWord = "";&#13;
&#13;
            for (var j = 0; j &lt; word.length; j++) {&#13;
                gridWord += grid[row][j + i].toLowerCase();&#13;
            }&#13;
&#13;
            if (gridWord === word || reverseString(gridWord) === word) {&#13;
                positions.push(i);&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            wordFound: positions.length &gt; 0,&#13;
            positions: positions&#13;
        };&#13;
    };&#13;
&#13;
    presenter.isWordInColumn = function(grid, column, word) {&#13;
        var positions = [];&#13;
        word = word.toLowerCase();&#13;
&#13;
        if (word.length &gt; grid.length) {&#13;
            return {&#13;
                wordFound: false,&#13;
                positions: positions&#13;
            };&#13;
        }&#13;
&#13;
        for (var i = 0; i &lt; (grid.length - word.length + 1); i++) {&#13;
            var gridWord = "";&#13;
&#13;
            for (var j = 0; j &lt; word.length; j++) {&#13;
                gridWord += grid[j + i][column].toLowerCase();&#13;
            }&#13;
&#13;
            if (gridWord === word || reverseString(gridWord) === word) {&#13;
                positions.push(i);&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            wordFound: positions.length &gt; 0,&#13;
            positions: positions&#13;
        };&#13;
    };&#13;
&#13;
    presenter.DIAGONALS = {&#13;
        NORMAL: 0,&#13;
        REVERSED: 1&#13;
    };&#13;
&#13;
    presenter.isWordOnDiagonals = function(grid, word, direction) {&#13;
        var rows = grid.length;&#13;
        var columns = grid[0].length;&#13;
        var positions = [];&#13;
        word = word.toLowerCase();&#13;
&#13;
        if (word.length &gt; rows || word.length &gt; columns) {&#13;
            return {&#13;
                wordFound: false,&#13;
                positions: positions&#13;
            };&#13;
        }&#13;
&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var column = 0; column &lt; columns; column++) {&#13;
                var columnCondition = direction === presenter.DIAGONALS.NORMAL ? word.length &lt;= columns - column : word.length &lt;= column + 1;&#13;
                var isWordSmallEnough = word.length &lt;= (rows - row);&#13;
                isWordSmallEnough = isWordSmallEnough &amp;&amp; columnCondition;&#13;
&#13;
                if (isWordSmallEnough) {&#13;
                    var gridWord = "";&#13;
&#13;
                    for (var i = 0; i &lt; word.length; i++) {&#13;
                        var columnIndex = direction === presenter.DIAGONALS.NORMAL ? column + i : column - i;&#13;
                        gridWord += grid[row + i][columnIndex].toLowerCase();&#13;
                    }&#13;
&#13;
                    if (gridWord === word || reverseString(gridWord) === word) {&#13;
                        positions.push({&#13;
                            row: row,&#13;
                            column: column&#13;
                        });&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            wordFound: positions.length &gt; 0,&#13;
            positions: positions&#13;
        };&#13;
    };&#13;
&#13;
    presenter.findGoodSelections = function (grid, answers) {&#13;
        var goodSelections = [];&#13;
        var l;&#13;
&#13;
        for (var i = 0; i &lt; answers.length; i++) {&#13;
            var answer = answers[i].toString().toLowerCase();&#13;
&#13;
            goodSelections = presenter.findGoodHorizontalSelections(grid, answer, goodSelections);&#13;
            goodSelections = presenter.findGoodVerticalSelections(grid, answer, goodSelections);&#13;
            goodSelections = presenter.findGoodDiagonalSelections(grid, answer, goodSelections);&#13;
            goodSelections = presenter.findGoodReverseDiagonalSelections(grid, answer, goodSelections);&#13;
        }&#13;
&#13;
        var rows = grid.length;&#13;
        var columns = grid[0].length;&#13;
&#13;
        return presenter.convertSelectionToArray(goodSelections, rows, columns);&#13;
    };&#13;
&#13;
    presenter.findGoodHorizontalSelections = function (grid, answer, goodSelections) {&#13;
        for (var r = 0; r &lt; grid.length; r++) {&#13;
            var horizontalResult = presenter.isWordInRow(grid, r, answer);&#13;
            for (var hr = 0; hr &lt; horizontalResult.positions.length; hr++) {&#13;
                for (l = 0; l &lt; answer.length; l++) {&#13;
                    if(presenter.configuration.checkByWords){&#13;
                        presenter.answerWords[answer].row.push(r);&#13;
                        presenter.answerWords[answer].column.push(horizontalResult.positions[hr] + l);&#13;
                    }&#13;
                    &#13;
                    presenter.GSAcorrectAnswerLocations[answer].row.push(r);&#13;
                    presenter.GSAcorrectAnswerLocations[answer].column.push(horizontalResult.positions[hr] + l);&#13;
&#13;
                    goodSelections.push({&#13;
                        row: r,&#13;
                        column: horizontalResult.positions[hr] + l&#13;
                    });&#13;
                }&#13;
            }&#13;
        }&#13;
        return goodSelections;&#13;
    }&#13;
&#13;
    presenter.findGoodVerticalSelections = function (grid, answer, goodSelections) {&#13;
        for (var c = 0; c &lt; grid[0].length; c++) {&#13;
            var verticalResult = presenter.isWordInColumn(grid, c, answer);&#13;
            for (var vr = 0; vr &lt; verticalResult.positions.length; vr++) {&#13;
                for (l = 0; l &lt; answer.length; l++) {&#13;
                    if(presenter.configuration.checkByWords){&#13;
                        presenter.answerWords[answer].row.push(verticalResult.positions[vr] + l);&#13;
                        presenter.answerWords[answer].column.push(c);&#13;
                    }&#13;
&#13;
                    presenter.GSAcorrectAnswerLocations[answer].row.push(verticalResult.positions[vr] + l);&#13;
                    presenter.GSAcorrectAnswerLocations[answer].column.push(c);&#13;
&#13;
                    goodSelections.push({&#13;
                        row: verticalResult.positions[vr] + l,&#13;
                        column: c&#13;
                    });&#13;
                }&#13;
            }&#13;
        }&#13;
        return goodSelections;&#13;
    }&#13;
&#13;
    presenter.findGoodDiagonalSelections = function (grid, answer, goodSelections) {&#13;
        var diagonalResult = presenter.isWordOnDiagonals(grid, answer, presenter.DIAGONALS.NORMAL);&#13;
        for (var dr = 0; dr &lt; diagonalResult.positions.length; dr++) {&#13;
            for (l = 0; l &lt; answer.length; l++) {&#13;
                if(presenter.configuration.checkByWords){&#13;
                    presenter.answerWords[answer].row.push(diagonalResult.positions[dr].row + l);&#13;
                    presenter.answerWords[answer].column.push(diagonalResult.positions[dr].column + l);&#13;
                }&#13;
&#13;
                presenter.GSAcorrectAnswerLocations[answer].row.push(diagonalResult.positions[dr].row + l);&#13;
                presenter.GSAcorrectAnswerLocations[answer].column.push(diagonalResult.positions[dr].column + l);&#13;
&#13;
                goodSelections.push({&#13;
                    row: diagonalResult.positions[dr].row + l,&#13;
                    column: diagonalResult.positions[dr].column + l&#13;
                });&#13;
            }&#13;
        }&#13;
        return goodSelections;&#13;
    }&#13;
&#13;
    presenter.findGoodReverseDiagonalSelections = function (grid, answer, goodSelections) {&#13;
        var reverseDiagonalResult = presenter.isWordOnDiagonals(grid, answer, presenter.DIAGONALS.REVERSED);&#13;
        for (var rdr = 0; rdr &lt; reverseDiagonalResult.positions.length; rdr++) {&#13;
            for (l = 0; l &lt; answer.length; l++) {&#13;
                if(presenter.configuration.checkByWords){&#13;
                    presenter.answerWords[answer].row.push(reverseDiagonalResult.positions[rdr].row + l);&#13;
                    presenter.answerWords[answer].column.push(reverseDiagonalResult.positions[rdr].column - l);&#13;
                }&#13;
                    &#13;
                presenter.GSAcorrectAnswerLocations[answer].row.push(reverseDiagonalResult.positions[rdr].row + l);&#13;
                presenter.GSAcorrectAnswerLocations[answer].column.push(reverseDiagonalResult.positions[rdr].column - l);&#13;
&#13;
                goodSelections.push({&#13;
                    row: reverseDiagonalResult.positions[rdr].row + l,&#13;
                    column: reverseDiagonalResult.positions[rdr].column - l&#13;
                });&#13;
            }&#13;
        }&#13;
        return goodSelections;&#13;
    }&#13;
&#13;
    presenter.countScoreForWords = function () {&#13;
        var score = 0;&#13;
        var errors = 0;&#13;
&#13;
        clearCorrectAnswers();&#13;
        for (var i=0; i&lt;presenter.configuration.answers.length; i++){&#13;
            if(presenter.checkIfWordIsSelected(presenter.configuration.answers[i].toString())){&#13;
                fillCorrectAnswers(presenter.configuration.answers[i].toString());&#13;
                score++;&#13;
            }&#13;
        }&#13;
&#13;
        for (var j=0; j&lt;presenter.configuration.rows; j++){&#13;
            for (var k=0; k&lt;presenter.configuration.columns; k++){&#13;
                if(gridSelection[j][k]  &amp;&amp; !correctAnswers[j][k]){&#13;
                    errors++;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            score: score,&#13;
            errors: errors&#13;
        };&#13;
    };&#13;
&#13;
    function fillCorrectAnswers(word) {&#13;
        for (var i = 0; i&lt;presenter.answerWords[word.toLowerCase()].column.length; i++ ){&#13;
            correctAnswers[presenter.answerWords[word.toLowerCase()].row[i]][presenter.answerWords[word.toLowerCase()].column[i]] = true;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.checkIfWordIsSelected = function(word) {&#13;
        var correct = 0;&#13;
        var incorrect= 0;&#13;
&#13;
        for(var i=0; i &lt; presenter.answerWords[word.toLowerCase()].column.length; i++){&#13;
            if(gridSelection[presenter.answerWords[word.toLowerCase()].row[i]][presenter.answerWords[word.toLowerCase()].column[i]]){&#13;
                correct++;&#13;
            }else{&#13;
                incorrect++;&#13;
            }&#13;
        }&#13;
        return correct&gt;0 &amp;&amp; incorrect == 0;&#13;
    };&#13;
&#13;
    presenter.convertSelectionToArray = function (selections, rows, columns) {&#13;
        var selectionArray = [];&#13;
        for (var i = 0; i &lt; rows; i++) {&#13;
            selectionArray[i] = [];&#13;
&#13;
            for (var j = 0; j &lt; columns; j++) {&#13;
                selectionArray[i][j] = false;&#13;
            }&#13;
        }&#13;
&#13;
        for (var s = 0; s &lt; selections.length; s++) {&#13;
            var row = selections[s].row;&#13;
            var column = selections[s].column;&#13;
&#13;
            selectionArray[row][column] = true;&#13;
        }&#13;
&#13;
        return selectionArray;&#13;
    };&#13;
&#13;
    presenter.convertSelectionToIndexes = function (selections, rows, columns) {&#13;
        var selectionIndexes = [];&#13;
&#13;
        for(var row = 0; row &lt; rows; row++) {&#13;
            for(var column = 0; column &lt; columns; column++) {&#13;
                var index = row * columns + column;&#13;
                if (selections[row][column]) {&#13;
                    selectionIndexes[index] = 1;&#13;
                } else {&#13;
                    selectionIndexes[index] = -1;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return selectionIndexes;&#13;
    };&#13;
&#13;
    presenter.calculateMaxScore = function(goodSelections) {&#13;
        var rows = goodSelections.length;&#13;
        var columns = goodSelections[0].length;&#13;
&#13;
        var maxScore = 0;&#13;
&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var column = 0; column &lt; columns; column++) {&#13;
                if (goodSelections[row][column]) {&#13;
                    maxScore++;&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return maxScore;&#13;
    };&#13;
&#13;
    presenter.calculateScore = function (goodSelections, selections) {&#13;
        var correct = 0;&#13;
        var errors = 0;&#13;
&#13;
        var rows = goodSelections.length;&#13;
        var columns = goodSelections[0].length;&#13;
&#13;
        for (var row = 0; row &lt; rows; row++) {&#13;
            for (var column = 0; column &lt; columns; column++) {&#13;
                if (selections[row][column]) {&#13;
                    if (selections[row][column] === goodSelections[row][column]) {&#13;
                        correct++;&#13;
                    } else {&#13;
                        errors++;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            correct: correct,&#13;
            errors: errors&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateGrid = function(gridDefinition) {&#13;
        var gridElements = [];&#13;
        var columnCount = 0;&#13;
        var rowCount = 0;&#13;
&#13;
        if(typeof gridDefinition === "undefined" || gridDefinition.length === 0) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.GRID_NOT_PROVIDED&#13;
            };&#13;
        }&#13;
&#13;
        // Following StackOverflow suggestion : replace -&gt; split&#13;
        // http://stackoverflow.com/questions/5034781/js-regex-to-split-by-line&#13;
        var rowsArray = $(gridDefinition.split("\n"));&#13;
        for (var i = 0; i &lt; rowsArray.length; i++) {&#13;
            var row = String(rowsArray[i]);&#13;
            if (row.length === 0) {&#13;
                return {&#13;
                    isError: true,&#13;
                    errorMessage: presenter.ERROR_MESSAGES.ROWS&#13;
                };&#13;
            }&#13;
&#13;
            if(row.search(/[\s\,\;]+/gm) != -1) { // Search for whitespace characters&#13;
                return {&#13;
                    isError: true,&#13;
                    errorMessage: presenter.ERROR_MESSAGES.ROWS&#13;
                };&#13;
            }&#13;
&#13;
            gridElements[i] = row.split("");&#13;
&#13;
            // Parsing grid definition&#13;
            if(rowCount === 0) {&#13;
                columnCount = row.length;&#13;
            }&#13;
&#13;
            if(columnCount != row.length) {&#13;
                return {&#13;
                    isError: true,&#13;
                    errorMessage: presenter.ERROR_MESSAGES.COLUMNS&#13;
                };&#13;
            }&#13;
&#13;
            rowCount++;&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            columns: columnCount,&#13;
            rows: rowCount,&#13;
            gridElements: gridElements&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateAnswers = function(answersDefinition) {&#13;
        var answers = [];&#13;
&#13;
        if(typeof answersDefinition === "undefined" || answersDefinition.length === 0) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: presenter.ERROR_MESSAGES.ANSWERS_NOT_PROVIDED&#13;
            };&#13;
        }&#13;
&#13;
        $(answersDefinition.split("\n")).each(function() {&#13;
            var answer = String(this);&#13;
            $(answer.split(/[\s\,\;]+/gm)).each(function() {&#13;
                answers.push(this);&#13;
            });&#13;
        });&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            answers: answers&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var gridDefinition = model.Grid;&#13;
        var answersDefinition = model.Answers;&#13;
&#13;
        var gridValidationResult = presenter.validateGrid(gridDefinition);&#13;
        if (gridValidationResult.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: gridValidationResult.errorMessage&#13;
            };&#13;
        }&#13;
&#13;
        var answersValidationResult = presenter.validateAnswers(answersDefinition);&#13;
        if (answersValidationResult.isError) {&#13;
            return {&#13;
                isError: true,&#13;
                errorMessage: answersValidationResult.errorMessage&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            isError: false,&#13;
            columns: gridValidationResult.columns,&#13;
            rows: gridValidationResult.rows,&#13;
            gridElements: gridValidationResult.gridElements,&#13;
            answers: answersValidationResult.answers,&#13;
            checkByWords: ModelValidationUtils.validateBoolean(model['CheckByWords']),&#13;
            isVisible: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
            isVisibleByDefault: ModelValidationUtils.validateBoolean(model["Is Visible"]),&#13;
            langTag: model['langAttribute']&#13;
        };&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (!presenter.isSelectionPossible) return;&#13;
&#13;
        var commands = {&#13;
            'isAllOK': presenter.isAllOK,&#13;
            'showAnswers' : presenter.showAnswers,&#13;
            'hideAnswers' : presenter.hideAnswers,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide&#13;
        };&#13;
&#13;
        return Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css('visibility', isVisible ? 'visible' : 'hidden');&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore() &amp;&amp; presenter.getErrorCount() === 0;&#13;
    };&#13;
&#13;
    presenter.createAllOKEventData = function () {&#13;
        return {&#13;
            'source': presenter.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createEventData = function (item, value, score) {&#13;
        return {&#13;
            'source': presenter.addonID,&#13;
            'item': item,&#13;
            'value': value,&#13;
            'score': score&#13;
        };&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName, data) {&#13;
        switch (eventName) {&#13;
            case "ShowAnswers":&#13;
                presenter.showAnswers();&#13;
                break;&#13;
&#13;
            case "HideAnswers":&#13;
                presenter.hideAnswers();&#13;
                break;&#13;
&#13;
            case "GradualShowAnswers":&#13;
                presenter.gradualShowAnswers(data);&#13;
                break;&#13;
&#13;
            case "GradualHideAnswers":&#13;
                presenter.gradualHideAnswers();&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    function applyShowAnswerStyles() {&#13;
        gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}`).each(function(index) {&#13;
&#13;
            var className;&#13;
&#13;
            if(goodSelectionIndexes[index] != -1){&#13;
                className = presenter.CSS_CLASSES.SHOW_ANSWERS;&#13;
            }&#13;
&#13;
            $(this).addClass(className);&#13;
        });&#13;
    }&#13;
&#13;
    function cleanShowAnswersStyles() {&#13;
        gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}`).each(function() {&#13;
            if($(this).hasClass(presenter.CSS_CLASSES.SHOW_ANSWERS)) {&#13;
                $(this).removeClass(presenter.CSS_CLASSES.SHOW_ANSWERS);&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.isAttempted = function () {&#13;
        for (var i = 0; i&lt;presenter.configuration.rows; i++){&#13;
            for (var j = 0; j&lt;presenter.configuration.columns; j++){&#13;
                if(gridSelection[i][j] == true){&#13;
                    return true;&#13;
                }&#13;
            }&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    function checkIfSelected (row, column){&#13;
        var index = row * presenter.configuration.columns + column;&#13;
        var element = gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:eq(${index})`);&#13;
&#13;
        if(gridSelection[row][column]) {// is selected&#13;
            if(element.hasClass(presenter.CSS_CLASSES.SELECTED)) {&#13;
                element.removeClass(presenter.CSS_CLASSES.SELECTED);&#13;
                return true;&#13;
            }else{&#13;
                return false;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    function addClassToSelectedElement (row, column){&#13;
        var index = row * presenter.configuration.columns + column;&#13;
        var element = gridContainerWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:eq(${index})`);&#13;
            element.addClass(presenter.CSS_CLASSES.SELECTED);&#13;
    }&#13;
&#13;
    presenter.getActivitiesCount = function() {&#13;
        if(presenter.configuration.checkByWords){&#13;
            return presenter.configuration.answers.length;&#13;
        } else {&#13;
            goodSelectionIndexes = presenter.convertSelectionToIndexes(goodSelections, presenter.configuration.rows, presenter.configuration.columns);&#13;
            let numberOfLetters = 0;&#13;
            for (let i = 0; i &lt; goodSelectionIndexes.length; i++) {&#13;
                if (goodSelectionIndexes[i] == 1) numberOfLetters++;&#13;
            }&#13;
            return numberOfLetters;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.saveUserSelectionBeforeShowAnswers = function () {&#13;
        presenter.isSelected = [];&#13;
        presenter.setWorkMode();&#13;
&#13;
        for(var row1 = 0; row1 &lt; presenter.configuration.rows; row1++) {&#13;
            presenter.isSelected[row1] = [];&#13;
            for(var column1 = 0; column1 &lt; presenter.configuration.columns; column1++) {&#13;
                presenter.isSelected[row1][column1] = 0;&#13;
            }&#13;
        }&#13;
&#13;
        for(var row = 0; row &lt; presenter.configuration.rows; row++) {&#13;
            for(var column = 0; column &lt; presenter.configuration.columns; column++) {&#13;
                if(checkIfSelected(row, column)){&#13;
                    presenter.isSelected[row][column] = 1;&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        presenter.isShowAnswersActive = true;&#13;
        presenter.saveUserSelectionBeforeShowAnswers();&#13;
&#13;
        presenter.isSelectionPossible = false;&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
&#13;
        goodSelectionIndexes = presenter.convertSelectionToIndexes(goodSelections, rows, columns);&#13;
&#13;
        applyShowAnswerStyles();&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        cleanShowAnswersStyles();&#13;
&#13;
        for(var row = 0; row &lt; presenter.configuration.rows; row++) {&#13;
            for(var column = 0; column &lt; presenter.configuration.columns; column++) {&#13;
                if(presenter.isSelected[row][column] == 1){&#13;
                    addClassToSelectedElement(row, column);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.isSelectionPossible = true;&#13;
&#13;
        presenter.isShowAnswersActive = false;&#13;
        presenter.isGradualShowAnswersActive = false;&#13;
    };&#13;
&#13;
    presenter.gradualShowAnswers = function (data) {&#13;
        if(data.moduleID !== presenter.addonID) return;&#13;
&#13;
        if(!presenter.isGradualShowAnswersActive){&#13;
            presenter.saveUserSelectionBeforeShowAnswers();&#13;
        }&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
        presenter.isGradualShowAnswersActive = true;&#13;
        presenter.isSelectionPossible = false;&#13;
&#13;
        for(const key in presenter.GSAcorrectAnswerLocations) {&#13;
            if (usedGSAKeys.includes(key)) {&#13;
                continue;&#13;
            } else if (presenter.configuration.checkByWords) {&#13;
                usedGSAKeys.push(key);&#13;
            }&#13;
            if (!presenter.GSAcorrectAnswerLocations.hasOwnProperty(key)) continue;&#13;
&#13;
            const answer = presenter.GSAcorrectAnswerLocations[key];&#13;
            const row = answer["row"];&#13;
            const column = answer["column"];&#13;
            if (row.length !== column.length) continue;&#13;
            &#13;
            presenter.configuration.checkByWords&#13;
                    ? presenter.showNextWord(row, column)&#13;
                    : presenter.showNextLetter(key, row, column);&#13;
&#13;
            break;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showNextWord = function (row, column) {&#13;
        const columns = presenter.configuration.columns;&#13;
&#13;
        for (let i = 0; i &lt; row.length; i++){&#13;
            let index = row[i] * columns + column[i];&#13;
            let element = gridContainerWrapper.find(`.selectable-element:eq(${index})`);&#13;
            element.addClass('selectable-element-show-answers');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showNextLetter = function (key, row, column) { &#13;
        const columns = presenter.configuration.columns;&#13;
&#13;
        var element;&#13;
        do {&#13;
            let index = row[GSALetterCounter] * columns + column[GSALetterCounter];&#13;
            element = gridContainerWrapper.find(`.selectable-element:eq(${index})`);&#13;
            GSALetterCounter++;&#13;
        } while(element.hasClass("selectable-element-show-answers"));&#13;
        element.addClass('selectable-element-show-answers');&#13;
&#13;
        if (GSALetterCounter === row.length) {&#13;
            usedGSAKeys.push(key);&#13;
            GSALetterCounter = 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.gradualHideAnswers = function () {&#13;
        if (!presenter.isGradualShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        GSALetterCounter = 0;&#13;
        usedGSAKeys = [];&#13;
&#13;
        presenter.hideAnswers();&#13;
    };&#13;
&#13;
    presenter.keyboardController = function (keycode, isShiftKeyDown, event) {&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
    };&#13;
&#13;
    function MagicBoxesKeyboardController (elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
        this.updateMapping();&#13;
    }&#13;
&#13;
    MagicBoxesKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    MagicBoxesKeyboardController.prototype.constructor = MagicBoxesKeyboardController;&#13;
&#13;
    presenter.buildKeyboardController = function () {&#13;
        const keyNavElements = presenter.getElementsForKeyboardNavigation();&#13;
        presenter.keyboardControllerObject = new MagicBoxesKeyboardController(&#13;
            keyNavElements, presenter.configuration.columns&#13;
        );&#13;
    };&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        return presenter.$view.find(`.${presenter.CSS_CLASSES.ELEMENT_WRAPPER}`);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.updateMapping = function () {&#13;
        this.mapping[window.KeyboardControllerKeys.TAB] = this.nextTabElement;&#13;
        this.shiftKeysMapping[window.KeyboardControllerKeys.TAB] = this.previousTabElement;&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.nextTabElement = function (event) {&#13;
        KeyboardController.prototype.nextElement.call(this, event);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.previousTabElement = function (event) {&#13;
        KeyboardController.prototype.previousElement.call(this, event);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.nextElement = function (event) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
        const newPositionIndex = this.calculateNewPositionIndexForHorizontalMove(1);&#13;
        if (newPositionIndex !== undefined) {&#13;
            this.markCurrentElement(newPositionIndex);&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.previousElement = function (event) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
        const newPositionIndex = this.calculateNewPositionIndexForHorizontalMove(-1);&#13;
        if (newPositionIndex !== undefined) {&#13;
            this.markCurrentElement(newPositionIndex);&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.nextRow = function (event) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
        const newPositionIndex = this.calculateNewPositionIndexForVerticalMove(this.columnsCount);&#13;
        if (newPositionIndex !== undefined) {&#13;
            this.markCurrentElement(newPositionIndex);&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.previousRow = function (event) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
        const newPositionIndex = this.calculateNewPositionIndexForVerticalMove(-this.columnsCount);&#13;
        if (newPositionIndex !== undefined) {&#13;
            this.markCurrentElement(newPositionIndex);&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.calculateNewPositionIndexForHorizontalMove = function (move) {&#13;
        return this.calculateNewPositionIndexForMoveInOneAxis(move, true);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.calculateNewPositionIndexForVerticalMove = function (move) {&#13;
        return this.calculateNewPositionIndexForMoveInOneAxis(move, false);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.calculateNewPositionIndexForMoveInOneAxis = function (move, isHorizontal = true) {&#13;
        const oldPosition = this.calculatePosition();&#13;
        const newPosition = this.calculatePosition(move);&#13;
        const newPositionIndex = this.keyboardNavigationCurrentElementIndex + move;&#13;
        if (move === 0&#13;
            || (isHorizontal &amp;&amp; newPosition.y !== oldPosition.y)&#13;
            || (!isHorizontal &amp;&amp; newPosition.x !== oldPosition.x)&#13;
            || (newPositionIndex &gt;= this.keyboardNavigationElementsLen)&#13;
            || (newPositionIndex &lt; 0)) {&#13;
            return undefined;&#13;
        }&#13;
        return newPositionIndex;&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.calculatePosition = function (move = 0) {&#13;
        const newIndex = this.keyboardNavigationCurrentElementIndex + move;&#13;
        return {&#13;
            x: newIndex % this.columnsCount,&#13;
            y: Math.floor(newIndex / this.columnsCount)&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.markCurrentElement = function (new_position_index) {&#13;
        KeyboardController.prototype.markCurrentElement.call(this, new_position_index);&#13;
&#13;
        if (presenter.isTTS()) {&#13;
            this.readCurrentElement();&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.enter = function (event) {&#13;
        const isFirstEnter = !this.keyboardNavigationActive;&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
&#13;
        if (presenter.isTTS() &amp;&amp; !isFirstEnter) {&#13;
            this.readCurrentElement();&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.select = function (event) {&#13;
        if (event) {&#13;
            event.preventDefault();&#13;
        }&#13;
&#13;
        if (!this.isSelectEnabled || !presenter.isSelectionPossible) {&#13;
            return;&#13;
        }&#13;
&#13;
        const $currentSelectableElement = this.getCurrentSelectableElement();&#13;
        const hadSelectedClass = $currentSelectableElement.hasClass(presenter.CSS_CLASSES.SELECTED);&#13;
&#13;
        this.selectAction();&#13;
&#13;
        const haveSelectedClass = $currentSelectableElement.hasClass(presenter.CSS_CLASSES.SELECTED);&#13;
        const classChanged = hadSelectedClass !== haveSelectedClass;&#13;
        if (classChanged) {&#13;
            if (haveSelectedClass) {&#13;
                readSelected();&#13;
            } else {&#13;
                readDeselected();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.selectAction = function () {&#13;
        const currentPosition = this.calculatePosition();&#13;
        selectionHandler(currentPosition.y, currentPosition.x);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.getCurrentSelectableElement = function () {&#13;
        const $elementWrapper = this.getCurrentElement();&#13;
        return $elementWrapper.find(`.${presenter.CSS_CLASSES.ELEMENT}:first`);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.getCurrentElement = function () {&#13;
        return this.getTarget(this.keyboardNavigationCurrentElement, false);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.getTarget = function (element, willBeClicked) {&#13;
        return $(element);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.readCurrentElement = function () {&#13;
        const $element = this.getCurrentSelectableElement();&#13;
&#13;
        let textVoices = window.TTSUtils.getTextVoiceArrayFromElement($element, presenter.configuration.langTag);&#13;
        this.unshiftElementIndexTextVoice(textVoices);&#13;
        this.addElementStateInfoTextVoices(textVoices, $element);&#13;
&#13;
        presenter.speak(textVoices);&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.unshiftElementIndexTextVoice = function (textVoices) {&#13;
        const alphabet = "ABCDEFGHIJKLMNOPRSTUWXYZ";&#13;
        const position = this.calculatePosition();&#13;
        const message = presenter.speechTexts.Cell&#13;
            + " " + alphabet[position.x % alphabet.length]&#13;
            + " " + (position.y + 1);&#13;
        textVoices.unshift(window.TTSUtils.getTextVoiceObject(message));&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.addElementStateInfoTextVoices = function (textVoices, $selectableElement) {&#13;
        if ($selectableElement.hasClass(presenter.CSS_CLASSES.SELECTED)&#13;
            || $selectableElement.hasClass(presenter.CSS_CLASSES.SHOW_ANSWERS)) {&#13;
            addTextVoiceWithLanguageFromLesson(textVoices, presenter.speechTexts.Selected);&#13;
        }&#13;
&#13;
        switch (true) {&#13;
            case ($selectableElement.hasClass(presenter.CSS_CLASSES.CORRECT_SELECTED)):&#13;
                addTextVoiceWithLanguageFromLesson(textVoices, presenter.speechTexts.Correct);&#13;
                break;&#13;
            case ($selectableElement.hasClass(presenter.CSS_CLASSES.WRONG_SELECTED)):&#13;
                addTextVoiceWithLanguageFromLesson(textVoices, presenter.speechTexts.Wrong);&#13;
                break;&#13;
            default:&#13;
                break;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setWCAGStatus = function(isWCAGOn) {&#13;
        presenter.isWCAGOn = isWCAGOn;&#13;
    };&#13;
&#13;
    MagicBoxesKeyboardController.prototype.exitWCAGMode = function () {&#13;
        KeyboardController.prototype.exitWCAGMode.call(this);&#13;
        presenter.setWCAGStatus(false);&#13;
    };&#13;
&#13;
    function readSelected () {&#13;
        let textVoices = [];&#13;
        addTextVoiceWithLanguageFromLesson(textVoices, presenter.speechTexts.Selected);&#13;
        presenter.speak(textVoices);&#13;
    }&#13;
&#13;
    function readDeselected () {&#13;
        let textVoices = [];&#13;
        addTextVoiceWithLanguageFromLesson(textVoices, presenter.speechTexts.Deselected);&#13;
        presenter.speak(textVoices);&#13;
    }&#13;
&#13;
    function addTextVoiceWithLanguageFromLesson(textVoices, message) {&#13;
        textVoices.push(window.TTSUtils.getTextVoiceObject(message));&#13;
    }&#13;
&#13;
    presenter.isTTS = function () {&#13;
        return presenter.isWCAGOn &amp;&amp; presenter.getTextToSpeechOrNull(playerController);&#13;
    };&#13;
&#13;
    presenter.speak = function(data) {&#13;
        const tts = presenter.getTextToSpeechOrNull(playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(data);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function (playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>