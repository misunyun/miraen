<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Grid_Scene" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property name="Rows" nameLabel="Grid_Scene_property_rows" type="string"/>
        <property name="Columns" nameLabel="Grid_Scene_property_columns" type="string"/>
        <property name="Color" nameLabel="Grid_Scene_property_color" type="string"/>
        <property name="delay" nameLabel="Grid_Scene_property_delay" type="string"/>
        <property isDefault="true" name="default_commands" nameLabel="Grid_Scene_property_default_commands" type="staticlist">
            <property displayName="setColor(Color)" name="command_setColor" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="clear()" name="command_clear" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="setCursor(x,y)" name="command_setCursor" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="mark(x,y)" name="command_mark" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="clearMark(x,y)" name="command_clearMark" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawLeft(Steps)" name="command_drawLeft" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawUp(Steps)" name="command_drawUp" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawRight(Steps)" name="command_drawRight" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawDown(Steps)" name="command_drawDown" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawLeftFrom(x,y,Steps)" name="command_drawLeftFrom" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawUpFrom(x,y,Steps)" name="command_drawUpFrom" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawRightFrom(x,y,Steps)" name="command_drawRightFrom" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
            <property displayName="drawDownFrom(x,y,Steps)" name="command_drawDownFrom" type="staticrow">
                <property name="alias" nameLabel="Grid_Scene_property_default_commands_command_alias" type="string"/>
                <property name="arguments_aliases" nameLabel="Grid_Scene_property_default_commands_arguments_alias" type="string"/>
                <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
            </property>
        </property>
        <property name="custom_commands" nameLabel="Grid_Scene_property_custom_commands" type="list">
            <property name="command_name" nameLabel="Grid_Scene_property_custom_command_name" type="string"/>
            <property name="command_arguments" nameLabel="Grid_Scene_property_custom_command_arguments" type="string"/>
            <property name="command_code" nameLabel="Grid_Scene_property_custom_command_code" type="text"/>
            <property name="is_disabled" nameLabel="Grid_Scene_property_default_commands_is_disabled" type="boolean"/>
        </property>
        <property name="json_commands" nameLabel="Grid_Scene_property_json_commands" type="text"/>
        <property name="answer" nameLabel="Grid_Scene_property_answer" type="text"/>
	</model>
<css>.grid-scene-wrapper {&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.grid-scene-cell {&#13;
    margin: 0;&#13;
    padding: 0;&#13;
    border: none;&#13;
}&#13;
&#13;
.grid-scene-cell-element {&#13;
    float: left;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    color: black;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
&#13;
.grid-scene-cell-element-wrapper {&#13;
    float: left;&#13;
    padding: 0;&#13;
    margin: 0;&#13;
    border-style: solid;&#13;
    border-color: black;&#13;
    border-width: 1px;&#13;
    -webkit-box-sizing:border-box;&#13;
    -moz-box-sizing:border-box;&#13;
    box-sizing:border-box;&#13;
}&#13;
&#13;
.grid-scene-correct {&#13;
    background-color: green;&#13;
}&#13;
&#13;
.grid-scene-wrong {&#13;
    background-color: red;&#13;
}&#13;
</css><view>&lt;div class="grid-scene-wrapper"&gt;&#13;
    &lt;div class="grid-scene-cell"&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="grid-scene-wrapper"&gt;&#13;
    &lt;div class="grid-scene-cell"&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonGrid_Scene_create(){&#13;
&#13;
    var presenter = function(){};&#13;
&#13;
    presenter.playerController = null;&#13;
    presenter.eventBus = null;&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        GS01: "Columns and rows must be a positive integer",&#13;
        GS02: "Delay have to be a positive integer",&#13;
        GS03: "Commands have to be a valid JSON string",&#13;
        GS04: "Error while getting file with commands. Check url.",&#13;
        CP01: "Custom Command must have command_arguments property",&#13;
        CP02: "Custom Command must have is_disabled property",&#13;
        CP03: "Custom Command must have command_code property",&#13;
        CP04: "Custom Command must have command_name property",&#13;
        CP05: "Custom Command must have valid JS name",&#13;
        CP06: "Custom Command arguments must have valid JS name",&#13;
        CP07: "Multiple Custom Command declared",&#13;
        AE01: "Multiple alias declaration in default commands",&#13;
        DA01: "Default Command alias must have valid JS name",&#13;
        DA02: "Default Command Arguments aliases must have valid JS names",&#13;
        BG01: "Exceeded maximum column number",&#13;
        BG02: "Exceeded maximum row number"&#13;
    };&#13;
&#13;
    presenter.LABELS = {&#13;
        "command_clear": "clear",&#13;
        "command_mark": "mark",&#13;
        "command_drawLeft": "drawLeft",&#13;
        "command_drawRight": "drawRight",&#13;
        "command_drawUp": "drawUp",&#13;
        "command_drawDown": "drawDown",&#13;
        "command_drawLeftFrom": "drawLeftFrom",&#13;
        "command_drawRightFrom": "drawRightFrom",&#13;
        "command_drawUpFrom": "drawUpFrom",&#13;
        "command_drawDownFrom": "drawDownFrom",&#13;
        "command_setColor": "setColor",&#13;
        "command_setCursor": "setCursor",&#13;
        "command_clearMark": "clearMark",&#13;
        "block_mark": "mark",&#13;
        "block_x": "x",&#13;
        "block_y": "y",&#13;
        "block_clear": "clear",&#13;
        "block_steps": "steps",&#13;
        "block_drawLeft": "drawLeft",&#13;
        "block_drawRight": "drawRight",&#13;
        "block_drawUp": "drawUp",&#13;
        "block_drawDown": "drawDown",&#13;
        "block_drawLeftFrom": "drawLeftFrom",&#13;
        "block_drawRightFrom": "drawRightFrom",&#13;
        "block_drawUpFrom": "drawUpFrom",&#13;
        "block_drawDownFrom": "drawDownFrom",&#13;
        "block_setColor": "setColor",&#13;
        "block_setCursor": "setCursor",&#13;
        "block_clearMark": "clearMark"&#13;
    };&#13;
&#13;
    presenter.DEFAULT_COMMANDS_TO_BLOCKS = {&#13;
        "command_clear" : 'scene_grid_clear',&#13;
        "command_mark" : 'scene_grid_mark',&#13;
        "command_drawLeft" : 'scene_grid_drawleft',&#13;
        "command_drawRight" : 'scene_grid_drawright',&#13;
        "command_drawUp" : 'scene_grid_drawup',&#13;
        "command_drawDown" : 'scene_grid_drawdown',&#13;
        "command_drawLeftFrom" : 'scene_grid_drawleftfrom',&#13;
        "command_drawRightFrom" : 'scene_grid_drawrightfrom',&#13;
        "command_drawUpFrom" : 'scene_grid_drawupfrom',&#13;
        "command_drawDownFrom" : 'scene_grid_drawdownfrom',&#13;
        "command_setColor" : 'scene_grid_setcolor',&#13;
        "command_setCursor" : 'scene_grid_setcursor',&#13;
        "command_clearMark" : 'scene_grid_clearmark'&#13;
    };&#13;
&#13;
    presenter.configuration = {&#13;
        isError : true,&#13;
        isVisible : true,&#13;
        isPreview: false,&#13;
        visibleByDefault : true,&#13;
        addonID : null,&#13;
        rows : null,&#13;
        columns : null,&#13;
        color : null,&#13;
        hasDelay: false,&#13;
        isErrorMode: false,&#13;
        isSavingAnswer: false,&#13;
        delay: 0,&#13;
        queLoopTimer: null,&#13;
        commandQueue: [],&#13;
        blockLabels: {},&#13;
        commandsLabels: {},&#13;
        excludedCommands: {},&#13;
        answerCode: "",&#13;
        isShowingAnswers: false,&#13;
        isAnswer: false,&#13;
        isVisible: true&#13;
    };&#13;
&#13;
&#13;
    presenter.originalCommands = null;&#13;
&#13;
    presenter.commandsArgs = {&#13;
        "command_clear": "",&#13;
        "command_mark": "x, y",&#13;
        "command_drawLeft": "steps",&#13;
        "command_drawRight": "steps",&#13;
        "command_drawUp": "steps",&#13;
        "command_drawDown": "steps",&#13;
        "command_drawLeftFrom": "x, y, steps",&#13;
        "command_drawRightFrom": "x, y, steps",&#13;
        "command_drawUpFrom": "x, y, steps",&#13;
        "command_drawDownFrom": "x, y, steps",&#13;
        "command_setColor": "color",&#13;
        "command_setCursor": "x, y",&#13;
        "command_clearMark": "x, y"&#13;
    };&#13;
&#13;
    presenter.coloredGrid = [];&#13;
    presenter.actualCursorPosition = [1,1];&#13;
&#13;
    function delayDecorator(func) {&#13;
        if (presenter.configuration.hasDelay) {&#13;
            return function () {&#13;
                presenter.configuration.commandQueue.push({&#13;
                    function: func,&#13;
                    args: arguments&#13;
                });&#13;
            }&#13;
        } else {&#13;
            return func;&#13;
        }&#13;
    }&#13;
&#13;
    function applyDecorator (func) {&#13;
        return function (args) {&#13;
            return func.apply(null, args);&#13;
        };&#13;
    }&#13;
&#13;
    function applyDelayDecorator (func) {&#13;
        if (presenter.configuration.hasDelay) {&#13;
            return function (args) {&#13;
                presenter.configuration.commandQueue.push({&#13;
                    function: func,&#13;
                    args: args&#13;
                });&#13;
            };&#13;
        } else {&#13;
            return function (args) {&#13;
                return func.apply(null, args);&#13;
            };&#13;
        }&#13;
    }&#13;
&#13;
    function isValidName (name) {&#13;
        return ModelValidationUtils.validateJSVariableName(name.trim()).isValid;&#13;
    }&#13;
&#13;
    function returnErrorObject(errorCode) {&#13;
        return { isError: true, errorCode: errorCode };&#13;
    }&#13;
&#13;
    var gridContainerWrapper;&#13;
    var gridContainer;&#13;
&#13;
    presenter.initColoredGridArray = function Grid_Addon_initColoredGridArray(rows, columns) {&#13;
        for (var rows_index = 0; rows_index &lt; rows; rows_index++) {&#13;
            presenter.coloredGrid[rows_index] = [];&#13;
            for (var columns_index = 0; columns_index &lt; columns; columns_index++) {&#13;
                presenter.coloredGrid[rows_index][columns_index] = "Empty";&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setColoredGridArray = function Grid_Addon_set_colored_grid_array (array) {&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
&#13;
        for (var rows_index = 0; rows_index &lt; rows; rows_index++) {&#13;
            for (var columns_index = 0; columns_index &lt; columns; columns_index++) {&#13;
                if (array[rows_index][columns_index] != "Empty") {&#13;
                    presenter.setColor(array[rows_index][columns_index]);&#13;
                    presenter.markPoint(columns_index+1, rows_index+1);&#13;
                } else {&#13;
                    presenter.resetMark(columns_index+1, rows_index+1);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    function initGrid(model) {&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
&#13;
        presenter.initColoredGridArray(rows,columns);&#13;
        for(var row = 0; row &lt; rows; row++) {&#13;
            for(var column = 0; column &lt; columns; column++) {&#13;
                var wrapperElement = $(document.createElement('div'));&#13;
                wrapperElement.addClass('grid-scene-cell-element-wrapper');&#13;
&#13;
                var selectableElement = $(document.createElement('div'));&#13;
                selectableElement.addClass('grid-scene-cell-element');&#13;
                selectableElement.attr('coordinates', (column+1)+"-"+((rows-row)));&#13;
&#13;
                wrapperElement.append(selectableElement);&#13;
                gridContainer.append(wrapperElement);&#13;
            }&#13;
        }&#13;
&#13;
        var gridContainerWrapperDimensions = getElementDimensions(gridContainerWrapper);&#13;
        var gridContainerWrapperDistances = calculateInnerDistance(gridContainerWrapperDimensions);&#13;
&#13;
        var wrapperDimensions = getElementDimensions(gridContainerWrapper.find('.grid-scene-cell-element-wrapper:first')[0]);&#13;
        var wrapperDistances = calculateInnerDistance(wrapperDimensions);&#13;
&#13;
        var elementDimensions = getElementDimensions(gridContainerWrapper.find('.grid-scene-cell-element:first')[0]);&#13;
        var elementDistances = calculateInnerDistance(elementDimensions);&#13;
&#13;
        var wrapperWidth = parseInt((model.Width - gridContainerWrapperDistances.horizontal - (wrapperDistances.horizontal * columns)) / columns, 10);&#13;
        var wrapperHeight = parseInt((model.Height - gridContainerWrapperDistances.vertical - (wrapperDistances.vertical * rows)) / rows, 10);&#13;
&#13;
        var elementWidth = wrapperWidth - elementDistances.horizontal;&#13;
        var elementHeight = wrapperHeight - elementDistances.vertical;&#13;
&#13;
        var newContainerWrapperHeight = wrapperHeight * rows + wrapperDistances.vertical * rows;&#13;
        var newContainerWrapperWidth = wrapperWidth * columns + wrapperDistances.horizontal * columns;&#13;
&#13;
        var verticalGapHeight = model.Height - newContainerWrapperHeight;&#13;
        var horizontalGapHeight = model.Width - newContainerWrapperWidth;&#13;
&#13;
        gridContainerWrapper.css('height', model.Height + 'px');&#13;
        gridContainerWrapper.css('width', model.Width + 'px');&#13;
        gridContainer.css('height', model.Height + 'px');&#13;
        gridContainer.css('width', (parseInt(model.Width, 10)+parseInt(elementWidth / 2, 10)) + 'px');&#13;
&#13;
        var vertical = verticalGapHeight / rows;&#13;
        var horizontal = horizontalGapHeight / columns;&#13;
&#13;
        gridContainer.find(".grid-scene-cell-element-wrapper").each(function() {&#13;
            var index = $(this).index();&#13;
            var selectedRow = parseInt(index / columns, 10);&#13;
&#13;
            $(this).width(wrapperWidth + horizontal + 2);&#13;
            $(this).height(wrapperHeight + vertical + 2);&#13;
&#13;
            var selectableElement = $(this).find('.grid-scene-cell-element:first');&#13;
&#13;
            var lineHeight = selectedRow === rows -1 ? elementHeight + verticalGapHeight : elementHeight;&#13;
            selectableElement.css('line-height', lineHeight + "px");&#13;
        });&#13;
    }&#13;
&#13;
    function getElementDimensions(element) {&#13;
        element = $(element);&#13;
&#13;
        return {&#13;
            border:{&#13;
                top:parseInt(element.css('border-top-width'), 10),&#13;
                bottom:parseInt(element.css('border-bottom-width'), 10),&#13;
                left:parseInt(element.css('border-left-width'), 10),&#13;
                right:parseInt(element.css('border-right-width'), 10)&#13;
            },&#13;
            margin:{&#13;
                top:parseInt(element.css('margin-top'), 10),&#13;
                bottom:parseInt(element.css('margin-bottom'), 10),&#13;
                left:parseInt(element.css('margin-left'), 10),&#13;
                right:parseInt(element.css('margin-right'), 10)&#13;
            },&#13;
            padding:{&#13;
                top:parseInt(element.css('padding-top'), 10),&#13;
                bottom:parseInt(element.css('padding-bottom'), 10),&#13;
                left:parseInt(element.css('padding-left'), 10),&#13;
                right:parseInt(element.css('padding-right'), 10)&#13;
            }&#13;
        };&#13;
    }&#13;
&#13;
    function calculateInnerDistance(elementDimensions) {&#13;
        var vertical = elementDimensions.border.top + elementDimensions.border.bottom;&#13;
        vertical += elementDimensions.margin.top + elementDimensions.margin.bottom;&#13;
        vertical += elementDimensions.padding.top + elementDimensions.padding.top;&#13;
&#13;
        var horizontal = elementDimensions.border.left + elementDimensions.border.right;&#13;
        horizontal += elementDimensions.margin.left + elementDimensions.margin.right;&#13;
        horizontal += elementDimensions.padding.left + elementDimensions.padding.right;&#13;
&#13;
        return {&#13;
            vertical : vertical,&#13;
            horizontal : horizontal&#13;
        };&#13;
    }&#13;
&#13;
    presenter.colorSquare = function (x, y){&#13;
        if (!presenter.configuration.isSavingAnswer) {&#13;
            var coordinates = x + "-" + y;&#13;
            var element = presenter.$view.find('.grid-scene-cell-element[coordinates="' + coordinates + '"]');&#13;
&#13;
            element.css('background-color', presenter.configuration.color);&#13;
            element.attr('colored', 'true');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.resetMark = function (x, y){&#13;
        presenter.actualCursorPosition = [x,y];&#13;
        var coordinates = x+"-"+ y;&#13;
        var element = presenter.$view.find('.grid-scene-cell-element[coordinates="'+ coordinates +'"]');&#13;
        if (ModelValidationUtils.validateIntegerInRange(x, presenter.configuration.columns + 1, 1).isValid != false) {&#13;
            if (ModelValidationUtils.validateIntegerInRange(y, presenter.configuration.rows + 1, 1).isValid != false) {&#13;
                presenter.coloredGrid[y - 1][x - 1] = "Empty";&#13;
            }&#13;
        }&#13;
        element.css('background-color', '');&#13;
        element.attr('colored', 'false');&#13;
        presenter.sendMarkEvent("clearMark", x, y);&#13;
    };&#13;
    &#13;
    &#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    presenter.run = function(view, model){&#13;
        presenter.presenterLogic(view, model, false);&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model){&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.presenterLogic = function(view, model, isPreview) {&#13;
        presenter.configuration.isPreview = isPreview;&#13;
&#13;
        presenter.view = view;&#13;
        presenter.$view = $(view);&#13;
&#13;
        presenter.configuration = $.extend({}, presenter.configuration, presenter.validateModel(model));&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
&#13;
        gridContainerWrapper = presenter.$view.find(".grid-scene-wrapper:first");&#13;
        gridContainer = gridContainerWrapper.find(".grid-scene-cell:first");&#13;
&#13;
        initGrid(model);&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
&#13;
        presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved(ev) {&#13;
            if (ev.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
&#13;
&#13;
&#13;
        if (!isPreview) {&#13;
            presenter.setQueLoopTimer();&#13;
        }&#13;
&#13;
        presenter.saveAnswer(isPreview);&#13;
&#13;
        presenter.actualCursorPosition = [1,1];&#13;
        presenter.startCursorPosition = presenter.actualCursorPosition;&#13;
    };&#13;
&#13;
    presenter.saveAnswer = function Grid_Scene_save_answer(isPreview) {&#13;
        if (!isPreview) {&#13;
            presenter.configuration.isSavingAnswer = true;&#13;
        }&#13;
&#13;
        var originalDelay = presenter.configuration.hasDelay;&#13;
        presenter.configuration.hasDelay = false;&#13;
        presenter.generateOriginalCommands();&#13;
&#13;
        presenter.executeCode(presenter.configuration.answerCode);&#13;
        presenter.configuration.hasDelay = originalDelay;&#13;
        presenter.generateOriginalCommands();&#13;
        presenter.configuration.answer = $.extend(true,[], presenter.coloredGrid);&#13;
&#13;
        presenter.initColoredGridArray(presenter.configuration.rows, presenter.configuration.columns);&#13;
        presenter.setColor(presenter.configuration.defaultColor);&#13;
        presenter.configuration.isSavingAnswer = false;&#13;
&#13;
    };&#13;
&#13;
    presenter.generateOriginalCommands = function () {&#13;
        presenter.originalCommands = {&#13;
                command_clear: delayDecorator(presenter.reset),&#13;
                command_mark: delayDecorator(presenter.mark),&#13;
                command_drawLeft: delayDecorator(presenter.drawLeft),&#13;
                command_drawRight: delayDecorator(presenter.drawRight),&#13;
                command_drawUp: delayDecorator(presenter.drawUp),&#13;
                command_drawDown: delayDecorator(presenter.drawDown),&#13;
                command_drawLeftFrom: delayDecorator(presenter.drawLeft),&#13;
                command_drawRightFrom: delayDecorator(presenter.drawRight),&#13;
                command_drawUpFrom: delayDecorator(presenter.drawUp),&#13;
                command_drawDownFrom: delayDecorator(presenter.drawDown),&#13;
                command_setColor: delayDecorator(presenter.setColor),&#13;
                command_setCursor: delayDecorator(presenter.setCursor),&#13;
                command_clearMark: delayDecorator(presenter.resetMark)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.setQueLoopTimer = function () {&#13;
        if(presenter.configuration.hasDelay) {&#13;
            presenter.configuration.queLoopTimer = setInterval(presenter.queLoop, presenter.configuration.delay)&#13;
        }&#13;
    };&#13;
&#13;
    presenter.queLoop = function () {&#13;
        if (presenter.configuration.commandQueue.length &gt; 0) {&#13;
            var task = presenter.configuration.commandQueue.shift();&#13;
            task.function.apply(null, task.args);&#13;
        }&#13;
    };&#13;
    presenter.destroy = function () {&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        clearInterval(presenter.configuration.queLoopTimer);&#13;
        presenter.$view = null;&#13;
        presenter.view = null;&#13;
        presenter.configuration = null;&#13;
        presenter.originalCommands = null;&#13;
        presenter.commandsArgs = null;&#13;
        presenter.coloredGrid = null;&#13;
        presenter.actualCursorPosition = null;&#13;
        presenter.lastState = null;&#13;
    };&#13;
&#13;
&#13;
    function haveDuplicatedValue(firstDict, secondDict) {&#13;
        for (var key in firstDict) {&#13;
            for (var comparedKey in secondDict) {&#13;
                if (firstDict.hasOwnProperty(key) &amp;&amp; secondDict.hasOwnProperty(comparedKey)) {&#13;
                    if (key != comparedKey) {&#13;
                        if (firstDict[key] == secondDict[comparedKey]) {&#13;
                            return true;&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.validateModel = function(model) {&#13;
        var validatedIsVisible = ModelValidationUtils.validateBoolean(model['Is Visible']);&#13;
        var addonID = model['ID'];&#13;
        var rows = ModelValidationUtils.validatePositiveInteger(model['Rows']);&#13;
        if (rows.value &gt; 40) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "BG02"&#13;
            }&#13;
        }&#13;
        var columns = ModelValidationUtils.validatePositiveInteger(model['Columns']);&#13;
        if (columns.value &gt; 40) {&#13;
            return {&#13;
                isValid: false,&#13;
                errorCode: "BG01"&#13;
            }&#13;
        }&#13;
&#13;
        if(!rows.isValid || !columns.isValid){&#13;
            return returnErrorObject('GS01');&#13;
        }&#13;
&#13;
        var color = model['Color'];&#13;
        if(color == ''){&#13;
            color = 'black';&#13;
        }&#13;
&#13;
        var validatedDelay = presenter.validateDelay(model);&#13;
        if (!validatedDelay.isValid) {&#13;
            return validatedDelay;&#13;
        }&#13;
&#13;
&#13;
        var validatedDefaultCommands = presenter.validateDefaultCommands(model);&#13;
        if (!validatedDefaultCommands.isValid) {&#13;
            return validatedDefaultCommands;&#13;
        }&#13;
&#13;
        var validatedTranslations = validatedDefaultCommands.value.translations;&#13;
        if (haveDuplicatedValue(validatedTranslations, validatedTranslations)) {&#13;
            return presenter.getErrorObject("AE01");&#13;
        }&#13;
&#13;
        presenter.commandsArgs = $.extend(presenter.commandsArgs, validatedDefaultCommands.value.argumentsTranslation);&#13;
&#13;
        var validatedCustomCommands = presenter.validateCustomCommands(model['custom_commands']);&#13;
        if (!validatedCustomCommands.isValid) {&#13;
            return validatedCustomCommands;&#13;
        }&#13;
&#13;
        var validatedCommandsFromFile = presenter.validateCommandsJSON(model['json_commands']);&#13;
        if (!validatedCommandsFromFile.isValid) {&#13;
            return validatedCommandsFromFile;&#13;
        }&#13;
&#13;
        var mergedCustomCommands = $.merge(validatedCustomCommands.value.commands,&#13;
                                 validatedCommandsFromFile.value.commands);&#13;
&#13;
        var customCommandsNames = {};&#13;
        for (var i = 0; i &lt; mergedCustomCommands.length; i++) {&#13;
            customCommandsNames[i] = mergedCustomCommands[i].name;&#13;
        }&#13;
&#13;
        if (haveDuplicatedValue(customCommandsNames, customCommandsNames)) {&#13;
            return presenter.getErrorObject("CP07");&#13;
        }&#13;
&#13;
        return {&#13;
            'isError' : false,&#13;
            'isVisible' : validatedIsVisible,&#13;
            'visibleByDefault' : validatedIsVisible,&#13;
            'addonID' : addonID,&#13;
            'rows' : rows.value,&#13;
            'columns' : columns.value,&#13;
            'color' : color,&#13;
            'defaultColor': color,&#13;
            'startPoint': null,&#13;
            'hasDelay': validatedDelay.hasDelay,&#13;
            'delay': validatedDelay.delay,&#13;
            'labels': validatedTranslations,&#13;
            'customCommands': mergedCustomCommands,&#13;
            'excludedCommands': $.extend({},validatedCustomCommands.value.excludedCommands,&#13;
                                    validatedDefaultCommands.value.excludedCommands,&#13;
                                    validatedCommandsFromFile.value.excludedCommands),&#13;
            'answerCode': model['answer'],&#13;
            'isAnswer': !ModelValidationUtils.isStringEmpty(model['answer'])&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateDefaultCommand = function Grid_Scene_validate_default_command (key, command) {&#13;
        if (!ModelValidationUtils.isStringEmpty(command['alias'].trim())) {&#13;
            if (!isValidName(command['alias'])) {&#13;
                return presenter.getErrorObject("DA01");&#13;
            }&#13;
        }&#13;
        return {&#13;
            isValid: true,&#13;
            value : {&#13;
                validatedTranslation: command['alias'],&#13;
                validatedIsExcluded: ModelValidationUtils.validateBoolean(command['is_disabled']),&#13;
                validatedArgumentsTranslation: command['arguments_aliases']&#13;
            }&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateDefaultCommands = function Grid_Scene_validate_default_commands (model) {&#13;
        var translations = {};&#13;
        var excludedCommands = {};&#13;
        var argumentsTranslation = {};&#13;
        var defaultCommands = model['default_commands'];&#13;
        for (var key in defaultCommands) {&#13;
            if (defaultCommands.hasOwnProperty(key)) {&#13;
                var validatedDefaultCommand = presenter.validateDefaultCommand(key, defaultCommands[key]);&#13;
                if (!validatedDefaultCommand.isValid) {&#13;
                    return validatedDefaultCommand;&#13;
                }&#13;
                if (!ModelValidationUtils.isStringEmpty(validatedDefaultCommand.value.validatedTranslation)) {&#13;
                    translations[key] = validatedDefaultCommand.value.validatedTranslation;&#13;
                }&#13;
                if (validatedDefaultCommand.value.validatedIsExcluded) {&#13;
                    excludedCommands[key] = true;&#13;
                }&#13;
                if (!ModelValidationUtils.isStringEmpty(validatedDefaultCommand.value.validatedArgumentsTranslation)) {&#13;
                    argumentsTranslation[key] = validatedDefaultCommand.value.validatedArgumentsTranslation;&#13;
                }&#13;
            }&#13;
    }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {&#13;
                translations: translations,&#13;
                excludedCommands: excludedCommands,&#13;
                argumentsTranslation: argumentsTranslation&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateCustomCommand = function Grid_Scene_validate_command (command) {&#13;
&#13;
        if (!command.hasOwnProperty('command_arguments')) {&#13;
            return presenter.getErrorObject("CP01");&#13;
        }&#13;
        if (!command.hasOwnProperty('is_disabled')) {&#13;
            return presenter.getErrorObject("CP02");&#13;
        }&#13;
        if (!command.hasOwnProperty('command_code')) {&#13;
            return presenter.getErrorObject("CP03");&#13;
        }&#13;
        if (!command.hasOwnProperty('command_name')) {&#13;
            return presenter.getErrorObject("CP04");&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(command['command_name'])) {&#13;
            return {&#13;
                isValid: true,&#13;
                name: null&#13;
            };&#13;
        }&#13;
&#13;
        if (!isValidName(command['command_name'])) {   //REGEX to check name&#13;
            return presenter.getErrorObject("CP05");&#13;
        }&#13;
&#13;
        if (!ModelValidationUtils.isStringEmpty(command['command_arguments'].trim())) {&#13;
            var argumentsSplited = command['command_arguments'].split(",");&#13;
            for (var key in argumentsSplited) {&#13;
                if(argumentsSplited.hasOwnProperty(key)) {&#13;
                    if(!isValidName(argumentsSplited[key])) { //REGEX to check name&#13;
                        return presenter.getErrorObject("CP06");&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            name: command['command_name'],&#13;
            arguments: command['command_arguments'],&#13;
            code: command['command_code'],&#13;
            isExcluded: ModelValidationUtils.validateBoolean(command['is_disabled'])&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateCustomCommands = function Grid_Scene_validate_commands (commands) {&#13;
        var validatedCommands = [];&#13;
        var excludedCommands = {};&#13;
&#13;
        for (var key in commands) {&#13;
            if (commands.hasOwnProperty(key)) {&#13;
                var validatedCommand = presenter.validateCustomCommand(commands[key]);&#13;
                if (!validatedCommand.isValid) {&#13;
                    return validatedCommand;&#13;
                }&#13;
&#13;
                if (validatedCommand.name != null) {&#13;
                    validatedCommands.push(validatedCommand);&#13;
                    if (validatedCommand.isExcluded) {&#13;
                        excludedCommands[validatedCommand.name] = validatedCommand.isExcluded;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: {&#13;
                commands: validatedCommands,&#13;
                excludedCommands: excludedCommands&#13;
            }&#13;
        };&#13;
    };&#13;
&#13;
    presenter.validateCommandsJSON = function Grid_Scene_validate_commands_file (commands) {&#13;
        if (commands === undefined) {&#13;
            return {};&#13;
        }&#13;
&#13;
        var trimmedCommands = commands.trim();&#13;
        var result;&#13;
&#13;
        if (trimmedCommands == "") {&#13;
            result = {};&#13;
        } else {&#13;
            /*&#13;
            Remove all new lines from text&#13;
            e.g. : "Something&#13;
                    Here" -&gt; "SomethingHere"&#13;
             */&#13;
            var data = commands.replace(/\r?\n|\r/g,""); //removing all new lines&#13;
            /*&#13;
            Change all tabulators to space in text&#13;
            e.g. : "Something    Here" -&gt; "Something here"&#13;
             */&#13;
            data = data.replace(/\t/g," ");&#13;
&#13;
            try {&#13;
                result = JSON.parse(data);&#13;
            } catch (e) {&#13;
                return  presenter.getErrorObject("GS03");&#13;
            }&#13;
        }&#13;
&#13;
        var validatedCustomCommands = presenter.validateCustomCommands(result);&#13;
        if (!validatedCustomCommands.isValid) {&#13;
            return validatedCustomCommands;&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            value: validatedCustomCommands.value&#13;
        };&#13;
    };&#13;
&#13;
&#13;
&#13;
    presenter.validateDelay = function(model) {&#13;
        function getDelayObject (isValid, hasDelay, delay) {return {isValid: isValid, hasDelay: hasDelay, delay: delay};}&#13;
&#13;
        if (model["delay"] == undefined) {&#13;
            return getDelayObject(true, false);&#13;
        }&#13;
&#13;
        var trimmedDelay = model["delay"].trim();&#13;
        if (trimmedDelay == "") {&#13;
            return getDelayObject(true, false);&#13;
        }&#13;
&#13;
        var parsedDelay = Number(trimmedDelay);&#13;
        if(isNaN(parsedDelay)) {&#13;
            return presenter.getErrorObject("GS02");&#13;
        }&#13;
&#13;
        if (parsedDelay &gt; 0) {&#13;
            return getDelayObject(true, true, parsedDelay);&#13;
        } else {&#13;
            return getDelayObject(true, false, parsedDelay);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getErrorObject = function (errorCode) {&#13;
        return {isValid: false, isError: true, errorCode: errorCode};&#13;
    };&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.configuration.visibility = isVisible;&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.getDefaultCommands = function Grid_Scene_get_commands (withParams) {&#13;
        var functions = "";&#13;
        var labels = presenter.configuration.labels;&#13;
&#13;
        if (withParams === undefined) {&#13;
            withParams = false;&#13;
        }&#13;
&#13;
        for (var key in presenter.originalCommands) {&#13;
            if (presenter.originalCommands.hasOwnProperty(key)) {&#13;
                if (!(presenter.configuration.excludedCommands.hasOwnProperty(key))) {&#13;
                    var functionText = "";&#13;
                    var args = "";&#13;
&#13;
                    if (labels.hasOwnProperty(key)) {&#13;
                        functionText = labels[key];&#13;
                    } else {&#13;
                        functionText = presenter.LABELS[key];&#13;
                    }&#13;
&#13;
                    if (withParams) {&#13;
                        args = "(" + presenter.commandsArgs[key] + ")";&#13;
                    }&#13;
&#13;
                    functions += functionText + args + "&lt;br /&gt;";&#13;
                }&#13;
            }&#13;
        }&#13;
        return functions;&#13;
    };&#13;
&#13;
    presenter.getCustomCommands = function Grid_Screne_get_custom_commands (withParams) {&#13;
        var commands = "";&#13;
&#13;
        if (withParams === undefined) {&#13;
            withParams = false;&#13;
        }&#13;
&#13;
        var customCommands = presenter.configuration.customCommands;&#13;
        for (var key in customCommands) {&#13;
            if (customCommands.hasOwnProperty(key)) {&#13;
                if (!(customCommands[key].name in presenter.configuration.excludedCommands)) {&#13;
                    var args ="";&#13;
&#13;
                    if (withParams) {&#13;
                        args = "(" + customCommands[key].arguments + ")";&#13;
                    }&#13;
&#13;
                    commands += customCommands[key].name + args + "&lt;br /&gt;";&#13;
                }&#13;
            }&#13;
        }&#13;
        return commands;&#13;
    };&#13;
&#13;
    presenter.getCommands = function Grid_Screne_get_custom_commands (withParams) {&#13;
        if (withParams === undefined) {&#13;
            withParams = false;&#13;
        }&#13;
&#13;
        return presenter.getDefaultCommands(withParams) + presenter.getCustomCommands(withParams);&#13;
    };&#13;
&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'mark' : applyDelayDecorator(presenter.mark),&#13;
            'drawLeft': applyDelayDecorator(presenter.drawLeft),&#13;
            'drawRight': applyDelayDecorator(presenter.drawRight),&#13;
            'drawDown': applyDelayDecorator(presenter.drawDown),&#13;
            'drawUp': applyDelayDecorator(presenter.drawUp),&#13;
            'drawLeftFrom':applyDelayDecorator(presenter.drawLeft),&#13;
            'drawRightFrom': applyDelayDecorator(presenter.drawRight),&#13;
            'drawDownFrom': applyDelayDecorator(presenter.drawDown),&#13;
            'drawUpFrom': applyDelayDecorator(presenter.drawUp),&#13;
            'setCursor': applyDelayDecorator(presenter.setCursor),&#13;
            'setColor': applyDelayDecorator(presenter.setColor),&#13;
            'clearMark' : applyDelayDecorator(presenter.resetMark),&#13;
            'clear': applyDelayDecorator(presenter.reset),&#13;
            'reset' : presenter.reset,&#13;
            'executeCode': applyDecorator(presenter.executeCode),&#13;
            'getDefaultCommands': applyDelayDecorator(presenter.getDefaultCommands),&#13;
            'getCustomCommands': applyDelayDecorator(presenter.getCustomCommands),&#13;
            'getCommands': applyDelayDecorator(presenter.getCommands),&#13;
            'isAllOK': presenter.isAllOK&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.reset = function(){&#13;
        console.log("Reset");&#13;
        console.log(this);&#13;
        presenter.$view.find('.grid-scene-cell-element').each(function () {&#13;
            $(this).removeClass('grid-scene-wrong').removeClass('grid-scene-cell-element-wrapper');&#13;
            if($(this).attr('colored') == 'true'){&#13;
                var coordinates = $(this).attr('coordinates').split('-');&#13;
                presenter.resetMark(coordinates[0], coordinates[1]);&#13;
            }&#13;
        });&#13;
&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
        presenter.initColoredGridArray(rows,columns);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.visibleByDefault);&#13;
        presenter.configuration.color = presenter.configuration.defaultColor;&#13;
&#13;
        if(presenter.configuration.answer.length &gt; 0){&#13;
            presenter.actualCursorPosition = presenter.startCursorPosition;&#13;
        }else {&#13;
            presenter.actualCursorPosition = [1,1];&#13;
        }&#13;
&#13;
        presenter.configuration.isErrorMode = false;&#13;
        presenter.configuration.isShowingAnswers = false;&#13;
    };&#13;
&#13;
    presenter.setCursor = function (x, y) {&#13;
        if(!isNaN(parseInt(x, 10)) &amp;&amp; !isNaN(parseInt(y, 10))) {&#13;
            presenter.actualCursorPosition = [x, y];&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawHorizontalLine = function (from, to, y) {&#13;
        if (from &lt;= to) {&#13;
            for (var i = from; i &lt;= to; i++) {&#13;
                presenter.markPoint(i, y);&#13;
            }&#13;
        } else {&#13;
            for (var i = from; i &gt;= to; i--) {&#13;
                presenter.markPoint(i, y);&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawVerticalLine = function (from, to, x) {&#13;
        if (from &lt;= to) {&#13;
            for (var i = from; i &lt;= to; i++) {&#13;
                presenter.markPoint(x, i);&#13;
            }&#13;
        } else {&#13;
            for (var i = from; i &gt;= to; i--) {&#13;
                presenter.markPoint(x, i);&#13;
            }&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.clear = presenter.reset;&#13;
&#13;
    presenter.clearMark = presenter.resetMark;&#13;
&#13;
    presenter.markPoint = function(x, y) {&#13;
        x = parseInt(x, 10);&#13;
        y = parseInt(y, 10);&#13;
        presenter.actualCursorPosition = [x,y];&#13;
        if (ModelValidationUtils.validateIntegerInRange(x, presenter.configuration.columns, 1).isValid != false) {&#13;
            if (ModelValidationUtils.validateIntegerInRange(y, presenter.configuration.rows, 1).isValid != false) {&#13;
                presenter.coloredGrid[y - 1][x - 1] = presenter.configuration.color;&#13;
            }&#13;
        }&#13;
        presenter.colorSquare(x, y);&#13;
    };&#13;
&#13;
    presenter.mark = function mark (x, y) {&#13;
        presenter.markPoint(x, y);&#13;
        presenter.sendMarkEvent("mark", x, y);&#13;
    };&#13;
&#13;
    presenter.sendMarkEvent = function (name, x, y) {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': name,&#13;
            'value': x +"-"+ y,&#13;
            'score': ''&#13;
        };&#13;
        sendValueChangedEvent(eventData);&#13;
    };&#13;
&#13;
    presenter.sendDrawFromEvent = function (name, x, y, numberOfSteps) {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': name,&#13;
            'value': x +"-"+ y +"-"+ numberOfSteps,&#13;
            'score': ''&#13;
        };&#13;
        sendValueChangedEvent(eventData);&#13;
    };&#13;
&#13;
    presenter.sendDrawEvent = function (name, x) {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': name,&#13;
            'value': x,&#13;
            'score': ''&#13;
        };&#13;
        sendValueChangedEvent(eventData);&#13;
    };&#13;
&#13;
    presenter.drawLeft = function (x, y, numberOfSteps) {&#13;
        x = parseInt(x, 10);&#13;
        y = parseInt(y, 10);&#13;
        numberOfSteps = parseInt(numberOfSteps, 10);&#13;
        if (arguments.length == 1) {&#13;
            if (x &lt;= 0) return;&#13;
            presenter.drawHorizontalLine( presenter.actualCursorPosition[0] - 1, presenter.actualCursorPosition[0] - x, presenter.actualCursorPosition[1]);&#13;
            presenter.sendDrawEvent("drawLeft", x);&#13;
        } else {&#13;
            if (numberOfSteps &lt;= 0) return;&#13;
            presenter.drawHorizontalLine(x, x - numberOfSteps + 1 , y);&#13;
            presenter.sendDrawFromEvent("drawLeftFrom", x, y, numberOfSteps);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawLeftFrom = presenter.drawLeft;&#13;
&#13;
    presenter.drawRight = function (x, y, numberOfSteps) {&#13;
        x = parseInt(x, 10);&#13;
        y = parseInt(y, 10);&#13;
        numberOfSteps = parseInt(numberOfSteps, 10);&#13;
        if (arguments.length == 1) {&#13;
            if (x &lt;= 0) return;&#13;
            presenter.drawHorizontalLine(presenter.actualCursorPosition[0] + 1, presenter.actualCursorPosition[0] + x, presenter.actualCursorPosition[1]);&#13;
            presenter.sendDrawEvent("drawRight", x);&#13;
        } else {&#13;
            if (numberOfSteps &lt;= 0) return;&#13;
            presenter.drawHorizontalLine(x, x + numberOfSteps - 1, y);&#13;
            presenter.sendDrawFromEvent("drawRightFrom", x, y, numberOfSteps);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawRightFrom = presenter.drawRight;&#13;
&#13;
    presenter.drawUp = function (x, y, numberOfSteps) {&#13;
        x = parseInt(x, 10);&#13;
        y = parseInt(y, 10);&#13;
        numberOfSteps = parseInt(numberOfSteps);&#13;
        if (arguments.length == 1) {&#13;
            if (x &lt;= 0) return;&#13;
            presenter.drawVerticalLine(presenter.actualCursorPosition[1] + 1, presenter.actualCursorPosition[1] + x, presenter.actualCursorPosition[0]);&#13;
            presenter.sendDrawEvent("drawUp", x);&#13;
        } else {&#13;
            if (numberOfSteps &lt;= 0) return;&#13;
            presenter.drawVerticalLine(y, y + numberOfSteps - 1, x);&#13;
            presenter.sendDrawFromEvent("drawUpFrom", x, y, numberOfSteps);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawUpFrom = presenter.drawUp;&#13;
&#13;
    presenter.drawDown = function (x, y, numberOfSteps) {&#13;
        x = parseInt(x, 10);&#13;
        y = parseInt(y, 10);&#13;
        numberOfSteps = parseInt(numberOfSteps, 10);&#13;
        if (arguments.length == 1) {&#13;
            if (x &lt;= 0) return;&#13;
            presenter.drawVerticalLine(presenter.actualCursorPosition[1] - 1, presenter.actualCursorPosition[1]  - x, presenter.actualCursorPosition[0]);&#13;
            presenter.sendDrawEvent("drawDown", x);&#13;
        } else {&#13;
            if (numberOfSteps &lt;= 0) return;&#13;
            presenter.drawVerticalLine(y, y - numberOfSteps + 1, x);&#13;
            presenter.sendDrawFromEvent("drawDownFrom", x, y, numberOfSteps);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.drawDownFrom = presenter.drawDown;&#13;
&#13;
    presenter.setColor = function (color) {&#13;
        if (color.trim() === '') {&#13;
            return;&#13;
        }&#13;
        presenter.configuration.color = color;&#13;
    };&#13;
&#13;
    presenter.generateCommand = function Grid_Scene_generate_command (code, name, args) {&#13;
        return eval ("(function() { return function(" + args + "){" + code + "}}())");&#13;
    };&#13;
&#13;
    function isExcluded(name, excludedCommands) {&#13;
        if ((excludedCommands[name] != null) &amp;&amp; (excludedCommands[name])) {&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.getSceneCommands = function () {&#13;
        var commandsLabels = $.extend({}, presenter.LABELS, presenter.configuration.labels);&#13;
&#13;
        var commands = $.extend(true, {}, presenter.originalCommands);&#13;
        var excludedCommands = presenter.configuration.excludedCommands;&#13;
&#13;
        for (var key in excludedCommands) {&#13;
            if (excludedCommands.hasOwnProperty(key)) {&#13;
                if (commands.hasOwnProperty(key)) {&#13;
                    commands[key] = delayDecorator(presenter.generateCommand("", "empty", ""));&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        var result = {};&#13;
        for (var key in commands) {&#13;
            var label = commandsLabels[key];&#13;
            result[label] = commands[key];&#13;
        }&#13;
&#13;
        return result;&#13;
    };&#13;
&#13;
    presenter.getCustomCommandsToEval = function () {&#13;
        var customCommands = presenter.configuration.customCommands;&#13;
        var excludedCommands = presenter.configuration.excludedCommands;&#13;
        var customCommandsString = "";&#13;
        for (var index = 0; index &lt; customCommands.length; index++) {&#13;
            var customCommand = customCommands[index];&#13;
            if (!isExcluded(customCommand['name'], excludedCommands)) {&#13;
                customCommandsString += "function " + customCommand['name'] + "(" + customCommand['arguments'] + "){" + customCommand['code'] + "};";&#13;
            }&#13;
            else {&#13;
                customCommandsString += "function " + customCommand['name'] + "(){};";&#13;
            }&#13;
        }&#13;
        return customCommandsString;&#13;
    };&#13;
&#13;
    presenter.executeCode = function (code) {&#13;
        if (presenter.configuration.isShowingAnswers || presenter.configuration.isErrorMode)  {&#13;
            return;&#13;
        }&#13;
&#13;
        with (presenter.getSceneCommands()) {&#13;
            var customCommands = presenter.getCustomCommandsToEval();&#13;
            try {&#13;
                eval(customCommands);&#13;
                eval(code);&#13;
            } catch (e) {&#13;
                //console.log(e);&#13;
            }&#13;
&#13;
        }&#13;
        sendRunEvent();&#13;
&#13;
        if (presenter.isAllOK()) {&#13;
            sendAllOKEvent();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getState = function Grid_Scene_get_state () {&#13;
        if(presenter.configuration.isShowingAnswers) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        return JSON.stringify( {&#13;
            grid: presenter.coloredGrid,&#13;
            visibility: presenter.configuration.isVisible,&#13;
            color: presenter.configuration.color&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function Grid_Scene_set_state (state) {&#13;
        if (state != null) {&#13;
            var state = JSON.parse(state);&#13;
            presenter.setColoredGridArray(state.grid);&#13;
            presenter.setVisibility(state.visibility);&#13;
            presenter.setColor(state.color);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function Grid_Scene_get_max_score () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
        return 1;&#13;
    };&#13;
&#13;
    presenter.getScore = function Grid_Scene_get_score () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
        if (presenter.configuration.isShowingAnswers) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
        var answer = presenter.configuration.answer;&#13;
        var actualState = presenter.coloredGrid;&#13;
        for (var i = 0; i &lt; rows; i++) {&#13;
            for (var j = 0; j &lt; columns; j++) {&#13;
                if (actualState[i][j] != answer[i][j]) {&#13;
                    return 0;&#13;
                }&#13;
            }&#13;
        }&#13;
        return 1;&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
        var errors = 0;&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
        var answer = presenter.configuration.answer;&#13;
        var actualState = presenter.coloredGrid;&#13;
        for (var i = 0; i &lt; rows; i++) {&#13;
            for (var j = 0; j &lt; columns; j++) {&#13;
                if (actualState[i][j] == "Empty")&#13;
                    continue;&#13;
                if (actualState[i][j] != answer[i][j]) {&#13;
                    errors ++;&#13;
                }&#13;
            }&#13;
        }&#13;
        return errors;&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
        for (var i = 0; i &lt; columns; i++){&#13;
            for (var j = 0; j &lt; rows; j++){&#13;
                var coordinates = (i + 1) + "-" +(1 + j);&#13;
                var element = presenter.$view.find('.grid-scene-cell-element[coordinates="' + coordinates + '"]');&#13;
                element.removeClass('grid-scene-wrong').removeClass('grid-scene-correct');&#13;
            }&#13;
        }&#13;
        presenter.configuration.isErrorMode = false;&#13;
        presenter.setColoredGridArray(presenter.coloredGrid);&#13;
        presenter.actualCursorPosition = presenter.currentCursorPosition;&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
        if (presenter.configuration.isShowingAnswers) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        var rows = presenter.configuration.rows;&#13;
        var columns = presenter.configuration.columns;&#13;
        var answer = presenter.configuration.answer;&#13;
        var actualState = presenter.coloredGrid;&#13;
&#13;
        for (var i = 0; i &lt; columns; i++){&#13;
            for (var j = 0; j &lt; rows; j++){&#13;
                var coordinates = (i + 1) + "-" +(j + 1);&#13;
                var element = presenter.$view.find('.grid-scene-cell-element[coordinates="' + coordinates + '"]');&#13;
                element.css('background-color', '');&#13;
                if (actualState[j][i] != "Empty") {&#13;
                    if (answer[j][i] == actualState[j][i]) {&#13;
                        element.addClass('grid-scene-correct');&#13;
                    } else {&#13;
                        element.addClass('grid-scene-wrong');&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.currentCursorPosition = presenter.actualCursorPosition;&#13;
&#13;
        presenter.configuration.isErrorMode = true;&#13;
    };&#13;
&#13;
    presenter.showAnswers = function AddonIFrame_Communication_show_answers () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        presenter.beforeSACursorPosition = presenter.actualCursorPosition;&#13;
&#13;
        if(presenter.configuration.isErrorMode) {&#13;
            presenter.setWorkMode();&#13;
        }&#13;
        presenter.lastState = $.extend(true,[], presenter.coloredGrid);&#13;
        presenter.reset();&#13;
        presenter.configuration.isShowingAnswers = true;&#13;
        presenter.setColoredGridArray(presenter.configuration.answer);&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function AddonIFrame_Communication_hide_answers () {&#13;
        if (!presenter.configuration.isAnswer) {&#13;
            return 0;&#13;
        }&#13;
        presenter.configuration.isShowingAnswers = false;&#13;
        presenter.reset();&#13;
        presenter.coloredGrid = presenter.lastState;&#13;
        presenter.lastState = null;&#13;
        presenter.setColoredGridArray(presenter.coloredGrid);&#13;
        presenter.actualCursorPosition = presenter.beforeSACursorPosition;&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        } else if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        if (!presenter.configuration.isSavingAnswer) {&#13;
            if (!presenter.configuration.isPreview) {&#13;
                var rows = presenter.configuration.rows;&#13;
                var columns = presenter.configuration.columns;&#13;
                var answer = presenter.configuration.answer;&#13;
                var actualState = presenter.coloredGrid;&#13;
                for (var i = 0; i &lt; rows; i++) {&#13;
                    for (var j = 0; j &lt; columns; j++) {&#13;
                        if (actualState[i][j] != answer[i][j]) {&#13;
                            return false;&#13;
                        }&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.getBlocklyData = function () {&#13;
        var excludedBlocks = {};&#13;
        for (var key in presenter.DEFAULT_COMMANDS_TO_BLOCKS) {&#13;
            if (presenter.DEFAULT_COMMANDS_TO_BLOCKS.hasOwnProperty(key)) {&#13;
                if (!presenter.configuration.excludedCommands.hasOwnProperty(key)) {&#13;
                    excludedBlocks[presenter.DEFAULT_COMMANDS_TO_BLOCKS[key]] = true;&#13;
                }&#13;
            }&#13;
        }&#13;
        return {&#13;
            "type": "GridScene",&#13;
            "labels": $.extend({}, presenter.LABELS, presenter.configuration.labels),&#13;
            "availableBlocks" : excludedBlocks&#13;
&#13;
        }&#13;
    };&#13;
&#13;
    function sendRunEvent () {&#13;
        sendValueChangedEvent({&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': 1,&#13;
            'score': ''&#13;
        });&#13;
    }&#13;
&#13;
    function sendAllOKEvent() {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
        sendValueChangedEvent(eventData);&#13;
    }&#13;
&#13;
    function sendValueChangedEvent(eventData) {&#13;
        if (presenter.eventBus != null) {&#13;
            presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
        }&#13;
    }&#13;
&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>