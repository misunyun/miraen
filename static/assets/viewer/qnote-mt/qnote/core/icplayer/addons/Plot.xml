<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Plot" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="Expressions" nameLabel="Plot_property_expressions" type="list">
			<property isLocalized="false" name="id" nameLabel="Plot_property_id" type="string"/>
			<property isLocalized="false" name="expression" nameLabel="Plot_property_expression" type="string"/>
			<property isLocalized="false" name="xMin" nameLabel="Plot_property_x_min" type="int"/>
			<property isLocalized="false" name="xMax" nameLabel="Plot_property_x_max" type="int"/>
			<property isLocalized="false" name="yMin" nameLabel="Plot_property_y_min" type="int"/>
			<property isLocalized="false" name="yMax" nameLabel="Plot_property_y_max" type="int"/>
			<property isLocalized="false" name="selectable" nameLabel="Plot_property_selectable" type="boolean"/>
			<property isLocalized="false" name="correct" nameLabel="Plot_property_correct" type="boolean"/>
			<property isLocalized="false" name="y to x" nameLabel="Plot_property_y_to_x" type="boolean"/>
			<property isLocalized="false" name="hidden" nameLabel="Plot_property_hidden" type="boolean"/>
			<property isLocalized="false" name="color" nameLabel="Plot_property_color" type="string"/>
		</property>
		<property name="Variables" nameLabel="Plot_property_variables" type="list">
			<property isLocalized="false" name="plot id" nameLabel="Plot_property_plot_id" type="string"/>
			<property isLocalized="false" name="variable" nameLabel="Plot_property_variable" type="string"/>
			<property isLocalized="false" name="value" nameLabel="Plot_property_value" type="string"/>
			<property isLocalized="false" name="expected" nameLabel="Plot_property_expected" type="string"/>
		</property>
		<property name="Points" nameLabel="Plot_property_points" type="list">
			<property isLocalized="false" name="x value" nameLabel="Plot_property_x_value" type="string"/>
			<property isLocalized="false" name="y value" nameLabel="Plot_property_y_value" type="string"/>
			<property isLocalized="false" name="selected" nameLabel="Plot_property_selected" type="boolean"/>
			<property isLocalized="false" name="correct" nameLabel="Plot_property_correct" type="boolean"/>
			<property isLocalized="false" name="not scored" nameLabel="Plot_property_not_scored" type="boolean"/>
		</property>
		<property isLocalized="false" name="xMin" nameLabel="Plot_property_x_min" type="int"/>
		<property isLocalized="false" name="xMax" nameLabel="Plot_property_x_max" type="int"/>
		<property isLocalized="false" name="yMin" nameLabel="Plot_property_y_min" type="int"/>
		<property isLocalized="false" name="yMax" nameLabel="Plot_property_y_max" type="int"/>
		<property isLocalized="false" name="Grid" nameLabel="Plot_property_grid" type="boolean"/>
		<property isLocalized="false" name="GridStepX" nameLabel="Plot_property_grid_step_x" type="int"/>
		<property isLocalized="false" name="GridStepY" nameLabel="Plot_property_grid_step_y" type="int"/>
		<property isLocalized="false" name="Arrowhead size" nameLabel="Plot_property_arrow_head_size" type="int"/>
		<property isLocalized="false" name="Axis values" nameLabel="Plot_property_axis_values" type="boolean"/>
		<property isLocalized="false" name="Axis x values" nameLabel="Plot_property_axis_x_values" type="string"/>
		<property isLocalized="false" name="Axis y values" nameLabel="Plot_property_axis_y_values" type="string"/>
		<property isLocalized="true" name="X axis description" nameLabel="Plot_property_x_axis_description" type="string"/>
		<property isLocalized="true" name="Y axis description" nameLabel="Plot_property_y_axis_description" type="string"/>
		<property isLocalized="false" name="hide X axis" nameLabel="Plot_property_hide_x_axis" type="boolean"/>
		<property isLocalized="false" name="hide Y axis" nameLabel="Plot_property_hide_y_axis" type="boolean"/>
		<property isLocalized="false" name="Point active area size" nameLabel="Plot_property_points_active_area_size" type="int"/>
		<property isLocalized="false" name="Point radius" nameLabel="Plot_property_points_radius" type="int"/>
		<property isLocalized="false" name="Point outline radius" nameLabel="Plot_property_points_outline_radius" type="int"/>
		<property isLocalized="false" name="Max selected points" nameLabel="Plot_property_max_selected_points" type="int"/>
		<property isLocalized="false" name="Not activity" nameLabel="Plot_property_not_activity" type="boolean"/>
		<property isLocalized="false" name="Free points" nameLabel="Plot_property_free_points" type="boolean"/>
		<property isLocalized="false" name="Asymptote DY" nameLabel="Plot_property_asymptote_dy" type="int"/>
		<property isLocalized="false" name="Broadcast" nameLabel="Plot_property_broadcast" type="string"/>
		<property isLocalized="false" name="Decimal separator" nameLabel="Plot_property_decimal_separator" type="string"/>
        <property isLocalized="false" name="X axis values position" nameLabel="Plot_property_x_axis_values_position" type="int"/>
        <property isLocalized="false" name="Y axis values position" nameLabel="Plot_property_y_axis_values_position" type="int"/>
	</model>
<css>.canvas {&#13;
	background-color:#ffffff;&#13;
}&#13;
/* axis */&#13;
.axisText {&#13;
	font-family:Verdana, sans-serif; &#13;
	font-size:8pt; &#13;
	fill:#000000;&#13;
	stroke-width:0;&#13;
}&#13;
.axisXText {&#13;
	text-anchor: end;&#13;
}		&#13;
.axisYText {&#13;
}	&#13;
.axis {&#13;
	stroke:#000000;&#13;
	stroke-width: 1;&#13;
}&#13;
.axisArrows {&#13;
	fill: #000000;&#13;
}&#13;
.axisThicksTextX {&#13;
	text-anchor: middle;&#13;
	dominant-baseline: central&#13;
}&#13;
.axisThicksTextY {&#13;
	text-anchor: left;&#13;
	dominant-baseline: central&#13;
}&#13;
/* grid */&#13;
.grid {&#13;
	stroke:#ddd;&#13;
	stroke-width: 1;&#13;
    stroke-dasharray: 2 2;&#13;
}&#13;
/* plot */&#13;
.draw_active_area {&#13;
	stroke-opacity:0.0;&#13;
	stroke-linecap:round;&#13;
	stroke-linejoin:round;&#13;
	stroke-width:10;&#13;
	fill:none;&#13;
	stroke:#ffffff;&#13;
}&#13;
.draw_outline_base {&#13;
	stroke-linecap:round;&#13;
	stroke-linejoin:round;&#13;
	stroke-opacity:0;&#13;
	fill:none;&#13;
}&#13;
.draw_outline {&#13;
	stroke-opacity:0.5;&#13;
	stroke-width:5;&#13;
	fill:none;&#13;
	stroke:#008800;&#13;
}&#13;
.draw_outline_mark_error {&#13;
	stroke-opacity:0.5;&#13;
	stroke-width:5;&#13;
	fill:none;			&#13;
	stroke:#ff0000;&#13;
}&#13;
.draw_outline_mark_correct {&#13;
	stroke-opacity:0.5;&#13;
	stroke-width:5;&#13;
	fill:none;&#13;
	stroke:#008800;&#13;
}&#13;
.draw {&#13;
	fill: none;&#13;
	stroke:#0000ff;&#13;
	stroke-width: 2;			&#13;
}&#13;
.draw_selected {&#13;
	fill: none;&#13;
	stroke-width:3;&#13;
	stroke:#008800;&#13;
}&#13;
.draw_over{&#13;
	stroke:#888888;&#13;
}	&#13;
.draw_mark_error {&#13;
	stroke: #ff0000;&#13;
    stroke-width:2;&#13;
}&#13;
.draw_mark_correct {&#13;
	stroke:#008800;&#13;
}&#13;
/* point */&#13;
.point_active_area {&#13;
	stroke-width:0;&#13;
	fill:#ff0000;&#13;
	fill-opacity:0;&#13;
}&#13;
.point_outline_base {&#13;
	stroke-opacity:0;&#13;
	stroke:#bb0000;&#13;
	stroke-width:2;&#13;
	fill-opacity:0;&#13;
	fill:#dd0000;&#13;
}		&#13;
.point_outline {&#13;
	stroke-opacity:1;&#13;
	stroke:#006600;&#13;
	stroke-width:2;&#13;
	fill-opacity:1;&#13;
	fill:#00bb00;&#13;
}	&#13;
.point_outline_mark_error {&#13;
	stroke-opacity:1;&#13;
	stroke:#bb0000;&#13;
	stroke-width:2;&#13;
    fill-opacity:1;&#13;
	fill:#ff0000;&#13;
}&#13;
.point_outline_mark_correct {&#13;
	stroke-opacity:1;&#13;
	stroke:#006600;&#13;
	stroke-width:2;&#13;
	fill-opacity:1;&#13;
	fill:#00bb00;&#13;
}&#13;
.point {&#13;
	fill:#dddddd;&#13;
	stroke:#bbbbbb;&#13;
	stroke-width:0.5;&#13;
}&#13;
.point_selected {&#13;
	fill:#00bb00;&#13;
	stroke:#006600;&#13;
	stroke-width:2;&#13;
}&#13;
.point_over {&#13;
	fill:#aaaaaa;&#13;
	stroke:#666666;&#13;
	stroke-width:2;&#13;
}&#13;
.point_error {&#13;
	fill:#ff0000;&#13;
	stroke:#bb0000;&#13;
	stroke-width:2;&#13;
}&#13;
.point_correct {&#13;
	fill:#00bb00;&#13;
	stroke:#00bb00;&#13;
	stroke-width:2;&#13;
}&#13;
&#13;
.plot_show_answers {&#13;
    stroke-opacity:1;&#13;
    stroke:#006600;&#13;
    stroke-width:2;&#13;
    fill-opacity:1;&#13;
    fill:#00bb00;&#13;
}&#13;
</css><view>&lt;div class="canvas" style="width:100%; height:100%; overflow:hidden"&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="canvas" style="width:100%; height:100%; overflow:hidden"&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonPlot_create(){&#13;
    function Plot() {&#13;
        this.VERSION = '1.1.17';&#13;
        this.STATE_CORRECT = 1;&#13;
        this.STATE_INCORRECT = 0;&#13;
        this.STATE_NOT_ACTIVITY = '';&#13;
        this.STATE_NULL = 0;&#13;
        this.STATE_SELECT_POINT = 1;&#13;
        this.STATE_DESELECT_POINT = 0;&#13;
        this.INFINITY_NEGATIVE_VALUE = -2147483647;&#13;
        this.INFINITY_POSITIVE_VALUE = 2147483647;&#13;
        this.ASYMPTOTE_MINIMUM_TRIAL = 3;&#13;
        this.TYPE_X_TO_Y = 1;&#13;
        this.TYPE_Y_TO_X = 2;&#13;
        this.asymptoteMinimumDY = 5;&#13;
        this.interactive = true;&#13;
        this.xMin = -10;&#13;
        this.xMax = 10;&#13;
        this.yMin = -10;&#13;
        this.yMax = 10;&#13;
        this.zoomStep = 0.1;&#13;
        this.expressions = [];&#13;
        this.points = [];&#13;
        this.svg = null;&#13;
        this.stepX = 0;&#13;
        this.stepY = 0;&#13;
        this.offsetX = 0;&#13;
        this.offsetY = 0;&#13;
        this.width = 0;&#13;
        this.height = 0;&#13;
        this.gridStepX = 1;&#13;
        this.gridStepY = 1;&#13;
        this.grid = true;&#13;
        this.lastOffsetX = 0;&#13;
        this.lastOffsetY = 0;&#13;
        this.arrowheadSize = 6;&#13;
        this.axisValues = true;&#13;
        this.svgDoc = null;&#13;
        this.uiEnabled = true;&#13;
        this.initXMin = this.xMin;&#13;
        this.initXMax = this.xMax;&#13;
        this.initYMin = this.yMin;&#13;
        this.initYMax = this.yMax;&#13;
        this.pointActiveArea = 15;&#13;
        this.pointRadius = 3;&#13;
        this.pointOutlineRadius = 7;&#13;
        this.selectedPoints = [];&#13;
        this.xAxisDescription = 'x';&#13;
        this.yAxisDescription = 'y';&#13;
        this.xAxisVisible = true;&#13;
        this.yAxisVisible = true;&#13;
        this.xAxisCyclicValues = [];&#13;
        this.xAxisCustomValues = [];&#13;
        this.yAxisCyclicValues = [];&#13;
        this.yAxisCustomValues = [];&#13;
        this.maxSelectedPoints = 0;&#13;
        this.stateChanged = function(){};&#13;
        this.convertValueToDisplay = function(val){ return val; };&#13;
        this.isActivity = true;&#13;
        this.freePoints = false;&#13;
        this.precision = {x: 100, y:100};&#13;
        this.attempted = false;&#13;
        this.xAxisValuesPosition = 0;&#13;
        this.yAxisValuesPosition = 0;&#13;
&#13;
        this.setXAxisValuesPosition = function (value) {&#13;
            this.svgDoc.find('.axisThicksTextX').attr('y', value);&#13;
        };&#13;
&#13;
        this.setYAxisValuesPosition = function (value) {&#13;
            var element = this.svgDoc.find('.axisThicksTextY');&#13;
            element.attr('x', value);&#13;
            if(value &lt; 0) {&#13;
                element.attr("text-anchor", "end");&#13;
            }&#13;
        };&#13;
&#13;
        this.setScale = function () {&#13;
            this.svgDoc.find('.scale').attr('transform', 'scale(1, -1)');&#13;
        };&#13;
        this.setStep = function () {&#13;
            this.stepX = this.width/(Math.max(this.xMin, this.xMax) - Math.min(this.xMin, this.xMax));&#13;
            this.stepY = this.height/(Math.max(this.yMin, this.yMax) - Math.min(this.yMin, this.yMax));&#13;
        };&#13;
        this.translate = function() {&#13;
            this.offsetX = this.xMin*this.stepX*(-1);&#13;
            this.offsetY = this.yMax*this.stepY*(-1);&#13;
            this.svgDoc.find('.translate').attr('transform', 'translate('+this.offsetX+', '+this.offsetY+')');&#13;
        };&#13;
        this.draw = function() {&#13;
            this.clearCanvas();&#13;
            if(this.grid) {&#13;
                this.drawGrid();&#13;
            }&#13;
            this.drawAxis();&#13;
            this.drawPlots();&#13;
            if(this.points.length &gt; 0 || this.freePoints) {&#13;
                this.drawPoints();&#13;
            }&#13;
            this.enableUI(this.uiEnabled);&#13;
            if(this.xAxisValuesPosition != '' &amp;&amp; !isNaN(this.xAxisValuesPosition)){&#13;
                this.setXAxisValuesPosition(this.xAxisValuesPosition);&#13;
            }&#13;
&#13;
            if(this.yAxisValuesPosition != '' &amp;&amp; !isNaN(this.yAxisValuesPosition)){&#13;
                this.setYAxisValuesPosition(this.yAxisValuesPosition);&#13;
            }&#13;
        };&#13;
        this.clearCanvas = function() {&#13;
            this.svgDoc.find('.drawings').children().remove();&#13;
            this.svgDoc.find('.grid').children().remove();&#13;
            this.svgDoc.find('.axis').children().remove();&#13;
            this.svgDoc.find('.points').children().remove();&#13;
            this.svgDoc.find('.pointsAreas').children().remove();&#13;
            this.svgDoc.find('.drawingsAreas').children().remove();&#13;
        }&#13;
        this.drawXAxis = function() {&#13;
            var path = this.svg.createPath();&#13;
            this.svg.line(this.svgDoc.find('.axis'), -this.offsetX, 0, this.width-this.offsetX, 0);&#13;
            path.move(this.width - this.offsetX, 0).&#13;
            line(this.width - this.offsetX - this.arrowheadSize, this.arrowheadSize/2).&#13;
            line(this.width - this.offsetX - this.arrowheadSize, -this.arrowheadSize/2).&#13;
            line(this.width - this.offsetX, 0);&#13;
            this.svg.text(this.svgDoc.find('.axis'), this.width-this.offsetX-3, 13, this.xAxisDescription, {&#13;
                'class':'axisText axisXText',&#13;
                transform:'scale(1,-1)'&#13;
            });&#13;
            this.svg.path(this.svgDoc.find('.axis'), path, {&#13;
                'class':'axisArrows'&#13;
            });&#13;
        };&#13;
        this.drawYAxis = function() {&#13;
            var path = this.svg.createPath();&#13;
            this.svg.line(this.svgDoc.find('.axis'), 0, -this.offsetY, 0, -this.height-this.offsetY);&#13;
            path.move(0, -this.offsetY).&#13;
            line(this.arrowheadSize/2, -this.offsetY - this.arrowheadSize).&#13;
            line(-this.arrowheadSize/2, -this.offsetY - this.arrowheadSize).&#13;
            line(0, -this.offsetY);&#13;
            this.svg.text(this.svgDoc.find('.axis'), 7, this.offsetY+10, this.yAxisDescription, {&#13;
                'class':'axisText axisYText',&#13;
                transform:'scale(1,-1)'&#13;
            });&#13;
            this.svg.path(this.svgDoc.find('.axis'), path, {&#13;
                'class':'axisArrows'&#13;
            });&#13;
        };&#13;
        this.drawAxis0Point = function() {&#13;
            this.svg.text(this.svgDoc.find('.axis'), 3, 13, '0', {&#13;
                'class':'axisText',&#13;
                transform:'scale(1,-1)'&#13;
            });&#13;
        };&#13;
        this.drawXTick = function(x) {&#13;
            if(x &lt; this.width - this.offsetX - this.arrowheadSize) {&#13;
                this.svg.line(this.svgDoc.find('.axis'), x, -3, x, 3);&#13;
            }&#13;
        };&#13;
        this.drawYTick = function(y) {&#13;
            if(y &lt; -this.offsetY - this.arrowheadSize) {&#13;
                this.svg.line(this.svgDoc.find('.axis'), -3, y, 3, y);&#13;
            }&#13;
        };&#13;
        this.drawXTickValue = function(x, coords) {&#13;
            if(x &lt; this.width - this.offsetX - 15) {&#13;
                if(this.xAxisVisible &amp;&amp; this.yAxisVisible &amp;&amp; coords.x == 0) {&#13;
                    return;&#13;
                } else {&#13;
                    this.svg.text(this.svgDoc.find('.axis'), x, 10, this.convertValueToDisplay(coords.x.toString()), {&#13;
                        'class':'axisText axisThicksTextX',&#13;
                        transform:'scale(1,-1)'&#13;
                    });&#13;
                }&#13;
            }&#13;
        };&#13;
        this.drawYTickValue = function(y, coords) {&#13;
            if(this.xAxisVisible &amp;&amp; this.yAxisVisible &amp;&amp; coords.y == 0) {&#13;
            ;&#13;
            } else {&#13;
                this.svg.text(this.svgDoc.find('.axis'), 7, y, this.convertValueToDisplay(coords.y.toString()), {&#13;
                    'class':'axisText axisThicksTextY',&#13;
                    transform:'scale(1,-1)'&#13;
                });&#13;
            }&#13;
        };&#13;
        this.checkAndDrawXTickValue = function(x, dx, cx, tx) {&#13;
            var currentTick;&#13;
            var coords = this.px2coords(cx, 0);&#13;
            //check cyclic values&#13;
            if(this.xAxisCyclicValues.length &gt; 0) {&#13;
                currentTick = Math.round(x/dx);&#13;
                $.each(this.xAxisCyclicValues, function(k, v) {&#13;
                    if(currentTick%v == 0) {&#13;
                        plot.drawXTickValue(tx, coords);&#13;
                        return;&#13;
                    }&#13;
                })&#13;
            } else if(this.xAxisCustomValues.length == 0) {&#13;
                this.drawXTickValue(tx, coords);&#13;
            }&#13;
        };&#13;
        this.drawCustomXTicks = function() {&#13;
            $.each(this.xAxisCustomValues, function(idx, val) {&#13;
                p = plot.coords2px(val, 0);&#13;
                plot.drawXTick(p.x);&#13;
                plot.drawXTickValue(p.x, {x:val, y:0});&#13;
            });&#13;
        };&#13;
        this.drawXTicks = function() {&#13;
            var x, sp;&#13;
            var dx = this.gridStepX*this.stepX;&#13;
            var modX = this.offsetX%(dx);&#13;
            //get starting point of viewport&#13;
            sp = this.offsetX &lt; 0 ? -this.offsetX + modX: 0&#13;
            //above 0&#13;
            for(x = sp; x &lt;= this.width - this.offsetX; x += dx) {&#13;
                this.drawXTick(x);&#13;
                this.checkAndDrawXTickValue(x, dx, x+this.offsetX, x);&#13;
            }&#13;
            //below 0&#13;
            for(x = sp; x &gt;= -this.offsetX - modX; x-= dx) {&#13;
                this.drawXTick(x);&#13;
                this.checkAndDrawXTickValue(x, dx, x+this.offsetX, x);&#13;
            }&#13;
            this.drawCustomXTicks();&#13;
        };&#13;
        this.checkAndDrawYTickValue = function(y, dy, cy, ty) {&#13;
            coords = this.px2coords(0, cy);&#13;
            //check cyclic values&#13;
            if(this.yAxisCyclicValues.length &gt; 0) {&#13;
                currentTick = Math.round(y/dy);&#13;
                $.each(this.yAxisCyclicValues, function(k, v) {&#13;
                    if(currentTick%v == 0) {&#13;
                        plot.drawYTickValue(ty, coords);&#13;
                        return;&#13;
                    }&#13;
                })&#13;
            } else if(this.yAxisCustomValues.length == 0) {&#13;
                this.drawYTickValue(ty, coords);&#13;
            }&#13;
        };&#13;
        this.drawCustomYTicks = function() {&#13;
            var p;&#13;
            $.each(this.yAxisCustomValues, function(idx, val){&#13;
                p = plot.coords2px(0, val);&#13;
                plot.drawYTick(p.y);&#13;
                plot.drawYTickValue(-p.y, {&#13;
                    x:0,&#13;
                    y:val&#13;
                });&#13;
            });&#13;
        };&#13;
        this.drawYTicks = function() {&#13;
            var y;&#13;
            var dy = this.gridStepY*this.stepY;&#13;
            var modY = this.offsetY%(dy);&#13;
            sp = Math.abs(this.offsetY) &lt; this.height ? 0 : Math.abs(this.offsetY) - this.height - (Math.abs(this.offsetY) - this.height)%dy;&#13;
            //above 0&#13;
            for(y = sp; y &lt;= sp+this.height+dy; y += dy) {&#13;
                this.drawYTick(y);&#13;
                this.checkAndDrawYTickValue(y, dy, -y-this.offsetY, -y);&#13;
            }&#13;
            //below 0&#13;
            sp = this.offsetY &gt; 0 ? this.offsetY - modY : 0;&#13;
            for(y = sp; y &lt; this.offsetY + this.height; y += dy) {&#13;
                this.drawYTick(-y);&#13;
                this.checkAndDrawYTickValue(y, dy, y-this.offsetY, y);&#13;
            }&#13;
            this.drawCustomYTicks();&#13;
        };&#13;
        this.drawAxis = function() {&#13;
            if(this.yAxisVisible) {&#13;
                this.drawYAxis();&#13;
            }&#13;
            if(this.xAxisVisible) {&#13;
                this.drawXAxis();&#13;
            }&#13;
            if(this.xAxisVisible &amp;&amp; this.yAxisVisible) {&#13;
                this.drawAxis0Point();&#13;
            }&#13;
            if(this.axisValues) {&#13;
                if(this.xAxisVisible) {&#13;
                    this.drawXTicks();&#13;
                }&#13;
                if(this.yAxisVisible) {&#13;
                    this.drawYTicks();&#13;
                }&#13;
            }&#13;
        };&#13;
        this.drawGrid = function() {&#13;
            var dx = this.gridStepX*this.stepX;&#13;
            var modX = this.offsetX%(dx);&#13;
            for(var x = -this.offsetX+modX; x &lt;= this.width-this.offsetX; x += dx) {&#13;
                //pionowe&#13;
                this.svg.line(this.svgDoc.find('.grid'), x, -this.offsetY, x, -this.height-this.offsetY);&#13;
            }&#13;
&#13;
            var dy = this.gridStepY*this.stepY;&#13;
            var modY = this.offsetY%(dy);&#13;
            for(var y = -this.offsetY+modY; y &gt;= -this.height-this.offsetY; y -= dy) {&#13;
                //poziome&#13;
                this.svg.line(this.svgDoc.find('.grid'), -this.offsetX, y, this.width-this.offsetX, y);&#13;
            }&#13;
        };&#13;
        this.drawPoints = function() {&#13;
            var dx = this.gridStepX*this.stepX;&#13;
            var modX = this.offsetX%(dx);&#13;
            var dy = this.gridStepY*this.stepY;&#13;
            var modY = this.offsetY%(dy);&#13;
            var point;&#13;
            var html = $('&lt;span class="point"&gt;&lt;/span&gt;');&#13;
            for(var x = -this.offsetX+modX; x &lt;= this.width-this.offsetX; x += dx) {&#13;
                var idx = 0;&#13;
                for(var y = -this.offsetY+modY; y &gt;= -this.height-this.offsetY; y -= dy) {&#13;
                    point = this.px2coords(x+this.offsetX,dy*idx-modY);&#13;
                    this.svg.circle(this.svgDoc.find('.points'), x, y, this.pointOutlineRadius, {&#13;
                        'class':'point_outline_base',&#13;
                        vx:point.x,&#13;
                        vy:point.y&#13;
                        });&#13;
                    this.svg.circle(this.svgDoc.find('.points'), x, y, this.pointRadius, {&#13;
                        'class':'point',&#13;
                        vx:point.x,&#13;
                        vy:point.y&#13;
                        });&#13;
                    if(this.interactive) {&#13;
                        this.svg.rect(this.svgDoc.find('.pointsAreas'), x-this.pointActiveArea/2, y-this.pointActiveArea/2, this.pointActiveArea, this.pointActiveArea, {&#13;
                            'class':'point_active_area',&#13;
                            vx:point.x,&#13;
                            vy:point.y&#13;
                            });&#13;
                    }&#13;
                    idx++;&#13;
                }&#13;
            }&#13;
            $.each(plot.selectedPoints, function(k, v) {&#13;
                var refObj = plot.svgDoc.find('.point[vx="'+v.x+'"][vy="'+v.y+'"]');&#13;
                var refObjOutline = plot.svgDoc.find('.point_outline_base[vx="'+v.x+'"][vy="'+v.y+'"]');&#13;
                refObj.addClass('point_selected');&#13;
                refObjOutline.addClass('point_outline');&#13;
                if(!v.clickable) {&#13;
                    refObj.addClass('nonclickable');&#13;
                }&#13;
            });&#13;
&#13;
            if(this.interactive) {&#13;
                obj = this.svgDoc.find('.point_active_area');&#13;
                obj.mouseover(function() {&#13;
                    var vx = $(this).attr('vx');&#13;
                    var vy = $(this).attr('vy');&#13;
                    var point;&#13;
                    var point = plot.svgDoc.find('.point[vx="'+vx+'"][vy="'+vy+'"]');&#13;
                    if(plot.maxSelectedPoints == 0 || plot.selectedPoints.length &lt; plot.maxSelectedPoints || point.hasClass('point_selected')) {&#13;
                        point = plot.svgDoc.find('.point[vx="'+vx+'"][vy="'+vy+'"]');&#13;
                        if(!point.hasClass('nonclickable')) {&#13;
                            point.addClass('point_over');&#13;
                        }&#13;
                    }&#13;
                });&#13;
                obj.mouseout(function() {&#13;
                    var vx = $(this).attr('vx');&#13;
                    var vy = $(this).attr('vy');&#13;
                    plot.svgDoc.find('.point[vx="'+vx+'"][vy="'+vy+'"]').removeClass('point_over');&#13;
                });&#13;
                obj.click(function(e) {&#13;
                    e.stopPropagation();&#13;
&#13;
                    var vx = $(this).attr('vx');&#13;
                    var vy = $(this).attr('vy');&#13;
                    var refObj = plot.svgDoc.find('.point[vx="'+vx+'"][vy="'+vy+'"]');&#13;
                    if(!refObj.hasClass('nonclickable')) {&#13;
                        if(refObj.hasClass('point_selected')) {&#13;
                            plot._deselectPoint(vx, vy, false);&#13;
                        } else {&#13;
                            plot._selectPoint(vx, vy, false);&#13;
                        }&#13;
                    }&#13;
                });&#13;
            }&#13;
        };&#13;
        this._touchPoint = function(x, y) {&#13;
            this.attempted = true;&#13;
            var pvx = parseFloat(x);&#13;
            var pvy = parseFloat(y);&#13;
            //mark as touched in model if exists&#13;
            $.each(plot.points, function(k,v) {&#13;
                if(v.x == pvx &amp;&amp; v.y == pvy) {&#13;
                    v.touched = true;&#13;
                }&#13;
            });&#13;
        }&#13;
        this._deselectPoint = function(x,y, isShowAnswersMode) {&#13;
            if (!isShowAnswersMode) {&#13;
                 this._touchPoint(x, y);&#13;
            }&#13;
            var pvx = parseFloat(x);&#13;
            var pvy = parseFloat(y);&#13;
            var refObj = plot.svgDoc.find('.point[vx="'+x+'"][vy="'+y+'"]');&#13;
            var refObjOutline = plot.svgDoc.find('.point_outline_base[vx="'+x+'"][vy="'+y+'"]');&#13;
            refObj.removeClass('point_selected');&#13;
            refObjOutline.removeClass('point_outline');&#13;
            $.each(this.selectedPoints, function(k, v) {&#13;
                if(v.x == pvx &amp;&amp; v.y == pvy) {&#13;
                    plot.selectedPoints.splice(k, 1);&#13;
                    if (!isShowAnswersMode) {&#13;
                        plot.stateChanged({&#13;
                            item:'point_'+pvx+'_'+pvy,&#13;
                            value:0,&#13;
                            score:plot.getPointEventScore(pvx, pvy, plot.STATE_DESELECT_POINT)&#13;
                        });&#13;
                    }&#13;
                    return false;&#13;
                }&#13;
            });&#13;
        }&#13;
        this._selectPoint = function(x,y, isShowAnswersMode) {&#13;
            if (!isShowAnswersMode) {&#13;
                this._touchPoint(x, y);&#13;
            }&#13;
            var pvx = parseFloat(x);&#13;
            var pvy = parseFloat(y);&#13;
            var refObj = plot.svgDoc.find('.point[vx="'+x+'"][vy="'+y+'"]');&#13;
            var refObjOutline = plot.svgDoc.find('.point_outline_base[vx="'+x+'"][vy="'+y+'"]');&#13;
            //check if we can add another point&#13;
            if(plot.maxSelectedPoints == 0 || plot.selectedPoints.length &lt; plot.maxSelectedPoints) {&#13;
                refObj.addClass('point_selected');&#13;
                refObjOutline.addClass('point_outline');&#13;
                var hasPoint = false;&#13;
                $.each(plot.selectedPoints, function(k, v) {&#13;
                    if(v.x == pvx &amp;&amp; v.y == pvy) {&#13;
                        hasPoint = true;&#13;
                        return false;&#13;
                    }&#13;
                });&#13;
                if(!hasPoint) {&#13;
                    plot.selectedPoints.push({&#13;
                        x:pvx,&#13;
                        y:pvy,&#13;
                        clickable: true&#13;
                    });&#13;
                    if (!isShowAnswersMode) {&#13;
                        plot.stateChanged({&#13;
                            item:'point_'+pvx+'_'+pvy,&#13;
                            value:1,&#13;
                            score:plot.getPointEventScore(pvx, pvy, plot.STATE_SELECT_POINT)&#13;
                        });&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
        this.removePlot = function(p) {&#13;
            this.svgDoc.find('.drawingsAreas .draw_active_area[refuid="'+p+'"]').remove();&#13;
            this.svgDoc.find('.drawings .draw_outline_base[ouid="'+p+'"]').remove();&#13;
            this.svgDoc.find('.drawings .draw[uid="'+p+'"]').remove();&#13;
        }&#13;
        this.drawPlot = function(p) {&#13;
            var obj, cp;&#13;
            var path = this.svg.createPath();&#13;
            //function type x to y&#13;
            if(this.expressions[p].type == this.TYPE_X_TO_Y) {&#13;
                path = this._drawXToY(p);&#13;
            //function type y to x&#13;
            } else if(this.expressions[p].type == this.TYPE_Y_TO_X) {&#13;
                path = this._drawYToX(p);&#13;
            }&#13;
            this.svg.path(this.svgDoc.find('.drawings'), path, {&#13;
                ouid:p,&#13;
                'class': 'draw_outline_base'&#13;
            });&#13;
            this.svg.path(this.svgDoc.find('.drawings'), path, {&#13;
                uid:p,&#13;
                isselected: this.expressions[p].selected ? 1 : 0,&#13;
                'class': 'is_plot draw draw_'+(parseInt(p)+1)&#13;
            });&#13;
            //restore style&#13;
            cp = plot.svgDoc.find('.drawings [uid="'+p+'"]');&#13;
            var props = this.expressions[p].cssProperties;&#13;
            props['stroke'] = this.expressions[p].cssColor;&#13;
            cp.data({&#13;
                cssStyle: this._composeStyle(props)&#13;
            });&#13;
            cp.attr('style', cp.data().cssStyle);&#13;
            if(this.interactive) {&#13;
                this.svg.path(this.svgDoc.find('.drawingsAreas'), path, {&#13;
                    refuid:p,&#13;
                    'class':'draw_active_area'&#13;
                });&#13;
            }&#13;
            if(this.expressions[p].selected) {&#13;
                plot.svgDoc.find('.is_plot[uid="'+p+'"]').addClass('draw_selected draw_'+(parseInt(p)+1)+'_selected').removeAttr('style');&#13;
                plot.svgDoc.find('.draw_outline_base[ouid="'+p+'"]').addClass('draw_outline draw_'+(parseInt(p)+1)+'_outline');&#13;
            }&#13;
            if(this.expressions[p].selectable &amp;&amp; this.interactive) {&#13;
                obj = this.svgDoc.find('.draw_active_area[refuid="'+p+'"]');&#13;
                obj.mouseover(function() {&#13;
                    var id = parseInt($(this).attr('refuid'));&#13;
                    p = plot.svgDoc.find('.is_plot[uid="'+id+'"]');&#13;
                    p.addClass('draw_over draw_'+(id+1)+'_over').removeAttr('style');&#13;
                });&#13;
                obj.mouseout(function() {&#13;
                    var id = parseInt($(this).attr('refuid'));&#13;
                    p = plot.svgDoc.find('.is_plot[uid="'+id+'"]');&#13;
                    p.removeClass('draw_over draw_'+(id+1)+'_over');&#13;
                    if(p.attr('isselected') != 1) {&#13;
                        p.attr('style', p.data().cssStyle);&#13;
                    }&#13;
                });&#13;
                obj.click(function(e) {&#13;
                    e.stopPropagation();&#13;
&#13;
                    var id = parseInt($(this).attr('refuid'));&#13;
                    var refObj = plot.svgDoc.find('.is_plot[uid="'+id+'"]');&#13;
                    var refObjOutline = plot.svgDoc.find('.draw_outline_base[ouid="'+id+'"]');&#13;
                    var selected = parseInt(refObj.attr('isselected'));&#13;
                    plot.expressions[id].touched = true;&#13;
                    plot.attempted = true;&#13;
                    if(selected) {&#13;
                        refObj.attr('isselected', 0);&#13;
                        refObj.attr('style', refObj.data().cssStyle);&#13;
                        refObj.removeClass('draw_selected draw_'+(id+1)+'_selected');&#13;
                        refObjOutline.removeClass('draw_outline draw_'+(id+1)+'_outline');&#13;
                        plot.expressions[id].selected = false;&#13;
                        plot.stateChanged({&#13;
                            item:'plot_'+plot.expressions[id].id,&#13;
                            value:0,&#13;
                            score: plot.getPlotEventScore(plot.expressions[id].id)&#13;
                        });&#13;
                    } else {&#13;
                        refObj.attr('isselected', 1);&#13;
                        refObj.addClass('draw_selected draw_'+(id+1)+'_selected');&#13;
                        refObj.removeAttr('style');&#13;
                        refObjOutline.addClass('draw_outline draw_'+(id+1)+'_outline');&#13;
                        plot.expressions[id].selected = true;&#13;
                        plot.stateChanged({&#13;
                            item:'plot_'+plot.expressions[id].id,&#13;
                            value:1,&#13;
                            score: plot.getPlotEventScore(plot.expressions[id].id)&#13;
                        });&#13;
                    }&#13;
                });&#13;
            }&#13;
        }&#13;
        this.drawPlots = function() {&#13;
            $.each(this.expressions, function(idx, val) {&#13;
                if(val.visible) {&#13;
                    plot.drawPlot(idx);&#13;
                }&#13;
            });&#13;
        };&#13;
        this._drawYToX = function(p) {&#13;
            var path = this.svg.createPath();&#13;
            var rx, ry, i;&#13;
            var idx = 0;&#13;
            var values = [];&#13;
            var sy = -this.offsetY;&#13;
            var ey = -this.height-this.offsetY;&#13;
            var domain = this._getPlotDomain(p);&#13;
            var xMin = domain.xMin;&#13;
            var xMax = domain.xMax;&#13;
            var yMin = domain.yMin;&#13;
            var yMax = domain.yMax;&#13;
&#13;
            //create variables for parser&#13;
            var variables = this._mapPlotVariables(p);&#13;
&#13;
            for(i = sy; i &gt;= ey; i--) {&#13;
                ry = this.yMax-(idx)/this.stepY;&#13;
                //add x to parser variables&#13;
                variables.y = ry;&#13;
                try {&#13;
                    rx = Parser.evaluate(this.expressions[p].expression, variables);&#13;
                } catch (e) {&#13;
                    break;&#13;
                }&#13;
                if(rx &gt; this.INFINITY_POSITIVE_VALUE) {&#13;
                    //console.log(i,ry,'-n');&#13;
                    rx = Infinity;&#13;
                }&#13;
                if(rx &lt; this.INFINITY_NEGATIVE_VALUE) {&#13;
                    //console.log(i,ry,'+n');&#13;
                    rx = -Infinity;&#13;
                }&#13;
&#13;
                values.push({&#13;
                   rx: rx.toFixed(5),&#13;
                   ry: ry.toFixed(5),&#13;
                   i: i&#13;
                });&#13;
&#13;
                idx++;&#13;
            }&#13;
&#13;
            var d1 = d2 = d3 = dX = 0;&#13;
            var asymptote = false;&#13;
            var positioning = true; //set position at the beginning of drawing&#13;
            var closedAsymptote = false;&#13;
            var prevXMin = prevXMax = prevYMin = prevYMax = false;&#13;
&#13;
            for(var j = 0; j&lt;values.length; j+=1) {&#13;
                ry = values[j].ry;&#13;
                rx = values[j].rx;&#13;
                i = values[j].i;&#13;
&#13;
                //yMin is set&#13;
                if(yMin !== null) {&#13;
                    //range check&#13;
                    if(ry &lt; yMin) {&#13;
                        prevYMin = ry;&#13;
                        positioning = true;&#13;
                        continue;&#13;
                    }&#13;
                    //if we pass from out of range to in range&#13;
                    if(prevYMin !== false &amp;&amp; prevYMin &lt; yMin &amp;&amp; ry &gt;= yMin) {&#13;
                        prevYMin = false;&#13;
                        //console.log('przejscie xmin',i,rx)&#13;
                        //calculate equation for xMin&#13;
                        variables.y = yMin;&#13;
                        try {&#13;
                            rx = Parser.evaluate(this.expressions[p].expression, variables);&#13;
                        } catch (e) {&#13;
                            break;&#13;
                        }&#13;
                        //force to draw y at draw point x&#13;
                        i = this.coords2px(0, yMin).y;&#13;
                    }&#13;
                }&#13;
&#13;
                //yMax is set&#13;
                if(yMax !== null) {&#13;
                    //we are in range&#13;
                    if(ry &lt;= yMax) {&#13;
                        prevYMax = ry;&#13;
                    }&#13;
                    //we pass xMax&#13;
                    if(prevYMax !== false &amp;&amp; prevYMax &lt;= yMax &amp;&amp; ry &gt; yMax) {&#13;
                        prevYMax = false;&#13;
                        //console.log('przejscie xmax',i,rx)&#13;
                        //calculate equation for xMin&#13;
                        variables.y = yMax;&#13;
                        try {&#13;
                            rx = Parser.evaluate(this.expressions[p].expression, variables);&#13;
                        } catch (e) {&#13;
                            break;&#13;
                        }&#13;
                        //force draw x value&#13;
                        i = this.coords2px(0,yMax).y;&#13;
                    } else if(ry &gt; yMax) {&#13;
                        positioning = true;&#13;
                        prevYMax = false;&#13;
                        continue;&#13;
                    }&#13;
                }&#13;
&#13;
                if(xMin !== null) {&#13;
                    //range check&#13;
                    if(rx &lt; xMin) {&#13;
                        prevXMin = rx;&#13;
                    }&#13;
                    //if we pass from out of range to in range - open path with yMin&#13;
                    if(prevXMin !== false &amp;&amp; prevXMin &lt; xMin &amp;&amp; rx &gt;= xMin) {&#13;
                        positioning = true;&#13;
                        prevXMin = false;&#13;
                        //console.log('wejscie xmin',i,rx,ry);&#13;
                        rx = xMin;&#13;
                    } else if(j&gt;0 &amp;&amp; values[j-1].rx &gt;= xMin &amp;&amp; rx &lt; xMin)  {&#13;
                        //if we pass from in range to out of range (close path)&#13;
                        positioning = false;&#13;
                        //console.log('zejscie xmin', i, rx, ry);&#13;
                        rx = xMin;&#13;
                    } else if( rx &lt; xMin){&#13;
                        continue;&#13;
                    }&#13;
                }&#13;
&#13;
                if(xMax !== null) {&#13;
                    if(rx &lt;= xMax) {&#13;
                        prevXMax = rx;&#13;
                    }&#13;
                    //we pass yMax&#13;
                    if(prevXMax !== false &amp;&amp; prevXMax &lt;= xMax &amp;&amp; rx &gt; xMax) {&#13;
                        prevXMax = false;&#13;
                        //console.log('zejscie poza xmax',j,i,rx,ry)&#13;
                        rx = xMax;&#13;
                    } else if(j &gt; 0 &amp;&amp; values[j-1].rx &gt; xMax &amp;&amp; rx &lt;= xMax) {&#13;
                        //console.log('wejscie z poza xmax',j,i,rx,ry,values[j-1].ry )&#13;
                        positioning = true;&#13;
                        rx = xMax;&#13;
                    } else if(rx &gt; xMax) {&#13;
                        positioning = true;&#13;
                        prevXMax = false;&#13;
                        continue;&#13;
                    }&#13;
                }&#13;
&#13;
                if(j &gt; this.ASYMPTOTE_MINIMUM_TRIAL) {&#13;
                    dX = rx-values[j-1].rx;&#13;
                    d3 = values[j-1].rx - values[j-2].rx;&#13;
                    d2 = values[j-2].rx - values[j-3].rx;&#13;
                    d1 = values[j-3].rx - values[j-4].rx;&#13;
                }&#13;
&#13;
                //detect discontinuous&#13;
                if(this.isDiscontinuous(d1, d2, d3, dX)) {&#13;
                    rx = Number.NaN;&#13;
                }&#13;
&#13;
                //detect asymptote&#13;
                asymptote=this.hasAsymptote(d1, d2, d3, dX);&#13;
&#13;
                if(asymptote.asymptote) {&#13;
                    //console.log('Asymptote: ',i, j,asymptote.asymptote,asymptote.val, rx,ry,'d:',d1,d2,d3,dX);&#13;
                    //draw graph to -+Infinity&#13;
                    //draw to -Infinity&#13;
                    if(!closedAsymptote) {&#13;
                        //draw to -Infinity&#13;
                        if(asymptote.val == 1) {&#13;
                            //if prevoius value was in range draw closing asymptote line&#13;
                            if(j&gt;0 &amp;&amp; values[j-1].rx &gt;= xMin &amp;&amp; rx &lt; xMin) {&#13;
                                path.line((this.xMin*this.stepX).toFixed(5), i);&#13;
                            }&#13;
                            path.move((this.xMax*this.stepX).toFixed(5), i);&#13;
                            //console.log(i,'-n closing');&#13;
                            closedAsymptote = true;&#13;
                        }&#13;
                        //draw to +Infinity&#13;
                        if(asymptote.val == -1) {&#13;
                            //if prevoius value was in range draw closing asymptote line&#13;
                            if(j &gt; 0 &amp;&amp; !(values[j-1].rx &gt; xMax &amp;&amp; rx &lt;= xMax)) {&#13;
                                path.line((this.xMax*this.stepX).toFixed(5), i);&#13;
                            }&#13;
                            path.move((this.xMin*this.stepX).toFixed(5), i);&#13;
                            //console.log(i,'+n closing');&#13;
                            closedAsymptote = true;&#13;
                        }&#13;
                    }&#13;
                } else {&#13;
                    closedAsymptote = false;&#13;
                    //if point in range&#13;
                    if(rx != Infinity &amp;&amp; rx != -Infinity &amp;&amp; !isNaN(rx)) {&#13;
                        //set starting point&#13;
                        if(positioning) {&#13;
                            path.move((rx*this.stepX).toFixed(5), i);&#13;
                            positioning = false;&#13;
                        }&#13;
                        //draw&#13;
                        if(!positioning) {&#13;
                            path.line((rx*this.stepX).toFixed(5),i);&#13;
                        }&#13;
                    } else {&#13;
                        positioning = true;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            return path;&#13;
        }&#13;
&#13;
        this.isDiscontinuous = function(d1, d2, d3, dY) {&#13;
            if(Math.abs(dY) &gt; this.asymptoteMinimumDY &amp;&amp; d1 == 0 &amp;&amp; d2 == 0 &amp;&amp; d3 == 0 &amp;&amp; dY != 0) {&#13;
                return true;&#13;
            }&#13;
        };&#13;
&#13;
        //detect asymptote&#13;
        this.hasAsymptote = function(d1, d2, d3, dY) {&#13;
            //if dY is greater than minimum step or is equal to +- infinity check deltas&#13;
            if(Math.abs(dY) &gt; this.asymptoteMinimumDY || dY == -Infinity || dY == Infinity) {&#13;
                if(d1 &gt; 0 &amp;&amp; d2 &gt; 0 &amp;&amp; d3 &gt; 0 &amp;&amp; d1 &lt; d2 &amp;&amp; d2 &lt; d3)	{&#13;
                    if(dY &lt; d3) {&#13;
                        return {&#13;
                            asymptote: true,&#13;
                            val: -1&#13;
                        };&#13;
                    } else {&#13;
                        return {&#13;
                            asymptote: false,&#13;
                            val: 0&#13;
                        };&#13;
                    }&#13;
                }&#13;
                if(d1 &lt; 0 &amp;&amp; d2 &lt; 0 &amp;&amp; d3 &lt; 0 &amp;&amp; d1 &gt; d2 &amp;&amp; d2 &gt; d3) {&#13;
                    if(dY &gt; d3) {&#13;
                        return {&#13;
                            asymptote: true,&#13;
                            val: 1&#13;
                        };&#13;
                    } else {&#13;
                        return {&#13;
                            asymptote: false,&#13;
                            val: 0&#13;
                        };&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            return {&#13;
                asymptote: false,&#13;
                val: 0&#13;
            };&#13;
        }&#13;
        this._mapPlotVariables = function(p) {&#13;
            var variables = {};&#13;
            $.each(this.expressions[p].variables, function(k,v) {&#13;
                variables[k] = v.value;&#13;
            });&#13;
&#13;
            return variables;&#13;
        }&#13;
        this._getPlotDomain = function(p) {&#13;
            var variables = this._mapPlotVariables(p);&#13;
            var xMin = this.expressions[p].xMin !== false ? Parser.evaluate(this.expressions[p].xMin.toString(), variables) : null;&#13;
            var xMax = this.expressions[p].xMax !== false ? Parser.evaluate(this.expressions[p].xMax.toString(), variables) : null;&#13;
            var yMin = this.expressions[p].yMin !== false ? Parser.evaluate(this.expressions[p].yMin.toString(), variables) : null;&#13;
            var yMax = this.expressions[p].yMax !== false ? Parser.evaluate(this.expressions[p].yMax.toString(), variables) : null;&#13;
            if(xMin === null || xMin &lt; this.xMin) {&#13;
                xMin = this.xMin;&#13;
            }&#13;
            if(xMax === null || xMax &gt; this.xMax) {&#13;
                xMax = this.xMax;&#13;
            }&#13;
            if(yMin === null || yMin &lt; this.yMin) {&#13;
                yMin = this.yMin;&#13;
            }&#13;
            if(yMax === null || yMax &gt; this.yMax) {&#13;
                yMax = this.yMax;&#13;
            }&#13;
&#13;
            return {xMin: xMin, xMax:xMax, yMin: yMin, yMax: yMax};&#13;
        }&#13;
        this._drawXToY = function(p) {&#13;
            var path = this.svg.createPath();&#13;
            var rx, ry, i;&#13;
            var values = [];&#13;
            var sx = -this.offsetX;&#13;
            var ex = sx+this.width;&#13;
            var domain = this._getPlotDomain(p);&#13;
            var xMin = domain.xMin;&#13;
            var xMax = domain.xMax;&#13;
            var yMin = domain.yMin;&#13;
            var yMax = domain.yMax;&#13;
&#13;
            //create variables for parser&#13;
            var variables = this._mapPlotVariables(p);&#13;
&#13;
            //calculate values for every pixel&#13;
            for(i = sx; i &lt;= ex; i++) {&#13;
                rx = this.xMin+(i-sx)/this.stepX;&#13;
                //add x to parser variables&#13;
                variables.x = rx;&#13;
                try {&#13;
                    ry = Parser.evaluate(this.expressions[p].expression, variables);&#13;
                } catch (e) {&#13;
                    break;&#13;
                }&#13;
                if(ry &gt; this.INFINITY_POSITIVE_VALUE) {&#13;
                    //console.log(i,ry,'-n');&#13;
                    ry = Infinity;&#13;
                }&#13;
                if(ry &lt; this.INFINITY_NEGATIVE_VALUE) {&#13;
                    //console.log(i,ry,'+n');&#13;
                    ry = -Infinity;&#13;
                }&#13;
&#13;
                values.push({&#13;
                   rx: rx.toFixed(5),&#13;
                   ry: ry.toFixed(5),&#13;
                   i: i&#13;
                });&#13;
            }&#13;
&#13;
            var d1 = d2 = d3 = dY = 0;&#13;
            var asymptote = false;&#13;
            var positioning = true; //set position at the beginning of drawing&#13;
            var closedAsymptote = false;&#13;
            var prevXMin = prevXMax = prevYMin = prevYMax = false;&#13;
&#13;
            for(var j = 0; j&lt;values.length; j+=1) {&#13;
                ry = values[j].ry;&#13;
                rx = values[j].rx;&#13;
                i = values[j].i;&#13;
&#13;
                //xMin is set&#13;
                if(xMin !== null) {&#13;
                    //range check&#13;
                    if(rx &lt; xMin) {&#13;
                        prevXMin = rx;&#13;
                        positioning = true;&#13;
                        continue;&#13;
                    }&#13;
                    //if we pass from out of range to in range&#13;
                    if(prevXMin !== false &amp;&amp; prevXMin &lt; xMin &amp;&amp; rx &gt;= xMin) {&#13;
                        prevXMin = false;&#13;
                        //console.log('przejscie xmin',i,rx)&#13;
                        //calculate equation for xMin&#13;
                        variables.x = xMin;&#13;
                        try {&#13;
                            ry = Parser.evaluate(this.expressions[p].expression, variables);&#13;
                        } catch (e) {&#13;
                            break;&#13;
                        }&#13;
                        //force to draw y at draw point x&#13;
                        i = this.coords2px(xMin, 0).x;&#13;
                    }&#13;
                }&#13;
&#13;
                //xMax is set&#13;
                if(xMax !== null) {&#13;
                    //we are in range&#13;
                    if(rx &lt;= xMax) {&#13;
                        prevXMax = rx;&#13;
                    }&#13;
                    //we pass xMax&#13;
                    if(prevXMax !== false &amp;&amp; prevXMax &lt;= xMax &amp;&amp; rx &gt; xMax) {&#13;
                        prevXMax = false;&#13;
                        //console.log('przejscie xmax',i,rx)&#13;
                        //calculate equation for xMin&#13;
                        variables.x = xMax;&#13;
                        try {&#13;
                            ry = Parser.evaluate(this.expressions[p].expression, variables);&#13;
                        } catch (e) {&#13;
                            break;&#13;
                        }&#13;
                        //force draw x value&#13;
                        i = this.coords2px(xMax, 0).x;&#13;
                    } else if(rx &gt; xMax) {&#13;
                        positioning = true;&#13;
                        prevXMax = false;&#13;
                        continue;&#13;
                    }&#13;
                }&#13;
&#13;
                if(yMin !== null) {&#13;
                    //range check&#13;
                    if(ry &lt; yMin) {&#13;
                        prevYMin = ry;&#13;
                    }&#13;
&#13;
                    //if we pass from out of range to in range - open path with yMin&#13;
                    if(prevYMin !== false &amp;&amp; prevYMin &lt; yMin &amp;&amp; ry &gt;= yMin) {&#13;
                        positioning = true;&#13;
                        prevYMin = false;&#13;
                        //console.log('wejscie ymin',i,rx,ry);&#13;
                        ry = yMin;&#13;
                    } else if(j&gt;0 &amp;&amp; values[j-1].ry &gt;= yMin &amp;&amp; ry &lt; yMin)  {&#13;
                        //if we pass from in range to out of range (close path)&#13;
                        positioning = false;&#13;
                        //console.log('zejscie ymin', i, rx, ry);&#13;
                        ry = yMin;&#13;
                    } else if( ry &lt; yMin){&#13;
                        continue;&#13;
                    }&#13;
                }&#13;
&#13;
                if(yMax !== null) {&#13;
                    if(ry &lt;= yMax) {&#13;
                        prevYMax = ry;&#13;
                    }&#13;
                    //we pass yMax&#13;
                    if(prevYMax !== false &amp;&amp; prevYMax &lt;= yMax &amp;&amp; ry &gt; yMax) {&#13;
                        prevYMax = false;&#13;
                        //console.log('zejscie poza ymax',j,i,rx,ry)&#13;
                        ry = yMax;&#13;
                    } else if(j &gt; 0 &amp;&amp; values[j-1].ry &gt; yMax &amp;&amp; ry &lt;= yMax) {&#13;
                        //console.log('wejscie z poza ymax',j,i,rx,ry,values[j-1].ry )&#13;
                        positioning = true;&#13;
                        ry = yMax;&#13;
                    } else if(ry &gt; yMax) {&#13;
                        positioning = true;&#13;
                        prevYMax = false;&#13;
                        continue;&#13;
                    }&#13;
                }&#13;
&#13;
                //calculate deltas&#13;
                if(j &gt; this.ASYMPTOTE_MINIMUM_TRIAL) {&#13;
                    dY = ry-values[j-1].ry;&#13;
                    d3 = values[j-1].ry - values[j-2].ry;&#13;
                    d2 = values[j-2].ry - values[j-3].ry;&#13;
                    d1 = values[j-3].ry - values[j-4].ry;&#13;
                }&#13;
&#13;
                //detect discontinuous&#13;
                if(this.isDiscontinuous(d1, d2, d3, dY)) {&#13;
                    ry = Number.NaN;&#13;
                }&#13;
                //detect asymptote&#13;
                asymptote=this.hasAsymptote(d1, d2, d3, dY);&#13;
&#13;
                if(asymptote.asymptote) {&#13;
                    //console.log('Asymptote: ',i, j,asymptote.asymptote,asymptote.val, rx,ry,'d:',d1,d2,d3,dY);&#13;
                    //draw graph to -+Infinity&#13;
                    //draw to -Infinity&#13;
                    if(!closedAsymptote) {&#13;
                        //draw to -Infinity&#13;
                        if(asymptote.val == 1) {&#13;
                            //if prevoius value was in range draw closing asymptote line&#13;
                            if(j&gt;0 &amp;&amp; values[j-1].ry &gt;= yMin &amp;&amp; ry &lt; yMin) {&#13;
                                path.line(i, (this.yMin*this.stepY).toFixed(5));&#13;
                            }&#13;
                            path.move(i, (this.yMax*this.stepY).toFixed(5));&#13;
                            //console.log(i,'-n closing');&#13;
                            closedAsymptote = true;&#13;
                        }&#13;
                        //draw to +Infinity&#13;
                        if(asymptote.val == -1) {&#13;
                            //if prevoius value was in range draw closing asymptote line&#13;
                            if(j &gt; 0 &amp;&amp; !(values[j-1].ry &gt; yMax &amp;&amp; ry &lt;= yMax)) {&#13;
                                path.line(i, (this.yMax*this.stepY).toFixed(5));&#13;
                            }&#13;
                            path.move(i, (this.yMin*this.stepY).toFixed(5));&#13;
                            //console.log(i,'+n closing');&#13;
                            closedAsymptote = true;&#13;
                        }&#13;
                    }&#13;
                }  else {&#13;
                    closedAsymptote = false;&#13;
                    //if point in range&#13;
                    if(ry != Infinity &amp;&amp; ry != -Infinity &amp;&amp; !isNaN(ry)) {&#13;
                        //set starting point&#13;
                        if(positioning) {&#13;
                            path.move(i, (ry*this.stepY).toFixed(5));&#13;
                            positioning = false;&#13;
                        }&#13;
                        //draw&#13;
                        if(!positioning) {&#13;
                            path.line(i, (ry*this.stepY).toFixed(5));&#13;
                        }&#13;
                    } else {&#13;
                        positioning = true;&#13;
                    }&#13;
                }&#13;
            }&#13;
&#13;
            return path;&#13;
        }&#13;
        this.reset = function() {&#13;
            $.each(this.expressions, function(idx, val) {&#13;
                if(val.selectable) {&#13;
                    val.selected = false;&#13;
                }&#13;
                val.touched = false;&#13;
            })&#13;
&#13;
            this.selectedPoints = [];&#13;
            $.each(this.points, function(idx, val) {&#13;
                if(val.initiallySelected) {&#13;
                    plot.selectedPoints.push({&#13;
                        x: val.x,&#13;
                        y: val.y,&#13;
                        clickable: val.clickable&#13;
                    });&#13;
                }&#13;
            });&#13;
            this.uiEnabled = true;&#13;
            this.restoreInitialViewPort();&#13;
        }&#13;
        this.restoreInitialViewPort = function() {&#13;
            this.xMin = this.initXMin;&#13;
            this.xMax = this.initXMax;&#13;
            this.yMin = this.initYMin;&#13;
            this.yMax = this.initYMax;&#13;
            this.setStep();&#13;
            this.translate();&#13;
            this.draw();&#13;
        }&#13;
        this.coords2px = function(cx, cy) {&#13;
            return {&#13;
                x:cx*this.stepX,&#13;
                y:cy*this.stepY&#13;
            }&#13;
        };&#13;
        this.px2coords = function(px, py) {&#13;
            var xRange = Math.max(this.xMin, this.xMax) - Math.min(this.xMin, this.xMax);&#13;
            var yRange = Math.max(this.yMin, this.yMax) - Math.min(this.yMin, this.yMax);&#13;
&#13;
            var x = px*xRange/this.width+this.xMin;&#13;
            x = Math.round(this.precision.x*x)/this.precision.x;&#13;
            var y = (py*yRange/this.height)*(-1)+this.yMax;&#13;
            y = Math.round(this.precision.y*y)/this.precision.y;&#13;
&#13;
            return {&#13;
                x: x,&#13;
                y: y&#13;
            };&#13;
        };&#13;
&#13;
        this.calculateRange = function() {&#13;
            var xRange = Math.max(this.xMin, this.xMax) - Math.min(this.xMin, this.xMax);&#13;
            var offsetX = this.lastOffsetX*xRange/this.width&#13;
            this.lastOffsetX = 0;&#13;
            this.xMin -= offsetX;&#13;
            this.xMax -= offsetX;&#13;
&#13;
            var yRange = Math.max(this.yMin, this.yMax) - Math.min(this.yMin, this.yMax);&#13;
            var offsetY = this.lastOffsetY*yRange/this.height&#13;
            this.lastOffsetY = 0;&#13;
&#13;
            this.yMin -= offsetY;&#13;
            this.yMax -= offsetY;&#13;
&#13;
            this.setStep();&#13;
        };&#13;
&#13;
        this.calculatePrecision = function() {&#13;
            var idx = this.gridStepX.toString().indexOf('.');&#13;
            var idy = this.gridStepY.toString().indexOf('.');&#13;
            this.precision.x = idx !== -1 ? Math.pow(10, this.gridStepX.toString().length - idx - 1) : 100;&#13;
            this.precision.y = idy !== -1 ? Math.pow(10, this.gridStepY.toString().length - idx - 1) : 100;&#13;
        };&#13;
&#13;
        /**&#13;
         * param int direction - -1 zoomOut, +1 zoomIn&#13;
         **/&#13;
        this.zoom = function(direction) {&#13;
            this.xMin -= this.xMin*this.zoomStep*direction;&#13;
            this.xMax -= this.xMax*this.zoomStep*direction;&#13;
            this.yMin -= this.yMin*this.zoomStep*direction;&#13;
            this.yMax -= this.yMax*this.zoomStep*direction;&#13;
            this.setStep();&#13;
            this.draw();&#13;
        };&#13;
&#13;
        this.zoomIn = function(direction) {&#13;
            this.zoom(1);&#13;
        }&#13;
&#13;
        this.zoomOut = function(direction) {&#13;
            this.zoom(-1);&#13;
        }&#13;
&#13;
        this.move = function(dx, dy) {&#13;
            this.offsetX += dx;&#13;
            this.offsetY += dy;&#13;
            this.svgDoc.find('.translate').attr('transform', 'translate('+this.offsetX+', '+this.offsetY+')');&#13;
            this.lastOffsetX = dx;&#13;
            this.lastOffsetY = dy;&#13;
            this.calculateRange();&#13;
            this.draw();&#13;
        };&#13;
&#13;
        this.moveLeft = function(dx) {&#13;
            this.move(parseInt(dx),0);&#13;
        }&#13;
&#13;
        this.moveRight = function(dx) {&#13;
            this.move(parseInt(dx)*(-1),0);&#13;
        }&#13;
&#13;
        this.moveUp = function(dy) {&#13;
            this.move(0, parseInt(dy)*(-1));&#13;
        }&#13;
&#13;
        this.moveDown = function(dy) {&#13;
            this.move(0, parseInt(dy));&#13;
        }&#13;
&#13;
        this._composeStyle = function(style) {&#13;
            var formattedStyle = '';&#13;
            $.each(style, function(o, v) {&#13;
                if(v!='') {&#13;
                    formattedStyle += o+':'+v+';'&#13;
                }&#13;
            });&#13;
            return formattedStyle;&#13;
        }&#13;
        this.enableUI = function(state) {&#13;
            this.svgDoc.find('.blocker').remove();&#13;
            if(state) {&#13;
                this.uiEnabled = true;&#13;
            } else {&#13;
                this.uiEnabled = false;&#13;
                this.svg.polygon(this.svgDoc.find('.overall'), [[-this.offsetX,-this.offsetY], [this.width-this.offsetX,-this.offsetY], [this.width-this.offsetX,-this.height-this.offsetY], [-this.offsetX, -this.height-this.offsetY]], {&#13;
                    'class':'blocker',&#13;
                    fill: '#000000',&#13;
                    'fill-opacity':0,&#13;
                    strokeWidth: 0&#13;
                });&#13;
            }&#13;
        }&#13;
        this.setVariable = function(id, variable, value) {&#13;
            if(id != '' &amp;&amp; variable != '') {&#13;
                $.each(this.expressions, function(idx, val){&#13;
                    if(val.id == id) {&#13;
                        if(val.variables[variable] != undefined) {&#13;
                            plot.attempted = true;&#13;
                            val.variables[variable]['value'] = value != '' ? value : 0;&#13;
                            if(val.variables[variable]['isExercise']) {&#13;
                                val.variables[variable]['touched'] = true;&#13;
                                //call chain of events&#13;
                                plot.stateChanged([&#13;
                                {&#13;
                                    item:'variable_'+val.id+'_'+variable,&#13;
                                    value:value,&#13;
                                    score: plot.isCorrectVariable(val.id, variable)&#13;
                                },&#13;
&#13;
                                {&#13;
                                    item:'variables_'+val.id+'_'+variable,&#13;
                                    value:'',&#13;
                                    score: plot.areCorrectPlotVariables(val.id)&#13;
                                }&#13;
                                ]);&#13;
                            }&#13;
                        }&#13;
                        plot.removePlot(idx);&#13;
                        if(val.visible) {&#13;
                            plot.drawPlot(idx);&#13;
                        }&#13;
                    }&#13;
&#13;
                });&#13;
            }&#13;
        }&#13;
        this.setVisible = function(id, value) {&#13;
            if(id != '') {&#13;
                $.each(this.expressions, function(idx, val) {&#13;
                    if(val.id == id) {&#13;
                        val.visible = value;&#13;
                        //remove existing plot&#13;
                        plot.removePlot(idx);&#13;
                        //show plot&#13;
                        if(value) {&#13;
                            plot.drawPlot(idx);&#13;
                        }&#13;
                    }&#13;
                });&#13;
            }&#13;
        }&#13;
        this.setPointVisibility = function(x, y, visibility) {&#13;
            if(x != '' &amp;&amp; y != '') {&#13;
                var refObj = plot.svgDoc.find('.point[vx="'+x+'"][vy="'+y+'"]');&#13;
                var refObjOutline = plot.svgDoc.find('.point_outline_base[vx="'+x+'"][vy="'+y+'"]');&#13;
                if(visibility &amp;&amp; !refObj.hasClass('point_selected')) {&#13;
                    this._selectPoint(x, y, false);&#13;
                } else if(!visibility &amp;&amp; refObj.hasClass('point_selected')) {&#13;
                    this._deselectPoint(x, y, false);&#13;
                }&#13;
            }&#13;
        }&#13;
        this.setPlotStyle = function(id, type, prop, value) {&#13;
            if(id != '') {&#13;
                if(type == 'plot') {&#13;
                    $.each(this.expressions, function(idx, val) {&#13;
                        if(val.id == id) {&#13;
                            if(prop == 'color' || prop == 'stroke') {&#13;
                                val.cssColor = value;&#13;
                            } else {&#13;
                                val.cssProperties[prop] = value;&#13;
                            }&#13;
                            //remove existing plot&#13;
                            plot.removePlot(idx);&#13;
                            //show plot&#13;
                            if(val.visible) {&#13;
                                plot.drawPlot(idx);&#13;
                            }&#13;
                        }&#13;
                    });&#13;
                }&#13;
            }&#13;
        }&#13;
        this.plotVariablesResult = function(plotId) {&#13;
            //check variables&#13;
            var variablesTodo = 0;&#13;
            var variablesDone = 0;&#13;
            var touched = false;&#13;
            $.each(this.expressions[plotId].variables, function(k,v) {&#13;
                if(v.isExercise) {&#13;
                    variablesTodo++;&#13;
                    if(v.expectedValue == v.value) {&#13;
                        variablesDone++;&#13;
                    }&#13;
                    if(v.touched) {&#13;
                        touched = true;&#13;
                    }&#13;
                }&#13;
            });&#13;
&#13;
            return {&#13;
                todo: variablesTodo,&#13;
                done: variablesDone,&#13;
                touched: touched&#13;
            };&#13;
        };&#13;
&#13;
        this.getPlotEventScore = function(pid) {&#13;
            if(!this.isActivity) {&#13;
                return this.STATE_NOT_ACTIVITY;&#13;
            }&#13;
            var state = this.STATE_INCORRECT;&#13;
            $.each(this.expressions, function(idx, val) {&#13;
                if(val.id == pid) {&#13;
                    if(val.selected == val.correctAnswer &amp;&amp; val.correctAnswer == true) {&#13;
                        state = plot.STATE_CORRECT;&#13;
                    } else if((val.correctAnswer == true &amp;&amp; val.selected == false) || (val.correctAnswer == false &amp;&amp; val.selected == false)) {&#13;
                        state = plot.STATE_NULL;&#13;
                    } else if(val.correctAnswer == false &amp;&amp; val.selected == true) {&#13;
                        state = plot.STATE_INCORRECT;&#13;
                    }&#13;
                    return false;&#13;
                }&#13;
            });&#13;
            return state;&#13;
        };&#13;
        this.isPointOnPlot = function(pid, x, y) {&#13;
            var rv, rc, domain;&#13;
            var isCorrect = false;&#13;
            $.each(this.expressions, function(idx, val) {&#13;
                if (val.id == pid) {&#13;
                    var variables = plot._mapPlotVariables(idx);&#13;
                    if(val.type == plot.TYPE_X_TO_Y) {&#13;
                        rc = y;&#13;
                        variables.x = x;&#13;
                    } else {&#13;
                        rc = x;&#13;
                        variables.y = y;&#13;
                    }&#13;
                    try {&#13;
                        rv = Parser.evaluate(plot.expressions[idx].expression, variables);&#13;
                    } catch (e) {&#13;
                        return false;&#13;
                    }&#13;
&#13;
                    isCorrect = rv == rc;&#13;
&#13;
                    //check if point is in range&#13;
                    if(isCorrect) {&#13;
                        domain = plot._getPlotDomain(idx);&#13;
                        if(x &lt; domain.xMin || x &gt; domain.xMax || y &lt; domain.yMin || y &gt; domain.yMax) {&#13;
                            isCorrect = false;&#13;
                        }&#13;
                    }&#13;
                    return false;&#13;
                }&#13;
            });&#13;
&#13;
            return isCorrect;&#13;
        };&#13;
        this.getPointEventScore = function(vx, vy, state) {&#13;
            var currentState = this.STATE_NULL;&#13;
            var pointInDefinedPoints = false;&#13;
            if(!this.isActivity || (this.points.length == 0 &amp;&amp; this.freePoints)) {&#13;
                return this.STATE_NOT_ACTIVITY;&#13;
            }&#13;
&#13;
            //check point in model points&#13;
            $.each(this.points, function(idx, val) {&#13;
                //we have this point&#13;
                if(val.x == vx &amp;&amp; val.y == vy) {&#13;
                    //check if should be selected or not&#13;
                    if((val.correct &amp;&amp; state == plot.STATE_SELECT_POINT) || (!val.correct &amp;&amp; state == plot.STATE_DESELECT_POINT)) {&#13;
                        currentState = plot.STATE_CORRECT;&#13;
                    } else if(state == plot.STATE_SELECT_POINT) {&#13;
                        currentState = plot.STATE_INCORRECT;&#13;
                    } else {&#13;
                        currentState = plot.STATE_NULL;&#13;
                    }&#13;
                    pointInDefinedPoints = true;&#13;
                    return false;&#13;
                }&#13;
            });&#13;
&#13;
            if(pointInDefinedPoints) {&#13;
                return currentState;&#13;
            } else {&#13;
                return state == this.STATE_SELECT_POINT ? this.STATE_INCORRECT : this.STATE_NULL;&#13;
            }&#13;
        };&#13;
&#13;
        this.isCorrectVariable = function(pid, variable) {&#13;
            var state = this.STATE_INCORRECT;&#13;
            if(!this.isActivity) {&#13;
                return this.STATE_NOT_ACTIVITY;&#13;
            }&#13;
&#13;
            $.each(this.expressions, function(idx, val) {&#13;
                if(val.id == pid) {&#13;
                    state = val.variables[variable].value == val.variables[variable].expectedValue ? plot.STATE_CORRECT : plot.STATE_INCORRECT;&#13;
                    return false;&#13;
                }&#13;
            });&#13;
&#13;
            return state;&#13;
        }&#13;
&#13;
        this.areCorrectPlotVariables = function(pid) {&#13;
            if(!this.isActivity) {&#13;
                return this.STATE_NOT_ACTIVITY;&#13;
            }&#13;
&#13;
            var state = this.STATE_CORRECT;&#13;
            $.each(this.expressions, function(idx, val) {&#13;
                if(val.id == pid) {&#13;
                    $.each(val, function(vidx, variableObj) {&#13;
                        if(variableObj.isExercise &amp;&amp; variableObj.value != variableObj.expectedValue) {&#13;
                            state = plot.STATE_INCORRECT;&#13;
                            return false;&#13;
                        }&#13;
                    })&#13;
                }&#13;
            })&#13;
&#13;
            return state;&#13;
        }&#13;
&#13;
        this.isAttempted = function () {&#13;
            return this.attempted;&#13;
        }&#13;
&#13;
        this.setAttempted = function (state) {&#13;
            this.attempted = state;&#13;
        }&#13;
    }&#13;
&#13;
    var presenter = function(){};&#13;
    var addonID;&#13;
    var plot = new Plot();&#13;
    presenter.isShowAnswersActive = false;&#13;
&#13;
    presenter.setWorkMode = function(){&#13;
        var ref;&#13;
        if(!presenter.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.errorsMode = false;&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            ref = plot.svgDoc.find('.is_plot[uid="'+idx+'"]');&#13;
            if(ref.length &gt; 0) {&#13;
                ref.removeClass('draw_mark_error draw_'+(parseInt(idx)+1)+'_mark_error draw_mark_correct draw_'+(parseInt(idx)+1)+'_mark_correct');&#13;
                ref.attr('style', ref.data().cssStyle);&#13;
                plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').removeClass('draw_outline_mark_error draw_'+(parseInt(idx)+1)+'_outline_mark_error draw_outline_mark_correct draw_'+(parseInt(idx)+1)+'_outline_mark_correct');&#13;
            }&#13;
        });&#13;
        this.removePointsStateMarks();&#13;
        plot.enableUI(true);&#13;
    };&#13;
    presenter.removePointsStateMarks = function() {&#13;
        plot.svgDoc.find('.point_error').removeClass('point_error');&#13;
        plot.svgDoc.find('.point_outline_mark_error').removeClass('point_outline_mark_error');&#13;
        plot.svgDoc.find('.point_correct').removeClass('point_correct');&#13;
        plot.svgDoc.find('.point_outline_mark_correct').removeClass('point_outline_mark_correct');&#13;
        plot.svgDoc.find('.point_outline_base').removeClass('plot_show_answers');&#13;
    };&#13;
    presenter.markPointAsError = function(x, y) {&#13;
        plot.svgDoc.find('.point[vx="' + x + '"][vy="' + y + '"]').addClass('point_error');&#13;
        plot.svgDoc.find('.point_outline_base[vx="' + x + '"][vy="' + y + '"]').addClass('point_outline_mark_error');&#13;
    };&#13;
    presenter.markPointAsCorrect = function(x, y) {&#13;
        plot.svgDoc.find('.point[vx="' + x + '"][vy="' + y + '"]').addClass('point_correct');&#13;
        plot.svgDoc.find('.point_outline_base[vx="' + x + '"][vy="' + y + '"]').addClass('point_outline_mark_correct');&#13;
    };&#13;
&#13;
    presenter.setPointShowAnswersClass = function(x, y) {&#13;
        plot.svgDoc.find('.point_outline_base[vx="' + x + '"][vy="' + y + '"]').addClass('plot_show_answers');&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function (eventName) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function() {&#13;
        if(!presenter.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
&#13;
        // POINTS&#13;
        presenter.clickedPoints = {};&#13;
&#13;
        $.extend( true, presenter.clickedPoints, plot.selectedPoints );&#13;
&#13;
        $.each(presenter.clickedPoints, function(_, point) {&#13;
            plot._deselectPoint(point.x, point.y, true);&#13;
        });&#13;
&#13;
        presenter.removePointsStateMarks();&#13;
&#13;
        $.each(plot.points, function(_, point) {&#13;
            if (point.correct) {&#13;
                presenter.setPointShowAnswersClass(point.x, point.y);&#13;
            }&#13;
        });&#13;
&#13;
        // FUNCTIONS&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            plot.removePlot(idx);&#13;
        });&#13;
&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            if(val.correctAnswer) {&#13;
                plot.drawPlot(idx);&#13;
                plot.svgDoc.find('.is_plot[uid="'+idx+'"]').addClass('show_answers').removeAttr('style');&#13;
                plot.svgDoc.find('.is_plot[uid="'+idx+'"]').removeClass('draw_selected');&#13;
                plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').addClass('show_answers');&#13;
                plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').removeClass('draw_outline').removeClass('draw_"' + idx + '"_outline');&#13;
            }&#13;
        });&#13;
&#13;
        plot.enableUI(false);&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function() {&#13;
        if(!presenter.isActivity || !presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
        presenter.isShowAnswersActive = false;&#13;
&#13;
        // POINTS&#13;
        presenter.removePointsStateMarks();&#13;
&#13;
        $.each(presenter.clickedPoints, function(_, point) {&#13;
            plot._selectPoint(point.x, point.y, true);&#13;
        });&#13;
&#13;
        //FUNCTIONS&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            if(val.correctAnswer) {&#13;
                plot.removePlot(idx);&#13;
            }&#13;
        });&#13;
&#13;
        plot.drawPlots();&#13;
&#13;
        plot.enableUI(true);&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function() {&#13;
        if(!presenter.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        var res;&#13;
        presenter.errorsMode = true;&#13;
        plot.enableUI(false);&#13;
&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            if(val.selectable &amp;&amp; val.touched) {&#13;
                if(val.correctAnswer == false &amp;&amp; val.selected == true) {&#13;
                    //mark error&#13;
                    plot.svgDoc.find('.is_plot[uid="'+idx+'"]').addClass('draw_mark_error draw_'+(parseInt(idx)+1)+'_mark_error').removeAttr('style');&#13;
                    plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').addClass('draw_outline_mark_error draw_'+(parseInt(idx)+1)+'_outline_mark_error');&#13;
                } else if(val.correctAnswer == true &amp;&amp; val.selected == true) {&#13;
                    //mark as correct only plots which are selectable, selected, touched and it\'s correct answer is true (selected)&#13;
                    plot.svgDoc.find('.is_plot[uid="'+idx+'"]').addClass('draw_mark_correct draw_'+(parseInt(idx)+1)+'_mark_correct').removeAttr('style');&#13;
                    plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').addClass('draw_outline_mark_correct draw_'+(parseInt(idx)+1)+'_outline_mark_correct');&#13;
                }&#13;
            }&#13;
            res = plot.plotVariablesResult(idx);&#13;
            if(res.todo != res.done &amp;&amp; res.todo &gt; 0 &amp;&amp; res.touched) {&#13;
                //mark error&#13;
                plot.svgDoc.find('.is_plot[uid="'+idx+'"]').addClass('draw_mark_error draw_'+(parseInt(idx)+1)+'_mark_error').removeAttr('style');&#13;
                plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').addClass('draw_outline_mark_error draw_'+(parseInt(idx)+1)+'_outline_mark_error');&#13;
            } else if(res.todo == res.done &amp;&amp; res.todo &gt; 0 &amp;&amp; res.touched) {&#13;
                //mark correct&#13;
                plot.svgDoc.find('.is_plot[uid="'+idx+'"]').addClass('draw_mark_correct draw_'+(parseInt(idx)+1)+'_mark_correct').removeAttr('style');&#13;
                plot.svgDoc.find('.draw_outline_base[ouid="'+idx+'"]').addClass('draw_outline_mark_correct draw_'+(parseInt(idx)+1)+'_outline_mark_correct');&#13;
            }&#13;
        });&#13;
&#13;
        if(plot.points.length &gt; 0) {&#13;
            $.each(plot.points, function(idx, val) {&#13;
                res = presenter.grepPoints(plot.selectedPoints, val);&#13;
                if(val.notScored === false) {&#13;
                    if(!val.correct &amp;&amp; res &amp;&amp; val.touched) {&#13;
                        //mark wrong&#13;
                        presenter.markPointAsError(val.x, val.y);&#13;
                    } else if(val.correct &amp;&amp; res &amp;&amp; val.touched) {&#13;
                        //mark correct&#13;
                        presenter.markPointAsCorrect(val.x, val.y);&#13;
                    }&#13;
                }&#13;
            });&#13;
&#13;
            //check excess points&#13;
            $.each(plot.selectedPoints, function(idx, val) {&#13;
                res = presenter.grepPoints(plot.points, val);&#13;
                if(!res) {&#13;
                    presenter.markPointAsError(val.x, val.y);&#13;
                }&#13;
            });&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function(){&#13;
        if(!presenter.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var todo = 0;&#13;
&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            //include selectable plots&#13;
            if(val.selectable &amp;&amp; val.correctAnswer) {&#13;
                todo++;&#13;
            }&#13;
            //include expected variables&#13;
            var res = plot.plotVariablesResult(idx);&#13;
            if(res.todo &gt; 0) {&#13;
                todo++;&#13;
            }&#13;
        });&#13;
        //include all scorable points&#13;
        $.each(plot.points, function(idx, val) {&#13;
            if(val.notScored === false) {&#13;
                todo++;&#13;
            }&#13;
        })&#13;
&#13;
        return todo;&#13;
    }&#13;
&#13;
    presenter.getScore = function(){&#13;
        if(!presenter.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var done = 0;&#13;
        var res;&#13;
&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            if(val.selectable &amp;&amp; val.correctAnswer == val.selected &amp;&amp; val.correctAnswer) {&#13;
                done++;&#13;
            }&#13;
            //get variables score&#13;
            res = plot.plotVariablesResult(idx);&#13;
            if(res.todo &gt; 0 &amp;&amp; res.todo == res.done) {&#13;
                done++;&#13;
            }&#13;
        });&#13;
&#13;
        $.each(plot.points, function(idx, val) {&#13;
            res = presenter.grepPoints(plot.selectedPoints, val);&#13;
            if(((val.correct &amp;&amp; res) || (!val.correct &amp;&amp; !res)) &amp;&amp; val.notScored === false) {&#13;
                done++;&#13;
            }&#13;
        })&#13;
&#13;
        return done;&#13;
    }&#13;
&#13;
    presenter.grepPoints = function(arr, point) {&#13;
        var res = false;&#13;
        $.each(arr, function(idx, el) {&#13;
            if(el.x == point.x &amp;&amp; el.y == point.y) {&#13;
                res = true;&#13;
                return;&#13;
            }&#13;
        });&#13;
&#13;
        return res;&#13;
    }&#13;
&#13;
    presenter.getErrorCount = function(){&#13;
        if(!presenter.isActivity) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        var errors = 0;&#13;
        var res;&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            if(val.selectable &amp;&amp; val.correctAnswer == false &amp;&amp; val.selected == true &amp;&amp; val.touched) {&#13;
                errors++;&#13;
            }&#13;
            //check variables&#13;
            res = plot.plotVariablesResult(idx);&#13;
            if(res.todo != res.done &amp;&amp; res.touched) {&#13;
                errors++;&#13;
            }&#13;
        })&#13;
&#13;
        //check points&#13;
        if(plot.points.length &gt; 0) {&#13;
            $.each(plot.points, function(idx, val) {&#13;
                res = presenter.grepPoints(plot.selectedPoints, val);&#13;
                //var res = $.grep(plot.selectedPoints, function(e){ return e.x == plot.points[p].x &amp;&amp; e.y == plot.points[p].y; });&#13;
                if(!val.correct &amp;&amp; res &amp;&amp; val.touched &amp;&amp; val.notScored === false) {&#13;
                    errors++;&#13;
                }&#13;
            })&#13;
&#13;
            $.each(plot.selectedPoints, function(idx, val) {&#13;
                res = presenter.grepPoints(plot.points, val);&#13;
                //var res = $.grep(plot.points, function(e){ return e.x == plot.selectedPoints[p].x &amp;&amp; e.y == plot.selectedPoints[p].y; });&#13;
                if(!res) {&#13;
                    errors++;&#13;
                }&#13;
            });&#13;
        }&#13;
&#13;
        return errors;&#13;
    }&#13;
&#13;
    presenter.reset = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.errorsMode = false;&#13;
        presenter._allDoneState = false;&#13;
        presenter.isShowAnswersActive = false;&#13;
        plot.setAttempted(false);&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            val.touched = false;&#13;
            val.cssColor = val.cssColorInitialValue;&#13;
            val.cssProperties = {};&#13;
            val.visible = val.initVisible;&#13;
            $.each(val.variables, function(vidx, variableObj) {&#13;
                variableObj.touched = false;&#13;
                variableObj.value = variableObj.initialValue;&#13;
            })&#13;
        });&#13;
&#13;
        $.each(plot.points, function(idx, val) {&#13;
            val.touched = false;&#13;
        })&#13;
        plot.reset();&#13;
        presenter.isVisible = presenter.initIsVisible;&#13;
        presenter.updateVisibility();&#13;
    }&#13;
&#13;
    presenter.run = function(view, model){&#13;
        presenter.errorsMode = false;&#13;
        presenter.view = view;&#13;
        presenter.model = model;&#13;
        presenter._allDoneState = false;&#13;
&#13;
        addonID = model.ID;&#13;
&#13;
        presenter.initialize(presenter.view, presenter.model, true);&#13;
&#13;
        presenter.eventBus.addEventListener('ShowAnswers', this);&#13;
        presenter.eventBus.addEventListener('HideAnswers', this);&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = presenter.playerController.getEventBus();&#13;
    };&#13;
&#13;
    presenter.updateVisibility = function() {&#13;
        if(presenter.isVisible) {&#13;
            presenter.show();&#13;
        } else {&#13;
            presenter.hide();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.initialize = function(view, model, isInteractive) {&#13;
        var v, p, el;&#13;
        this._model = model;&#13;
        presenter.isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
        presenter.initIsVisible = presenter.isVisible;&#13;
        presenter.decimalSeparator = (model['Decimal separator'] === undefined || model['Decimal separator'] == '') ? '.' : model['Decimal separator'];&#13;
        if(presenter.decimalSeparator != '.' &amp;&amp; presenter.decimalSeparator != ',') {&#13;
            presenter.decimalSeparator = '.';&#13;
        };&#13;
        if (isInteractive) {&#13;
            presenter.updateVisibility();&#13;
        } else {&#13;
            presenter.show();&#13;
        }&#13;
        plot.interactive = isInteractive;&#13;
        plot.width = parseInt(model['Width']);&#13;
        plot.height = parseInt(model['Height']);&#13;
        plot.xMin = (model['xMin'] == '' &amp;&amp; model['xMin'] != '0' ? -10 : parseFloat(this.toDotSeparator(model['xMin'])));&#13;
        plot.xMax = (model['xMax'] == '' &amp;&amp; model['xMax'] != '0' ? 10 : parseFloat(this.toDotSeparator(model['xMax'])));&#13;
        plot.yMin = (model['yMin'] == '' &amp;&amp; model['yMin'] != '0' ? -10 : parseFloat(this.toDotSeparator(model['yMin'])));&#13;
        plot.yMax = (model['yMax'] == '' &amp;&amp; model['yMax'] != '0' ? 10 : parseFloat(this.toDotSeparator(model['yMax'])));&#13;
        plot.initXMin = plot.xMin;&#13;
        plot.initXMax = plot.xMax;&#13;
        plot.initYMin = plot.yMin;&#13;
        plot.initYMax = plot.yMax;&#13;
        plot.grid = model['Grid'].toLowerCase() === 'true' ? true : false;&#13;
        plot.gridStepX = Math.abs(parseFloat(this.toDotSeparator(model['GridStepX']))) || 1;&#13;
        plot.gridStepY = Math.abs(parseFloat(this.toDotSeparator(model['GridStepY']))) || 1;&#13;
        plot.arrowheadSize = parseInt(model['Arrowhead size']) || 6;&#13;
        plot.asymptoteMinimumDY = this.toDotSeparator(model['Asymptote DY']) || 5;&#13;
        plot.axisValues = model['Axis values'].toLowerCase() === 'true' ? true : false;&#13;
        plot.xAxisDescription = model['X axis description'] || 'x';&#13;
        plot.yAxisDescription = model['Y axis description'] || 'y';&#13;
        plot.xAxisVisible = model['hide X axis'] === undefined || model['hide X axis'].toLowerCase() === 'false' || model['hide X axis'] == '' ? true : false;&#13;
        plot.yAxisVisible = model['hide Y axis'] === undefined || model['hide Y axis'].toLowerCase() === 'false' || model['hide Y axis'] == '' ? true : false;&#13;
        plot.xAxisValuesPosition = model['X axis values position'];&#13;
        plot.yAxisValuesPosition = model['Y axis values position'];&#13;
        var xAxisValues = model['Axis x values'] === undefined || model['Axis x values'] == '' || this._hasIllegalCharacters(model['Axis x values'].toString()) ? false : model['Axis x values'].toString().split(this.getSeparatorByDecimalSeparator());&#13;
        var yAxisValues = model['Axis y values'] === undefined || model['Axis y values'] == '' || this._hasIllegalCharacters(model['Axis y values'].toString()) ? false : model['Axis y values'].toString().split(this.getSeparatorByDecimalSeparator());&#13;
        if(xAxisValues !== false &amp;&amp; xAxisValues.length &gt; 0) {&#13;
            $.each(xAxisValues, function(idx, val) {&#13;
                if(val.toString().match(/\*/) !== null) {&#13;
                    plot.xAxisCyclicValues.push(presenter.toDotSeparator(parseInt(val)));&#13;
                } else {&#13;
                    plot.xAxisCustomValues.push(parseFloat(presenter.toDotSeparator(val)));&#13;
                }&#13;
            });&#13;
        }&#13;
        if(yAxisValues !== false &amp;&amp; yAxisValues.length &gt; 0) {&#13;
            $.each(yAxisValues, function(idx, val) {&#13;
                if(val.toString().match(/\*/) !== null) {&#13;
                    plot.yAxisCyclicValues.push(presenter.toDotSeparator(parseInt(val)));&#13;
                } else {&#13;
                    plot.yAxisCustomValues.push(parseFloat(presenter.toDotSeparator(val)));&#13;
                }&#13;
            });&#13;
        }&#13;
        plot.expressions = new Array();&#13;
        plot.pointActiveArea = parseInt(this.toDotSeparator(model['Point active area size'])) || 10;&#13;
        plot.pointRadius = parseInt(this.toDotSeparator(model['Point radius'])) || 3;&#13;
        plot.pointOutlineRadius = parseInt(this.toDotSeparator(model['Point outline radius'])) || 7;&#13;
&#13;
        for (p in model['Expressions']) {&#13;
            if(model['Expressions'][p]['expression'] != '') {&#13;
                el = {&#13;
                    id: model['Expressions'][p]['id'] === undefined || model['Expressions'][p]['id'] == '' ? p : model['Expressions'][p]['id'],&#13;
                    expression: this.toDotSeparator(model['Expressions'][p]['expression']),&#13;
                    selectable: model['Expressions'][p]['selectable'].toLowerCase() === 'true' ? true : false,&#13;
                    selected: false,&#13;
                    correctAnswer: model['Expressions'][p]['correct'].toLowerCase() === 'true' ? true : false,&#13;
                    xMin: model['Expressions'][p]['xMin'] === undefined || (model['Expressions'][p]['xMin'] == '' &amp;&amp; model['Expressions'][p]['xMin'] != '0') ? false : this.toDotSeparator(model['Expressions'][p]['xMin']),&#13;
                    xMax: model['Expressions'][p]['xMax'] === undefined || (model['Expressions'][p]['xMax'] == '' &amp;&amp; model['Expressions'][p]['xMax'] != '0') ? false : this.toDotSeparator(model['Expressions'][p]['xMax']),&#13;
                    yMin: model['Expressions'][p]['yMin'] === undefined || (model['Expressions'][p]['yMin'] == '' &amp;&amp; model['Expressions'][p]['yMin'] != '0') ? false : this.toDotSeparator(model['Expressions'][p]['yMin']),&#13;
                    yMax: model['Expressions'][p]['yMax'] === undefined || (model['Expressions'][p]['yMax'] == '' &amp;&amp; model['Expressions'][p]['yMax'] != '0') ? false : this.toDotSeparator(model['Expressions'][p]['yMax']),&#13;
                    variables: {},&#13;
                    initVisible: model['Expressions'][p]['hidden'] !== undefined &amp;&amp; model['Expressions'][p]['hidden'] != '' &amp;&amp; model['Expressions'][p]['hidden'].toLowerCase() === 'true' ? false : true,&#13;
                    type: model['Expressions'][p]['y to x'] === undefined || model['Expressions'][p]['y to x'] == '' || model['Expressions'][p]['y to x'].toLowerCase() === 'false' ? plot.TYPE_X_TO_Y : plot.TYPE_Y_TO_X,&#13;
                    touched: false,&#13;
                    cssColorInitialValue: model['Expressions'][p]['color'] === undefined || model['Expressions'][p]['color'] == '' ? '' : model['Expressions'][p]['color'],&#13;
                    cssProperties: {}&#13;
                };&#13;
                el.cssColor = el.cssColorInitialValue;&#13;
                el.visible = el.initVisible;&#13;
                plot.expressions.push(el);&#13;
            }&#13;
        }&#13;
        for(v in model['Variables']) {&#13;
            var plotId = model['Variables'][v]['plot id'];&#13;
            var variable = model['Variables'][v]['variable'];&#13;
            var variableValue = this.toDotSeparator(model['Variables'][v]['value']);&#13;
            var expectedValue = model['Variables'][v]['expected'] === undefined || (model['Variables'][v]['expected'] == '' &amp;&amp; model['Variables'][v]['expected'] != '0') ? null : this.toDotSeparator(model['Variables'][v]['expected']);&#13;
&#13;
            if(plotId != '' &amp;&amp; variable != '') {&#13;
                for (var ex in plot.expressions) {&#13;
                    if(plot.expressions[ex].id == plotId) {&#13;
                        var iv = variableValue != '' ? parseFloat(variableValue) : 0;&#13;
                        el = {&#13;
                            initialValue: this.valueToFloat(variableValue),&#13;
                            value: this.valueToFloat(variableValue),&#13;
                            isExercise: expectedValue ? true : false,&#13;
                            expectedValue: parseFloat(expectedValue),&#13;
                            touched: false&#13;
                        };&#13;
                        plot.expressions[ex].variables[variable] = el;&#13;
                    }&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        plot.points = new Array();&#13;
        for (p in model['Points']) {&#13;
            if((model['Points'][p]['x value'] == '0' || model['Points'][p]['y value'] == '0') || (model['Points'][p]['x value'] != '' &amp;&amp; model['Points'][p]['y value'] != '')) {&#13;
                var point = {&#13;
                    x: this.toDotSeparator(model['Points'][p]['x value']),&#13;
                    y: this.toDotSeparator(model['Points'][p]['y value']),&#13;
                    initiallySelected: model['Points'][p]['selected'] === undefined || model['Points'][p]['selected'].toLowerCase() === 'false' ? false : true,&#13;
                    correct: model['Points'][p]['correct'] === undefined || model['Points'][p]['correct'].toLowerCase() === 'true' ? true : false,&#13;
                    touched: false,&#13;
                    notScored: model['Points'][p]['not scored'] === undefined || model['Points'][p]['not scored'].toLowerCase() === 'false' || model['Points'][p]['not scored'] == '' ? false : true,&#13;
                    clickable: true&#13;
                }&#13;
                //if we don't want that point in score make it non-clickable&#13;
                if(point.notScored) {&#13;
                    point.clickable = false;&#13;
                }&#13;
                plot.points.push(point);&#13;
                if(point.initiallySelected) {&#13;
                    plot.selectedPoints.push({&#13;
                        x: point.x,&#13;
                        y: point.y,&#13;
                        clickable: point.clickable&#13;
                    });&#13;
                }&#13;
            }&#13;
        }&#13;
        plot.maxSelectedPoints = model['Max selected points'] === undefined || model['Max selected points'] == '' || model['Max selected points'] == 0 ? 0 : parseInt(model['Max selected points']);&#13;
        presenter.isActivity = model['Not activity'] !== undefined &amp;&amp; model['Not activity'] != '' &amp;&amp; model['Not activity'].toLowerCase() === 'true' ? false : true;&#13;
        plot.isActivity = presenter.isActivity;&#13;
        plot.freePoints = model['Free points'] !== undefined &amp;&amp; model['Free points'] != '' &amp;&amp; model['Free points'].toLowerCase() === 'true' ? true : false;&#13;
&#13;
        presenter.broadcast = [];&#13;
        if(model['Broadcast'] !== '' &amp;&amp; model['Broadcast'] !== undefined) {&#13;
            var broadcasts = model['Broadcast'].split(',');&#13;
            $.each(broadcasts, function(idx, val) {&#13;
                presenter.broadcast.push(val.trim());&#13;
            });&#13;
        }&#13;
        plot.stateChanged = presenter.stateChanged;&#13;
        plot.convertValueToDisplay = presenter.convertValueToDisplay;&#13;
        plot.calculatePrecision();&#13;
&#13;
        var canvas = $(view).find('.canvas:first');&#13;
        canvas.click(function(e) {&#13;
            e.stopPropagation();&#13;
        });&#13;
&#13;
        canvas.svg({&#13;
            onLoad: presenter.onSvgCreate,&#13;
            settings: {&#13;
                width: '100%',&#13;
                height: '100%',&#13;
                preserveAspectRatio: "none"&#13;
            }&#13;
        });&#13;
&#13;
        if(plot.xAxisValuesPosition != '' &amp;&amp; !isNaN(plot.xAxisValuesPosition)){&#13;
            plot.setXAxisValuesPosition(plot.xAxisValuesPosition);&#13;
        }&#13;
&#13;
        if(plot.yAxisValuesPosition != '' &amp;&amp; !isNaN(plot.yAxisValuesPosition)){&#13;
            plot.setYAxisValuesPosition(plot.yAxisValuesPosition);&#13;
        }&#13;
    };&#13;
    presenter.toDotSeparator = function(value) {&#13;
        return (value + '').replace(this.decimalSeparator, '.');&#13;
    };&#13;
    presenter.getSeparatorByDecimalSeparator = function() {&#13;
        return this.decimalSeparator == '.' ? ',' : ';';&#13;
    };&#13;
    presenter.convertValueToDisplay = function(value) {&#13;
        //set correct decimal separator&#13;
        value = presenter.replaceDecimalSeparator(value);&#13;
        //change minus to en dash&#13;
        value = value.replace(new RegExp('\-', 'g'), '\u2013');&#13;
        return value;&#13;
    };&#13;
    presenter.replaceDecimalSeparator = function(value) {&#13;
        return (value + '').replace(new RegExp('\\.', 'g'), presenter.decimalSeparator);&#13;
    };&#13;
    presenter.getDecimalSeparator = function() {&#13;
        return presenter.decimalSeparator;&#13;
    };&#13;
    presenter.valueToFloat = function(val) {&#13;
        if(val === '' || val === undefined || !this.isCorrectDecimal(val)) {&#13;
            return Number.NaN;&#13;
        }&#13;
         val = this.toDotSeparator(val);&#13;
         return parseFloat(val);&#13;
    };&#13;
    presenter._hasIllegalCharacters = function(word) {&#13;
        var tmpWord;&#13;
        if(this.decimalSeparator == ',') {&#13;
            //use ';' for ',' seprator&#13;
            tmpWord = word.replace(/[^\*0-9;,-]/g, '');&#13;
        } else {&#13;
            //use ',' for '.' separator&#13;
            tmpWord = word.replace(/[^\*0-9,.-]/g, '');&#13;
        }&#13;
        return tmpWord != word;&#13;
    };&#13;
    presenter.isCorrectDecimal = function(nmb) {&#13;
        if (nmb === null ||&#13;
                ModelValidationUtils.isStringEmpty(nmb) ||&#13;
                (this.getDecimalSeparator() === ',' &amp;&amp; nmb.toString().indexOf('.') !== -1) ||&#13;
                (this.getDecimalSeparator() === '.' &amp;&amp; nmb.toString().indexOf(',') !== -1)) {&#13;
            return false;&#13;
        }&#13;
&#13;
        return true;&#13;
    };&#13;
    presenter.createPreview = function(view, model) {&#13;
        presenter.errorsMode = false;&#13;
        presenter.view = view;&#13;
        presenter.model = model;&#13;
        presenter.initialize(presenter.view, presenter.model, false);&#13;
    };&#13;
&#13;
    presenter.onSvgCreate = function(svg) {&#13;
        plot.svg = svg;&#13;
        plot.svgDoc = $(plot.svg._svg);&#13;
        var plotScale = plot.svg.group({&#13;
            class_:'scale',&#13;
            transform:''&#13;
        });&#13;
        var plotTranslate = plot.svg.group(plotScale, {&#13;
            class_:'translate',&#13;
            transform:''&#13;
        });&#13;
        var plotOverall = plot.svg.group(plotTranslate, {&#13;
            class_:'overall'&#13;
        });&#13;
        plot.svg.group(plotOverall, {&#13;
            class_:'grid'&#13;
        });&#13;
        plot.svg.group(plotOverall, {&#13;
            class_:'axis'&#13;
        });&#13;
        plot.svg.group(plotOverall, {&#13;
            class_:'drawings'&#13;
        });&#13;
        plot.svg.group(plotOverall, {&#13;
            class_:'points'&#13;
        });&#13;
        plot.svg.group(plotOverall, {&#13;
            class_:'drawingsAreas'&#13;
        });&#13;
        plot.svg.group(plotOverall, {&#13;
            class_:'pointsAreas'&#13;
        });&#13;
        plot.setScale();&#13;
        plot.setStep();&#13;
        plot.translate();&#13;
        plot.draw();&#13;
        if(!presenter.isVisible) {&#13;
            presenter.hide();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        switch(name.toLowerCase()) {&#13;
            case 'zoomIn'.toLowerCase():&#13;
                plot.zoom(1);&#13;
                break;&#13;
            case 'zoomOut'.toLowerCase():&#13;
                plot.zoom(-1);&#13;
                break;&#13;
            case 'moveLeft'.toLowerCase():&#13;
                plot.move(parseInt(this.toDotSeparator(params)),0);&#13;
                break;&#13;
            case 'moveRight'.toLowerCase():&#13;
                plot.move(parseInt(this.toDotSeparator(params))*(-1),0);&#13;
                break;&#13;
            case 'moveDown'.toLowerCase():&#13;
                plot.move(0, parseInt(this.toDotSeparator(params)));&#13;
                break;&#13;
            case 'moveUp'.toLowerCase():&#13;
                plot.move(0, parseInt(this.toDotSeparator(params))*(-1));&#13;
                break;&#13;
            case 'getState'.toLowerCase():&#13;
                return this.getState();&#13;
                break;&#13;
            case 'setState'.toLowerCase():&#13;
                this.setState(params);&#13;
                break;&#13;
            case 'setVariable'.toLowerCase():&#13;
                plot.setVariable(params[0], params[1], presenter.valueToFloat(params[2]));&#13;
                break;&#13;
            case 'setVisible'.toLowerCase():&#13;
                plot.setVisible(params[0], parseInt(params[1]) == 1 ? true : false);&#13;
                break;&#13;
            case 'setPointVisibility'.toLowerCase():&#13;
                plot.setPointVisibility(this.toDotSeparator(params[0]), this.toDotSeparator(params[1]), parseInt(params[2]) == 1 ? true : false);&#13;
                break;&#13;
            case 'setPlotStyle'.toLowerCase():&#13;
                plot.setPlotStyle(params[0], params[1], params[2], params[3]);&#13;
                break;&#13;
            case 'hide'.toLowerCase():&#13;
                presenter.hide();&#13;
                break;&#13;
            case 'show'.toLowerCase():&#13;
                presenter.show();&#13;
                break;&#13;
            case 'restoreView'.toLowerCase():&#13;
                plot.restoreInitialViewPort();&#13;
                break;&#13;
            case 'isAttempted'.toLowerCase():&#13;
                return presenter.isAttempted();&#13;
                break;&#13;
            case 'setAttempted'.toLocaleLowerCase():&#13;
                presenter.setAttempted(params);&#13;
                break;&#13;
            case 'isAllOK'.toLocaleLowerCase():&#13;
                return presenter.isAllOK();&#13;
        }&#13;
        if(presenter.errorsMode) {&#13;
            presenter.setShowErrorsMode();&#13;
        }&#13;
    };&#13;
    presenter.enableUI = function(state) {&#13;
        plot.enableUI(state);&#13;
    };&#13;
    presenter.hide = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.isVisible = false;&#13;
        presenter.setVisibility(false);&#13;
    };&#13;
    presenter.show = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        presenter.isVisible = true;&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        $(presenter.view).css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
    presenter.getState = function() {&#13;
        var plotState = [];&#13;
        var variableState = [];&#13;
        var pointsState = [];&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        $.each(plot.expressions, function(idx, val) {&#13;
            plotState[idx] = {&#13;
                selected: val.selected,&#13;
                touched: val.touched,&#13;
                visible: val.visible&#13;
            }&#13;
            //old state&#13;
            //plotState[p] = val.selected;&#13;
&#13;
            $.each(val.variables, function(vidx, variableObj) {&#13;
                variableState.push({&#13;
                    plotId: val.id,&#13;
                    variable: vidx,&#13;
                    value: variableObj.value,&#13;
                    touched: variableObj.touched&#13;
                });&#13;
            });&#13;
        })&#13;
&#13;
        $.each(plot.points, function(idx, val) {&#13;
            pointsState[idx] = {&#13;
                touched: val.touched&#13;
            }&#13;
        });&#13;
&#13;
        var state = JSON.stringify({&#13;
            version: 2,&#13;
            plots: plotState,&#13;
            variables: variableState,&#13;
            selectedPoints: plot.selectedPoints,&#13;
            points: pointsState,&#13;
            isVisible: presenter.isVisible,&#13;
            isAttempted: presenter.isAttempted()&#13;
        });&#13;
        return state;&#13;
    }&#13;
&#13;
    presenter.setState = function(state) {&#13;
        if(state != '' &amp;&amp; state !== undefined) {&#13;
            state = JSON.parse(state);&#13;
            //old state&#13;
            if(state.version == undefined) {&#13;
                if(state.plots.length &gt; 0) {&#13;
                    $.each(state.plots, function(idx, val) {&#13;
                        plot.expressions[idx].touched = true;&#13;
                        plot.expressions[idx].selected = val;&#13;
&#13;
                    });&#13;
                    plot.selectedPoints = state.points;&#13;
                }&#13;
            } else {&#13;
                if(state.plots.length &gt; 0) {&#13;
                    $.each(state.plots, function(idx, val) {&#13;
                        plot.expressions[idx].selected = val.selected;&#13;
                        plot.expressions[idx].touched = val.touched;&#13;
                        plot.expressions[idx].visible = val.visible != undefined ? val.visible : true;&#13;
                    });&#13;
                }&#13;
                //restore variables&#13;
                if(state.variables.length &gt; 0) {&#13;
                    $.each(state.variables, function(sidx, sval) {&#13;
                        $.each(plot.expressions, function(pidx, pval) {&#13;
                            if(sval.plotId == pval.id) {&#13;
                                pval.variables[sval.variable].value = presenter.valueToFloat(sval.value);&#13;
                                pval.variables[sval.variable].touched = sval.touched;&#13;
                            }&#13;
                        });&#13;
                    });&#13;
                }&#13;
                $.each(state.points, function(idx, val) {&#13;
                    plot.points[idx].touched = val.touched&#13;
                })&#13;
                plot.selectedPoints = [];&#13;
                $.each(state.selectedPoints, function(k, v) {&#13;
                    plot.selectedPoints.push(&#13;
                        {&#13;
                            x: v.x,&#13;
                            y: v.y,&#13;
                            clickable: v.clickable != undefined ? v.clickable : true&#13;
                        }&#13;
                    )&#13;
                });&#13;
                if(state.isVisible === false) {&#13;
                    presenter.hide();&#13;
                } else {&#13;
                    presenter.show();&#13;
                }&#13;
                if(state.isAttempted === undefined) {&#13;
                    state.isAttempted = true;&#13;
                }&#13;
                presenter.setAttempted(state.isAttempted);&#13;
            }&#13;
&#13;
            plot.draw();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.isAllOK = function () {&#13;
        return presenter.getMaxScore() === presenter.getScore() &amp;&amp; presenter.getErrorCount() === 0;&#13;
    };&#13;
&#13;
    presenter.stateChanged = function(data) {&#13;
        var receiver;&#13;
        if(data) {&#13;
            //chained events when data is array&#13;
            if(!(data instanceof Array)) {&#13;
                //become chain with single event&#13;
                data = [data];&#13;
            }&#13;
&#13;
            //call chained events&#13;
            for(var t=0;t&lt;data.length;t++) {&#13;
                data[t].source = addonID;&#13;
                data[t].item = data[t].item.toString();&#13;
                if(data[t].item.substring(0,6) == 'point_') {&#13;
                    data[t].item = presenter.replaceDecimalSeparator(data[t].item);&#13;
                }&#13;
                data[t].value = data[t].value.toString();&#13;
                data[t].score = data[t].score === null ? null : data[t].score.toString();&#13;
                //broadcast events or send event to bus&#13;
                if(presenter.broadcast.length &gt; 0) {&#13;
                    $.each(presenter.broadcast, function(idx, broadcastTo) {&#13;
                        receiver = presenter.playerController.getModule(broadcastTo);&#13;
                        if(receiver) {&#13;
                            receiver.onEvent('ValueChanged', data[t]);&#13;
                        }&#13;
                    });&#13;
                } else {&#13;
                    presenter.eventBus.sendEvent('ValueChanged', data[t]);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        if(presenter.broadcast.length === 0) {&#13;
            if(presenter.isActivity &amp;&amp; presenter.isAllOK()) {&#13;
                if(!presenter._allDoneState) {&#13;
                    presenter._allDoneState = true;&#13;
                    sendAllOKEvent();&#13;
                }&#13;
            } else {&#13;
                presenter._allDoneState = false;&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    function sendAllOKEvent () {&#13;
        var eventData = {&#13;
            'source': addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    }&#13;
&#13;
    presenter.isAttempted = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
        return !this.isActivity ? true : this.getPlot().isAttempted();&#13;
    }&#13;
&#13;
    presenter.setAttempted = function (state) {&#13;
        this.getPlot().setAttempted(state);&#13;
    }&#13;
&#13;
    presenter.getPlot = function() {&#13;
        return plot;&#13;
    }&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>