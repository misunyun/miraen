<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="eKeyboard" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
        <property displayName="Work With" name="workWith" nameLabel="eKeyboard_property_work_with" type="text"/>
        <property displayName="Works With All" name="worksWithAll" nameLabel="eKeyboard_property_works_with_all" type="boolean"/>
        <property displayName="Layout Type" name="layoutType" nameLabel="eKeyboard_property_layout_type" type="{Numeric, French (Special Characters), German (Special Characters), Italian (Special Characters), Spanish (Special Characters), Custom}"/>
        <property displayName="Custom Layout" isLocalized="true" name="customLayout" nameLabel="eKeyboard_property_custom_layout" type="text"/>
        <property displayName="Position My" name="positionMy" nameLabel="eKeyboard_property_position_my" type="string"/>
        <property displayName="Position At" name="positionAt" nameLabel="eKeyboard_property_position_at" type="string"/>
        <property displayName="Max Characters" name="maxCharacters" nameLabel="eKeyboard_property_max_characters" type="string"/>
        <property displayName="Don't Open On Focus" name="noOpenOnFocus" nameLabel="eKeyboard_property_no_open_on_focus" type="boolean"/>
        <property displayName="Lock Standard Keyboard Input" name="lockStandardKeyboardInput" nameLabel="eKeyboard_property_lock_standard_keyboard_input" type="boolean"/>
        <property displayName="Custom Display" isLocalized="true" name="customDisplay" nameLabel="eKeyboard_property_custom_display" type="text"/>
        <property displayName="Show Close Button" name="showCloseButton" nameLabel="eKeyboard_property_show_close_button" type="boolean"/>
	</model>
<css>/* keyboard - jQuery UI Widget */&#13;
.ui-keyboard { padding: .3em; position: absolute; left: 0; top: 0; z-index: 16000; }&#13;
.ui-keyboard-has-focus { z-index: 16001; }&#13;
.ui-keyboard div { font-size: 1.1em; }&#13;
.ui-keyboard-button { height: 2em; width: 2em; min-width: 1em; margin: .1em; cursor: pointer; overflow: hidden; line-height: 2em; -moz-user-focus: ignore; }&#13;
.ui-keyboard-button span { padding: 0; margin: 0; white-space:nowrap; display: inline-block; }&#13;
.ui-keyboard-button-endrow { clear: left; }&#13;
.ui-keyboard-widekey { min-width: 4em; width: auto; }&#13;
.ui-keyboard-space { width: 15em; }&#13;
.ui-keyboard-space span, .ui-keyboard-empty span { font: 0/0 a; text-shadow: none; color: transparent; } /* see http://nicolasgallagher.com/another-css-image-replacement-technique/ */&#13;
.ui-keyboard-preview-wrapper { text-align: center; }&#13;
.ui-keyboard-preview { text-align: left; margin: 0 0 3px 0; display: inline; width: 99%;} /* width is calculated in IE, since 99% = 99% full browser width =( */&#13;
.ui-keyboard-keyset { text-align: center; white-space: nowrap; }&#13;
.ui-keyboard-input { text-align: left; }&#13;
.ui-keyboard-input-current { }&#13;
.ui-keyboard-placeholder { color: #888; }&#13;
.ui-keyboard-nokeyboard { color: #888; border-color: #888; } /* disabled or readonly inputs, or use input[disabled='disabled'] { color: #f00; } */&#13;
.ui-keyboard-button.disabled { opacity: 0.5; filter: alpha(opacity=50); } /* used by the acceptValid option to make the accept button appear faded */&#13;
.ui-keyboard-spacer { display: inline-block; width: 1px; height: 0; }&#13;
&#13;
/* combo key styling - toggles diacritics on/off */&#13;
.ui-keyboard-button.ui-keyboard-combo.ui-state-default { border-color: #ffaf0f; }&#13;
&#13;
/* (in)valid inputs */&#13;
button.ui-keyboard-accept.ui-keyboard-valid-input { border-color: #0c0; background: #080; color: #fff; }&#13;
button.ui-keyboard-accept.ui-keyboard-valid-input:hover { background: #0a0; }&#13;
button.ui-keyboard-accept.ui-keyboard-invalid-input { border-color: #c00; background: #800; color: #fff; }&#13;
button.ui-keyboard-accept.ui-keyboard-invalid-input:hover { background: #a00; }&#13;
&#13;
/*** jQuery Mobile definitions ***/&#13;
/* jQuery Mobile styles - need wider buttons because of font size and text-overflow:ellipsis */&#13;
.ui-bar .ui-keyboard-button { width: 3em; display: inline-block; }&#13;
.ui-bar .ui-keyboard-widekey { width: 5.5em; }&#13;
.ui-bar .ui-keyboard-space { width: 15em; }&#13;
.ui-bar .ui-keyboard-space span { visibility: hidden; } /* hides the ellipsis */&#13;
.ui-bar .ui-keyboard-keyset { line-height: 0.5em; }&#13;
.ui-bar input.ui-input-text, .ui-bar textarea.ui-input-text { width: 95%; }&#13;
&#13;
/* over-ride padding set by mobile ui theme - needed because the mobile script wraps button text with several more spans */&#13;
.ui-bar .ui-btn-inner { height: 2em; padding: 0.2em 0; margin: 0; }&#13;
.ui-bar .ui-btn { margin: 0; font-size: 13px; } /* mobile default size is 13px */&#13;
&#13;
/* Media Queries (optimized for jQuery UI themes; may be slightly off in jQuery Mobile themes) */&#13;
/* 240 x 320 (small phone)  */&#13;
@media all and (max-width: 319px) {&#13;
    .ui-keyboard div { font-size: 9px; }&#13;
    .ui-keyboard .ui-keyboard-input { font-size: 12px; }&#13;
    /* I don't own an iPhone so I have no idea how small this really is... is it even clickable with your finger? */&#13;
    .ui-bar .ui-btn { margin: 0; font-size: 9px; }&#13;
    .ui-bar .ui-keyboard-button { width: 1.8em; height: 2.5em; }&#13;
    .ui-bar .ui-keyboard-widekey { width: 4em; }&#13;
    .ui-bar .ui-keyboard-space { width: 8em; }&#13;
    .ui-bar .ui-btn-inner { height: 2.5em; padding: 0.3em 0; }&#13;
}&#13;
&#13;
/* 320 x 480 (iPhone)  */&#13;
@media all and (min-width: 320px) and (max-width: 479px) {&#13;
    .ui-keyboard div { font-size: 9px; }&#13;
    .ui-keyboard .ui-keyboard-input { font-size: 14px; }&#13;
    /* I don't own an iPhone so I have no idea how small this really is... is it even clickable with your finger? */&#13;
    .ui-bar .ui-btn { margin: 0; font-size: 11px; }&#13;
    .ui-bar .ui-keyboard-button { width: 1.8em; height: 3em; }&#13;
    .ui-bar .ui-keyboard-widekey { width: 4.5em; }&#13;
    .ui-bar .ui-keyboard-space { width: 10em; }&#13;
    .ui-bar .ui-btn-inner { height: 3em; padding: 0.7em 0; }&#13;
}&#13;
&#13;
/* 480 x 640 (small tablet) */&#13;
@media all and (min-width: 480px) and (max-width: 767px) {&#13;
    .ui-keyboard div { font-size: 13px; }&#13;
    .ui-keyboard .ui-keyboard-input { font-size: 14px; }&#13;
    .ui-bar .ui-btn { margin: 0; font-size: 10px; }&#13;
    .ui-bar .ui-keyboard-button { height: 2.5em; }&#13;
    .ui-bar .ui-btn-inner { height: 2.5em; padding: 0.5em 0; }&#13;
}&#13;
&#13;
.eKeyboard-close-button {&#13;
	border: 1px solid #cccccc;&#13;
  	background: #f6f6f6;&#13;
  	color: red;&#13;
    top: 0;&#13;
    left: 101%;&#13;
}&#13;
&#13;
.eKeyboard-open-button {&#13;
  	width: 33px;&#13;
  	height: 33px;&#13;
    background-color: transparent;&#13;
    border: 0px;&#13;
    background-position: center;&#13;
    background-image: url("resources/eKeyboard.png");&#13;
    background-repeat: no-repeat;&#13;
    background-size: 32px 32px;&#13;
}&#13;
&#13;
&#13;
</css><view>&lt;div class="eKeyboard-wrapper"&gt;&#13;
    &lt;div class="eKeyboard-container"&gt;&#13;
&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="eKeyboard-wrapper"&gt;&#13;
    &lt;div class="eKeyboard-container"&gt;&#13;
&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddoneKeyboard_create(){&#13;
&#13;
    (function(){&#13;
        console.log("한글 조합");&#13;
        'use strict';&#13;
        var CHO = [&#13;
                'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ',&#13;
                'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ',&#13;
                'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ',&#13;
                'ㅍ', 'ㅎ'&#13;
            ],&#13;
            JUNG = [&#13;
                'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ',&#13;
                'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', ['ㅗ', 'ㅏ'], ['ㅗ', 'ㅐ'],&#13;
                ['ㅗ', 'ㅣ'], 'ㅛ', 'ㅜ', ['ㅜ','ㅓ'], ['ㅜ','ㅔ'], ['ㅜ','ㅣ'],&#13;
                'ㅠ', 'ㅡ', ['ㅡ', 'ㅣ'], 'ㅣ'&#13;
            ],&#13;
            JONG = [&#13;
                '', 'ㄱ', 'ㄲ', ['ㄱ','ㅅ'], 'ㄴ', ['ㄴ','ㅈ'], ['ㄴ', 'ㅎ'], 'ㄷ', 'ㄹ',&#13;
                ['ㄹ', 'ㄱ'], ['ㄹ','ㅁ'], ['ㄹ','ㅂ'], ['ㄹ','ㅅ'], ['ㄹ','ㅌ'], ['ㄹ','ㅍ'], ['ㄹ','ㅎ'], 'ㅁ',&#13;
                'ㅂ', ['ㅂ','ㅅ'], 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'&#13;
            ],&#13;
            HANGUL_OFFSET = 0xAC00,&#13;
            CONSONANTS = [&#13;
                'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄸ',&#13;
                'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ',&#13;
                'ㅁ', 'ㅂ', 'ㅃ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ',&#13;
                'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'&#13;
            ],&#13;
            COMPLETE_CHO = [&#13;
                'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ',&#13;
                'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ',&#13;
                'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'&#13;
            ],&#13;
            COMPLETE_JUNG = [&#13;
                'ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ',&#13;
                'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ',&#13;
                'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ',&#13;
                'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'&#13;
            ],&#13;
            COMPLETE_JONG = [&#13;
                '', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ',&#13;
                'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ',&#13;
                'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'&#13;
            ],&#13;
            COMPLEX_CONSONANTS = [&#13;
                ['ㄱ','ㅅ','ㄳ'],&#13;
                ['ㄴ','ㅈ','ㄵ'],&#13;
                ['ㄴ','ㅎ','ㄶ'],&#13;
                ['ㄹ','ㄱ','ㄺ'],&#13;
                ['ㄹ','ㅁ','ㄻ'],&#13;
                ['ㄹ','ㅂ','ㄼ'],&#13;
                ['ㄹ','ㅅ','ㄽ'],&#13;
                ['ㄹ','ㅌ','ㄾ'],&#13;
                ['ㄹ','ㅍ','ㄿ'],&#13;
                ['ㄹ','ㅎ','ㅀ'],&#13;
                ['ㅂ','ㅅ','ㅄ']&#13;
            ],&#13;
            COMPLEX_VOWELS = [&#13;
                ['ㅗ','ㅏ','ㅘ'],&#13;
                ['ㅗ','ㅐ','ㅙ'],&#13;
                ['ㅗ','ㅣ','ㅚ'],&#13;
                ['ㅜ','ㅓ','ㅝ'],&#13;
                ['ㅜ','ㅔ','ㅞ'],&#13;
                ['ㅜ','ㅣ','ㅟ'],&#13;
                ['ㅡ','ㅣ','ㅢ']&#13;
            ],&#13;
            CONSONANTS_HASH,&#13;
            CHO_HASH,&#13;
            JUNG_HASH,&#13;
            JONG_HASH,&#13;
            COMPLEX_CONSONANTS_HASH,&#13;
            COMPLEX_VOWELS_HASH;&#13;
&#13;
        function _makeHash(array){&#13;
            var length = array.length,&#13;
                hash = {0 : 0};&#13;
&#13;
            for (var i = 0; i&lt;length; i++) {&#13;
                if(array[i]){&#13;
                    hash[array[i].charCodeAt(0)] = i;&#13;
                }&#13;
&#13;
            }&#13;
            return hash;&#13;
        }&#13;
&#13;
        CONSONANTS_HASH = _makeHash(CONSONANTS);&#13;
        CHO_HASH = _makeHash(COMPLETE_CHO);&#13;
        JUNG_HASH = _makeHash(COMPLETE_JUNG);&#13;
        JONG_HASH = _makeHash(COMPLETE_JONG);&#13;
&#13;
        function _makeComplexHash(array){&#13;
            var length = array.length,&#13;
                hash = {},&#13;
                code1,&#13;
                code2&#13;
            ;&#13;
            for (var i = 0; i &lt; length; i++) {&#13;
            code1 = array[i][0].charCodeAt(0);&#13;
            code2 = array[i][1].charCodeAt(0);&#13;
            if (typeof hash[code1] === 'undefined') {&#13;
                hash[code1] = {};&#13;
            }&#13;
            hash[code1][code2] = array[i][2].charCodeAt(0);&#13;
            }&#13;
            return hash;&#13;
        }&#13;
&#13;
        COMPLEX_CONSONANTS_HASH = _makeComplexHash(COMPLEX_CONSONANTS);&#13;
        COMPLEX_VOWELS_HASH = _makeComplexHash(COMPLEX_VOWELS);&#13;
&#13;
        function _isConsonant(c) {&#13;
            return typeof CONSONANTS_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isCho(c){&#13;
            return typeof CHO_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isJung(c){&#13;
            return typeof JUNG_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isJong(c){&#13;
            return typeof JONG_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isHangul(c /* code number */){&#13;
            return 0xAC00 &lt;= c &amp;&amp; c &lt;= 0xd7a3;&#13;
        }&#13;
&#13;
        function _isJungJoinable(a,b){&#13;
            return (COMPLEX_VOWELS_HASH[a] &amp;&amp; COMPLEX_VOWELS_HASH[a][b]) ? COMPLEX_VOWELS_HASH[a][b] : false;&#13;
        }&#13;
&#13;
        function _isJongJoinable(a,b){&#13;
            return COMPLEX_CONSONANTS_HASH[a] &amp;&amp; COMPLEX_CONSONANTS_HASH[a][b] ? COMPLEX_CONSONANTS_HASH[a][b] : false;&#13;
        }&#13;
&#13;
        var disassemble = function(string, grouped){&#13;
            if (string === null) {&#13;
            throw new Error('Arguments cannot be null');&#13;
            }&#13;
&#13;
            if (typeof string === 'object') {&#13;
            string = string.join('');&#13;
            }&#13;
&#13;
            var result = [],&#13;
                length = string.length,&#13;
                cho,&#13;
                jung,&#13;
                jong,&#13;
                code,&#13;
                r&#13;
            ;&#13;
&#13;
            for (var i = 0; i &lt; length; i++) {&#13;
            var temp = [];&#13;
&#13;
            code = string.charCodeAt(i);&#13;
            if (_isHangul(code)) { // 완성된 한글이면&#13;
                code -= HANGUL_OFFSET;&#13;
                jong = code % 28;&#13;
                jung = (code - jong) / 28 % 21;&#13;
                cho = parseInt((code - jong) / 28 / 21);&#13;
                temp.push(CHO[cho]);&#13;
                if (typeof JUNG[jung] === 'object') {&#13;
                temp = temp.concat(JUNG[jung]);&#13;
                } else {&#13;
                temp.push(JUNG[jung]);&#13;
                }&#13;
                if (jong &gt; 0) {&#13;
                if(typeof JONG[jong] === 'object') {&#13;
                    temp = temp.concat(JONG[jong]);&#13;
                } else {&#13;
                    temp.push(JONG[jong]);&#13;
                }&#13;
                }&#13;
            } else if (_isConsonant(code)) { //자음이면&#13;
                if (_isCho(code)) {&#13;
                r = CHO[CHO_HASH[code]];&#13;
                } else {&#13;
                r = JONG[JONG_HASH[code]];&#13;
                }&#13;
                if (typeof r === 'string') {&#13;
                temp.push(r);&#13;
                } else {&#13;
                temp = temp.concat(r);&#13;
                }&#13;
            } else if (_isJung(code)) {&#13;
                r = JUNG[JUNG_HASH[code]];&#13;
                if (typeof r === 'string') {&#13;
                temp.push(r);&#13;
                } else {&#13;
                temp = temp.concat(r);&#13;
                }&#13;
            } else {&#13;
                temp.push(string.charAt(i));&#13;
            }&#13;
&#13;
            if(grouped) result.push(temp);&#13;
            else result = result.concat(temp);&#13;
            }&#13;
&#13;
            return result;&#13;
        };&#13;
&#13;
        var disassembleToString =  function(str) {&#13;
            if (typeof str !== 'string') {&#13;
            return '';&#13;
            }&#13;
            str = disassemble(str);&#13;
            return str.join('');&#13;
        };&#13;
&#13;
&#13;
        CONSONANTS_HASH = _makeHash(CONSONANTS);&#13;
        CHO_HASH = _makeHash(COMPLETE_CHO);&#13;
        JUNG_HASH = _makeHash(COMPLETE_JUNG);&#13;
        JONG_HASH = _makeHash(COMPLETE_JONG);&#13;
&#13;
        function _makeComplexHash(array){&#13;
            var length = array.length,&#13;
                hash = {},&#13;
                code1,&#13;
                code2&#13;
            ;&#13;
            for (var i = 0; i &lt; length; i++) {&#13;
            code1 = array[i][0].charCodeAt(0);&#13;
            code2 = array[i][1].charCodeAt(0);&#13;
            if (typeof hash[code1] === 'undefined') {&#13;
                hash[code1] = {};&#13;
            }&#13;
            hash[code1][code2] = array[i][2].charCodeAt(0);&#13;
            }&#13;
            return hash;&#13;
        }&#13;
&#13;
        COMPLEX_CONSONANTS_HASH = _makeComplexHash(COMPLEX_CONSONANTS);&#13;
        COMPLEX_VOWELS_HASH = _makeComplexHash(COMPLEX_VOWELS);&#13;
&#13;
        function _isConsonant(c) {&#13;
            return typeof CONSONANTS_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isCho(c){&#13;
            return typeof CHO_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isJung(c){&#13;
            return typeof JUNG_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isJong(c){&#13;
            return typeof JONG_HASH[c] !== 'undefined';&#13;
        }&#13;
&#13;
        function _isHangul(c /* code number */){&#13;
            return 0xAC00 &lt;= c &amp;&amp; c &lt;= 0xd7a3;&#13;
        }&#13;
&#13;
        function _isJungJoinable(a,b){&#13;
            return (COMPLEX_VOWELS_HASH[a] &amp;&amp; COMPLEX_VOWELS_HASH[a][b]) ? COMPLEX_VOWELS_HASH[a][b] : false;&#13;
        }&#13;
&#13;
        function _isJongJoinable(a,b){&#13;
            return COMPLEX_CONSONANTS_HASH[a] &amp;&amp; COMPLEX_CONSONANTS_HASH[a][b] ? COMPLEX_CONSONANTS_HASH[a][b] : false;&#13;
        }&#13;
&#13;
        var disassemble = function(string, grouped){&#13;
            if (string === null) {&#13;
            throw new Error('Arguments cannot be null');&#13;
            }&#13;
&#13;
            if (typeof string === 'object') {&#13;
            string = string.join('');&#13;
            }&#13;
&#13;
            var result = [],&#13;
                length = string.length,&#13;
                cho,&#13;
                jung,&#13;
                jong,&#13;
                code,&#13;
                r&#13;
            ;&#13;
&#13;
            for (var i = 0; i &lt; length; i++) {&#13;
            var temp = [];&#13;
&#13;
            code = string.charCodeAt(i);&#13;
            if (_isHangul(code)) { // 완성된 한글이면&#13;
                code -= HANGUL_OFFSET;&#13;
                jong = code % 28;&#13;
                jung = (code - jong) / 28 % 21;&#13;
                cho = parseInt((code - jong) / 28 / 21);&#13;
                temp.push(CHO[cho]);&#13;
                if (typeof JUNG[jung] === 'object') {&#13;
                temp = temp.concat(JUNG[jung]);&#13;
                } else {&#13;
                temp.push(JUNG[jung]);&#13;
                }&#13;
                if (jong &gt; 0) {&#13;
                if(typeof JONG[jong] === 'object') {&#13;
                    temp = temp.concat(JONG[jong]);&#13;
                } else {&#13;
                    temp.push(JONG[jong]);&#13;
                }&#13;
                }&#13;
            } else if (_isConsonant(code)) { //자음이면&#13;
                if (_isCho(code)) {&#13;
                r = CHO[CHO_HASH[code]];&#13;
                } else {&#13;
                r = JONG[JONG_HASH[code]];&#13;
                }&#13;
                if (typeof r === 'string') {&#13;
                temp.push(r);&#13;
                } else {&#13;
                temp = temp.concat(r);&#13;
                }&#13;
            } else if (_isJung(code)) {&#13;
                r = JUNG[JUNG_HASH[code]];&#13;
                if (typeof r === 'string') {&#13;
                temp.push(r);&#13;
                } else {&#13;
                temp = temp.concat(r);&#13;
                }&#13;
            } else {&#13;
                temp.push(string.charAt(i));&#13;
            }&#13;
&#13;
            if(grouped) result.push(temp);&#13;
            else result = result.concat(temp);&#13;
            }&#13;
&#13;
            return result;&#13;
        };&#13;
&#13;
        var disassembleToString =  function(str) {&#13;
            if (typeof str !== 'string') {&#13;
            return '';&#13;
            }&#13;
            str = disassemble(str);&#13;
            return str.join('');&#13;
        };&#13;
&#13;
        var assemble = function(array){&#13;
            if (typeof array === 'string') {&#13;
            array = disassemble(array);&#13;
            }&#13;
&#13;
            var result = [],&#13;
                length = array.length,&#13;
                code ,&#13;
                stage = 0,&#13;
                complete_index = -1, //완성된 곳의 인덱스&#13;
                previous_code&#13;
            ;&#13;
&#13;
            function _makeHangul(index){ // complete_index + 1부터 index까지를 greedy하게 한글로 만든다.&#13;
            var code,&#13;
                cho,&#13;
                jung1,&#13;
                jung2,&#13;
                jong1 = 0,&#13;
                jong2,&#13;
                hangul = ''&#13;
                ;&#13;
            if (complete_index + 1 &gt; index) {&#13;
                return;&#13;
            }&#13;
            for (var step = 1; ; step++) {&#13;
                if (step === 1) {&#13;
                cho = array[complete_index + step].charCodeAt(0);&#13;
                if (_isJung(cho)) { // 첫번째 것이 모음이면 1) ㅏ같은 경우이거나 2) ㅙ같은 경우이다&#13;
                    if (complete_index + step + 1 &lt;= index &amp;&amp; _isJung(jung1 = array[complete_index + step + 1].charCodeAt(0))) { //다음것이 있고 모음이면&#13;
                    result.push(String.fromCharCode(_isJungJoinable(cho, jung1)));&#13;
                    complete_index = index;&#13;
                    return;&#13;
                    } else {&#13;
                    result.push(array[complete_index + step]);&#13;
                    complete_index = index;&#13;
                    return;&#13;
                    }&#13;
                } else if (!_isCho(cho)) {&#13;
                    result.push(array[complete_index + step]);&#13;
                    complete_index = index;&#13;
                    return;&#13;
                }&#13;
                hangul = array[complete_index + step];&#13;
                } else if (step === 2) {&#13;
                jung1 = array[complete_index + step].charCodeAt(0);&#13;
                if (_isCho(jung1)) { //두번째 또 자음이 오면 ㄳ 에서 ㅅ같은 경우이다&#13;
                    cho = _isJongJoinable(cho, jung1);&#13;
                    hangul = String.fromCharCode(cho);&#13;
                    result.push(hangul);&#13;
                    complete_index = index;&#13;
                    return;&#13;
                } else {&#13;
                    hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + HANGUL_OFFSET);&#13;
                }&#13;
                } else if (step === 3) {&#13;
                jung2 = array[complete_index + step].charCodeAt(0);&#13;
                if (_isJungJoinable(jung1, jung2)) {&#13;
                    jung1 = _isJungJoinable(jung1, jung2);&#13;
                } else {&#13;
                    jong1 = jung2;&#13;
                }&#13;
                hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + JONG_HASH[jong1] + HANGUL_OFFSET);&#13;
                } else if (step === 4) {&#13;
                jong2 = array[complete_index + step].charCodeAt(0);&#13;
                if (_isJongJoinable(jong1, jong2)) {&#13;
                    jong1 = _isJongJoinable(jong1, jong2);&#13;
                } else {&#13;
                    jong1 = jong2;&#13;
                }&#13;
                hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + JONG_HASH[jong1] + HANGUL_OFFSET);&#13;
                } else if (step === 5) {&#13;
                jong2 = array[complete_index + step].charCodeAt(0);&#13;
                jong1 = _isJongJoinable(jong1, jong2);&#13;
                hangul = String.fromCharCode((CHO_HASH[cho] * 21 + JUNG_HASH[jung1]) * 28 + JONG_HASH[jong1] + HANGUL_OFFSET);&#13;
                }&#13;
&#13;
                if (complete_index + step &gt;= index) {&#13;
                result.push(hangul);&#13;
                complete_index = index;&#13;
                return;&#13;
                }&#13;
            }&#13;
            }&#13;
&#13;
            for (var i = 0 ; i &lt; length ; i++) {&#13;
            code = array[i].charCodeAt(0);&#13;
            if (!_isCho(code) &amp;&amp; !_isJung(code) &amp;&amp; !_isJong(code)){ //초, 중, 종성 다 아니면&#13;
                _makeHangul(i-1);&#13;
                _makeHangul(i);&#13;
                stage = 0;&#13;
                continue;&#13;
            }&#13;
            //console.log(stage, array[i]);&#13;
            if (stage === 0) { // 초성이 올 차례&#13;
                if (_isCho(code)) { // 초성이 오면 아무 문제 없다.&#13;
                stage = 1;&#13;
                } else if (_isJung(code)) {&#13;
                // 중성이오면 ㅐ 또는 ㅘ 인것이다. 바로 구분을 못한다. 따라서 특수한 stage인 stage4로 이동&#13;
                stage = 4;&#13;
                }&#13;
            } else if (stage == 1) { //중성이 올 차례&#13;
                if (_isJung(code)) { //중성이 오면 문제없음 진행.&#13;
                stage = 2;&#13;
                } else { //아니고 자음이오면 ㄻ같은 경우가 있고 ㄹㅋ같은 경우가 있다.&#13;
                //합쳐질 수 없다면 앞 글자 완성 후 여전히 중성이 올 차례&#13;
                    _makeHangul(i-1);&#13;
                }&#13;
&#13;
                /*if (_isJung(code)) { //중성이 오면 문제없음 진행.&#13;
                stage = 2;&#13;
                } else { //아니고 자음이오면 ㄻ같은 경우가 있고 ㄹㅋ같은 경우가 있다.&#13;
                if (_isJongJoinable(previous_code, code)) {&#13;
                    // 합쳐질 수 있다면 ㄻ 같은 경우인데 이 뒤에 모음이 와서 ㄹ마 가 될수도 있고 초성이 올 수도 있다. 따라서 섣불리 완성할 수 없다. 이땐 stage5로 간다.&#13;
                    stage = 5;&#13;
                } else { //합쳐질 수 없다면 앞 글자 완성 후 여전히 중성이 올 차례&#13;
                    _makeHangul(i-1);&#13;
                }&#13;
                }*/&#13;
            } else if (stage == 2) { //종성이 올 차례&#13;
                if (_isJong(code)) { //종성이 오면 다음엔 자음 또는 모음이 온다.&#13;
                stage = 3;&#13;
                } else if (_isJung(code)) { //그런데 중성이 오면 앞의 모음과 합칠 수 있는지 본다.&#13;
                if (_isJungJoinable(previous_code, code)) { //합칠 수 있으면 여전히 종성이 올 차례고 그대로 진행&#13;
                } else { // 합칠 수 없다면 오타가 생긴 경우&#13;
                    _makeHangul(i-1);&#13;
                    stage = 4;&#13;
                }&#13;
                } else { // 받침이 안되는 자음이 오면 ㄸ 같은 이전까지 완성하고 다시시작&#13;
                _makeHangul(i-1);&#13;
                stage = 1;&#13;
                }&#13;
            } else if (stage == 3) { // 종성이 하나 온 상태.&#13;
                if (_isJong(code)) { // 또 종성이면 합칠수 있는지 본다.&#13;
                if (_isJongJoinable(previous_code, code)) { //합칠 수 있으면 계속 진행. 왜냐하면 이번에 온 자음이 다음 글자의 초성이 될 수도 있기 때문&#13;
                } else { //없으면 한글자 완성&#13;
                    _makeHangul(i-1);&#13;
                    stage = 1; // 이 종성이 초성이 되고 중성부터 시작&#13;
                }&#13;
                } else if (_isCho(code)) { // 초성이면 한글자 완성.&#13;
                _makeHangul(i-1);&#13;
                stage = 1; //이 글자가 초성이되므로 중성부터 시작&#13;
                } else if (_isJung(code)) { // 중성이면 이전 종성은 이 중성과 합쳐지고 앞 글자는 받침이 없다.&#13;
                _makeHangul(i-2);&#13;
                stage = 2;&#13;
                }&#13;
            } else if (stage == 4) { // 중성이 하나 온 상태&#13;
                if (_isJung(code)) { //중성이 온 경우&#13;
                if(_isJungJoinable(previous_code, code)) { //이전 중성과 합쳐질 수 있는 경우&#13;
                    _makeHangul(i);&#13;
                    stage = 0;&#13;
                } else { //중성이 왔지만 못합치는 경우. ㅒㅗ 같은&#13;
                    _makeHangul(i-1);&#13;
                }&#13;
                } else { // 아니면 자음이 온 경우.&#13;
                _makeHangul(i-1);&#13;
                stage = 1;&#13;
                }&#13;
            } else if (stage == 5) { // 초성이 연속해서 두개 온 상태 ㄺ&#13;
                if (_isJung(code)) { //이번에 중성이면 ㄹ가&#13;
                _makeHangul(i-2);&#13;
                stage = 2;&#13;
                } else {&#13;
                _makeHangul(i-1);&#13;
                stage = 1;&#13;
                }&#13;
            }&#13;
            previous_code = code;&#13;
            }&#13;
            _makeHangul(i-1);&#13;
            return result.join('');&#13;
        };&#13;
&#13;
        var search = function(a, b){&#13;
            var ad = disassemble(a).join(''),&#13;
                bd = disassemble(b).join('')&#13;
                ;&#13;
&#13;
            return ad.indexOf(bd);&#13;
        };&#13;
&#13;
        var rangeSearch = function(haystack, needle){&#13;
            var hex = disassemble(haystack).join(''),&#13;
                nex = disassemble(needle).join(''),&#13;
                grouped = disassemble(haystack, true),&#13;
                re = new RegExp(nex, 'gi'),&#13;
                indices = [],&#13;
                result;&#13;
&#13;
            if(!needle.length) return [];&#13;
&#13;
            while((result = re.exec(hex))) {&#13;
            indices.push(result.index);&#13;
            }&#13;
&#13;
            function findStart(index) {&#13;
            for(var i = 0, length = 0; i &lt; grouped.length; ++i) {&#13;
                length += grouped[i].length;&#13;
                if(index &lt; length) return i;&#13;
            }&#13;
            }&#13;
&#13;
            function findEnd(index) {&#13;
            for(var i = 0, length = 0; i &lt; grouped.length; ++i) {&#13;
                length += grouped[i].length;&#13;
                if(index + nex.length &lt;= length) return i;&#13;
            }&#13;
            }&#13;
&#13;
            return indices.map(function(i) {&#13;
            return [findStart(i), findEnd(i)];&#13;
            });&#13;
        };&#13;
&#13;
        function Searcher(string) {&#13;
            this.string = string;&#13;
            this.disassembled = disassemble(string).join('');&#13;
        }&#13;
&#13;
        Searcher.prototype.search = function(string) {&#13;
            return disassemble(string).join('').indexOf(this.disassembled);&#13;
        };&#13;
&#13;
        var endsWithConsonant = function (string) {&#13;
            if (typeof string === 'object') {&#13;
            string = string.join('');&#13;
            }&#13;
&#13;
            var code = string.charCodeAt(string.length - 1);&#13;
&#13;
            if (_isHangul(code)) { // 완성된 한글이면&#13;
            code -= HANGUL_OFFSET;&#13;
            var jong = code % 28;&#13;
            if (jong &gt; 0) {&#13;
                return true;&#13;
            }&#13;
            } else if (_isConsonant(code)) { //자음이면&#13;
            return true;&#13;
            }&#13;
            return false;&#13;
        };&#13;
&#13;
        var hangul = {&#13;
            disassemble: disassemble,&#13;
            d: disassemble, // alias for disassemble&#13;
            disassembleToString: disassembleToString,&#13;
            ds: disassembleToString, // alias for disassembleToString&#13;
            assemble: assemble,&#13;
            a: assemble, // alias for assemble&#13;
            search: search,&#13;
            rangeSearch: rangeSearch,&#13;
            Searcher: Searcher,&#13;
            endsWithConsonant: endsWithConsonant,&#13;
            isHangul: function(c){&#13;
            if (typeof c === 'string')&#13;
                c = c.charCodeAt(0);&#13;
            return _isHangul(c);&#13;
            },&#13;
            isComplete: function(c){&#13;
            if (typeof c === 'string')&#13;
                c = c.charCodeAt(0);&#13;
            return _isHangul(c);&#13;
            },&#13;
            isConsonant: function(c){&#13;
            if (typeof c === 'string')&#13;
                c = c.charCodeAt(0);&#13;
            return _isConsonant(c);&#13;
            },&#13;
            isVowel: function(c){&#13;
            if (typeof c === 'string')&#13;
                c = c.charCodeAt(0);&#13;
            return _isJung(c);&#13;
            },&#13;
            isCho: function(c){&#13;
            if (typeof c === 'string')&#13;
                c = c.charCodeAt(0);&#13;
            return _isCho(c);&#13;
            },&#13;
            isJong: function(c){&#13;
            if (typeof c === 'string')&#13;
                c = c.charCodeAt(0);&#13;
            return _isJong(c);&#13;
            },&#13;
            isHangulAll: function(str){&#13;
            if (typeof str !== 'string') return false;&#13;
            for (var i = 0; i &lt; str.length; i++) {&#13;
                if (!_isHangul(str.charCodeAt(i))) return false;&#13;
            }&#13;
            return true;&#13;
            },&#13;
            isCompleteAll: function(str){&#13;
            if (typeof str !== 'string') return false;&#13;
            for (var i = 0; i &lt; str.length; i++) {&#13;
                if (!_isHangul(str.charCodeAt(i))) return false;&#13;
            }&#13;
            return true;&#13;
            },&#13;
            isConsonantAll: function(str){&#13;
            if (typeof str !== 'string') return false;&#13;
            for (var i = 0; i &lt; str.length; i++) {&#13;
                if (!_isConsonant(str.charCodeAt(i))) return false;&#13;
            }&#13;
            return true;&#13;
            },&#13;
            isVowelAll: function(str){&#13;
            if (typeof str !== 'string') return false;&#13;
            for (var i = 0; i &lt; str.length; i++) {&#13;
                if (!_isJung(str.charCodeAt(i))) return false;&#13;
            }&#13;
            return true;&#13;
            },&#13;
            isChoAll: function(str){&#13;
            if (typeof str !== 'string') return false;&#13;
            for (var i = 0; i &lt; str.length; i++) {&#13;
                if (!_isCho(str.charCodeAt(i))) return false;&#13;
            }&#13;
            return true;&#13;
            },&#13;
            isJongAll: function(str){&#13;
            if (typeof str !== 'string') return false;&#13;
            for (var i = 0; i &lt; str.length; i++) {&#13;
                if (!_isJong(str.charCodeAt(i))) return false;&#13;
            }&#13;
            return true;&#13;
            }&#13;
        };&#13;
&#13;
        if (typeof define == 'function' &amp;&amp; define.amd) {&#13;
            define(function(){&#13;
            return hangul;&#13;
            });&#13;
        } else if (typeof module !== 'undefined') {&#13;
            module.exports = hangul;&#13;
        } else {&#13;
            window.Hangul = hangul;&#13;
        }&#13;
&#13;
    })();&#13;
    var presenter = function(){};&#13;
&#13;
    presenter.playerController = null;&#13;
    presenter.eventBus = null;&#13;
    presenter.display = null;&#13;
    presenter.isLoaded = false;&#13;
    presenter.functionsQueue = [];&#13;
&#13;
    var keyboardIsVisible = true;&#13;
    var closeButtonElement = null;&#13;
    var openButtonElement = null;&#13;
    var lastClickedElement = null;&#13;
    var movedInput = false;&#13;
    var escClicked = false;&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'E01' : 'The position is wrong. See documentation for more details.',&#13;
        'E02' : 'Module ID not found.',&#13;
        'E03' : 'The module you provided has no getView method implemented.',&#13;
        'E04' : 'Max Characters must be a digit or empty string (unlimited).'&#13;
    };&#13;
&#13;
&#13;
&#13;
//    console.log("AddoneKeyboard_create");&#13;
&#13;
&#13;
    presenter.LAYOUT_TO_LANGUAGE_MAPPING = {&#13;
        'french (special characters)' : "{ \&#13;
            'default': ['\u00e0 \u00e2 \u00e7 \u00e8 \u00e9 \u00ea \u00eb \u00ee \u00ef \u00f4 \u00f9 \u00fb \u00e6 \u0153 \u00ab \u00bb {shift}'], \&#13;
            'shift':   ['\u00c0 \u00c2 \u00c7 \u00c8 \u00c9 \u00ca \u00cb \u00ce \u00cf \u00d4 \u00d9 \u00db \u00c6 \u0152 \u00ab \u00bb {shift}'] \&#13;
        }",&#13;
        'german (special characters)' : "{ \&#13;
            'default': ['\u00e4 \u00f6 \u00fc \u00df {shift}'], \&#13;
            'shift': ['\u00c4 \u00d6 \u00dc {empty} {shift}'] \&#13;
        }",&#13;
        'spanish (special characters)' : "{ \&#13;
            'default': ['\u00e1 \u00e9 \u00ed \u00f3 \u00fa \u00f1 \u00e7 \u00fc \u00a1 \u00bf \u00ba \u00aa {shift}'], \&#13;
            'shift': ['\u00c1 \u00c9 \u00cd \u00d3 \u00da \u00d1 \u00c7 \u00dc {empty} {empty} {empty} {empty} {shift}'] \&#13;
        }",&#13;
        'italian (special characters)' : "{ \&#13;
            'default': ['\u00e0 \u00e8 \u00e9 \u00ec \u00f2 \u00f9 {shift}'], \&#13;
            'shift': ['\u00c0 \u00c8 \u00c9 \u00cc \u00d2 \u00d9 {shift}'] \&#13;
        }",&#13;
            'type1 (numeric)' : "{ \&#13;
            'default': ['1 2 3 4 5 {b}', '6 7 8 9 0 .'] \&#13;
        }",&#13;
            'type2 (numeric sign)' : "{ \&#13;
            'default': ['1 2 3 4 5 {b}', '6 7 8 9 0 .', '○ □ △ ♡ ☆ π', '+ - × ÷ = %'] \&#13;
        }",&#13;
            'type3 (hangul jaum)' : "{ \&#13;
            'default': ['\u3131 \u3134 \u3137 \u3139 \u3141 \u3142', '\u3145 \u3147 \u3148 \u314A \u314B \u314C', '\u314D \u314E {b} {empty} {empty} {empty}'] \&#13;
        }",&#13;
            'type4 (hangul jaum moum)' : "{ \&#13;
            'default': ['\u3142 \u3148 \u3137 \u3131 \u3145 \u315B \u3155 \u3151 \u3150 \u3154' , '\u3141 \u3134 \u3147 \u3139 \u314E \u3157 \u3153 \u314F \u3163', '\u314B \u314C \u314A \u314D \u3160 \u315C \u3161', '{s} {space} {b} {alt} {meta1} {cancel}' ], 'shift': ['\u3143 \u3149 \u3138 \u3132 \u3146 \u315B \u3155 \u3151 \u3152 \u3156', '\u3141 \u3134 \u3147 \u3139 \u314E \u3157 \u3153 \u314F \u3163 ', '\u314B \u314C \u314A \u314D \u3160 \u315C \u3161', '{s} {space} {b} {alt} {meta1} {cancel}'], 'alt' : ['q w e r t y u i o p', 'a s d f g h j k l', 'z x c v b n m', '{s} {space} {b} {alt} {meta1} {cancel}'], 'alt-shift' : ['Q W E R T Y U I O P', 'A S D F G H J K L', 'Z X C V B N M', '{s} {space} {b} {alt} {meta1} {cancel}'], 'meta1' : ['1 2 3 4 5 6 7 8 9 0', '+ - \u00D7 \u00F7 = / ', ', . \u318D \u25B3 \u25A1 \u25CB', '{s} {space} {b} {default} {cancel}'] \&#13;
        }"&#13;
        /* , 'type5 (hangul full)' : "{ \&#13;
        'default': ['1 2 3 4 5 6 7 8 9 0', '\u3142 \u3148 \u3137 \u3131 \u3145 \u315B \u3155 \u3151 \u3150 \u3154 {b}' , '\u3141 \u3134 \u3147 \u3139 \u314E \u3157 \u3153 \u314F \u3163', '{s} \u314B \u314C \u314A \u314D \u3160 \u315C \u3161 , . {s} ', '{meta1} {space} {left} {right} {alt} {cancel}'], 'shift': ['! @ # $ % ^ \u0026 * ( ) ', '\u3143 \u3149 \u3138 \u3132 \u3146 \u315B \u3155 \u3151 \u3152 \u3156  {b}', '\u3141 \u3134 \u3147 \u3139 \u314E \u3157 \u3153 \u314F \u3163 ', '{s} \u314B \u314C \u314A \u314D \u3160 \u315C \u3161 \u0021 \u003F {s}', '{meta1} {space} {left} {right} {alt} {cancel}'],  'alt' : ['1 2 3 4 5 6 7 8 9 0', 'q w e r t y u i o p {b}', 'a s d f g h j k l', '{s} z x c v b n m , . {s}', '{meta1} {space} {left} {right} {alt} {cancel}'], 'alt-shift' : ['! @ # $ % ^ \u0026 * ( )', 'Q W E R T Y U I O P  {b}', 'A S D F G H J K L', '{s} Z X C V B N M \u0021 \u003F {s}', '{meta1} {space} {left} {right} {alt} {cancel}'], 'meta1' : ['! @ # $ % ^ \u0026 * ( )', '\u007E \u003C \u003E \u007B \u007D \u005B \u005D - + {b}', '_ \u25CB \u003A ; \u0022 \u00D7 \u00F7 \u003D', '{s} \u25A1 \u2606 \u2661 ￦ ｜ ／ \u003F , . {s}', '{default} {space} {left} {right} {default} {cancel}'] \&#13;
        }"*/&#13;
    };&#13;
&#13;
    function getErrorObject (ec) { return { isError: true, errorCode: ec }; }&#13;
    function getCorrectObject(val) { return { isError: false, value: val }; }&#13;
&#13;
    function touchStartDecorator(func, element) {&#13;
        $(element).on('click', function (ev) {&#13;
            ev.preventDefault();&#13;
            ev.stopPropagation();&#13;
&#13;
            func();&#13;
        });&#13;
    }&#13;
&#13;
    presenter.initializeCloseButton = function AddoneKeyboard_initializeCloseButton() {&#13;
        closeButtonElement = document.createElement('button');&#13;
        closeButtonElement.className = 'eKeyboard-close-button';&#13;
        closeButtonElement.style.position = 'absolute';&#13;
        closeButtonElement.innerHTML = '&lt;span&gt;\u2716&lt;/span&gt;';&#13;
        closeButtonElement.style.display = 'none';&#13;
&#13;
        $(presenter.keyboardWrapper).append(closeButtonElement);&#13;
&#13;
        touchStartDecorator(closeButtonCallBack, closeButtonElement);&#13;
    };&#13;
&#13;
    function initializeOpenButton() {&#13;
        openButtonElement = document.createElement('button');&#13;
        openButtonElement.className = 'eKeyboard-open-button';&#13;
        openButtonElement.style.display = 'none';&#13;
        openButtonElement.style.zindex = 'none';&#13;
        $(openButtonElement).on('mousedown', function (ev) {&#13;
            ev.preventDefault();&#13;
            ev.stopPropagation();&#13;
            showOpenButtonCallback();&#13;
        });&#13;
&#13;
        $("body").append(openButtonElement);&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function (controller) {&#13;
        presenter.playerController = controller;&#13;
        presenter.eventBus = controller.getEventBus();&#13;
        presenter.eventBus.addEventListener('PageLoaded', this);&#13;
    };&#13;
&#13;
    presenter.onEventReceived = function(eventName) {&#13;
        if (eventName == 'PageLoaded') {&#13;
            presenter.pageLoadedDeferred.resolve();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateType = function(rawType) {&#13;
        if (rawType == 'Numeric' || rawType.length == 0) {&#13;
            return 'num';&#13;
        }&#13;
&#13;
        return rawType.toLowerCase();&#13;
    };&#13;
&#13;
    presenter.validateWorkWith = function (workWithModules, worksWithAll) {&#13;
        const workWithViews = [];&#13;
        for (let i = 0; i &lt; workWithModules.length; i++) {&#13;
            const module = presenter.playerController.getModule(workWithModules[i]);&#13;
            if (module) {&#13;
                if (module.getView &amp;&amp; module.getView()) {&#13;
                    workWithViews.push(module.getView());&#13;
                }&#13;
            } else if (!worksWithAll) {&#13;
                return getErrorObject("E02");&#13;
            }&#13;
        }&#13;
&#13;
        return workWithViews;&#13;
    }&#13;
&#13;
    presenter.validateMaxCharacters = function(rawMaxCharacters) {&#13;
        if (rawMaxCharacters.length == 0) {&#13;
            return getCorrectObject(false);&#13;
        }&#13;
&#13;
        if ( !(/\d+/.test(rawMaxCharacters)) ) {&#13;
            return getErrorObject("E04");&#13;
        }&#13;
&#13;
        return getCorrectObject(parseInt(rawMaxCharacters, 10));&#13;
    };&#13;
&#13;
    presenter.validatePosition = function(rawPosition, isMy) {&#13;
        if (!rawPosition.length) {&#13;
            return getCorrectObject(isMy ? 'left center' : 'right center');&#13;
        }&#13;
&#13;
        var possibilitiesOnTheLeft = ['left', 'center', 'right'],&#13;
            possibilitiesOnTheRight = ['top', 'center', 'bottom'],&#13;
            splitted = rawPosition.split(' ');&#13;
&#13;
        if (&#13;
            splitted.length === 2 &amp;&amp;&#13;
            possibilitiesOnTheLeft.indexOf(splitted[0]) &gt;= 0 &amp;&amp;&#13;
            possibilitiesOnTheRight.indexOf(splitted[1]) &gt;= 0&#13;
        ) {&#13;
            return getCorrectObject(rawPosition);&#13;
        } else {&#13;
            return getErrorObject("E01")&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateOffsetData = function(positionMy, positionAt) {&#13;
        var splittedMy = positionMy.split(' '),&#13;
            splittedAt = positionAt.split(' ');&#13;
&#13;
        if (splittedMy[1] == 'bottom' &amp;&amp; splittedAt[1] == 'top') {&#13;
            return {&#13;
                orientation: 'horizontal',&#13;
                directionSign: '-',&#13;
                value: '0 -10'&#13;
            }&#13;
        }&#13;
&#13;
        if (splittedMy[0] == 'left' &amp;&amp; splittedAt[0] == 'right') {&#13;
            return {&#13;
                orientation: 'vertical',&#13;
                directionSign: '',&#13;
                value: '10 0'&#13;
            };&#13;
        }&#13;
&#13;
        if (splittedMy[1] == 'top' &amp;&amp; splittedAt[1] == 'bottom') {&#13;
            return {&#13;
                orientation: 'horizontal',&#13;
                directionSign: '',&#13;
                value : '0 10'&#13;
            };&#13;
        }&#13;
&#13;
        if (splittedMy[0] == 'right' &amp;&amp; splittedAt[0] == 'left') {&#13;
            return {&#13;
                orientation: 'vertical',&#13;
                directionSign: '-',&#13;
                value: '-10 0'&#13;
            };&#13;
        }&#13;
&#13;
        return {&#13;
            orientation: 'none',&#13;
            directionSign: '',&#13;
            value : ''&#13;
        };&#13;
    };&#13;
&#13;
    presenter.createPreview = function(view, model) {&#13;
        runLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function AddoneKeyboard_upgradeModel(model) {&#13;
        const upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (!upgradedModel["worksWithAll"]) {&#13;
            upgradedModel["worksWithAll"] = "False";&#13;
        }&#13;
        if (!upgradedModel['customDisplay']) {&#13;
            upgradedModel['customDisplay'] = "";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.validateModel = function(model, isPreview) {&#13;
        const worksWithAll = ModelValidationUtils.validateBoolean(model.worksWithAll);&#13;
        let workWithModules = worksWithAll ? presenter.getAllPageModulesIds() : Helpers.splitLines(model['workWith']),&#13;
            workWithViews = [],&#13;
            layoutType = presenter.validateType(model['layoutType']),&#13;
            customLayout = model['customLayout'],&#13;
            maxCharacters = presenter.validateMaxCharacters(model['maxCharacters']),&#13;
            positionMy = presenter.validatePosition(model['positionMy'], true),&#13;
            positionAt = presenter.validatePosition(model['positionAt'], false);&#13;
&#13;
        if (!isPreview) {&#13;
            workWithViews = presenter.validateWorkWith(workWithModules, worksWithAll);&#13;
        }&#13;
&#13;
        if (presenter.LAYOUT_TO_LANGUAGE_MAPPING[layoutType] != undefined) {&#13;
            customLayout = presenter.LAYOUT_TO_LANGUAGE_MAPPING[layoutType];&#13;
            layoutType = 'custom';&#13;
        }&#13;
&#13;
        if (maxCharacters.isError) return maxCharacters;&#13;
        if (positionMy.isError) return positionMy;&#13;
        if (positionAt.isError) return positionAt;&#13;
        if (workWithViews.isError) return workWithViews;&#13;
&#13;
        return {&#13;
            'ID': model["ID"],&#13;
            'isError' : false,&#13;
            workWithViews,&#13;
            worksWithAll,&#13;
            layoutType,&#13;
            customLayout,&#13;
            positionAt,&#13;
            positionMy,&#13;
            'customDisplay' : model['customDisplay'],&#13;
            'maxCharacters' : maxCharacters.value,&#13;
            'offset' : presenter.validateOffsetData(positionMy.value, positionAt.value),&#13;
            'openOnFocus' : !ModelValidationUtils.validateBoolean(model['noOpenOnFocus']),&#13;
            'lockInput' : ModelValidationUtils.validateBoolean(model['lockStandardKeyboardInput']),&#13;
            'showCloseButton': ModelValidationUtils.validateBoolean(model['showCloseButton'])&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getAllPageModulesIds = function () {&#13;
        const currentPageIndex = presenter.playerController.getCurrentPageIndex();&#13;
        const allModulesIds = presenter.playerController.getPresentation().getPage(currentPageIndex).getModulesAsJS();&#13;
&#13;
        return allModulesIds;&#13;
    }&#13;
&#13;
    presenter.removeEventListeners = function () {&#13;
        presenter.configuration.$inputs.each(function (index, element) {&#13;
            element.removeEventListener('mousedown', presenter.focusOnMouseDown);&#13;
            element.removeEventListener('focus', presenter.openEKeyboardOnFocus);&#13;
            element.removeEventListener('forceClick', presenter.openEKeyboardOnForceClick);&#13;
            element.removeEventListener('keyup', presenter.onESCHideKeyboard);&#13;
            element.removeEventListener('change', presenter.moveToNextGap);&#13;
            element.removeEventListener('paste', presenter.moveToNextGap);&#13;
            element.removeEventListener('keyup', presenter.moveToNextGap);&#13;
            element.removeEventListener('focusout', focusoutCallBack);&#13;
        });&#13;
    };&#13;
&#13;
    function connectInputModule(view, model, isPreview){&#13;
        const upgradedModel = presenter.upgradeModel(model);&#13;
        presenter.configuration = presenter.validateModel(upgradedModel, isPreview);&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.$inputs = $(presenter.configuration.workWithViews).find('input').not('.ic_text_audio_button');&#13;
//               console.log("presenter.configuration.workWithViews", presenter.configuration.workWithViews);&#13;
//        console.log("presenter.configuration.$inputs", presenter.configuration.$inputs);&#13;
&#13;
//        for( var i=0; i&lt;presenter.configuration.$inputs.length; ++i){&#13;
//            var maxlength = presenter.configuration.$inputs[i].attr("maxlength");&#13;
//            console.log("maxlength", maxlength);&#13;
//            presenter.configuration.$inputs[i].attr("maxlength", 7);&#13;
//        }&#13;
&#13;
        if (!isPreview) {&#13;
            if (presenter.configuration.customLayout.length &gt; 0) {&#13;
                try {&#13;
                    eval('presenter.configuration.customLayout = ' + presenter.configuration.customLayout);&#13;
                } catch (e) {&#13;
                    presenter.ERROR_CODES['evaluationError'] = e.message;&#13;
                    DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, 'evaluationError');&#13;
                }&#13;
            }&#13;
&#13;
            if (presenter.configuration.customDisplay.length &gt; 0) {&#13;
                try {&#13;
                    eval('presenter.configuration.customDisplay = ' + presenter.configuration.customDisplay);&#13;
                } catch(e) {&#13;
                    presenter.ERROR_CODES['evaluationError'] = e.message;&#13;
                    DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, 'evaluationError');&#13;
                }&#13;
            }&#13;
            presenter.configuration.customLayout.id = new Date().getTime();&#13;
&#13;
            var defaultDisplay = {&#13;
                a      : '\u2714:Accept (Shift-Enter)', // check mark - same action as accept&#13;
                accept : 'Accept:Accept (Shift-Enter)',&#13;
                alt    : 'AltGr:Alternate Graphemes',&#13;
                b      : '\u2190:Backspace',    // Left arrow (same as &amp;larr;)&#13;
                bksp   : 'Bksp:Backspace',&#13;
                c      : '\u2716:Cancel (Esc)', // big X, close - same action as cancel&#13;
                cancel : 'Cancel:Cancel (Esc)',&#13;
                clear  : 'C:Clear',             // clear num pad&#13;
                combo  : '\u00f6:Toggle Combo Keys',&#13;
                dec    : '.:Decimal',           // decimal point for num pad (optional), change '.' to ',' for European format&#13;
                e      : '\u21b5:Enter',        // down, then left arrow - enter symbol&#13;
                enter  : 'Enter:Enter',&#13;
                left   : '\u2190',              // left arrow (move caret)&#13;
                lock   : '\u21ea Lock:Caps Lock', // caps lock&#13;
                next   : 'Next',&#13;
                prev   : 'Prev',&#13;
                right  : '\u2192',              // right arrow (move caret)&#13;
                s      : '\u21e7:Shift',        // thick hollow up arrow&#13;
                shift  : 'CapsLock:CapsLock',&#13;
                sign   : '\u00b1:Change Sign',  // +/- sign for num pad&#13;
                space  : '&amp;nbsp;:Space',&#13;
                t      : '\u21e5:Tab',          // right arrow to bar (used since this virtual keyboard works with one directional tabs)&#13;
                tab    : '\u21e5 Tab:Tab'       // \u21b9 is the true tab symbol (left &amp; right arrows)&#13;
            };&#13;
&#13;
            var customDisplay = presenter.configuration.customDisplay;&#13;
            presenter.display = $.extend(defaultDisplay, customDisplay);&#13;
&#13;
            if (MobileUtils.isMobileUserAgent(navigator.userAgent) &amp;&amp; presenter.configuration.lockInput) {&#13;
                presenter.configuration.$inputs.each(&#13;
                    function (index, element) {&#13;
                        var $el = $(element);&#13;
                        $el.addClass('ui-keyboard-lockedinput');&#13;
                        $el.attr('readonly', true);&#13;
                        $el.attr('inputmode', "none");&#13;
                    }&#13;
                );&#13;
            }&#13;
&#13;
            presenter.removeEventListeners();&#13;
&#13;
            presenter.connectHandlers();&#13;
        }&#13;
        for (var i = 0; i &lt; presenter.functionsQueue.length; i++) {&#13;
            presenter.functionsQueue[i]();&#13;
        }&#13;
        presenter.isLoaded = true;&#13;
    }&#13;
&#13;
&#13;
    function runLogic(view, model, isPreview) {&#13;
//        console.log("runLogic", view)&#13;
        presenter.$view = $(view);&#13;
        presenter.view = view;&#13;
        presenter.isPreview = isPreview;&#13;
        presenter.isShowCloseButton = false;&#13;
&#13;
        presenter.pageLoadedDeferred = new $.Deferred();&#13;
        presenter.pageLoaded = presenter.pageLoadedDeferred.promise();&#13;
&#13;
        presenter.keyboardWrapper = document.createElement("div");&#13;
        presenter.keyboardWrapper.className = "ui-ekeyboard-wrapper";&#13;
        $(document.body).append(presenter.keyboardWrapper);&#13;
&#13;
        initializeOpenButton();&#13;
        presenter.initializeCloseButton();&#13;
&#13;
        presenter.view.addEventListener('DOMNodeRemoved', function onDOMNodeRemoved_eKeyboard (ev) {&#13;
            if (ev.target === this) {&#13;
                presenter.destroy();&#13;
            }&#13;
        });&#13;
&#13;
        var mathJaxDeferred = new jQuery.Deferred(),&#13;
            mathJaxProcessEnded = mathJaxDeferred.promise();&#13;
&#13;
        MathJax.Hub.Register.MessageHook("End Process", function (message) {&#13;
            if ($(message[1]).hasClass('ic_page')) {&#13;
                if(mathJaxDeferred.state() != 'resolved'){&#13;
                    mathJaxDeferred.resolve();&#13;
                }&#13;
            }&#13;
&#13;
            if ($(message[1]).hasClass('ic_popup_page')) {&#13;
                if(mathJaxDeferred.state() != 'resolved'){&#13;
                    mathJaxDeferred.resolve();&#13;
                }&#13;
            }&#13;
        });&#13;
&#13;
&#13;
        $.when(presenter.pageLoaded, mathJaxProcessEnded).then(function() {&#13;
            //mathjax가 복잡한 경우 딜레이를 둬야 정상작동 함.&#13;
            let timerId = setInterval(function(){&#13;
                connectInputModule(view, model, isPreview);&#13;
            }, 1000);&#13;
            setTimeout(function(){&#13;
                 clearInterval(timerId);&#13;
            }, 5000)&#13;
        });&#13;
    }&#13;
&#13;
    /**&#13;
     * Adds handlers to all input elements with which eKeyboard works&#13;
     */&#13;
&#13;
    presenter.connectHandlers = function AddoneKeyboard_connectHandlers() {&#13;
//        console.log("presenter.configuration.$inputs", presenter.configuration.$inputs);&#13;
        presenter.configuration.$inputs.each(&#13;
            function (index, element) {&#13;
                if (DevicesUtils.isInternetExplorer()) {&#13;
                    element.addEventListener('mousedown', presenter.focusOnMouseDown);&#13;
                }&#13;
&#13;
                element.addEventListener('focus', presenter.openEKeyboardOnFocus);&#13;
                element.addEventListener('forceClick', presenter.openEKeyboardOnForceClick);&#13;
                element.addEventListener('keyup', presenter.onESCHideKeyboard);&#13;
&#13;
                if (presenter.configuration.maxCharacters !== false) {&#13;
                    element.addEventListener('change', presenter.moveToNextGap);&#13;
                    element.addEventListener('paste', presenter.moveToNextGap);&#13;
                    element.addEventListener('keyup', presenter.moveToNextGap);&#13;
                }&#13;
&#13;
                //This is after setState because validateModel is in promise.&#13;
                if (!keyboardIsVisible) {&#13;
                    element.addEventListener('focusout', focusoutCallBack);&#13;
                }&#13;
&#13;
                //이석웅 추가&#13;
                element.setAttribute("keyboardtype", presenter.layoutType);&#13;
            });&#13;
    };&#13;
&#13;
    presenter.focusOnMouseDown = function AddoneKeyboard_focusOnMouseDown () {&#13;
        $(this).focus();&#13;
    };&#13;
&#13;
    presenter.openEKeyboardOnFocus = function AddoneKeyboard_openEKeyboardOnFocus () {&#13;
        lastClickedElement = this;&#13;
        if (!keyboardIsVisible) {&#13;
            if ($(this).data('keyboard') !== undefined) {&#13;
                $(this).data('keyboard').destroy();&#13;
            }&#13;
            openButtonElement.style.display = 'block';&#13;
            actualizeOpenButtonPosition($(lastClickedElement));&#13;
        } else {&#13;
            presenter.createEKeyboard(this, presenter.display);&#13;
            $(this).trigger('showKeyboard');&#13;
        }&#13;
    };&#13;
&#13;
    presenter.openEKeyboardOnForceClick = function AddoneKeyboard_openEKeyboardOnForceClick() {&#13;
        if (presenter.configuration.openOnFocus) {&#13;
            $(this).data('keyboard').reveal();&#13;
            if ($(".ic_popup_page").length == 0) {&#13;
                $(this).data('keyboard').startup();&#13;
            }&#13;
        } else {&#13;
            $(this).focus();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.onESCHideKeyboard = function AddoneKeyboard_onESCHideKeyboard(e) {&#13;
        var isEKeyboardOpen = $(this).data('keyboard') &amp;&amp; $(this).data('keyboard').isOpen;&#13;
        if (e.keyCode === 27 &amp;&amp; isEKeyboardOpen) {&#13;
            onEscClick();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.moveToNextGap = function AddoneKeyboard_moveToNextGap() {&#13;
        if ($(this).val().length &gt;= presenter.configuration.maxCharacters) {&#13;
            var self = this;&#13;
            $(this).val($(this).val().substring(0, presenter.configuration.maxCharacters));&#13;
&#13;
            if ($(this).data('keyboard') !== undefined) {&#13;
                //Fix bug with events&#13;
                setTimeout(function () {&#13;
                    $(self).data('keyboard').switchInput(true, true);&#13;
                }, 0);&#13;
            } else {&#13;
                lastClickedElement = this;&#13;
                movedInput = true;&#13;
                getNextFocusableElement(this, true).focus();&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.clickedOutsideCallback = function AddoneKeyboard_clickedOutsideCallback(event) {&#13;
        // shouldn't hide keyboard when current input was clicked&#13;
        if (event.target === lastClickedElement) return;&#13;
&#13;
        var wrapper = $(presenter.keyboardWrapper);&#13;
&#13;
        // if click outside of wrapper or it's descendant, hide keyboard&#13;
        if (!wrapper.is(event.target) &amp;&amp; wrapper.has(event.target).length === 0) {&#13;
            presenter.hideKeyboard();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideKeyboard = function () {&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
&#13;
        $(closeButtonElement).hide();&#13;
        $(lastClickedElement).removeAttr("readonly");&#13;
        $(lastClickedElement).removeAttr("inputmode");&#13;
        var keyboard = $(lastClickedElement).data('keyboard');&#13;
        if (keyboard !== undefined) {&#13;
            keyboard.accept();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.createEKeyboard = function (element, display) {&#13;
        if ($(element).data('keyboard') !== undefined) {&#13;
            return;&#13;
        }&#13;
&#13;
        $(element).keyboard({&#13;
            // *** choose layout ***&#13;
            layout: presenter.configuration.layoutType,&#13;
            customLayout: presenter.configuration.customLayout,&#13;
            position: {&#13;
                of : null, // optional - null (attach to input/textarea) or a jQuery object (attach elsewhere)&#13;
                my : presenter.configuration.positionMy.value,&#13;
                at : presenter.configuration.positionAt.value,&#13;
                at2 : presenter.configuration.positionAt.value,&#13;
                offset : presenter.configuration.offset.value,&#13;
                collision: 'flip'&#13;
            },&#13;
&#13;
                    // preview added above keyboard if true, original input/textarea used if false&#13;
                    usePreview: false,&#13;
&#13;
                    // if true, the keyboard will always be visible&#13;
                    alwaysOpen: false,&#13;
&#13;
                    // give the preview initial focus when the keyboard becomes visible&#13;
                    initialFocus: presenter.configuration.lockInput,&#13;
&#13;
                    // if true, keyboard will remain open even if the input loses focus.&#13;
                    stayOpen: true,&#13;
&#13;
                    // *** change keyboard language &amp; look ***&#13;
                    display: display,&#13;
&#13;
                    // Message added to the key title while hovering, if the mousewheel plugin exists&#13;
                    wheelMessage: 'Use mousewheel to see other keys',&#13;
&#13;
                    css: {&#13;
                        input          : '', //'ui-widget-content ui-corner-all', // input &amp; preview&#13;
                        container      : 'ui-widget-content ui-widget ui-corner-all ui-helper-clearfix', // keyboard container&#13;
                        buttonDefault  : 'ui-state-default ui-corner-all', // default state&#13;
                        buttonHover    : 'ui-state-hover',  // hovered button&#13;
                        buttonAction   : 'ui-state-active', // Action keys (e.g. Accept, Cancel, Tab, etc); replaces "actionClass"&#13;
                        buttonDisabled : 'ui-state-disabled' // used when disabling the decimal button {dec}&#13;
                    },&#13;
&#13;
                    // *** Useability ***&#13;
                    // Auto-accept content when clicking outside the keyboard (popup will close)&#13;
                    autoAccept: true,&#13;
&#13;
                    // Prevents direct input in the preview window when true&#13;
                    lockInput: presenter.configuration.lockInput,&#13;
&#13;
                    // Prevent keys not in the displayed keyboard from being typed in&#13;
                    restrictInput: false,&#13;
&#13;
                    // Check input against validate function, if valid the accept button is clickable;&#13;
                    // if invalid, the accept button is disabled.&#13;
                    acceptValid: true,&#13;
&#13;
                    // Use tab to navigate between input fields&#13;
                    tabNavigation: true,&#13;
&#13;
                    // press enter (shift-enter in textarea) to go to the next input field&#13;
                    enterNavigation : true,&#13;
                    // mod key options: 'ctrlKey', 'shiftKey', 'altKey', 'metaKey' (MAC only)&#13;
                    enterMod : 'altKey', // alt-enter to go to previous; shift-alt-enter to accept &amp; go to previous&#13;
&#13;
                    // if true, the next button will stop on the last keyboard input/textarea; prev button stops at first&#13;
                    // if false, the next button will wrap to target the first input/textarea; prev will go to the last&#13;
                    stopAtEnd : false,&#13;
&#13;
                    // Set this to append the keyboard immediately after the input/textarea it is attached to.&#13;
                    // This option works best when the input container doesn't have a set width and when the&#13;
                    // "tabNavigation" option is true&#13;
                    appendLocally: false,&#13;
&#13;
            appendTo: presenter.keyboardWrapper,&#13;
&#13;
                    // If false, the shift key will remain active until the next key is (mouse) clicked on;&#13;
                    // if true it will stay active until pressed again&#13;
                    stickyShift: true,&#13;
&#13;
                    // Prevent pasting content into the area&#13;
                    preventPaste: false,&#13;
&#13;
                    // Set the max number of characters allowed in the input, setting it to false disables this option&#13;
                    //maxLength: presenter.configuration.maxCharacters,&#13;
&#13;
                    // Mouse repeat delay - when clicking/touching a virtual keyboard key, after this delay the key&#13;
                    // will start repeating&#13;
                    repeatDelay: 500,&#13;
&#13;
                    // Mouse repeat rate - after the repeatDelay, this is the rate (characters per second) at which the&#13;
                    // key is repeated. Added to simulate holding down a real keyboard key and having it repeat. I haven't&#13;
                    // calculated the upper limit of this rate, but it is limited to how fast the javascript can process&#13;
                    // the keys. And for me, in Firefox, it's around 20.&#13;
                    repeatRate: 20,&#13;
&#13;
                    // resets the keyboard to the default keyset when visible&#13;
                    resetDefault: false,&#13;
&#13;
                    // Event (namespaced) on the input to reveal the keyboard. To disable it, just set it to ''.&#13;
                    openOn: presenter.configuration.openOnFocus ? 'showKeyboard' : '',&#13;
&#13;
                    // When the character is added to the input&#13;
                    keyBinding: 'touchend mousedown',&#13;
&#13;
                    // combos (emulate dead keys : http://en.wikipedia.org/wiki/Keyboard_layout#US-International)&#13;
                    // if user inputs `a the script converts it to à, ^o becomes ô, etc.&#13;
                    useCombos: false,&#13;
&#13;
                    // if true, keyboard will not close if you press escape.&#13;
                    ignoreEsc : true,&#13;
&#13;
                    autoAcceptOnEsc : false,&#13;
                    // *** Methods ***&#13;
                    // Callbacks - add code inside any of these callback functions as desired&#13;
                    initialized: function (e, keyboard, el) {&#13;
                    },&#13;
                    beforeVisible: function (e, keyboard, el) {&#13;
                        if (!keyboard['$keyboard'].parent().hasClass('html')) {&#13;
                            var dialogBox = keyboard['$keyboard'].parent().find('.gwt-DialogBox');&#13;
                            dialogBox.append(keyboard['$keyboard']);&#13;
                        }&#13;
&#13;
                        var parent = keyboard['$keyboard'].parent(),&#13;
                            popup = parent.find('.ic_popup');&#13;
&#13;
                        if (popup.length &gt; 0) {&#13;
                            popup.append(keyboard['$keyboard']);&#13;
                        }&#13;
                    },&#13;
                    visible: function (e, keyboard, el) {&#13;
                        var isVisibleInViewPort = getIsVisibleInViewPort(keyboard['$keyboard']);&#13;
                        if (!isVisibleInViewPort) {&#13;
                            return;&#13;
                        }&#13;
&#13;
                        if (!isVisibleInViewPort.vertical || !isVisibleInViewPort.horizontal) {&#13;
                            shiftKeyboard(keyboard, isVisibleInViewPort);&#13;
                        }&#13;
&#13;
                        keyboard['$keyboard'].draggable({&#13;
                            drag: function () {&#13;
                                $(closeButtonElement).position({&#13;
                                    my:        "left top",&#13;
                                    at:        "right top",&#13;
                                    of:         keyboard['$keyboard'],&#13;
                                    collision: 'fit'&#13;
                                });&#13;
                            },&#13;
                            stop: function () {&#13;
                                $.ui.ddmanager.current = null;&#13;
                            }&#13;
                        });&#13;
&#13;
                        var $keyboard = keyboard['$keyboard'];&#13;
                        var position = $keyboard.position();&#13;
&#13;
                        var widthMargin = ($keyboard.outerWidth(true) -  $keyboard.innerWidth()) / 2;&#13;
                        var width = $keyboard.outerWidth() + widthMargin;&#13;
&#13;
                        var heightMargin = ($keyboard.outerHeight(true) -  $keyboard.innerHeight()) / 2;&#13;
&#13;
                        $(closeButtonElement).css({&#13;
                            top: position.top + heightMargin + 'px',&#13;
                            left: position.left + width + 'px'&#13;
                        });&#13;
&#13;
                        showCloseButton();&#13;
&#13;
                        document.addEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
                    },&#13;
                    change: function (e, keyboard, el) {&#13;
                        //한글 조합&#13;
                        el.value = Hangul.assemble(Hangul.disassemble(el.value));&#13;
&#13;
                        var api = $(lastClickedElement).data('keyboard');&#13;
&#13;
                        //Fixing the issue where if a key contains word 'meta' it will be treated as a meta key&#13;
                        if (api.last.key &amp;&amp; api.last.key.indexOf('meta') != -1&#13;
                            &amp;&amp; presenter.configuration.customLayout[api.last.key] == null) {&#13;
                            keyboard.insertText(api.last.key);&#13;
                        }&#13;
&#13;
                        var event = new Event('change');&#13;
                        el.dispatchEvent(event);&#13;
&#13;
                    },&#13;
                    beforeClose: function(e, keyboard, el, accepted) {&#13;
                        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
                        $(closeButtonElement).hide();&#13;
                    },&#13;
                    accepted: function(e, keyboard, el) {},&#13;
                    canceled: function(e, keyboard, el) {},&#13;
                    hidden: function(e, keyboard, el) {},&#13;
&#13;
                    switchInput : function(keyboard, goToNext, isAccepted){&#13;
                        var base = keyboard, kb, stopped = false,&#13;
                            all = $('input, textarea').filter(':enabled');&#13;
                        all = all.filter(function (element) {&#13;
                            return presenter.addonIsWorkingWithElement(all.eq(element))&#13;
                        });&#13;
                        var index = all.index(base.$el) + (goToNext ? 1 : -1);&#13;
                        if (index &gt; all.length - 1) {&#13;
                            stopped = keyboard.stopAtEnd;&#13;
                        }&#13;
                        if (index &lt; 0) {&#13;
                            stopped = keyboard.stopAtEnd;&#13;
                            index = all.length - 1; // stop or go to last&#13;
                        }&#13;
                        if (!stopped) {&#13;
                            if (!base.close(isAccepted)) {&#13;
                                return;&#13;
                            }&#13;
                            if (presenter.addonIsWorkingWithElement(all.eq(index))) {&#13;
                                    presenter.createEKeyboard(all.eq(index), display);&#13;
                            }&#13;
                            if (keyboardIsVisible) {&#13;
                                all.eq(index).trigger('forceClick');&#13;
                            }&#13;
                            if($(".ic_popup_page").length === 0){&#13;
                                all.eq(index).focus();&#13;
                            }&#13;
                        }&#13;
&#13;
                        return false;&#13;
                	},&#13;
                    // this callback is called just before the "beforeClose" to check the value&#13;
                    // if the value is valid, return true and the  will continue as it should&#13;
                    // (close if not always open, etc)&#13;
                    // if the value is not value, return false and the clear the keyboard value&#13;
                    // ( like this "keyboard.$preview.val('');" ), if desired&#13;
                    // The validate function is called after each input, the "isClosing" value will be false;&#13;
                    // when the accept button is clicked, "isClosing" is true&#13;
                    validate: function (keyboard, value, isClosing) {&#13;
                        return true;&#13;
                    }&#13;
                });&#13;
                $(lastClickedElement).trigger('forceClick');&#13;
            };&#13;
&#13;
    function getNextFocusableElement (element, next) {&#13;
        var all = $('input, textarea').filter(':enabled');&#13;
        var indx = all.index(element) + (next ? 1 : -1);&#13;
&#13;
        if (indx &gt; all.length - 1) {&#13;
            indx = 0; // go to first input&#13;
        }&#13;
        if (indx &lt; 0) {&#13;
            indx = all.length - 1; // stop or go to last&#13;
        }&#13;
        return all.eq(indx);&#13;
&#13;
    }&#13;
&#13;
    presenter.addonIsWorkingWithElement = function (element) {&#13;
        return ($(presenter.configuration.workWithViews).find(element).length != 0);&#13;
    };&#13;
&#13;
    function asyncFunctionDecorator(func) {&#13;
        if (presenter.isLoaded) {&#13;
            func();&#13;
        } else {&#13;
            presenter.functionsQueue.push(func);&#13;
        }&#13;
    }&#13;
&#13;
    function hideOpenButton() {&#13;
        openButtonElement.style.display = 'none';&#13;
    }&#13;
&#13;
    function focusoutCallBack(ev) {&#13;
        if (!keyboardIsVisible &amp;&amp; !movedInput) {&#13;
            hideOpenButton();&#13;
        }&#13;
        movedInput = false;&#13;
        ev.preventDefault();&#13;
    }&#13;
&#13;
    function showButtonDecorator(func) {&#13;
        if (presenter.configuration.showCloseButton || presenter.isShowCloseButton) {&#13;
            func();&#13;
        }&#13;
    }&#13;
&#13;
    function showCloseButton() {&#13;
        showButtonDecorator(function () {&#13;
            $(closeButtonElement).show();&#13;
        });&#13;
    }&#13;
&#13;
    function closeButtonCallBack() {&#13;
        presenter.disable();&#13;
&#13;
        $(lastClickedElement).focus();&#13;
        $(lastClickedElement).click();&#13;
&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
        $(closeButtonElement).hide();&#13;
    }&#13;
&#13;
    function showOpenButtonCallback() {&#13;
        hideOpenButton();&#13;
        presenter.configuration.$inputs.attr("inputmode", "none");&#13;
        presenter.enable();&#13;
&#13;
        escClicked = false;&#13;
&#13;
        document.activeElement.blur();&#13;
&#13;
        $(lastClickedElement).click();&#13;
        $(lastClickedElement).focus();&#13;
        $(lastClickedElement).trigger('showKeyboard');&#13;
    }&#13;
&#13;
    function actualizeOpenButtonPosition(element) {&#13;
        $(openButtonElement).position({&#13;
            of: element,&#13;
            my: presenter.configuration.positionMy.value,&#13;
            at: presenter.configuration.positionAt.value,&#13;
            at2: presenter.configuration.positionAt.value,&#13;
            offset: presenter.configuration.offset.value,&#13;
            collision: 'flip'&#13;
        });&#13;
    }&#13;
&#13;
    function shiftKeyboard(keyboard, isVisibleInViewPort) {&#13;
        if (!isVisibleInViewPort.horizontal) {&#13;
            var currentLeft = parseInt(keyboard['$keyboard'].css('left'), 10);&#13;
            keyboard['$keyboard'].css('left', currentLeft + parseInt(isVisibleInViewPort.horizontalSign + '10', 10));&#13;
        }&#13;
        if (!isVisibleInViewPort.vertical) {&#13;
            var currentTop = parseInt(keyboard['$keyboard'].css('top'), 10);&#13;
            keyboard['$keyboard'].css('top', currentTop + parseInt(isVisibleInViewPort.verticalSign + '10', 10));&#13;
        }&#13;
    }&#13;
&#13;
    function getIsVisibleInViewPort(element) {&#13;
        var $window = $(window);&#13;
&#13;
        if (this.length &lt; 1)&#13;
            return;&#13;
&#13;
        if ($(element).length == 0) {&#13;
            return;&#13;
        }&#13;
&#13;
        var $element = $(element),&#13;
            vpWidth = $window.width(),&#13;
            vpHeight = $window.height(),&#13;
            viewTop = $window.scrollTop(),&#13;
            viewBottom = viewTop + vpHeight,&#13;
            viewLeft = $window.scrollLeft(),&#13;
            viewRight = viewLeft + vpWidth,&#13;
            offset = $element.offset(),&#13;
            _top = offset.top,&#13;
            _bottom = _top + $element.height(),&#13;
            _left = offset.left,&#13;
            _right = _left + $element.width();&#13;
&#13;
        return {&#13;
            vertical: ((_bottom &lt;= viewBottom) &amp;&amp; (_top &gt;= viewTop)),&#13;
            horizontal: ((_right &lt;= viewRight) &amp;&amp; (_left &gt;= viewLeft)),&#13;
            verticalSign: _bottom &lt;= viewBottom ? '' : '-',&#13;
            horizontalSign: _right &lt;= viewRight ? '' : '-'&#13;
        };&#13;
    }&#13;
&#13;
    function onEscClick() {&#13;
        closeButtonCallBack();&#13;
&#13;
        openButtonElement.style.display = 'block';&#13;
        actualizeOpenButtonPosition($(lastClickedElement));&#13;
    }&#13;
&#13;
    presenter.run = function(view, model){&#13;
        runLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.setShowErrorsMode = function(){&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        if (presenter.configuration.isError) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            'open' : presenter.openCommand,&#13;
            'disable' : presenter.disable,&#13;
            'enable' : presenter.enable,&#13;
            'showCloseButton' : presenter.showCloseButton&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.showCloseButton = function () {&#13;
        presenter.isShowCloseButton = true;&#13;
    };&#13;
&#13;
    presenter.disable = function (){&#13;
        asyncFunctionDecorator(presenter.disableFunc.bind(this));&#13;
    };&#13;
&#13;
    presenter.disableFunc = function () {&#13;
        presenter.sendEvent("disable");&#13;
        if (presenter.configuration.openOnFocus) {&#13;
            keyboardIsVisible = false;&#13;
        }&#13;
&#13;
        presenter.configuration.$inputs.each(function (index, element) {&#13;
            try {&#13;
                $(element).data('keyboard').destroy();&#13;
            } catch(err){}&#13;
        });&#13;
&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
&#13;
        presenter.configuration.$inputs.on('focusout', focusoutCallBack);&#13;
        presenter.configuration.$inputs.removeClass('ui-keyboard-input ui-keyboard-input-current');&#13;
        presenter.configuration.$inputs.removeAttr("readonly");&#13;
        presenter.configuration.$inputs.removeAttr("inputmode");&#13;
    };&#13;
&#13;
    presenter.enable = function () {&#13;
        asyncFunctionDecorator(presenter.enableFunc.bind(this));&#13;
    };&#13;
&#13;
    presenter.enableFunc = function () {&#13;
        presenter.sendEvent("enable");&#13;
        keyboardIsVisible = true;&#13;
        $(presenter.configuration.workWithViews).find('input').off('focusout', focusoutCallBack);&#13;
    };&#13;
&#13;
    presenter.open = function (moduleId, index) {&#13;
        asyncFunctionDecorator(presenter.openFunc.bind(this, moduleId, index));&#13;
    };&#13;
&#13;
    presenter.openFunc = function(moduleId, index) {&#13;
        var module = presenter.playerController.getModule(moduleId);&#13;
        try {&#13;
            var input = $(module.getView()).find('input:enabled').get(parseInt(index, 10) - 1);&#13;
            presenter.createEKeyboard(input, presenter.display);&#13;
            $(input).data('keyboard').reveal();&#13;
        } catch (e) {&#13;
        }&#13;
&#13;
    };&#13;
&#13;
    presenter.openCommand = function(moduleId, index) {&#13;
        if ($.isArray(moduleId)) {&#13;
            presenter.open(moduleId[0], moduleId[1]);&#13;
        } else {&#13;
            presenter.open(moduleId, index);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.sendEvent = function (status) {&#13;
        presenter.eventBus.sendEvent('ValueChanged', {&#13;
            'source': presenter.configuration.ID,&#13;
            'item': '',&#13;
            'value': status&#13;
        });&#13;
    };&#13;
&#13;
&#13;
&#13;
&#13;
    presenter.destroy = function destroy_addon_eKeyboard_function () {&#13;
        if (presenter.isPreview || !presenter.configuration) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.$inputs.off('focusout', focusoutCallBack);&#13;
&#13;
        presenter.configuration.$inputs.each(function (index, element){&#13;
            try {&#13;
                $(element).data('keyboard').destroy();&#13;
                $(element).off('focusout change paste keyup forceClick focus mousedown');&#13;
            } catch(err){}&#13;
        });&#13;
&#13;
        document.removeEventListener('mousedown', presenter.clickedOutsideCallback);&#13;
        presenter.view.removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        $(presenter.keyboardWrapper).remove();&#13;
        $(openButtonElement).remove();&#13;
    };&#13;
&#13;
    presenter.setWorkMode = function(){&#13;
    };&#13;
&#13;
    presenter.reset = function(){&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function(){&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function(){&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getScore = function(){&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            "isClosed": keyboardIsVisible,&#13;
            "isShowCloseButton": presenter.isShowCloseButton&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        var parsedState = JSON.parse(state);&#13;
        keyboardIsVisible = parsedState.isClosed;&#13;
&#13;
        if(parsedState.isShowCloseButton != undefined) {&#13;
            presenter.isShowCloseButton = parsedState.isShowCloseButton;&#13;
        }&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>