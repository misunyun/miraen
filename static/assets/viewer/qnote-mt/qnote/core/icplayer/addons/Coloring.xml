<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Coloring" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property displayName="Image" name="Image" nameLabel="Coloring_property_image" type="image"/>
        <property displayName="Areas" name="Areas" nameLabel="Coloring_property_areas" type="text"/>
        <property displayName="Default Filling Color" name="DefaultFillingColor" nameLabel="Coloring_property_default_filling_color" type="string"/>
        <property displayName="Colors" name="colors" nameLabel="Coloring_property_colors" type="list">
            <property displayName="Description" isLocalized="true" name="speechText" nameLabel="Coloring_property_description" type="string"/>
            <property displayName="Color RGBA" name="colorRGBA" nameLabel="Coloring_property_color" type="string"/>
        </property>
        <property displayName="Tolerance" name="Tolerance" nameLabel="Coloring_property_tolerance" type="string"/>
        <property displayName="Is Not Activity" name="isNotActivity" nameLabel="Coloring_property_is_not_activity" type="boolean"/>
        <property displayName="Is Disabled" name="isDisabled" nameLabel="Coloring_property_is_disabled" type="boolean"/>
        <property displayName="Disable fill on click" name="disableFill" nameLabel="Coloring_property_disable_fill" type="boolean"/>
        <property displayName="Color correct" name="colorCorrect" nameLabel="Coloring_property_color_correct" type="boolean"/>
        <property displayName="Show all answers in gradual show answers mode" name="showAllAnswersInGradualShowAnswersMode" nameLabel="Coloring_property_show_all_answers_in_gradual_show_answers_mode" type="boolean"/>
        <property displayName="Speech texts" name="speechTexts" nameLabel="Coloring_property_speech_texts" type="staticlist">
            <property name="Area" nameLabel="Coloring_speech_text_area" type="staticrow">
                    <property name="Area" nameLabel="Coloring_speech_text_area" type="string"/>
            </property>
            <property name="Color" nameLabel="Coloring_speech_text_color" type="staticrow">
                    <property name="Color" nameLabel="Coloring_speech_text_color" type="string"/>
            </property>
            <property name="Selected" nameLabel="Coloring_speech_text_selected" type="staticrow">
                    <property name="Selected" nameLabel="Coloring_speech_text_selected" type="string"/>
            </property>
            <property name="Correct" nameLabel="Coloring_speech_text_correct" type="staticrow">
                    <property name="Correct" nameLabel="Coloring_speech_text_correct" type="string"/>
            </property>
            <property name="Incorrect" nameLabel="Coloring_speech_text_incorrect" type="staticrow">
                    <property name="Incorrect" nameLabel="Coloring_speech_text_incorrect" type="string"/>
            </property>
        </property>
        <property displayName="Lang attribute" name="langAttribute" nameLabel="Coloring_property_lang_attribute" type="string"/>
    </model>
<css>.coloring-wrapper .coloring-container canvas {&#13;
    display: table;&#13;
    margin: auto;&#13;
}&#13;
&#13;
.coloring-wrapper {&#13;
    display: table;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
    overflow: hidden;&#13;
    outline: none;&#13;
}&#13;
&#13;
.coloring-circle-mark {&#13;
    background-color: transparent;&#13;
    width: 20px;&#13;
    height: 20px;&#13;
    border-radius: 100%;&#13;
    border: 1mm solid lightblue;&#13;
    position : absolute;&#13;
}&#13;
&#13;
.coloring-color-list {&#13;
    display: flex;&#13;
    justify-content: center;&#13;
    gap: 2px;&#13;
    background-color: white;&#13;
    box-shadow: 0px 0.2px 0px 0.2px grey;&#13;
    align-items: center;&#13;
    align-content: center;&#13;
    flex-direction: column;&#13;
    position : absolute;&#13;
}&#13;
&#13;
.coloring-color-list-element {&#13;
    display: flex;&#13;
    min-width: 80px;&#13;
    padding: 5px;&#13;
    justify-content: center;&#13;
    align-items: center;&#13;
    align-content: center;&#13;
    background-color: white;&#13;
    box-shadow: 0px 0.2px 0px 0.2px grey;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container {&#13;
    display: table-cell;&#13;
    vertical-align: middle;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container {&#13;
    border: 1px solid #111111;&#13;
    border-radius: 50%;&#13;
    font-size: 10px;&#13;
    height: 8px;&#13;
    line-height: 6px;&#13;
    padding: 2px;&#13;
    position: absolute;&#13;
    width: 8px;&#13;
    font-weight: bold;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.wrong {&#13;
    background-color: #ff5599;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.correct {&#13;
    background-color: #55ff99;&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.correct:after {&#13;
    content: 'v';&#13;
}&#13;
&#13;
.coloring-wrapper .coloring-container .icon-container.wrong:after {&#13;
    content: 'x';&#13;
}&#13;
</css><view>&lt;div class="coloring-wrapper"&gt;&#13;
    &lt;div class="coloring-container"&gt;&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="coloring-wrapper"&gt;&#13;
    &lt;div class="coloring-container"&gt;&#13;
&#13;
    &lt;/div&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonColoring_create(){&#13;
    /*&#13;
        KNOWN ISSUES:&#13;
            Areas - property validation - backward compatibility:&#13;
                Co-ordinates X &amp; Y:&#13;
                    Due to invalid validation, those values can be negative numbers or non-numbers strings. The addon behavior is to&#13;
                    display image, pass the validation and just do nothing. Browser probably will throw a small stack trace with function's&#13;
                    referring to getImageData on canvas. You shouldn't broke this invalid validation due to backward compatibility&#13;
                Transparent color:&#13;
                    It's have been added with validation : only numbers between range 0-255, without inproper strings&#13;
&#13;
            Default Filling Color - backward compatibility:&#13;
                Empty string:&#13;
                    Default color is [255, 100, 100, 255], when provided string is just empty one.&#13;
&#13;
    * */&#13;
&#13;
    var presenter = function(){};&#13;
&#13;
    presenter.playerController = null;&#13;
    presenter.eventBus = null;&#13;
    presenter.lastEvent = null;&#13;
    presenter.imageHasBeenLoaded = false;&#13;
    presenter.keyboardControllerObject = null;&#13;
    presenter.colorSpeechTextMap = {};&#13;
    presenter.isTTSExitBlocked = false;&#13;
    presenter.initialState = null;&#13;
    presenter.isCanvasInitiated = false;&#13;
    presenter.defaultColorRGBA = [255, 100, 100, 255];&#13;
    presenter.whiteRGBA = [255, 255, 255, 255];&#13;
&#13;
    presenter.AREA_TYPE = {&#13;
        NORMAL: 0,&#13;
        TRANSPARENT: 1,&#13;
        USER_AREA: 2&#13;
    };&#13;
&#13;
    presenter.DEFAULT_TTS_PHRASES = {&#13;
        area: "Area",&#13;
        color: "Color",&#13;
        selected: "Selected",&#13;
        correct: "Correct",&#13;
        incorrect: "Incorrect",&#13;
    };&#13;
&#13;
    presenter.errorCodes = {&#13;
        'E01': 'Wrong color notation. Must be in "r g b a" format. See documentation for more details.',&#13;
        'E02': 'All color values must be between 0 - 255.',&#13;
        'E03': 'Areas are configured wrong. It should be in "x; y; color; optional TTS description" format. See documentation for more details.',&#13;
        'E04': 'Areas x &amp; y values have to be smaller than Width and Height properties.',&#13;
        'E05': 'Tolerance value must be between 0 - 100',&#13;
        'E06': 'Areas are configured wrong. Color has an invalid value, or TTS description is not properly separated. See documentation for more details',&#13;
        'E07': 'Colors property is configured wrong. "Description" field must not be empty.',&#13;
        'A01': "Areas x &amp; y values have to be integer values between 0 - 255."&#13;
    };&#13;
&#13;
    function getErrorObject (errorCode) { return { isValid: false, isError: true, errorCode }; }&#13;
    function getCorrectObject (value) { return { isValid: true, isError: false, value }; }&#13;
&#13;
    function areaObject(x, y, type) {&#13;
        this.x = x;&#13;
        this.y = y;&#13;
        this.type = type;&#13;
        this.defaultColor;&#13;
        this.pixelPosition;&#13;
        this.colorToFill = [];&#13;
&#13;
        this.getColor = function () {&#13;
            return presenter.getColorAtPoint(this.x, this.y);&#13;
        };&#13;
&#13;
        this.setPixelPosition = function () {&#13;
            this.pixelPosition = ((this.x + this.y * presenter.canvasWidth) * 4);&#13;
        };&#13;
    }&#13;
&#13;
    presenter.createPreview = function(view, model){&#13;
        runLogic(view, model, true);&#13;
    };&#13;
&#13;
    function setColorsThatCanBeFilled() {&#13;
        var configuration = presenter.configuration;&#13;
        configuration.colorsThatCanBeFilled = [];&#13;
        const wholeCanvas = presenter.ctx.getImageData(0, 0, presenter.canvasWidth, presenter.canvasHeight).data;&#13;
        const areas = configuration.areas;&#13;
&#13;
        for (var i = areas.length; i--;) {&#13;
            let area = areas[i];&#13;
            let color = getColorAtPointFromCanvas(area.x, area.y, wholeCanvas);&#13;
            if (!presenter.isAlreadyInColorsThatCanBeFilled(color)) {&#13;
                configuration.colorsThatCanBeFilled.push(color);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
&#13;
        presenter.runEndedDeferred = new $.Deferred();&#13;
        presenter.runEnded = presenter.runEndedDeferred.promise();&#13;
&#13;
        presenter.eventBus = controller.getEventBus();&#13;
    };&#13;
&#13;
    presenter.createEventData = function (item, value, score) {&#13;
        var score;&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(score)) {&#13;
            score = "";&#13;
        } else {&#13;
            score = score ? 1 : 0;&#13;
        }&#13;
&#13;
        return {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': item.join(';'),&#13;
            'value': value.toString(),&#13;
            'score': score&#13;
        };&#13;
    };&#13;
&#13;
    presenter.sendEvent = function(item, value, score) {&#13;
        if (!presenter.isShowAnswersActive &amp;&amp; !presenter.isShowErrorsModeActive) {&#13;
            var eventData = presenter.createEventData(item, value, score);&#13;
            presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
&#13;
            if (presenter.isAllOK()) sendAllOKEvent();&#13;
        }&#13;
    };&#13;
&#13;
    function sendAllOKEvent() {&#13;
        var eventData = {&#13;
            'source': presenter.configuration.addonID,&#13;
            'item': 'all',&#13;
            'value': '',&#13;
            'score': ''&#13;
        };&#13;
&#13;
        presenter.eventBus.sendEvent('ValueChanged', eventData);&#13;
    }&#13;
&#13;
    function setAreasDefaultColors() {&#13;
        var configuration = presenter.configuration;&#13;
        $.each(configuration.areas, function() {&#13;
            this.defaultColor = presenter.getColorAtPoint(this.x, this.y);&#13;
        });&#13;
    }&#13;
&#13;
    function setAreasPixelPosition() {&#13;
        var configuration = presenter.configuration;&#13;
        $.each(configuration.areas, function() {&#13;
            this.pixelPosition = (this.x + this.y * presenter.canvasWidth) * 4;&#13;
        });&#13;
    }&#13;
&#13;
    function getClickedArea(clickObject) {&#13;
        var configuration = presenter.configuration;&#13;
        var clickedArea = new areaObject(clickObject.x, clickObject.y, presenter.AREA_TYPE.USER_AREA);&#13;
        clickedArea.setPixelPosition();&#13;
        clickedArea.colorToFill = presenter.whiteRGBA;&#13;
&#13;
        for(var i = 0; i &lt; configuration.areas.length; i++) {&#13;
            var area = configuration.areas[i];&#13;
&#13;
            if(isAreaColored(area)) {&#13;
                presenter.allColoredPixels = [];&#13;
                return area;&#13;
            }&#13;
        }&#13;
&#13;
        if (presenter.configuration.userAreas == undefined) {&#13;
            presenter.configuration.userAreas = [];&#13;
        }&#13;
&#13;
        if (!isUserAreaExists()) {&#13;
            presenter.configuration.userAreas.push(clickedArea);&#13;
        }&#13;
&#13;
        presenter.allColoredPixels = [];&#13;
        return clickedArea;&#13;
    }&#13;
&#13;
    function isUserAreaExists() {&#13;
        var userAreas = presenter.configuration.userAreas;&#13;
        for(var i = 0; i &lt; userAreas.length; i++) {&#13;
            if(isAreaColored(userAreas[i])) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    function isAreaColored(area) {&#13;
        return (presenter.allColoredPixels.indexOf(area.pixelPosition) != -1);&#13;
    }&#13;
&#13;
    presenter.clearArea = function (x, y, isRemovingWrongColor) {&#13;
        presenter.fillArea(x, y, '255 255 255 255', isRemovingWrongColor);&#13;
    };&#13;
&#13;
    presenter.fillArea = function (x, y, color, isRemovingWrongColor) {&#13;
        presenter.isColored = true;&#13;
&#13;
        presenter.click = {&#13;
            x: parseInt(x, 10),&#13;
            y: parseInt(y, 10)&#13;
        };&#13;
&#13;
        presenter.click.color = presenter.getColorAtPoint(presenter.click.x, presenter.click.y);&#13;
&#13;
        if (color == undefined) {&#13;
            presenter.fillColor = presenter.configuration.currentFillingColor;&#13;
        } else {&#13;
            var validatedDefaultFillingColor = presenter.validateColor(color);&#13;
            if (validatedDefaultFillingColor.isError) {&#13;
                DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, validatedDefaultFillingColor.errorCode);&#13;
                return;&#13;
            }&#13;
            presenter.fillColor = validatedDefaultFillingColor.value;&#13;
        }&#13;
&#13;
        if ( presenter.isAlreadyInColorsThatCanBeFilled(presenter.click.color) || isRemovingWrongColor) {&#13;
            if (!presenter.isShowAnswersActive &amp;&amp; !presenter.isShowErrorsModeActive) {&#13;
                presenter.floodFill(&#13;
                    presenter.click,&#13;
                    presenter.fillColor,&#13;
                    presenter.configuration.tolerance&#13;
                );&#13;
            }&#13;
&#13;
            if (!presenter.isAlreadyInColorsThatCanBeFilled(presenter.fillColor)) {&#13;
                presenter.configuration.colorsThatCanBeFilled.push(presenter.fillColor)&#13;
            }&#13;
        }&#13;
&#13;
        presenter.allColoredPixels = [];&#13;
    };&#13;
&#13;
    presenter.checkIfColoredCorrectly = function () {&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            var area = this;&#13;
&#13;
            if(!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                return true; // continue&#13;
            }&#13;
&#13;
            if (!isCorrect(area)) {&#13;
                    var r = area.colorToFill[0],&#13;
                        g = area.colorToFill[1],&#13;
                        b = area.colorToFill[2],&#13;
                        a = area.colorToFill[3],&#13;
                        color = r + " " + g + " " + b + " " + a;&#13;
                if(r != -1){&#13;
                    presenter.fillArea(area.x, area.y, color, false);&#13;
                }else{&#13;
                    presenter.fillArea(area.x, area.y, '0 0 0 0', false);&#13;
                }&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.clickLogic = function(e, isTouch) {&#13;
        e.stopPropagation();&#13;
        e.preventDefault();&#13;
&#13;
        presenter.isColored = true;&#13;
&#13;
        presenter.click = getMousePositionOnCanvas(e, isTouch);&#13;
&#13;
        presenter.click.color = presenter.getColorAtPoint(presenter.click.x, presenter.click.y);&#13;
&#13;
        if (presenter.configuration.disableFill) {&#13;
            presenter.sendEvent([presenter.click.x, presenter.click.y], '', '');&#13;
&#13;
            return false;&#13;
        }&#13;
&#13;
        if ( presenter.isAlreadyInColorsThatCanBeFilled(presenter.click.color) ) {&#13;
&#13;
            if (!presenter.isShowAnswersActive &amp;&amp; !presenter.isShowErrorsModeActive) {&#13;
                presenter.floodFill(&#13;
                    presenter.click,&#13;
                    presenter.configuration.currentFillingColor,&#13;
                    presenter.configuration.tolerance&#13;
                );&#13;
            }&#13;
&#13;
            if(!presenter.configuration.colorCorrect){&#13;
                setTimeout(function(){&#13;
                    // Without timeout there are issues on Firefox if event handling takes too long&#13;
                    presenter.userInteractionSendingEvent(getClickedArea(presenter.click));&#13;
                }, 0);&#13;
            }&#13;
&#13;
            if (!presenter.isAlreadyInColorsThatCanBeFilled(presenter.configuration.currentFillingColor)) {&#13;
                presenter.configuration.colorsThatCanBeFilled.push(presenter.configuration.currentFillingColor)&#13;
            }&#13;
        }&#13;
        if(presenter.configuration.colorCorrect){&#13;
            presenter.checkIfColoredCorrectly();&#13;
            setTimeout(function(){&#13;
                // Without timeout there are issues on Firefox if event handling takes too long&#13;
                presenter.sendEvent([presenter.click.x, presenter.click.y], presenter.configuration.isErase ? 0 : 1, 1);&#13;
            }, 0);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.userInteractionSendingEvent = function (clickedArea) {&#13;
        if (clickedArea.type == presenter.AREA_TYPE.USER_AREA) {&#13;
            presenter.sendEvent([clickedArea.x, clickedArea.y], presenter.configuration.isErase ? 0 : 1, "");&#13;
        } else {&#13;
            presenter.sendEvent([clickedArea.x, clickedArea.y], presenter.configuration.isErase ? 0 : 1, isCorrect(clickedArea) ? 1 : 0);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.recolorImage = function () {&#13;
        var imageData = presenter.ctx.getImageData(0, 0,presenter.canvasWidth, presenter.canvasHeight);&#13;
&#13;
        for (var i=0; i&lt;imageData.data.length; i+=4) {&#13;
            if (imageData.data[i]==0 &amp;&amp;&#13;
                imageData.data[i+1]==0 &amp;&amp;&#13;
                imageData.data[i+2]==0 &amp;&amp;&#13;
                imageData.data[i+3]==255&#13;
                ){&#13;
                imageData.data[i]=55;&#13;
                imageData.data[i+1]=55;&#13;
                imageData.data[i+2]=55;&#13;
                imageData.data[i+3]=255;&#13;
            }&#13;
        }&#13;
&#13;
        presenter.ctx.putImageData(imageData,0,0);&#13;
    };&#13;
&#13;
    presenter.upgradeModel = function(model) {&#13;
        let upgradedModel = presenter.upgradeShowAllAnswersInGradualShowAnswersMode(model);&#13;
        upgradedModel = presenter.upgradeColors(upgradedModel);&#13;
        upgradedModel = presenter.upgradeSpeechTexts(upgradedModel);&#13;
        upgradedModel = presenter.upgradeLangTag(upgradedModel);&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeShowAllAnswersInGradualShowAnswersMode = function AddonColoring_upgradeShowAllAnswersInGradualShowAnswersMode (model) {&#13;
        const upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model);&#13;
&#13;
        if(!upgradedModel['showAllAnswersInGradualShowAnswersMode']) {&#13;
            upgradedModel['showAllAnswersInGradualShowAnswersMode'] = false;&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.upgradeColors = function AddonColoring_upgradeColors (model) {&#13;
        const upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model);&#13;
        if (!upgradedModel['colors']) {&#13;
            upgradedModel['colors'] = [];&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeSpeechTexts = function AddonColoring_upgradeSpeechTexts (model) {&#13;
        const defaultValue = {&#13;
            Area: { Area: "" },&#13;
            Color: { Color: "" },&#13;
            Selected: { Selected: "" },&#13;
            Correct: { Correct: "" },&#13;
            Incorrect: { Incorrect: "" }&#13;
        }&#13;
&#13;
        const upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model); // Deep copy of model object&#13;
        if (model["speechTexts"] === undefined) {&#13;
            upgradedModel["speechTexts"] = defaultValue;&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.upgradeLangTag = function AddonColoring_upgradeLangTag (model) {&#13;
        const upgradedModel = {};&#13;
        jQuery.extend(true, upgradedModel, model);&#13;
        if (model["langAttribute"] === undefined) {&#13;
            upgradedModel["langAttribute"] = "";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    };&#13;
&#13;
    presenter.validateModel = function(model, isPreview) {&#13;
        const validatedAreas = model['Areas'].toString().length&#13;
            ? presenter.validateAreas(model['Areas'], isPreview, model['Width'], model['Height'])&#13;
            : getCorrectObject([]);&#13;
        if (validatedAreas.isError) return validatedAreas;&#13;
&#13;
        const validatedTolerance = model['Tolerance'].toString().length&#13;
            ? ModelValidationUtils.validateIntegerInRange(model['Tolerance'], 100, 0)&#13;
            : getCorrectObject(50);&#13;
         if (!validatedTolerance.isValid) return getErrorObject('E05');&#13;
&#13;
        const validatedDefaultFillingColor = model['DefaultFillingColor'].toString().length&#13;
            ? presenter.validateColor(model['DefaultFillingColor'])&#13;
            : getCorrectObject(presenter.defaultColorRGBA);&#13;
        if (validatedDefaultFillingColor.isError) return validatedDefaultFillingColor;&#13;
&#13;
        const validatedColors = presenter.validateColors(model['colors']);&#13;
        const colorsError = validatedColors.find(colorObject =&gt; colorObject.isError);&#13;
        if (colorsError) return colorsError;&#13;
&#13;
        const validatedIsVisible = ModelValidationUtils.validateBoolean(model['Is Visible']);&#13;
        const validatedIsDisabled = ModelValidationUtils.validateBoolean(model['isDisabled']);&#13;
&#13;
        return {&#13;
            'isValid': true,&#13;
            'isError': false,&#13;
            'addonID' : model['ID'],&#13;
&#13;
            'imageFile': model.Image,&#13;
            'areas' : validatedAreas.value,&#13;
            'tolerance' : validatedTolerance.value,&#13;
            'currentFillingColor' : validatedDefaultFillingColor.value,&#13;
            'defaultFillingColor' : validatedDefaultFillingColor.value,&#13;
            'colors' : validatedColors,&#13;
            'isErase' : false,&#13;
            'isVisible' : validatedIsVisible,&#13;
            'isVisibleByDefault' : validatedIsVisible,&#13;
            'isDisabled' : validatedIsDisabled,&#13;
            'isDisabledByDefault' : validatedIsDisabled,&#13;
            'isActivity' : !(ModelValidationUtils.validateBoolean(model['isNotActivity'])),&#13;
            'lastUsedColor' : validatedDefaultFillingColor.value,&#13;
            'disableFill' : ModelValidationUtils.validateBoolean(model['disableFill']),&#13;
            'colorCorrect' : ModelValidationUtils.validateBoolean(model.colorCorrect),&#13;
            'showAllAnswersInGradualShowAnswersMode' : ModelValidationUtils.validateBoolean(model.showAllAnswersInGradualShowAnswersMode),&#13;
            'langTag': model.langAttribute&#13;
        }&#13;
    };&#13;
&#13;
    presenter.validateAreas = function(areasText, isPreview, modelWidth, modelHeight) {&#13;
        modelWidth = parseInt(modelWidth, 10);&#13;
        modelHeight = parseInt(modelHeight, 10);&#13;
        const areas = Helpers.splitLines(areasText)&#13;
            .map(element =&gt; element.split(';'))&#13;
            .map(element =&gt; presenter.validateArea(element, isPreview, modelWidth, modelHeight));&#13;
&#13;
        const errors = areas.filter(element =&gt; element.isError);&#13;
        if (errors.length) {&#13;
            return errors[0];&#13;
        }&#13;
&#13;
        return getCorrectObject(areas);&#13;
    };&#13;
&#13;
    presenter.validateArea = function(element, isPreview, modelWidth, modelHeight) {&#13;
        if (element.length === 3 || element.length === 4) {&#13;
            const trimmedArray = element.map(value =&gt; value.trim());&#13;
            if (presenter.isTransparent(trimmedArray)) {&#13;
                return presenter.parseTransparentArea(trimmedArray);&#13;
            }&#13;
            const area = {&#13;
                x: parseInt(trimmedArray[0], 10),&#13;
                y: parseInt(trimmedArray[1], 10),&#13;
                type: presenter.AREA_TYPE.NORMAL,&#13;
                speechText: trimmedArray[3] ? trimmedArray[3] : presenter.speechTexts.Area,&#13;
            };&#13;
&#13;
            if (isPreview &amp;&amp; (area.x &gt;= modelWidth || area.y &gt;= modelHeight)) {&#13;
                return getErrorObject('E04');&#13;
            }&#13;
&#13;
            const validatedColor = presenter.validateColor(trimmedArray[2]);&#13;
            if (validatedColor.isError) return getErrorObject("E06");&#13;
&#13;
            area.colorToFill = validatedColor.value;&#13;
            area.isError = false;&#13;
            return area;&#13;
        }&#13;
        return getErrorObject('E03');&#13;
    }&#13;
&#13;
&#13;
    presenter.isTransparent = function (value) {&#13;
        return value[2] === "transparent";&#13;
    };&#13;
&#13;
    presenter.parseTransparentArea = function (splittedAreaArray) {&#13;
        const area = {&#13;
            x: parseInt(Number(splittedAreaArray[0])),&#13;
            y: parseInt(Number(splittedAreaArray[1])),&#13;
            type: presenter.AREA_TYPE.TRANSPARENT,&#13;
            colorToFill: [-1, -1, -1, -1],&#13;
            speechText: splittedAreaArray[3] ? splittedAreaArray[3] : presenter.speechTexts.Area&#13;
        };&#13;
&#13;
        if (isNaN(area.x) || isNaN(area.y)) {&#13;
            return getErrorObject("A01");&#13;
        }&#13;
        if (area.x &lt; 0 || area.y &lt; 0) {&#13;
            return getErrorObject("A01");&#13;
        }&#13;
&#13;
        area.isError = false;&#13;
&#13;
        return area;&#13;
    };&#13;
&#13;
    presenter.validateColor = function(spaceSeparatedColor) {&#13;
        const splitted = spaceSeparatedColor.split(' '),&#13;
            validatedColors = [];&#13;
&#13;
        if (splitted.length !== 4) {&#13;
            return getErrorObject('E01');&#13;
        }&#13;
&#13;
        let areAllValuesInRange = true;&#13;
        $.each(splitted, function() {&#13;
            const validated = ModelValidationUtils.validateIntegerInRange(this, 255, 0);&#13;
            if (!validated.isValid) {&#13;
                areAllValuesInRange = false;&#13;
                return;&#13;
            }&#13;
            validatedColors.push(validated.value);&#13;
        });&#13;
&#13;
        if (!areAllValuesInRange) {&#13;
            return getErrorObject('E02');&#13;
        }&#13;
&#13;
        return getCorrectObject(validatedColors);&#13;
    };&#13;
&#13;
    presenter.validateColors = function (colorsModel) {&#13;
        return colorsModel&#13;
            .filter(colorObject =&gt; colorObject?.colorRGBA.length || colorObject?.speechText.length)&#13;
            .map(colorObject =&gt; {&#13;
                const colorValidation = presenter.validateColor(colorObject.colorRGBA)&#13;
                const speechText = colorObject.speechText?.length&#13;
                    ? colorObject.speechText&#13;
                    : getErrorObject("E07");&#13;
&#13;
                if (colorValidation.isError) return colorValidation;&#13;
                if (speechText.isError) return speechText;&#13;
&#13;
                return {&#13;
                        speechText,&#13;
                        colorRGBA: colorValidation.value&#13;
                    }&#13;
            });&#13;
    }&#13;
&#13;
    function runLogic(view, model, isPreview) {&#13;
        model = presenter.upgradeModel(model);&#13;
        presenter.setSpeechTexts(model["speechTexts"]);&#13;
&#13;
        presenter.configuration = presenter.validateModel(model, isPreview);&#13;
        presenter.createColorSpeechTextsMap(presenter.configuration.colors);&#13;
        presenter.allColoredPixels = [];&#13;
        presenter.currentAreaIdInGSAMode = 0;&#13;
&#13;
        if (presenter.configuration.isError) {&#13;
            DOMOperationsUtils.showErrorMessage($(view), presenter.errorCodes, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.$view = $(view);&#13;
        presenter.setVisibility(presenter.configuration.isVisible || isPreview);&#13;
        presenter.setImageElement(isPreview);&#13;
        presenter.buildKeyboardController();&#13;
    }&#13;
&#13;
    presenter.createColorSpeechTextsMap = function(colors) {&#13;
        if (!colors) return;&#13;
        const whiteRGBAString = presenter.getRGBAStringFromRGBAArray(presenter.whiteRGBA);&#13;
        presenter.colorSpeechTextMap = colors.reduce((prev, curr) =&gt; {&#13;
            const color = presenter.getRGBAStringFromRGBAArray(curr.colorRGBA);&#13;
            if (color === whiteRGBAString) return prev;&#13;
            return {&#13;
                ...prev,&#13;
                [color] : curr.speechText&#13;
            }&#13;
        }, {});&#13;
    }&#13;
&#13;
    presenter.setImageElement = function (isPreview) {&#13;
        const imageElement = $('&lt;img&gt;');&#13;
&#13;
        if(presenter.configuration.imageFile.indexOf("/file/serve") === 0){&#13;
            presenter.configuration.imageFile = presenter.configuration.imageFile + "?no_gcs=true";&#13;
        }&#13;
&#13;
        imageElement.attr('src', presenter.configuration.imageFile);&#13;
&#13;
        const canvasElement = $('&lt;canvas&gt;&lt;/canvas&gt;');&#13;
        presenter.ctx = canvasElement[0].getContext('2d');&#13;
&#13;
        imageElement.load(function() {&#13;
            canvasElement.attr('width', imageElement[0].width);&#13;
            canvasElement.attr('height', imageElement[0].height);&#13;
            presenter.canvasWidth = imageElement[0].width;&#13;
            presenter.canvasHeight = imageElement[0].height;&#13;
            presenter.canvas = canvasElement[0];&#13;
&#13;
            presenter.ctx.drawImage(imageElement[0], 0, 0);&#13;
            presenter.imageHasBeenLoaded = true;&#13;
            presenter.imageData = presenter.ctx.getImageData(0, 0, imageElement[0].width, imageElement[0].height);&#13;
            presenter.image = imageElement;&#13;
&#13;
            const coloringContainer = presenter.$view.find('.coloring-container');&#13;
            coloringContainer.append(canvasElement);&#13;
&#13;
            presenter.canvasOffset = canvasElement.offset();&#13;
&#13;
            setColorsThatCanBeFilled();&#13;
            setAreasDefaultColors();&#13;
            setAreasPixelPosition();&#13;
&#13;
            if (isPreview) {&#13;
                const coordinatesContainer = $('&lt;div&gt;&lt;/div&gt;'),&#13;
                    xContainer = $('&lt;div&gt;x: &lt;span class="value"&gt;&lt;/span&gt;&lt;/div&gt;'),&#13;
                    yContainer = $('&lt;div&gt;y: &lt;span class="value"&gt;&lt;/span&gt;&lt;/div&gt;'),&#13;
                    coloringWrapper = presenter.$view.find('.coloring-wrapper');&#13;
&#13;
                coordinatesContainer.css({&#13;
                    'width' : 60,&#13;
                    'height' : 25,&#13;
                    'border' : '1px solid #696969',&#13;
                    'borderRadius' : '3px',&#13;
                    'position' : 'absolute',&#13;
                    'top' : 5,&#13;
                    'left' : 5,&#13;
                    'fontSize' : '9px',&#13;
                    'padding': '5px',&#13;
                    'lineHeight' : '12px'&#13;
                });&#13;
&#13;
                coordinatesContainer&#13;
                    .append(xContainer)&#13;
                    .append(yContainer);&#13;
&#13;
                coloringWrapper.append(coordinatesContainer);&#13;
                coloringWrapper.css({&#13;
                    'position' : 'relative',&#13;
                    'minHeight' : presenter.canvasHeight,&#13;
                    'minWidth' : presenter.canvasWidth&#13;
                });&#13;
&#13;
                const moduleSelector = $('.moduleSelector[data-id="'+presenter.configuration.addonID+'"]');&#13;
&#13;
                moduleSelector.on('mousemove', function(e) {&#13;
                    xContainer.find('.value').html(getMousePositionOnCanvas(e).x);&#13;
                    yContainer.find('.value').html(getMousePositionOnCanvas(e).y);&#13;
                });&#13;
&#13;
                canvasElement.on('mousemove', function(e) {&#13;
                    xContainer.find('.value').html(getMousePositionOnCanvas(e).x);&#13;
                    yContainer.find('.value').html(getMousePositionOnCanvas(e).y);&#13;
                });&#13;
            } else if (!presenter.configuration.isDisabled) {&#13;
                canvasElement.on('click', function(e) {&#13;
                    presenter.clickLogic(e);&#13;
                });&#13;
&#13;
                canvasElement.on('touchstart', function (e){&#13;
                    presenter.lastEvent = e;&#13;
                });&#13;
&#13;
                canvasElement.on('touchend', function (e){&#13;
                    if (presenter.lastEvent.type != e.type) {&#13;
                        presenter.clickLogic(e, true);&#13;
                    }&#13;
                });&#13;
&#13;
                presenter.recolorImage();&#13;
                presenter.runEndedDeferred.resolve();&#13;
                presenter.isCanvasInitiated = true;&#13;
            }&#13;
        });&#13;
    }&#13;
&#13;
    presenter.setSpeechTexts = function AddonColoring_setSpeechTexts(speechTexts) {&#13;
        presenter.speechTexts = {&#13;
            ...presenter.DEFAULT_TTS_PHRASES&#13;
        };&#13;
&#13;
        if (!speechTexts || $.isEmptyObject(speechTexts)) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.speechTexts = {&#13;
            area: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Area.Area,&#13;
                presenter.speechTexts.area),&#13;
            color: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Color.Color,&#13;
                presenter.speechTexts.color),&#13;
            selected: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Selected.Selected,&#13;
                presenter.speechTexts.selected),&#13;
            correct: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Correct.Correct,&#13;
                presenter.speechTexts.correct),&#13;
            incorrect: TTSUtils.getSpeechTextProperty(&#13;
                speechTexts.Incorrect.Incorrect,&#13;
                presenter.speechTexts.incorrect)&#13;
        };&#13;
    };&#13;
&#13;
    presenter.run = function(view, model){&#13;
        runLogic(view, model, false);&#13;
&#13;
        var events = ['ShowAnswers', 'HideAnswers', 'GradualShowAnswers', 'GradualHideAnswers'];&#13;
        for (let i = 0; i &lt; events.length; i++) {&#13;
            presenter.eventBus.addEventListener(events[i], this);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isAlreadyInColorsThatCanBeFilled = function(color) {&#13;
        for (let i = 0; i &lt; presenter.configuration.colorsThatCanBeFilled.length; i++) {&#13;
            if (presenter.compareArrays(color, presenter.configuration.colorsThatCanBeFilled[i])) {&#13;
                return true;&#13;
            }&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.compareArrays = function(array1, array2) {&#13;
        // if the other array is a falsy value, return&#13;
        if (!array2)&#13;
            return false;&#13;
&#13;
        // compare lengths - can save a lot of time&#13;
        if (array1.length != array2.length)&#13;
            return false;&#13;
&#13;
        for (var i = 0, l=array1.length; i &lt; l; i++) {&#13;
            if (array1[i] != array2[i] &amp;&amp; (array1[i]+1) != array2[i] &amp;&amp; (array1[i]-1) != array2[i]) {&#13;
                //Due to the lossy nature of converting to and from premultiplied alpha color values,&#13;
                // pixels that have just been set using putImageData() might be returned to an equivalent getImageData() as different values. http://www.w3.org/TR/2dcontext/#dom-context-2d-getimagedata&#13;
                // Warning - two different object instances will never be equal: {x:20} != {x:20}&#13;
                return false;&#13;
            }&#13;
        }&#13;
        return true;&#13;
    };&#13;
&#13;
    presenter.getColorAtPoint = function(x, y) {&#13;
        var data = presenter.ctx.getImageData(x, y, 1, 1).data,&#13;
            color = [];&#13;
        for (var i = 0; i &lt; data.length; i++) {&#13;
            color.push(data[i]);&#13;
        }&#13;
        return color;&#13;
    };&#13;
&#13;
    function getColorAtPointFromCanvas (x, y, canvas) {&#13;
        // canvas is flat - 1 dimensional&#13;
        // data is flatened by going through whole X axis before incrementing Y axis - e.g. (x:1,y:0),(x:2,y:0) etc.&#13;
        // so to jump to desired position of pixel (Y:area.y, X:area.x) we need to multiply by width - that gives us desired row&#13;
        // and then add X position (area.x) - that gives us desired column&#13;
        // multiply by 4 is because wholeCanvas doesnt store px but R,G,B,A values, so each px takes 4 places in Canvas array&#13;
        let index = (y * presenter.canvasWidth + x ) * 4;&#13;
        let color = [&#13;
          canvas[index],     //R&#13;
          canvas[index + 1], //G&#13;
          canvas[index + 2], //B&#13;
          canvas[index + 3]  //A&#13;
        ];&#13;
        return color;&#13;
    }&#13;
&#13;
    function fixTouch (touch) {&#13;
        var winPageX = window.pageXOffset,&#13;
            winPageY = window.pageYOffset,&#13;
            x = touch.clientX,&#13;
            y = touch.clientY;&#13;
&#13;
        if (touch.pageY === 0 &amp;&amp; Math.floor(y) &gt; Math.floor(touch.pageY) ||&#13;
            touch.pageX === 0 &amp;&amp; Math.floor(x) &gt; Math.floor(touch.pageX)) {&#13;
            // iOS4 clientX/clientY have the value that should have been&#13;
            // in pageX/pageY. While pageX/page/ have the value 0&#13;
            x = x - winPageX;&#13;
            y = y - winPageY;&#13;
        } else if (y &lt; (touch.pageY - winPageY) || x &lt; (touch.pageX - winPageX) ) {&#13;
            // Some Android browsers have totally bogus values for clientX/Y&#13;
            // when scrolling/zooming a page. Detectable since clientX/clientY&#13;
            // should never be smaller than pageX/pageY minus page scroll&#13;
            x = touch.pageX - winPageX;&#13;
            y = touch.pageY - winPageY;&#13;
        }&#13;
&#13;
        return {&#13;
            x: x,&#13;
            y: y&#13;
        };&#13;
    }&#13;
&#13;
    function getMousePositionOnCanvas(e, isTouch) {&#13;
        var rect = presenter.canvas.getBoundingClientRect(),&#13;
            client = {&#13;
                x: e.clientX,&#13;
                y: e.clientY&#13;
            };&#13;
&#13;
        if (isTouch) {&#13;
            client = fixTouch(event.touches[0] || event.changedTouches[0]);&#13;
        }&#13;
&#13;
        var positionX = parseInt(client.x - rect.left, 10);&#13;
        var positionY = parseInt(client.y - rect.top, 10);&#13;
        var scaledPoint = scalePoint({x: positionX, y: positionY});&#13;
&#13;
        return {x: scaledPoint.x, y: scaledPoint.y};&#13;
    }&#13;
&#13;
    presenter.show = function() {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function() {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.disable = function() {&#13;
        presenter.configuration.isDisabled = true;&#13;
        $(presenter.canvas).off('click touchstart touchend');&#13;
        $(presenter.canvas).on('click touchstart touchend', function(e) {&#13;
            e.stopPropagation();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.enable = function() {&#13;
        presenter.configuration.isDisabled = false;&#13;
        $(presenter.canvas).off('click');&#13;
        $(presenter.canvas).on('click', function(e){&#13;
            presenter.clickLogic(e);&#13;
        });&#13;
&#13;
        $(presenter.canvas).off('touchstart');&#13;
        $(presenter.canvas).on('touchstart', function (e){&#13;
            e.stopPropagation();&#13;
            e.preventDefault();&#13;
&#13;
            presenter.lastEvent = e;&#13;
        });&#13;
&#13;
        $(presenter.canvas).off('touchend');&#13;
        $(presenter.canvas).on('touchend', function (e){&#13;
            e.stopPropagation();&#13;
            e.preventDefault();&#13;
&#13;
            if ( presenter.lastEvent.type != e.type ) {&#13;
                presenter.clickLogic(e, true);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.getView = function() {&#13;
        return presenter.$view;&#13;
    };&#13;
&#13;
    presenter.isAllOK = function() {&#13;
        var actualScore = presenter.getScore();&#13;
&#13;
        if (presenter.configuration.transparentAreaError) {&#13;
            return false;&#13;
        }&#13;
&#13;
        return actualScore === presenter.getMaxScore();&#13;
    };&#13;
&#13;
    presenter.isAttempted = function() {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        return presenter.isColored || false;&#13;
    };&#13;
&#13;
    presenter.getColor = function(x, y) {&#13;
        if (x === undefined || y === undefined) return;&#13;
&#13;
        return presenter.getColorAtPoint(x, y).join(' ');&#13;
    };&#13;
&#13;
    presenter.removeWrongColors = function () {&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            var area = this;&#13;
&#13;
            if(!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                return true; // continue&#13;
            }&#13;
&#13;
            if (!isCorrect(area)) {&#13;
                presenter.clearArea(area.x, area.y, true);&#13;
            }&#13;
        });&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'disable' : presenter.disable,&#13;
            'enable' : presenter.enable,&#13;
            'isAllOK' : presenter.isAllOK,&#13;
            'getView' : presenter.getView,&#13;
            'setColor' : presenter.setColorCommand,&#13;
            'setEraserOn' : presenter.setEraserOn,&#13;
            'isAttempted' : presenter.isAttempted,&#13;
            'showAnswers' : presenter.showAnswers,&#13;
            'hideAnswers' : presenter.hideAnswers,&#13;
            'fillArea' : presenter.fillAreaCommand,&#13;
            'clearArea' : presenter.clearAreaCommand,&#13;
            'getColor' : presenter.getColor,&#13;
            'removeWrongColors': presenter.removeWrongColors&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.setEraserOn = function() {&#13;
        presenter.configuration.isErase = true;&#13;
        presenter.configuration.lastUsedColor = presenter.configuration.currentFillingColor;&#13;
        presenter.configuration.currentFillingColor = presenter.whiteRGBA;&#13;
    };&#13;
&#13;
    presenter.clearAreaCommand = function (coordinates){&#13;
        presenter.clearArea(coordinates[0], coordinates[1], false);&#13;
    };&#13;
&#13;
    presenter.fillAreaCommand = function(coordinatesAndColor) {&#13;
        presenter.fillArea(coordinatesAndColor[0], coordinatesAndColor[1], coordinatesAndColor[2], false);&#13;
    };&#13;
&#13;
    presenter.setColorCommand = function(color) {&#13;
        presenter.setColor(color[0]);&#13;
    };&#13;
&#13;
    presenter.setColor = function(color) {&#13;
        var validatedDefaultFillingColor = presenter.validateColor(color);&#13;
        if (validatedDefaultFillingColor.isError) {&#13;
            DOMOperationsUtils.showErrorMessage(presenter.$view, presenter.errorCodes, validatedDefaultFillingColor.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.configuration.currentFillingColor = validatedDefaultFillingColor.value;&#13;
        presenter.configuration.isErase = false;&#13;
    };&#13;
&#13;
    presenter.activateErrorsMode = function () {&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity) {&#13;
            $.each(presenter.configuration.areas, function() {&#13;
                var area = this;&#13;
&#13;
                if(!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                    return true; // continue&#13;
                }&#13;
&#13;
                if (isCorrect(area)) {&#13;
                    displayIcon(area, false);&#13;
                } else {&#13;
                    displayIcon(area, true);&#13;
                }&#13;
            });&#13;
        }&#13;
&#13;
        presenter.isShowErrorsModeActive = true;&#13;
    }&#13;
&#13;
    function waitForElement(callback, timeout = 5000) {&#13;
        const startTime = Date.now();&#13;
&#13;
        let interval = setInterval(() =&gt; {&#13;
            if (!$.isEmptyObject(presenter.canvas)) {&#13;
                clearInterval(interval);&#13;
                callback();&#13;
            } else if (Date.now() - startTime &gt; timeout) {&#13;
                clearInterval(interval);&#13;
            }&#13;
        }, 100);&#13;
    }&#13;
&#13;
    presenter.setShowErrorsMode = function(){&#13;
        waitForElement(presenter.activateErrorsMode)&#13;
    };&#13;
&#13;
    function displayIcon(area, isWrong) {&#13;
        var iconContainer = $('&lt;div class="icon-container"&gt;&lt;/div&gt;'),&#13;
            container = presenter.$view.find('.coloring-container'),&#13;
            containerWidth = container.width(),&#13;
            canvasWidth = $(presenter.canvas).width(),&#13;
            leftDistance = (containerWidth-canvasWidth)/ 2,&#13;
            position = $(presenter.canvas).position(),&#13;
            top = area.y + position.top - 5, // -5 because it's half of the icon container width and height&#13;
            left = area.x + leftDistance - 5;&#13;
&#13;
        iconContainer.css({&#13;
            top: top + 'px',&#13;
            left: left + 'px'&#13;
        });&#13;
&#13;
        iconContainer.addClass(isWrong ? 'wrong' : 'correct');&#13;
&#13;
        container.append(iconContainer);&#13;
    }&#13;
&#13;
    presenter.setWorkMode = function(){&#13;
        presenter.$view.find('.icon-container').remove();&#13;
        presenter.isShowErrorsModeActive = false;&#13;
    };&#13;
&#13;
    presenter.clearCanvas = function() {&#13;
        presenter.ctx.clearRect(0, 0, presenter.canvasWidth, presenter.canvasHeight);&#13;
        presenter.ctx.drawImage(presenter.image[0], 0, 0);&#13;
    };&#13;
&#13;
    presenter.reset = function(resetOnlyWrong){&#13;
        if (resetOnlyWrong) {&#13;
            $.each(presenter.configuration.areas, function () {&#13;
                var area = this;&#13;
                if (!isCorrect(area)) {&#13;
                    presenter.clearArea(area.x, area.y, true)&#13;
                }&#13;
            });&#13;
        } else {&#13;
            presenter.clearCanvas();&#13;
        }&#13;
        presenter.removeAreaMark();&#13;
        presenter.removeColorList();&#13;
        presenter.$view.find('.icon-container').remove();&#13;
        presenter.isColored = false;&#13;
        presenter.isShowAnswersActive = false;&#13;
        presenter.isShowErrorsModeActive = false;&#13;
        presenter.configuration.isVisible = presenter.configuration.isVisibleByDefault;&#13;
        presenter.setVisibility(presenter.configuration.isVisibleByDefault);&#13;
&#13;
        presenter.configuration.isDisabled = presenter.configuration.isDisabledByDefault;&#13;
        presenter.configuration.isDisabledByDefault ? presenter.disable() : presenter.enable();&#13;
&#13;
        if (presenter.configuration.isErase) {&#13;
            presenter.configuration.currentFillingColor = presenter.configuration.lastUsedColor;&#13;
            presenter.configuration.isErase = false;&#13;
        } else {&#13;
            presenter.configuration.currentFillingColor = presenter.configuration.defaultFillingColor;&#13;
        }&#13;
&#13;
        setColorsThatCanBeFilled();&#13;
        presenter.recolorImage();&#13;
    };&#13;
&#13;
    presenter.getErrorCount = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            return presenter.currentErrorCount;&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity &amp;&amp; presenter.imageHasBeenLoaded) {&#13;
            var errorsCount = 0;&#13;
            $.each(presenter.configuration.areas, function() {&#13;
                var area = this;&#13;
&#13;
                if (!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
                    return true; // continue&#13;
                }&#13;
&#13;
                if (!isCorrect(area)) {&#13;
                    errorsCount++;&#13;
                }&#13;
            });&#13;
            return errorsCount;&#13;
        } else if (presenter.configuration.isActivity &amp;&amp; presenter.savedErrorCount) {&#13;
            return 0;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    function isCorrect(area) {&#13;
        return presenter.compareArrays(presenter.getColorAtPoint(area.x, area.y), area.colorToFill);&#13;
    }&#13;
&#13;
    presenter.shouldBeTakenIntoConsideration = function(area) {&#13;
        return !presenter.compareArrays(presenter.getColorAtPoint(area.x, area.y), area.defaultColor);&#13;
    };&#13;
&#13;
    presenter.getMaxScore = function(){&#13;
        if (presenter.configuration.isActivity) {&#13;
            var normalAreas = presenter.configuration.areas.filter(function (element) {&#13;
                   return (element.type == presenter.AREA_TYPE.NORMAL);&#13;
            });&#13;
&#13;
            return normalAreas.length;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getScoreForNormalArea = function (area) {&#13;
        if (!presenter.shouldBeTakenIntoConsideration(area)) {&#13;
            return 0; // continue&#13;
        }&#13;
&#13;
        if (isCorrect(area)) {&#13;
            return 1;&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getScoreForTransparentArea = function (area) {&#13;
&#13;
        if(!presenter.compareArrays(presenter.getColorAtPoint(area.x, area.y), area.defaultColor)) {&#13;
            presenter.configuration.transparentAreaError = true;&#13;
        }&#13;
&#13;
        return 0;&#13;
    };&#13;
&#13;
    presenter.getScore = function(){&#13;
        if (presenter.isShowAnswersActive) {&#13;
            return presenter.currentScore;&#13;
        }&#13;
&#13;
        if (presenter.configuration.isActivity &amp;&amp; presenter.imageHasBeenLoaded) {&#13;
            var scoreCount = 0;&#13;
            presenter.configuration.transparentAreaError = false;&#13;
            $.each(presenter.configuration.areas, function() {&#13;
                switch(this.type) {&#13;
                    case presenter.AREA_TYPE.NORMAL:&#13;
                        scoreCount += presenter.getScoreForNormalArea(this);&#13;
                        break;&#13;
                    case presenter.AREA_TYPE.TRANSPARENT:&#13;
                        scoreCount += presenter.getScoreForTransparentArea(this);&#13;
                        break;&#13;
                }&#13;
            });&#13;
&#13;
            return scoreCount;&#13;
        } else if (presenter.configuration.isActivity &amp;&amp; presenter.savedScore) {&#13;
            return 0;&#13;
        } else {&#13;
            return 0;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.getState = function(){&#13;
        const wasAnswersShow = presenter.isShowAnswersActive;&#13;
        const lastAreaIdInGSAMode = presenter.currentAreaIdInGSAMode;&#13;
&#13;
        if (!presenter.isCanvasInitiated &amp;&amp; presenter.initialState != null) {&#13;
            return presenter.initialState;&#13;
        }&#13;
&#13;
        if (presenter.isShowAnswersActive) {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        var filledAreas = [];&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            if (presenter.shouldBeTakenIntoConsideration(this)) {&#13;
                filledAreas.push({&#13;
                    area: this,&#13;
                    color: presenter.getColorAtPoint(this.x, this.y)&#13;
                });&#13;
            }&#13;
        });&#13;
&#13;
        var userAreas = [];&#13;
        if (presenter.configuration.userAreas != undefined) {&#13;
            userAreas = presenter.configuration.userAreas.map(function (elem) {&#13;
                return {&#13;
                    area: {x: elem.x, y: elem.y, type: elem.type, pixelPosition: elem.pixelPosition, colorToFill: elem.colorToFill},&#13;
                    color: elem.getColor()};&#13;
            });&#13;
        }&#13;
&#13;
&#13;
        var state = {&#13;
            filledAreas: filledAreas,&#13;
            currentFillingColor: presenter.configuration.currentFillingColor,&#13;
            isErase: presenter.configuration.isErase,&#13;
            colorsThatCanBeFilled: presenter.configuration.colorsThatCanBeFilled,&#13;
            isVisible: presenter.configuration.isVisible,&#13;
            isDisabled: presenter.configuration.isDisabled,&#13;
            isColored: presenter.isColored,&#13;
            score: presenter.getScore(),&#13;
            errorCount: presenter.getErrorCount(),&#13;
            userAreas: userAreas&#13;
        };&#13;
&#13;
        if (wasAnswersShow) {&#13;
            presenter.currentAreaIdInGSAMode = lastAreaIdInGSAMode;&#13;
            presenter.showAnswersAgain();&#13;
        }&#13;
&#13;
        return JSON.stringify(state);&#13;
    };&#13;
&#13;
    presenter.upgradeState = function(state) {&#13;
&#13;
        if (state.userAreas == undefined) {&#13;
            return presenter.upgradeUserAreas(state);&#13;
        }&#13;
&#13;
        return state;&#13;
    };&#13;
&#13;
    presenter.upgradeUserAreas = function(state) {&#13;
        var upgradedState = {};&#13;
        jQuery.extend(true, upgradedState, state); // Deep copy of model object&#13;
&#13;
        if(state.userAreas == undefined) {&#13;
            upgradedState["userAreas"] = [];&#13;
        }&#13;
&#13;
        return upgradedState;&#13;
    };&#13;
&#13;
    presenter.restoreUserAreasFromState = function (state) {&#13;
        presenter.configuration.userAreas = [];&#13;
&#13;
        $.each(state.userAreas, function() {&#13;
            var userArea = new areaObject(this.area.x, this.area.y, this.area.type);&#13;
            userArea.pixelPosition = this.area.pixelPosition;&#13;
            userArea.colorToFill = this.area.colorToFill;&#13;
&#13;
            presenter.configuration.userAreas.push(userArea);&#13;
        });&#13;
&#13;
    };&#13;
&#13;
    presenter.getAreasToFillFromSetState = function (state) {&#13;
        var filledAreasArray = state.filledAreas;&#13;
        filledAreasArray = filledAreasArray.concat(state.userAreas);&#13;
&#13;
        return filledAreasArray&#13;
    };&#13;
&#13;
    presenter.setCurrentFillingColorInSetState = function (state) {&#13;
        if (presenter.configuration.isErase) {&#13;
            presenter.configuration.currentFillingColor = presenter.whiteRGBA;&#13;
        } else {&#13;
            presenter.configuration.currentFillingColor = state.currentFillingColor;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.setState = function(state){&#13;
        if (!presenter.isCanvasInitiated) {&#13;
            presenter.initialState = state;&#13;
        }&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsed = JSON.parse(state);&#13;
        var upgradedState = presenter.upgradeState(parsed);&#13;
&#13;
        presenter.configuration.isErase = upgradedState.isErase;&#13;
        presenter.configuration.isVisible = upgradedState.isVisible;&#13;
        presenter.configuration.isDisabled = upgradedState.isDisabled;&#13;
        presenter.isColored = upgradedState.isColored;&#13;
        presenter.savedScore = upgradedState.score;&#13;
        presenter.savedErrorCount = upgradedState.errorCount;&#13;
&#13;
        presenter.setCurrentFillingColorInSetState(upgradedState);&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
&#13;
        presenter.restoreUserAreasFromState(upgradedState);&#13;
&#13;
        var areasToFill = presenter.getAreasToFillFromSetState(upgradedState);&#13;
&#13;
        if (upgradedState.colorsThatCanBeFilled) {&#13;
            presenter.restoreColoringAtState(areasToFill, upgradedState)&#13;
        }&#13;
    };&#13;
&#13;
    presenter.restoreColoringAtState = function (filledAreasArray, state) {&#13;
        presenter.runEnded.then(function() {&#13;
            presenter.configuration.colorsThatCanBeFilled = state.colorsThatCanBeFilled;&#13;
            $.each(filledAreasArray, presenter.restoreFilledArea);&#13;
        });&#13;
    };&#13;
&#13;
    presenter.restoreFilledArea = function (_, areaToFillObject) {&#13;
        presenter.floodFill({&#13;
            x: areaToFillObject.area.x,&#13;
            y: areaToFillObject.area.y,&#13;
            color: presenter.getColorAtPoint(areaToFillObject.area.x, areaToFillObject.area.y)&#13;
        },&#13;
&#13;
        areaToFillObject.color,&#13;
        presenter.configuration.tolerance);&#13;
        presenter.allColoredPixels = [];&#13;
    };&#13;
&#13;
    presenter.floodFill = function (position, fillColor, tolerance) {&#13;
        var img = presenter.ctx.getImageData(0, 0, presenter.canvasWidth, presenter.canvasHeight),&#13;
            surface = img.data,&#13;
            length = surface.length,&#13;
            queue = [],&#13;
            x = position.x,&#13;
            y = position.y,&#13;
            targetColor = position.color,&#13;
            startingPixel = (x + y * presenter.canvasWidth) * 4,&#13;
            east = startingPixel, west = startingPixel, rightBound, leftBound, leftEdge = presenter.canvasWidth * 4;&#13;
&#13;
        if(!pixelCompare(startingPixel, targetColor, fillColor, surface, length, tolerance).canFill) { return false; }&#13;
&#13;
        queue.push(startingPixel);&#13;
&#13;
        while(queue.length) {&#13;
            startingPixel = queue.pop();&#13;
&#13;
            if(pixelCompareAndSet(startingPixel, targetColor, fillColor, surface, length, tolerance)) {&#13;
                east = startingPixel;&#13;
                west = startingPixel;&#13;
                leftBound = parseInt(startingPixel / leftEdge) * leftEdge; //left bound&#13;
                rightBound = leftBound + leftEdge;	//right bound&#13;
                while(leftBound &lt; (west -= 4) &amp;&amp; pixelCompareAndSet(west, targetColor, fillColor, surface, length, tolerance)); //go left until edge hit&#13;
&#13;
                while(rightBound &gt; (east += 4) &amp;&amp; pixelCompareAndSet(east, targetColor, fillColor, surface, length, tolerance)); //go right until edge hit&#13;
&#13;
                for(var j = west; j &lt; east; j += 4) {&#13;
                    if(j - leftEdge &gt;= 0 		&amp;&amp; pixelCompare(j - leftEdge, targetColor, fillColor, surface, length, tolerance).canFill) queue.push(j - leftEdge);&#13;
                    if(j + leftEdge &lt; length	&amp;&amp; pixelCompare(j + leftEdge, targetColor, fillColor, surface, length, tolerance).canFill) queue.push(j + leftEdge);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        presenter.ctx.putImageData(img, 0, 0);&#13;
    };&#13;
&#13;
    function pixelCompare(i, targetColor, fillColor, surface, length, tolerance) {&#13;
        if (i &lt; 0 || i &gt;= length) { // out of bounds&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
        if (surface[i + 3] === 0) { //surface is invisible&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
&#13;
        if (targetColor[3] === fillColor[3] &amp;&amp; //target is same as fill&#13;
            targetColor[0] === fillColor[0] &amp;&amp;&#13;
            targetColor[1] === fillColor[1] &amp;&amp;&#13;
            targetColor[2] === fillColor[2]) {&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
&#13;
        if (fillColor[3] === surface[i+3] &amp;&amp; // surface matches fillColor&#13;
            fillColor[0] === surface[i]  &amp;&amp;&#13;
            fillColor[1] === surface[i+1] &amp;&amp;&#13;
            fillColor[2] === surface[i+2]) {&#13;
&#13;
            return {&#13;
                canFill: false,&#13;
                withinTolerance: false&#13;
            }&#13;
&#13;
        }&#13;
&#13;
        if (targetColor[3] === surface[i + 3] &amp;&amp; //target matches surface&#13;
            targetColor[0] === surface[i]  &amp;&amp;&#13;
            targetColor[1] === surface[i + 1] &amp;&amp;&#13;
            targetColor[2] === surface[i + 2]) {&#13;
&#13;
            return {&#13;
                canFill: true,&#13;
                withinTolerance: false&#13;
            };&#13;
        }&#13;
&#13;
        if (Math.abs(targetColor[3] - surface[i + 3]) &lt;= (255 - tolerance) &amp;&amp; //target to surface within tolerance&#13;
            Math.abs(targetColor[0] - surface[i]) &lt;= tolerance &amp;&amp;&#13;
            Math.abs(targetColor[1] - surface[i + 1]) &lt;= tolerance &amp;&amp;&#13;
            Math.abs(targetColor[2] - surface[i + 2]) &lt;= tolerance) {&#13;
&#13;
            return {&#13;
                canFill: true,&#13;
                withinTolerance: true&#13;
            };&#13;
&#13;
        }&#13;
&#13;
        return {&#13;
            canFill: false,&#13;
            withinTolerance: false&#13;
        }; //no match&#13;
    }&#13;
&#13;
    function pixelCompareAndSet(i, targetColor, fillColor, surface, length, tolerance) {&#13;
        var compareResult = pixelCompare(i, targetColor, fillColor, surface, length, tolerance);&#13;
&#13;
        if (compareResult.canFill) {&#13;
            for(var j = i; j &lt; i + 4; j++) {&#13;
                presenter.allColoredPixels.push(j);&#13;
            }&#13;
            //fill the color&#13;
            surface[i]     = fillColor[0];&#13;
            surface[i + 1] = fillColor[1];&#13;
            surface[i + 2] = fillColor[2];&#13;
            surface[i + 3] = fillColor[3];&#13;
&#13;
            return true;&#13;
        }&#13;
&#13;
        return false;&#13;
    }&#13;
&#13;
    presenter.onEventReceived = function (eventName, data) {&#13;
        if (eventName == "ShowAnswers") {&#13;
            presenter.showAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "HideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
&#13;
        if (eventName == "GradualShowAnswers") {&#13;
            if (presenter.configuration.addonID == data.moduleID) {&#13;
                presenter.gradualShowAnswers();&#13;
            } else if (!presenter.isShowAnswersActive) {&#13;
                presenter.activateShowAnswersMode();&#13;
            }&#13;
        }&#13;
&#13;
        if (eventName == "GradualHideAnswers") {&#13;
            presenter.hideAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.showAnswers = function () {&#13;
        if (!presenter.configuration.isActivity) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (!presenter.isShowAnswersActive) {&#13;
            presenter.activateShowAnswersMode();&#13;
        }&#13;
&#13;
        var areas = presenter.configuration.areas;&#13;
        for (var i=0; i&lt; areas.length; i++) {&#13;
            presenter.fillAreaWithCorrectColor(areas[i]);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.gradualShowAnswers = function () {&#13;
        if (!presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            if (!presenter.configuration.isActivity) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (!presenter.isShowAnswersActive) {&#13;
                presenter.activateShowAnswersMode();&#13;
            }&#13;
&#13;
            var area = presenter.configuration.areas[presenter.currentAreaIdInGSAMode];&#13;
            presenter.fillAreaWithCorrectColor(area);&#13;
            presenter.currentAreaIdInGSAMode++;&#13;
        } else {&#13;
            presenter.showAnswers();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.hideAnswers = function () {&#13;
        if (!presenter.configuration.isActivity || !presenter.isShowAnswersActive) {&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.deactivateShowAnswersMode();&#13;
    };&#13;
&#13;
    presenter.showAnswersAgain = function () {&#13;
        if (!presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            if (!presenter.isShowAnswersActive) {&#13;
                presenter.activateShowAnswersMode();&#13;
            }&#13;
&#13;
            if (presenter.currentAreaIdInGSAMode === 0) {&#13;
                presenter.showAnswers();&#13;
            } else {&#13;
                for (let i = 0; i &lt; presenter.currentAreaIdInGSAMode; i++) {&#13;
                    const area = presenter.configuration.areas[i];&#13;
                    presenter.fillAreaWithCorrectColor(area);&#13;
                }&#13;
            }&#13;
        } else {&#13;
            presenter.showAnswers();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.activateShowAnswersMode = function () {&#13;
        presenter.isShowErrorsModeActive = false;&#13;
&#13;
        presenter.$view.find('.icon-container').remove();&#13;
        presenter.currentScore = presenter.getScore();&#13;
        presenter.currentErrorCount = presenter.getErrorCount();&#13;
&#13;
        presenter.backupUserAreas();&#13;
&#13;
        presenter.clearCanvas();&#13;
        presenter.recolorImage();&#13;
&#13;
        presenter.isShowAnswersActive = true;&#13;
    };&#13;
&#13;
    presenter.deactivateShowAnswersMode = function () {&#13;
        presenter.currentAreaIdInGSAMode = 0;&#13;
&#13;
        presenter.clearCanvas();&#13;
        presenter.recolorImage();&#13;
&#13;
        presenter.restoreUserAreas();&#13;
&#13;
        presenter.isShowAnswersActive = false;&#13;
    };&#13;
&#13;
    presenter.backupUserAreas = function () {&#13;
        presenter.tmpFilledAreas = [];&#13;
        $.each(presenter.configuration.areas, function() {&#13;
            if (presenter.shouldBeTakenIntoConsideration(this)) {&#13;
                presenter.tmpFilledAreas.push({&#13;
                    area: this,&#13;
                    color: presenter.getColorAtPoint(this.x, this.y)&#13;
                });&#13;
            }&#13;
        });&#13;
&#13;
        if (presenter.configuration.userAreas) {&#13;
            for (var i = 0; i &lt; presenter.configuration.userAreas.length; i++) {&#13;
                var area = presenter.configuration.userAreas[i];&#13;
                presenter.tmpFilledAreas.push({&#13;
                    area: area,&#13;
                    color: area.getColor()&#13;
                });&#13;
            }&#13;
        }&#13;
    };&#13;
&#13;
    presenter.restoreUserAreas = function () {&#13;
        $.each(presenter.tmpFilledAreas, function() {&#13;
            presenter.floodFill({&#13;
                    x: this.area.x,&#13;
                    y: this.area.y,&#13;
                    color: presenter.whiteRGBA&#13;
                },&#13;
                this.color,&#13;
                presenter.configuration.tolerance);&#13;
&#13;
            presenter.allColoredPixels = [];&#13;
        });&#13;
    };&#13;
&#13;
    presenter.fillAreaWithCorrectColor = function (area) {&#13;
        presenter.floodFill({&#13;
                x: area.x,&#13;
                y: area.y,&#13;
                color: presenter.whiteRGBA&#13;
            },&#13;
            [area.colorToFill[0], area.colorToFill[1], area.colorToFill[2], area.colorToFill[3]],&#13;
            presenter.configuration.tolerance);&#13;
&#13;
        presenter.allColoredPixels = [];&#13;
    };&#13;
&#13;
    presenter.getActivitiesCount = function () {&#13;
        if (presenter.configuration.showAllAnswersInGradualShowAnswersMode) {&#13;
            return 1;&#13;
        }&#13;
        return presenter.configuration.areas.length;&#13;
    };&#13;
&#13;
    presenter.getRGBAStringFromRGBAArray = function(rgbaArray) {&#13;
        return rgbaArray.reduce((prev, curr) =&gt; (prev === "") ? curr : `${prev} ${curr}`, "");&#13;
    }&#13;
&#13;
    function scalePoint({x, y}) {&#13;
        var scaledPoint = {x: x, y: y};&#13;
        if (!presenter.playerController)&#13;
            return scaledPoint;&#13;
&#13;
        var scale = presenter.playerController.getScaleInformation();&#13;
        if (scale.scaleX !== 1.0 || scale.scaleY !== 1.0) {&#13;
            scaledPoint.x = Math.floor(scaledPoint.x / scale.scaleX);&#13;
            scaledPoint.y = Math.floor(scaledPoint.y / scale.scaleY);&#13;
        }&#13;
        return scaledPoint;&#13;
    }&#13;
&#13;
    function ColoringKeyboardController (elements, columnsCount) {&#13;
        KeyboardController.call(this, elements, columnsCount);&#13;
    }&#13;
&#13;
    presenter.isDeactivationBlocked = function() {&#13;
        if (presenter.isTTSExitBlocked) {&#13;
            presenter.isTTSExitBlocked = false;&#13;
            return true;&#13;
        }&#13;
        return false;&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype = Object.create(window.KeyboardController.prototype);&#13;
    ColoringKeyboardController.prototype.isColorSelectActive = false;&#13;
    ColoringKeyboardController.prototype.lastAreaElement = null;&#13;
    ColoringKeyboardController.prototype.colorElementsMap = {};&#13;
    ColoringKeyboardController.prototype.lastAreaElementIndex = null;&#13;
    ColoringKeyboardController.prototype.constructor = ColoringKeyboardController;&#13;
&#13;
&#13;
    presenter.buildKeyboardController = function AddonColoring_buildKeyboardController () {&#13;
        const elements = presenter.getElementsForKeyboardNavigation();&#13;
        presenter.keyboardControllerObject = new ColoringKeyboardController(elements, 1);&#13;
    };&#13;
&#13;
    presenter.keyboardController = function AddonColoring_keyboardController (keycode, isShiftKeyDown, event) {&#13;
        if (presenter.shouldIgnoreKeyNav()) {&#13;
            const enterKeycode = 13;&#13;
            if (keycode === enterKeycode) presenter.keyboardControllerObject.escape(event);&#13;
            event.preventDefault();&#13;
            return;&#13;
        }&#13;
        presenter.keyboardControllerObject.handle(keycode, isShiftKeyDown, event);&#13;
    };&#13;
&#13;
    presenter.shouldIgnoreKeyNav = function () {&#13;
        return !presenter.configuration.colors?.length &amp;&amp; !presenter.isTTS();&#13;
    }&#13;
&#13;
    presenter.getElementsForKeyboardNavigation = function () {&#13;
        return presenter.configuration.areas ? presenter.configuration.areas : [];&#13;
    };&#13;
&#13;
    presenter.getAvailableColorsForKeyboardNavigation = function() {&#13;
        return presenter.configuration.colors;&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.mark = function (element) {&#13;
        if (!this.isColorSelectActive) return;&#13;
        const $colorElement = this.colorElementsMap[this.keyboardNavigationCurrentElement.speechText];&#13;
        if ($colorElement) {&#13;
            $colorElement.addClass('keyboard_navigation_active_element');&#13;
        }&#13;
    };&#13;
    ColoringKeyboardController.prototype.unmark = function (element) {&#13;
        if (!this.isColorSelectActive) return;&#13;
        const $colorElement = this.colorElementsMap[this.keyboardNavigationCurrentElement.speechText];&#13;
        if ($colorElement) {&#13;
            $colorElement.removeClass('keyboard_navigation_active_element');&#13;
        }&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.nextRow = function (event) {&#13;
        this.nextElement(event);&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.previousRow = function (event) {&#13;
        this.previousElement(event);&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.nextElement = function (event) {&#13;
        if (event) event.preventDefault();&#13;
        if (this.keyboardNavigationCurrentElementIndex === this.keyboardNavigationElements.length - 1) {&#13;
            this.readCurrentElement();&#13;
        } else {&#13;
            this.switchElement(1);&#13;
        }&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.previousElement = function (event) {&#13;
        if (event) event.preventDefault();&#13;
        if (this.keyboardNavigationCurrentElementIndex === 0) {&#13;
            this.readCurrentElement();&#13;
        } else {&#13;
            this.switchElement(-1);&#13;
        }&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.switchElement = function (move) {&#13;
        KeyboardController.prototype.switchElement.call(this, move);&#13;
        if (this.isColorSelectActive) {&#13;
            this.adjustScroll(move);&#13;
        } else {&#13;
            presenter.markAreaWithCircle(this.keyboardNavigationCurrentElement);&#13;
        }&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.adjustScroll = function (move) {&#13;
        let currentElement = this.colorElementsMap[this.keyboardNavigationCurrentElement.speechText][0];&#13;
        let parentElement = currentElement.parentElement;&#13;
&#13;
        if (!isScrollbarVisible(parentElement)) {&#13;
            return;&#13;
        }&#13;
&#13;
        if (move &lt; 0) {&#13;
            parentElement.scrollTo(0, currentElement.offsetTop);&#13;
        } else {&#13;
            let currentElementOffsetBottom = currentElement.offsetTop + currentElement.offsetHeight;&#13;
            if (currentElementOffsetBottom &gt; parentElement.offsetHeight) {&#13;
                parentElement.scrollTo(0, currentElementOffsetBottom - parentElement.offsetHeight);&#13;
            } else {&#13;
                parentElement.scrollTo(0, 0);&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function isScrollbarVisible(element) {&#13;
        return element.scrollHeight &gt; element.clientHeight;&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.enter = function (event) {&#13;
        if (presenter.isFirstEnter) {&#13;
            this.setElements.call(this, presenter.getElementsForKeyboardNavigation());&#13;
            presenter.isFirstEnter = false;&#13;
        }&#13;
        KeyboardController.prototype.enter.call(this, event);&#13;
        if (!this.isColorSelectActive) {&#13;
            presenter.markAreaWithCircle(this.keyboardNavigationCurrentElement);&#13;
        }&#13;
        this.readCurrentElement();&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.select = function (event) {&#13;
        if (event) event.preventDefault();&#13;
        if (!this.isSelectEnabled) return;&#13;
        if (presenter.isShowAnswersActive) return;&#13;
        if (presenter.isShowErrorsModeActive) return;&#13;
        if (!presenter.configuration.colors?.length) return;&#13;
&#13;
        if (this.isColorSelectActive) {&#13;
            presenter.removeColorList();&#13;
            this.colorAreaWithSelectedColor();&#13;
            this.readSelectedColor();&#13;
            this.switchElementsToAreas();&#13;
        } else {&#13;
            this.switchElementsToColors();&#13;
            this.readCurrentElement();&#13;
        }&#13;
    };&#13;
&#13;
    presenter.markAreaWithCircle = function ({ x, y }) {&#13;
        presenter.removeAreaMark();&#13;
        const $mark = $("&lt;span&gt;&lt;/span&gt;");&#13;
        $mark.addClass("coloring-circle-mark");&#13;
        $mark.css({&#13;
            'top' : y + 20,&#13;
            'left' : x + 20,&#13;
        });&#13;
        const coloringWrapper = presenter.$view.find('.coloring-wrapper');&#13;
        coloringWrapper.append($mark);&#13;
        presenter.$areaMark = $mark;&#13;
    }&#13;
&#13;
    presenter.removeAreaMark = function () {&#13;
        if (presenter.$areaMark) {&#13;
            presenter.$areaMark.remove();&#13;
        }&#13;
    }&#13;
&#13;
    presenter.removeColorList = function () {&#13;
      if (presenter.$colorList) {&#13;
          presenter.$colorList.remove();&#13;
      }&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.colorAreaWithSelectedColor = function () {&#13;
            const previousColor = presenter.configuration.currentFillingColor;&#13;
            const colorString = presenter.getRGBAStringFromRGBAArray(this.keyboardNavigationCurrentElement.colorRGBA);&#13;
            presenter.setColor(colorString);&#13;
            presenter.floodFill({&#13;
                    x: this.lastAreaElement.x,&#13;
                    y: this.lastAreaElement.y,&#13;
                    color: presenter.getColorAtPoint(this.lastAreaElement.x, this.lastAreaElement.y)&#13;
                },&#13;
                this.keyboardNavigationCurrentElement.colorRGBA,&#13;
                presenter.configuration.tolerance&#13;
            );&#13;
            presenter.configuration.currentFillingColor = previousColor;&#13;
            this.sendColoredEvent(colorString);&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.sendColoredEvent = function (colorString) {&#13;
            const isColorWhite = colorString === presenter.getRGBAStringFromRGBAArray(presenter.whiteRGBA);&#13;
            setTimeout(() =&gt;{&#13;
                // Without timeout there are issues on Firefox if event handling takes too long&#13;
                presenter.sendEvent(&#13;
                    [this.lastAreaElement.x, this.lastAreaElement.y],&#13;
                    isColorWhite ? 0 : 1,&#13;
                    isCorrect(this.lastAreaElement) ? 1 : 0&#13;
                );&#13;
            }, 0);&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.switchElementsToAreas = function () {&#13;
        this.isColorSelectActive = false;&#13;
        this.setElements(presenter.getElementsForKeyboardNavigation());&#13;
        KeyboardController.prototype.switchElement.call(this, this.lastAreaElementIndex);&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.createColorListForKeyNav = function () {&#13;
        const $colorList = $("&lt;span&gt;&lt;/span&gt;");&#13;
        $colorList.addClass("coloring-color-list");&#13;
        $colorList.css({&#13;
            'top': this.lastAreaElement.y,&#13;
            'left': this.lastAreaElement.x,&#13;
        });&#13;
        this.populateColorListWithColors($colorList);&#13;
        const coloringWrapper = presenter.$view.find('.coloring-wrapper');&#13;
        coloringWrapper.append($colorList);&#13;
        presenter.$colorList = $colorList;&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.populateColorListWithColors = function ($colorList) {&#13;
        const colors = presenter.configuration.colors;&#13;
&#13;
        colors.forEach(color =&gt; {&#13;
            const $color = $("&lt;div&gt;&lt;/div&gt;");&#13;
            $color.addClass("coloring-color-list-element");&#13;
            $color.text(color.speechText);&#13;
            $colorList.append($color);&#13;
            this.colorElementsMap[color.speechText] = $color;&#13;
        });&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.switchElementsToColors = function () {&#13;
        this.isColorSelectActive = true;&#13;
        this.lastAreaElement = this.keyboardNavigationCurrentElement;&#13;
        this.lastAreaElementIndex = this.keyboardNavigationCurrentElementIndex;&#13;
        this.createColorListForKeyNav();&#13;
        const colors = presenter.getAvailableColorsForKeyboardNavigation();&#13;
        this.setElements(colors);&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.readCurrentElement = function () {&#13;
        const text = this.keyboardNavigationCurrentElement.speechText;&#13;
        const textWithPrefix = this.isColorSelectActive ? getColorTTS(text) : this.getAreaTTS(text);&#13;
&#13;
        presenter.speak(textWithPrefix);&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.readSelectedColor = function () {&#13;
        const textVoiceObject = [];&#13;
&#13;
        const color = this.keyboardNavigationCurrentElement.speechText;&#13;
&#13;
        pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.selected);&#13;
        pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, color);&#13;
&#13;
        presenter.speak(textVoiceObject);&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.escape = function (event) {&#13;
        if (event) {&#13;
            event.stopPropagation();&#13;
            event.preventDefault();&#13;
        }&#13;
        if (this.isColorSelectActive) {&#13;
            presenter.isTTSExitBlocked = true;&#13;
            this.switchElementsToAreas();&#13;
            presenter.removeColorList();&#13;
            this.readCurrentElement();&#13;
        } else {&#13;
            this.exitWCAGMode();&#13;
        }&#13;
    };&#13;
&#13;
    ColoringKeyboardController.prototype.exitWCAGMode = function () {&#13;
        presenter.removeAreaMark();&#13;
        presenter.removeColorList();&#13;
        this.isColorSelectActive = false;&#13;
        presenter.isFirstEnter = true;&#13;
        this.setElements.call(this, presenter.getElementsForKeyboardNavigation());&#13;
        KeyboardController.prototype.exitWCAGMode.call(this);&#13;
        presenter.setWCAGStatus(false);&#13;
    };&#13;
&#13;
    function getColorTTS(colorText) {&#13;
        const textVoiceObject = [];&#13;
&#13;
        const colorPrefix = presenter.speechTexts.color;&#13;
        pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, colorPrefix);&#13;
&#13;
        pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, colorText);&#13;
&#13;
        return textVoiceObject;&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.getAreaTTS = function(areaText) {&#13;
        const textVoiceObject = [];&#13;
&#13;
        const areaPrefix = presenter.speechTexts.area;&#13;
        pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, areaPrefix);&#13;
&#13;
        pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, areaText);&#13;
&#13;
        const colorText = this.getCurrentAreaColorSpeechText();&#13;
        if (colorText) {&#13;
            pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.color);&#13;
            pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, colorText);&#13;
            if (presenter.isShowErrorsModeActive) {&#13;
                if (isCorrect(this.keyboardNavigationCurrentElement)) {&#13;
                    pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.correct);&#13;
                } else {&#13;
                    pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, presenter.speechTexts.incorrect);&#13;
                }&#13;
            }&#13;
        }&#13;
&#13;
        return textVoiceObject;&#13;
    }&#13;
&#13;
    ColoringKeyboardController.prototype.getCurrentAreaColorSpeechText = function() {&#13;
        const colorArray = presenter.getColorAtPoint(&#13;
            this.keyboardNavigationCurrentElement.x,&#13;
            this.keyboardNavigationCurrentElement.y&#13;
        );&#13;
        const colorString = presenter.getRGBAStringFromRGBAArray(colorArray);&#13;
        return presenter.colorSpeechTextMap[colorString];&#13;
    }&#13;
&#13;
    function pushMessageToTextVoiceObjectWithLanguageFromLesson(textVoiceObject, message) {&#13;
        textVoiceObject.push(window.TTSUtils.getTextVoiceObject(message));&#13;
    }&#13;
&#13;
    function pushMessageToTextVoiceObjectWithLanguageFromPresenter(textVoiceObject, message) {&#13;
        textVoiceObject.push(window.TTSUtils.getTextVoiceObject(message, presenter.configuration.langTag));&#13;
    }&#13;
&#13;
    presenter.setWCAGStatus = function(isWCAGOn) {&#13;
        presenter.isWCAGOn = isWCAGOn;&#13;
    };&#13;
&#13;
    presenter.speak = function(text) {&#13;
        const tts = presenter.getTextToSpeechOrNull(presenter.playerController);&#13;
        if (tts &amp;&amp; presenter.isWCAGOn) {&#13;
            tts.speak(text);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.isTTS = function () {&#13;
        return presenter.getTextToSpeechOrNull(presenter.playerController) &amp;&amp; presenter.isWCAGOn;&#13;
    };&#13;
&#13;
    presenter.getTextToSpeechOrNull = function Coloring_getTextToSpeechOrNull(playerController) {&#13;
        if (playerController) {&#13;
            return playerController.getModule('Text_To_Speech1');&#13;
        }&#13;
&#13;
        return null;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
&#13;
AddonColoring_create.__supported_player_options__ = {&#13;
    resetInterfaceVersion: 2&#13;
};&#13;
</presenter></addon>