<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Text_To_Speech" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
    <model>
        <property displayName="Configuration" isDefault="true" name="configuration" nameLabel="Text_To_Speech_configuration" type="list">
            <property name="ID" nameLabel="Text_To_Speech_property_id" type="string"/>
            <property displayName="Area" name="Area" nameLabel="Text_To_Speech_area" type="{Main, Header, Footer}"/>
            <property isLocalized="true" name="Title" nameLabel="Text_To_Speech_property_title" type="string"/>
        </property>

        <property isLocalized="true" name="EnterText" nameLabel="Text_To_Speech_property_enter_text" type="string"/>
        <property isLocalized="true" name="ExitText" nameLabel="Text_To_Speech_property_exit_text" type="string"/>
        <property isLocalized="true" name="NewPage" nameLabel="Text_To_Speech_property_new_page" type="string"/>
        <property isLocalized="true" name="PageLangTag" nameLabel="Text_To_Speech_property_page_lang_tag" type="string"/>
        <property name="disableNewPageMessage" nameLabel="Text_To_Speech_property_disable_new_page_message" type="boolean"/>
    </model>
<css>.addon_Text_To_Speech {&#13;
    position: relative;&#13;
    width: 100%;&#13;
    height: 100%;&#13;
}&#13;
</css><view/><preview/><presenter>function AddonText_To_Speech_create() {&#13;
&#13;
    function getErrorObject (ec) { return {isValid: false, errorCode: ec}; }&#13;
&#13;
    function getCorrectObject (v) { return {isValid: true, value: v}; }&#13;
&#13;
    function getTextVoiceObject (text, lang) { return {text: text, lang: lang}; }&#13;
&#13;
    function getConfObject (id, area, title, description) {&#13;
        return {&#13;
            id: id,&#13;
            area: area,&#13;
            title: title,&#13;
            description: description&#13;
        };&#13;
    }&#13;
&#13;
    var presenter = function () {};&#13;
&#13;
    presenter.savedSentences = [];&#13;
    presenter.savedSentencesIndex = -1;&#13;
    presenter.saveNextSentences = false;&#13;
&#13;
    presenter.messagesQueue = [];&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        C01: 'Configuration cannot be empty',&#13;
&#13;
        S01: 'Sorry, your browser does not support speech synthesis.'&#13;
    };&#13;
&#13;
//    presenter.LANGUAGES_CODES = {&#13;
//        English: 'en-US',&#13;
//        Polski: 'pl-PL',&#13;
//        Deutsch: 'de-DE',&#13;
//        DEFAULT: 'English'&#13;
//    };&#13;
&#13;
    presenter.LANGUAGES_CODES = {&#13;
        English: 'en-US',&#13;
        Polski: 'pl-PL',&#13;
        Deutsch: 'de-DE',&#13;
        Korean: 'ko-KR',&#13;
        DEFAULT: 'Korean'&#13;
    };&#13;
&#13;
    presenter.AREAS = {&#13;
        Main: 'main',&#13;
        Header: 'header',&#13;
        Footer: 'footer',&#13;
        DEFAULT: 'Main'&#13;
    };&#13;
&#13;
    // Maximum length of a single utterance. If exceeded, the utterence will be split into multiple shorter ones&#13;
    presenter.maxUtteranceLength = 200;&#13;
&#13;
    function parseConfiguration(configuration) {&#13;
        if (!configuration) {&#13;
            return getErrorObject('C01');&#13;
        }&#13;
&#13;
        var addOnsTextToSpeechData = [];&#13;
        for (var i = 0; i &lt; configuration.length; i++) {&#13;
            var conf = configuration[i];&#13;
            addOnsTextToSpeechData.push(getConfObject(&#13;
                conf.ID,&#13;
                ModelValidationUtils.validateOption(presenter.AREAS, conf.Area),&#13;
                conf.Title&#13;
            ));&#13;
        }&#13;
&#13;
        return getCorrectObject(addOnsTextToSpeechData);&#13;
    }&#13;
&#13;
    function parseLanguage(language) {&#13;
        return getCorrectObject(presenter.LANGUAGES_CODES[language || 'English']);&#13;
    }&#13;
&#13;
    presenter.validateModel = function (model) {&#13;
        var validatedConfiguration = parseConfiguration(model['configuration']);&#13;
        if (!validatedConfiguration.isValid) {&#13;
            return getErrorObject(validatedConfiguration.errorCode);&#13;
        }&#13;
&#13;
//        console.log("validatedConfiguration.value", validatedConfiguration.value);&#13;
        return {&#13;
            ID: model.ID,&#13;
            isVisible: ModelValidationUtils.validateBoolean(model['Is Visible']),&#13;
            isValid: true,&#13;
&#13;
            addOnsConfiguration: validatedConfiguration.value,&#13;
            enterText: model['EnterText'],&#13;
            exitText: model['ExitText'],&#13;
            newPage: model['NewPage'] ? model['NewPage'] : "New page",&#13;
            pageLangTag: model['PageLangTag'],&#13;
            disableNewPageMessage: ModelValidationUtils.validateBoolean(model['disableNewPageMessage'])&#13;
        }&#13;
    };&#13;
&#13;
    function loadVoices () {&#13;
        presenter.configuration.voices = window.speechSynthesis.getVoices();&#13;
    }&#13;
&#13;
    presenter.upgradeModel = function(model) {&#13;
        var upgradedModel = presenter.upgradeDisableNewPageMessage(model);&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.upgradeDisableNewPageMessage = function(model) {&#13;
        var upgradedModel = {};&#13;
        $.extend(true, upgradedModel, model); // Deep copy of model object&#13;
&#13;
        if (upgradedModel['disableNewPageMessage'] === undefined) {&#13;
            upgradedModel['disableNewPageMessage'] = "";&#13;
        }&#13;
&#13;
        return upgradedModel;&#13;
    }&#13;
&#13;
    presenter.presenterLogic = function (view, model, isPreview) {&#13;
        presenter.$view = $(view);&#13;
        view.addEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        var upgradedModel = presenter.upgradeModel(model);&#13;
        presenter.configuration = presenter.validateModel(upgradedModel);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return false;&#13;
        }&#13;
&#13;
        loadVoices();&#13;
        window.speechSynthesis.onvoiceschanged = function (e) {&#13;
            loadVoices();&#13;
        };&#13;
&#13;
        if ('speechSynthesis' in window) {&#13;
&#13;
        } else {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, 'S01');&#13;
            return false;&#13;
        }&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
&#13;
        return false;&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.presenterLogic(view, model, false);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model, true);&#13;
    };&#13;
&#13;
    presenter.getAddOnConfiguration = function (area, id) {&#13;
        id = Array.isArray(id) ? id[0] : id;&#13;
        area = Array.isArray(area) ? area[0] : area;&#13;
&#13;
        for (var i = 0; i &lt; presenter.configuration.addOnsConfiguration.length; i++) {&#13;
            var conf = presenter.configuration.addOnsConfiguration[i];&#13;
&#13;
            if (conf.id === id &amp;&amp; conf.area.toLowerCase() === area.toLowerCase()) {&#13;
                return conf;&#13;
            }&#13;
        }&#13;
&#13;
        return {title: '', description: ''};&#13;
    }&#13;
&#13;
    function getResponsiveVoiceLanguage (langTag) {&#13;
        if (!langTag) {&#13;
            // get lang from document &lt;html lang=""&gt;&#13;
            langTag = document.documentElement.lang;&#13;
        }&#13;
&#13;
        // Tags for Identifying Languages: https://www.ietf.org/rfc/bcp/bcp47.txt&#13;
        var languages = {&#13;
            'en': 'UK English Male',&#13;
            'pl': 'Polish Female',&#13;
            'de': 'Deutsch Female',&#13;
            'ko': 'Korean Female'&#13;
        };&#13;
&#13;
        return languages[langTag] || 'UK English Male';&#13;
    }&#13;
&#13;
    function getSpeechSynthesisLanguage (langTag) {&#13;
        if (!langTag) {&#13;
            // get lang from document &lt;html lang=""&gt;&#13;
            langTag = document.documentElement.lang;&#13;
        }&#13;
&#13;
        loadVoices();&#13;
&#13;
        var languages = {&#13;
            'en': "en-US",&#13;
            'pl': 'pl-PL',&#13;
            'de': 'de-DE',&#13;
            'ko': 'ko-KR'&#13;
        };&#13;
        langTag = languages[langTag] || langTag;&#13;
&#13;
        for (var i=0; i&lt;presenter.configuration.voices.length; i++) {&#13;
            if (presenter.configuration.voices[i].lang === langTag) {&#13;
                return presenter.configuration.voices[i];&#13;
            }&#13;
        }&#13;
&#13;
        return presenter.configuration.voices[0];&#13;
    }&#13;
&#13;
    function filterTexts (texts, languageGetter) {&#13;
        return texts.map(function (t) {&#13;
            return {&#13;
                lang: languageGetter(t.lang),&#13;
                text: t.text ? t.text : ''&#13;
            };&#13;
        }).filter(function (t) { return t.text !== '' });&#13;
    }&#13;
&#13;
    // https://responsivevoice.org/&#13;
    function responsiveVoiceSpeak (texts, finalCallback) {&#13;
        var textsObjects = filterTexts(texts, getResponsiveVoiceLanguage);&#13;
        if (finalCallback === undefined) finalCallback = null;&#13;
&#13;
        var onEndStack = { onend: finalCallback };&#13;
        for (var i=textsObjects.length-1; i&gt;=0; i--) {&#13;
            var textObject = textsObjects[i];&#13;
&#13;
            if (i === 0) {&#13;
                window.responsiveVoice.speak(textObject.text, textObject.lang, onEndStack);&#13;
            } else {&#13;
                onEndStack.onend = (function (textObject, onEndStack) {&#13;
                    return function () {&#13;
                        window.responsiveVoice.speak(textObject.text, textObject.lang, onEndStack);&#13;
                    }&#13;
                })($.extend({}, textObject), $.extend({}, onEndStack));&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function containsOnlyNumbersAndDot(str) {&#13;
        // 정규표현식을 사용하여 문자열이 숫자와 소수점으로만 구성되어 있는지 확인합니다.&#13;
        // ^는 문자열의 시작을 나타냅니다.&#13;
        // [0-9]는 0부터 9까지의 숫자를 의미합니다.&#13;
        // \.은 소수점을 의미합니다.&#13;
        // *는 앞의 패턴이 0회 이상 반복됨을 나타냅니다.&#13;
        // $는 문자열의 끝을 나타냅니다.&#13;
        var regex = /^[0-9.]*$/;&#13;
&#13;
        // 정규표현식과 매치되는지 확인합니다.&#13;
        return regex.test(str);&#13;
    }&#13;
&#13;
    function containsKorean(str){&#13;
        str = str.replaceAll("|", "");&#13;
        var regex = /[ㄱ-ㅎ|ㅏ-ㅣ|가-힣]/;&#13;
        return regex.test(str);&#13;
    }&#13;
&#13;
    presenter.intervalId = null;&#13;
    presenter.intervalResume = null;&#13;
&#13;
    function replaceLang(texts){&#13;
        for( var i=0; i&lt;texts.length; ++i){&#13;
            //이석웅 추가&#13;
            //한글이 없고 숫자로만 이루어 지지 않았다면 lang을 eng로 변경&#13;
            console.log("texts[i].text", texts[i].text, containsKorean(texts[i].text), containsOnlyNumbersAndDot(texts[i].text) );&#13;
            if( !containsKorean(texts[i].text) &amp;&amp; !containsOnlyNumbersAndDot(texts[i].text) ){&#13;
                texts[i].lang = "en-US";&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
&#13;
&#13;
    // https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis&#13;
    function speechSynthesisSpeak (texts, finalCallback) {&#13;
        window.speechSynthesis.cancel();&#13;
&#13;
        console.log("speechSynthesisSpeak texts", texts);&#13;
&#13;
        // 이석웅 추가&#13;
        // 2024.04.27&#13;
//        replaceLang(texts);&#13;
&#13;
        if (presenter.intervalId != null) {&#13;
        clearInterval(presenter.intervalId);&#13;
            presenter.intervalId = undefined;&#13;
        }&#13;
        var onStartExecuted = false;&#13;
        // Fix for running speak method after cancelling SpeechSynthesis queue&#13;
        if(presenter.intervalResume != null) {&#13;
            clearInterval(presenter.intervalResume);&#13;
            presenter.intervalResume = undefined;&#13;
        }&#13;
&#13;
        // Necessary for Chrome browser because instead stop reading&#13;
        if (isChrome()) {&#13;
                presenter.intervalResume = setInterval(function () {&#13;
                window.speechSynthesis.pause();&#13;
                window.speechSynthesis.resume();&#13;
            }, 3000);&#13;
        }&#13;
&#13;
        presenter.intervalId = setInterval(function() {&#13;
&#13;
            if (window.speechSynthesis.speaking) {&#13;
                window.speechSynthesis.cancel();&#13;
                return;&#13;
            }&#13;
            var textsObjects = filterTexts(texts, getSpeechSynthesisLanguage);&#13;
            if (textsObjects.length === 0) {&#13;
                clearInterval(presenter.intervalId);&#13;
                presenter.intervalId = undefined;&#13;
&#13;
                clearInterval(presenter.intervalResume);&#13;
                presenter.intervalResume = undefined;&#13;
                return;&#13;
            }&#13;
            if (presenter.intervalId == null) return;&#13;
            var utterances = [];&#13;
            for (var i=0; i&lt;textsObjects.length; i++) {&#13;
                var textObject = textsObjects[i];&#13;
                var msg = new SpeechSynthesisUtterance(textObject.text);&#13;
                msg.volume = parseFloat(1); // 0 - 1&#13;
                msg.rate = parseFloat(1); // 0 - 10&#13;
                msg.pitch = parseFloat(1); // 0 - 2&#13;
                msg.voice = textObject.lang;&#13;
                var currentIntervalId = presenter.intervalId;&#13;
                if (i === 0) {&#13;
                    msg.onstart = function (event) {&#13;
                        onStartExecuted = true;&#13;
                        clearInterval(currentIntervalId);&#13;
                        if (currentIntervalId !== presenter.intervalId) {&#13;
                            window.speechSynthesis.cancel();&#13;
                        }&#13;
                    };&#13;
                }&#13;
                if (i === textsObjects.length - 1) {&#13;
                    msg.onend = function (event) {&#13;
                        if(currentIntervalId === presenter.intervalId){&#13;
                            window.speechSynthesis.cancel();&#13;
                        }&#13;
                        if (finalCallback &amp;&amp; onStartExecuted){&#13;
                            onStartExecuted = false;&#13;
                            finalCallback();&#13;
                            utterances = [];&#13;
                        };&#13;
                    };&#13;
                }&#13;
&#13;
                //this list and "push" is solving the problem on&#13;
                //'end' event of SpeechSynthesisUtterance object is not dispatched sometimes&#13;
                //https://www.e-learn.cn/content/wangluowenzhang/603510&#13;
                utterances.push(msg);&#13;
                window.speechSynthesis.speak(msg);&#13;
            }&#13;
        }, 250);&#13;
    }&#13;
&#13;
    function getAltTextOptions(expression) {&#13;
        var options = {};&#13;
        expression = expression.replace(/.*}\[/g, '');&#13;
        expression = expression.replace('\]\[', '|');&#13;
        expression = expression.replace('\]', '');&#13;
        var optionExp = expression.split('\|');&#13;
        for(var i=0;i&lt;optionExp.length;i++) {&#13;
            var optionValues = optionExp[i].split(' ');&#13;
            if(optionValues.length===2){&#13;
                options[optionValues[0]]=optionValues[1];&#13;
            }&#13;
        }&#13;
        return options;&#13;
    }&#13;
&#13;
     presenter.parseAltTexts = function(texts){&#13;
        for (var i=0; i &lt; texts.length; i++) {&#13;
            if (texts[i].text !== null &amp;&amp; texts[i].text !== undefined &amp;&amp; texts[i].text.trim().length &gt; 0)&#13;
            {&#13;
                // altText elements with a langTag need to be isolated into seperate items&#13;
                // in the texts array, so that they can use a different language tag.&#13;
                var match = texts[i].text.match(/\\alt{([^{}|]*?)\|([^{}|]*?)}(\[([a-zA-Z0-9_\- ]*?)\])+/g);&#13;
                if (match &amp;&amp; match.length&gt;0) {&#13;
                    // get the first altText element with a lang tag.&#13;
                    // if there are more, they will not be parsed in this iteration&#13;
                    // instead, they will become a part of the tail and will be parsed in future iterations&#13;
                    var matchText = match[0].trim();&#13;
                    var originalMatchText = matchText;&#13;
                    var splitTexts = texts[i].text.split(matchText);&#13;
                    var startIndex = texts[i].text.indexOf(matchText);&#13;
                    var readableText = matchText.replace(/.*\\alt{[^{}|]*?\|([^{}|]*?)}.*/g,"$1");&#13;
                    var options = getAltTextOptions(originalMatchText);&#13;
                    var langTag = "";&#13;
                    if(options.hasOwnProperty('lang')){&#13;
                        langTag = options.lang;&#13;
                    }&#13;
&#13;
&#13;
&#13;
                    if (langTag.length!==0) {&#13;
                        var altTextVoice = getTextVoiceObject(readableText, langTag);&#13;
&#13;
                        if (splitTexts) {&#13;
                            if (splitTexts.length &gt; 2) {&#13;
                                // It is possible that there will be multiple identical altText elements&#13;
                                // if that is the case, all elements of the splitTexts array should be merged&#13;
                                // with the exception of the head&#13;
                                var newSplitTexts = splitTexts.splice(0, 1);&#13;
                                newSplitTexts.push(splitTexts.join(originalMatchText));&#13;
                                splitTexts = newSplitTexts;&#13;
                            }&#13;
                            if (splitTexts.length === 2) {&#13;
                                texts[i].text = splitTexts[0];&#13;
                                texts.splice(i + 1, 0, getTextVoiceObject(splitTexts[1], texts[i].lang));&#13;
                                texts.splice(i + 1, 0, altTextVoice);&#13;
                            } else if (splitTexts.length === 1) {&#13;
                                texts[i].text = splitTexts[0];&#13;
                                if (startIndex === 0) {&#13;
                                    texts.splice(i, 0, altTextVoice);&#13;
                                } else {&#13;
                                    texts.splice(i + 1, 0, altTextVoice);&#13;
                                }&#13;
                            } else if(splitTexts.length === 0) {&#13;
                                texts[i] = altTextVoice;&#13;
                            }&#13;
                        }&#13;
                    } else {&#13;
                        //if there is no lang option, there is not reason to create a new element in texts array&#13;
                        texts[i].text = texts[i].text.replace(originalMatchText, readableText);&#13;
                    }&#13;
                }&#13;
&#13;
                // handle altText elements without a langTag&#13;
                texts[i].text = texts[i].text.replace(/\\alt{.*?\|(.*?)}/g, '$1');&#13;
            }&#13;
        }&#13;
&#13;
        // splitting matched texts might create elements with an empty text field. This removes them&#13;
        texts = texts.filter(function(element){return element &amp;&amp; element.text &amp;&amp; element.text.trim().length&gt;0});&#13;
        return texts;&#13;
    };&#13;
&#13;
    // The speak method is overloaded:&#13;
    // texts argument can be either an array of TextVoiceObjects, or a String&#13;
    // langTag argument is optional and only used when texts is a String&#13;
    presenter.speak = function (texts, langTag) {&#13;
        var class_ = Object.prototype.toString.call(texts);&#13;
        if (class_.indexOf('String') !== -1) {&#13;
            texts = [getTextVoiceObject(texts, langTag)];&#13;
        }&#13;
&#13;
        presenter.speakWithCallback(texts, null);&#13;
    };&#13;
&#13;
    function splitByPunctuationSigns(text) {&#13;
        let splitIndexes = findPunctuationSignsIndexes(text);&#13;
        return splitByIndexesInConsiderationOfProtectedSyntax(text, splitIndexes);&#13;
    }&#13;
&#13;
    function findPunctuationSignsIndexes(text) {&#13;
        const regexp = /[.,:;!?\/\\()]/g;&#13;
        return Array.from(text.matchAll(regexp)).map(x =&gt; x.index);&#13;
    }&#13;
&#13;
    function splitByEndOfSentenceSigns(text) {&#13;
        let splitIndexes = findEndOfSentenceSignsIndexes(text);&#13;
        return splitByIndexesInConsiderationOfProtectedSyntax(text, splitIndexes);&#13;
    }&#13;
&#13;
    function findEndOfSentenceSignsIndexes(text) {&#13;
        const regexp = /[.?!;]/g;&#13;
        return Array.from(text.matchAll(regexp)).map(x =&gt; x.index);&#13;
    }&#13;
&#13;
    function protectTimeSyntaxInText(text, splitIndexes) {&#13;
        protectAMAndPMSyntaxInText(text, splitIndexes);&#13;
        protectDigitHourSyntaxInText(text, splitIndexes);&#13;
    }&#13;
&#13;
    function protectAMAndPMSyntaxInText(text, splitIndexes) {&#13;
        const regexp = /(at[\s]+[\d]{1,2}[\s]+)([ap].[m].)/g;&#13;
        let matches = text.matchAll(regexp);&#13;
        filterSplittingIndexes(matches, splitIndexes);&#13;
    }&#13;
&#13;
    function protectDigitHourSyntaxInText(text, splitIndexes) {&#13;
        const regexp = /([\s]+)([\d]{1,2}:[\d]{2})/g;&#13;
        let matches = text.matchAll(regexp);&#13;
        filterSplittingIndexes(matches, splitIndexes);&#13;
    }&#13;
&#13;
    function protectNumberSyntaxInText(text, splitIndexes) {&#13;
        const regexp = /()([0-9]*[.!?;][0-9])/g;&#13;
        let matches = text.matchAll(regexp);&#13;
        filterSplittingIndexes(matches, splitIndexes);&#13;
    }&#13;
&#13;
    /**&#13;
    * Leaves the indexes that are not between the range of the matches' second groups&#13;
    * @param matches - RegExp matches, where second groups are texts protected from splitting&#13;
    * @param splitIndexes - List of indexes (breaking points) to split text&#13;
    * @return undefined&#13;
    **/&#13;
    function filterSplittingIndexes(matches, splitIndexes) {&#13;
        for (const match of matches) {&#13;
            const startIndex = match.index + match[1].length;&#13;
            const endIndex = startIndex + match[2].length - 1;&#13;
            for (let i = 0; i &lt; splitIndexes.length; i++) {&#13;
                if (startIndex &lt;= splitIndexes[i] &amp;&amp; splitIndexes[i] &lt;= endIndex) {&#13;
                    splitIndexes.splice(i, 1);&#13;
                    i--;&#13;
                }&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    /**&#13;
    * Split text considering protected syntax using given indexes.&#13;
    * @param text - Text to split&#13;
    * @param splitIndexes - List of indexes (breaking points) to split text. A breakpoint will have no effect when referring to a protected syntax.&#13;
    * @return split text&#13;
    **/&#13;
    function splitByIndexesInConsiderationOfProtectedSyntax(text, splitIndexes) {&#13;
        protectTimeSyntaxInText(text, splitIndexes);&#13;
        protectNumberSyntaxInText(text, splitIndexes);&#13;
        return splitByIndexes(text, splitIndexes);&#13;
    }&#13;
&#13;
    /**&#13;
    * Split text using given indexes.&#13;
    * @param text - Text to split&#13;
    * @param splitIndexes - List of indexes (breaking points) to split text&#13;
    * @return split text&#13;
    **/&#13;
    function splitByIndexes(text, splitIndexes) {&#13;
        splitIndexes.unshift(-1);&#13;
        splitIndexes.push(text.length);&#13;
        let splitText = [];&#13;
        for (let i = 1; i &lt; splitIndexes.length; i++) {&#13;
            let textFragment = text.slice(splitIndexes[i-1] + 1, splitIndexes[i]);&#13;
            if (textFragment.trim().length &gt; 0) {&#13;
                splitText.push(textFragment);&#13;
            }&#13;
        }&#13;
        return splitText;&#13;
    }&#13;
&#13;
    presenter.removeUnnecessaryPunctuationMarks = function (texts) {&#13;
        texts.forEach(text =&gt; {&#13;
            const splittedWords = text.text&#13;
                .replaceAll(" \/", ",")&#13;
                .split(" ");&#13;
&#13;
            const newSentence = [];&#13;
            splittedWords.forEach(word =&gt; {&#13;
                if (word.trim().length) {&#13;
                    const matchAfterLetter = word.match(/(\w\W)[.,?!]+/); // regex captures at least 2 special characters after word&#13;
                    const matchAloneOrSeparated = word.match(/(^|\s)[.,?!(){}\\\/\-\[\]]+/); // regex captures at least 1 special separated character or character at the beginning of sentence&#13;
                    if (matchAfterLetter) {&#13;
                        newSentence.push(word.replace(matchAfterLetter[0], matchAfterLetter[1]));&#13;
                    } else if (matchAloneOrSeparated &amp;&amp; !presenter.isMatchContainSentence(matchAloneOrSeparated)) {&#13;
                        return;&#13;
                    } else {&#13;
                        newSentence.push(word);&#13;
                    }&#13;
                }&#13;
            });&#13;
            text.text = newSentence.join(" ");&#13;
        });&#13;
&#13;
        return texts.filter(text =&gt; text.text.length);&#13;
    };&#13;
&#13;
    presenter.isMatchContainSentence = function (word) {&#13;
        if (!word) {&#13;
            return;&#13;
        }&#13;
&#13;
        return word['input'].match(/[a-zA-Z0-9]+/);&#13;
    }&#13;
&#13;
    // Too long utterences may take much too long to load or exceed Speech Synthesis API character limit&#13;
    presenter.splitLongTexts = function (texts) {&#13;
        let finalSplitTexts = [];&#13;
        texts.forEach(text =&gt; {&#13;
            if (text === null || text === undefined) {&#13;
                return;&#13;
            }&#13;
&#13;
            const textLen = text.text.trim().length;&#13;
            if (textLen === 0) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (textLen &lt; presenter.maxUtteranceLength) {&#13;
                finalSplitTexts.push(text);&#13;
            } else {&#13;
                let textFragments = splitLongText(text.text, text.lang);&#13;
                finalSplitTexts = finalSplitTexts.concat(textFragments);&#13;
            }&#13;
        })&#13;
        return finalSplitTexts;&#13;
    }&#13;
    &#13;
    function splitLongText(text, lang) {&#13;
        return minSplitHandler(text, lang, splitByEndOfSentenceSigns, splitLongSentence);&#13;
    }&#13;
&#13;
    function splitLongSentence (sentence, lang) {&#13;
        return minSplitHandler(sentence, lang, splitByPunctuationSigns, splitLongSentenceByMaxUtterances);&#13;
    }&#13;
    &#13;
    function minSplitHandler (text, lang, currentSplitFunc, nextSplitFunc) {&#13;
        let finalSplitTexts = [];&#13;
        let splitTexts = currentSplitFunc(text);&#13;
        splitTexts.forEach((splitText) =&gt; {&#13;
            const textLength = splitText.trim().length;&#13;
            if (textLength === 0) {&#13;
                return;&#13;
            }&#13;
&#13;
            if (textLength &lt; presenter.maxUtteranceLength) {&#13;
                finalSplitTexts.push({&#13;
                    text: splitText,&#13;
                    lang: lang&#13;
                });&#13;
            } else {&#13;
                let textFragments = nextSplitFunc(splitText, lang);&#13;
                finalSplitTexts = finalSplitTexts.concat(textFragments);&#13;
            }&#13;
        })&#13;
        return finalSplitTexts;&#13;
    }&#13;
&#13;
    // creates an array of utterances from a single text that exceeds max utterance length and has no natural break points&#13;
    function splitLongSentenceByMaxUtterances (sentence, lang) {&#13;
        let finalSplitTexts = [];&#13;
        let sentenceLen = sentence.trim().length;&#13;
        let maxSplitLen = sentenceLen / (Math.floor(sentenceLen / presenter.maxUtteranceLength) + 1);&#13;
        let workString = '';&#13;
        let words = sentence.split(/\s/);&#13;
        for (let k = 0; k &lt; words.length; k++) {&#13;
            workString += words[k] + ' ';&#13;
            if (workString.length &gt; maxSplitLen) {&#13;
                finalSplitTexts.push({&#13;
                    text: workString,&#13;
                    lang: lang&#13;
                });&#13;
                workString = '';&#13;
            }&#13;
        }&#13;
        finalSplitTexts.push({&#13;
            text: workString,&#13;
            lang: lang&#13;
        });&#13;
        return finalSplitTexts;&#13;
    }&#13;
&#13;
    var JaxToML = {&#13;
     toMathML: function(jax, callback) {&#13;
         var mml;&#13;
         try {&#13;
             mml = jax.root.toMathML("");&#13;
         } catch (err) {&#13;
             if (!err.restart) {&#13;
                 throw err&#13;
             } // an actual error&#13;
             return MathJax.Callback.After([JaxToML.toMathML, jax, callback], err.restart);&#13;
         }&#13;
         MathJax.Callback(callback)(mml);&#13;
     },&#13;
     convert: function(texts, callback) {&#13;
        try{&#13;
             var retText = "";&#13;
             for( var j=0; j&lt;texts.length; ++j ){&#13;
                 var tempDiv = document.createElement("tempDiv");&#13;
                 console.log(" AjaxText 1 ",  texts[j].text);&#13;
                 tempDiv.innerHTML = texts[j].text;&#13;
                 document.body.appendChild(tempDiv);&#13;
    //             var tempDiv = $('&lt;div style="width:455px;height:450px:border-width:thick;border-style:double;display:none;"&gt;&lt;/div&gt;').appendTo("body").html(AjaxText)[0];&#13;
                 MathJax.Hub.Queue(["Typeset", MathJax.Hub, tempDiv]); //first place in Q&#13;
                 MathJax.Hub.Queue(function() { //wait for a callback to be fired&#13;
                     var jax = MathJax.Hub.getAllJax(tempDiv);&#13;
                     for (var i = 0; i &lt; jax.length; i++) {&#13;
                         JaxToML.toMathML(jax[i], function(mml) {//alert(jax[i].originalText + "\n\n=&gt;\n\n"+ mml);&#13;
                             texts[j].text = texts[j].text.replace(jax[i].originalText, mml);&#13;
                              console.log("mml ", mml);&#13;
                         });&#13;
                     }&#13;
    //                 $(tempDiv).remove();&#13;
                     tempDiv.remove();&#13;
                     texts[j].text = texts[j].text.replace(/\(/g,""); //notice this escape character for ( - i.e it has to be \( , know why it is beacuse JS will treat ) or ( as end/begin of function as there are no quotes here.&#13;
                     texts[j].text = texts[j].text.replace(/\)/g,""); //notice this escape character for ) - i.e it has to be \)&#13;
                     texts[j].text = texts[j].text.replace(/\\/g,"");&#13;
&#13;
&#13;
                     if( j == texts.length-1) callback(texts[j].text);&#13;
                 });&#13;
             }&#13;
&#13;
        }catch(e){&#13;
            console.log("convert e: ", e);&#13;
            callback(AjaxText);&#13;
        }&#13;
     },&#13;
    };&#13;
&#13;
//    presenter.speakWithCallback = function (texts, callback) {&#13;
//        console.log("speakWithCallback", texts)&#13;
//        JaxToML.convert(texts, function(mml) {&#13;
//            texts = presenter.parseAltTexts(texts);&#13;
//            console.log("mml", mml);&#13;
//            presenter.saveSentences(texts);&#13;
//            if (isChrome()) {&#13;
//                presenter.amplifyABeforeColon(texts);&#13;
//            }&#13;
//&#13;
//&#13;
//            presenter.readText(texts, callback);&#13;
//        });&#13;
//&#13;
//    };&#13;
&#13;
    presenter.speakWithCallback = function (texts, callback) {&#13;
        console.log("speakWithCallback", texts)&#13;
&#13;
        texts = presenter.parseAltTexts(texts);&#13;
        presenter.saveSentences(texts);&#13;
        if (isChrome()) {&#13;
            presenter.amplifyABeforeColon(texts);&#13;
        }&#13;
&#13;
&#13;
        presenter.readText(texts, callback);&#13;
    };&#13;
&#13;
    /**&#13;
    * Amplify the letter 'A' or 'a' before colon&#13;
    * @param texts&#13;
    * @return&#13;
    **/&#13;
    presenter.amplifyABeforeColon = function (texts) {&#13;
        const regex = /([Aa][\s]*?):/;&#13;
        for (let i = 0; i &lt; texts.length; i++) {&#13;
            texts[i].text = texts[i].text.replace(regex, "$1,");&#13;
        }&#13;
    }&#13;
&#13;
    function isChrome () {&#13;
        const isEdge = navigator.userAgent.indexOf('Edge') !== -1 &amp;&amp; (!!navigator.msSaveBlob || !!navigator.msSaveOrOpenBlob);&#13;
        const isOpera = !!window.opera || navigator.userAgent.indexOf('OPR/') !== -1;&#13;
        const isSafari = navigator.userAgent.toLowerCase().indexOf('safari/') &gt; -1;&#13;
        return (!isOpera &amp;&amp; !isEdge &amp;&amp; !!navigator.webkitGetUserMedia) || isElectron() || isSafari;&#13;
    }&#13;
&#13;
    presenter.readText = function(texts, callback) {&#13;
        texts = presenter.splitLongTexts(texts);&#13;
        texts = presenter.removeUnnecessaryPunctuationMarks(texts);&#13;
&#13;
        if (window.responsiveVoice) {&#13;
            responsiveVoiceSpeak(texts, callback);&#13;
            return;&#13;
        }&#13;
&#13;
        if ('speechSynthesis' in window) {&#13;
            speechSynthesisSpeak(texts, callback);&#13;
            return;&#13;
        }&#13;
&#13;
        if (callback) {&#13;
            callback();&#13;
        }&#13;
    };&#13;
&#13;
    var delayedSpeakInterval = null; // only used by speakWhenIdle, which is why they are here and not at the top of the file&#13;
    var delayedSpeakTimeout = null;&#13;
    //This method works like speakWithCallback, except that it waits for TTS to be idle instead of interrupting it&#13;
    presenter.speakWhenIdle = function (data, callback) {&#13;
        if(delayedSpeakTimeout) {&#13;
            clearTimeout(delayedSpeakTimeout);&#13;
            delayedSpeakTimeout = null;&#13;
        }&#13;
         if(delayedSpeakInterval) {&#13;
            clearInterval(delayedSpeakInterval);&#13;
            delayedSpeakInterval = null;&#13;
        }&#13;
&#13;
        function setSpeakInterval (data, callback) {&#13;
            delayedSpeakInterval = setInterval(function () {&#13;
                var speechSynthSpeaking = false;&#13;
                var responsiveVoiceSpeaking = false;&#13;
&#13;
                // Detect if TTS is idle&#13;
                if ('speechSynthesis' in window) {&#13;
                    speechSynthSpeaking = window.speechSynthesis.speaking;&#13;
                }&#13;
                if (window.responsiveVoice) {&#13;
                    responsiveVoiceSpeaking = window.responsiveVoice.isPlaying();&#13;
                }&#13;
&#13;
                if (!speechSynthSpeaking &amp;&amp; !responsiveVoiceSpeaking) {&#13;
                    // If TTS is idle, pass data to TTS and break the loop&#13;
                    clearInterval(delayedSpeakInterval);&#13;
                    delayedSpeakInterval = null;&#13;
                    presenter.speakWithCallback(data, callback);&#13;
                }&#13;
            }, 100);&#13;
        }&#13;
&#13;
        /*&#13;
        * The timeout is used to ensure that if animation is triggered by another addon,&#13;
        * that addon has the opportunity to use TTS first, since animation acts as feedback&#13;
        */&#13;
        delayedSpeakTimeout = setTimeout(function(){ setSpeakInterval(data, callback); }, 200);&#13;
    };&#13;
&#13;
    presenter.playTitle = function (area, id, langTag) {&#13;
        if (area &amp;&amp; id) {&#13;
            var textVoices = [getTextVoiceObject(presenter.getAddOnConfiguration(area, id).title, langTag)];&#13;
            var module = null;&#13;
            if(0 === area.toLowerCase().localeCompare("main")){&#13;
                module = presenter.playerController.getModule(id);&#13;
            } else if (0 === area.toLowerCase().localeCompare("footer")) {&#13;
                module = presenter.playerController.getFooterModule(id);&#13;
            } else if (0 === area.toLowerCase().localeCompare("header")) {&#13;
                module = presenter.playerController.getHeaderModule(id);&#13;
            }&#13;
            if (module !== undefined &amp;&amp; module !== null &amp;&amp; module.hasOwnProperty('getTitlePostfix')) {&#13;
                textVoices.push(getTextVoiceObject(module.getTitlePostfix(), langTag));&#13;
            }&#13;
            presenter.speak(textVoices);&#13;
        }&#13;
    };&#13;
&#13;
    presenter.playPageTitle = function () {&#13;
        var textVoices = [];&#13;
        textVoices.push(getTextVoiceObject(presenter.configuration.newPage,''));&#13;
        if (!presenter.configuration.disableNewPageMessage) {&#13;
            textVoices.push(getTextVoiceObject(presenter.playerController.getPageTitle(),presenter.configuration.pageLangTag));&#13;
        }&#13;
        presenter.speak(textVoices);&#13;
    };&#13;
&#13;
    presenter.playEnterText = function () {&#13;
        presenter.speak([getTextVoiceObject(presenter.configuration.enterText)]);&#13;
    };&#13;
&#13;
    presenter.playExitText = function () {&#13;
        presenter.speak([getTextVoiceObject(presenter.configuration.exitText)]);&#13;
    };&#13;
&#13;
    presenter.getModulesOrder = function () {&#13;
        return presenter.configuration.addOnsConfiguration.map(function (c) {&#13;
            return {&#13;
                id: c.id,&#13;
                area: c.area&#13;
            };&#13;
        });&#13;
    };&#13;
&#13;
    presenter.saveSentences = function(texts) {&#13;
        if (!presenter.saveNextSentences) return;&#13;
        presenter.saveNextSentences = false;&#13;
        let textVoices = [];&#13;
        for (let i = 0; i &lt; texts.length; i++) {&#13;
            let speechText = texts[i];&#13;
            let splitSpeechTexts = splitLongText(speechText.text, speechText.lang);&#13;
            for (let j = 0; j &lt; splitSpeechTexts.length; j++) {&#13;
                textVoices.push(window.TTSUtils.getTextVoiceObject(splitSpeechTexts[j].text, speechText.lang));&#13;
            }&#13;
        }&#13;
        if (!presenter.compareSentences(presenter.savedSentences, textVoices)) {&#13;
            presenter.savedSentences = textVoices;&#13;
            presenter.savedSentencesIndex = -1;&#13;
        }&#13;
    }&#13;
&#13;
    presenter.clearSavedSentences = function() {&#13;
        presenter.savedSentences = [];&#13;
        presenter.savedSentencesIndex = -1;&#13;
        presenter.saveNextSentences = false;&#13;
    }&#13;
&#13;
    presenter.setSaveNextSentences = function(value) {&#13;
        presenter.saveNextSentences = value;&#13;
    }&#13;
&#13;
    presenter.readNextSavedSentence = function() {&#13;
        if (presenter.savedSentences.length == 0) {&#13;
            presenter.savedSentencesIndex = -1;&#13;
            return;&#13;
        }&#13;
        presenter.savedSentencesIndex += 1;&#13;
        if (presenter.savedSentencesIndex &gt;= presenter.savedSentences.length) presenter.savedSentencesIndex = presenter.savedSentences.length - 1;&#13;
        presenter.readCurrentSavedSentence();&#13;
    }&#13;
&#13;
    presenter.readPrevSavedSentence = function() {&#13;
        if (presenter.savedSentences.length == 0) {&#13;
            presenter.savedSentencesIndex = -1;&#13;
            return;&#13;
        }&#13;
        presenter.savedSentencesIndex -= 1;&#13;
        if (presenter.savedSentencesIndex &lt; 0) presenter.savedSentencesIndex = 0;&#13;
        presenter.readCurrentSavedSentence();&#13;
    }&#13;
&#13;
    presenter.readCurrentSavedSentence = function() {&#13;
        presenter.readText([presenter.savedSentences[presenter.savedSentencesIndex]], null);&#13;
    }&#13;
&#13;
    presenter.compareSentences = function(sentences1, sentences2) {&#13;
        if (sentences1.length != sentences2.length) return false;&#13;
        for (var i = 0; i &lt; sentences1.length; i++) {&#13;
            if (sentences1[i].lang != sentences2[i].lang) return false;&#13;
            if (sentences1[i].text != sentences2[i].text) return false;&#13;
        }&#13;
        return true;&#13;
    }&#13;
&#13;
    presenter.setVisibility = function (isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = function () {&#13;
        presenter.setVisibility(true);&#13;
        presenter.configuration.isVisible = true;&#13;
    };&#13;
&#13;
    presenter.hide = function () {&#13;
        presenter.setVisibility(false);&#13;
        presenter.configuration.isVisible = false;&#13;
    };&#13;
&#13;
    presenter.executeCommand = function (name, params) {&#13;
        if (!presenter.configuration.isValid) {&#13;
            return;&#13;
        }&#13;
&#13;
        var commands = {&#13;
            "show": presenter.show,&#13;
            "hide": presenter.hide,&#13;
            "speak": function(params) {&#13;
                    if (params.length === 2) {&#13;
                        presenter.speak(params[0], params[1]);&#13;
                    } else if (params.length === 1) {&#13;
                        presenter.speak(params[0]);&#13;
                    }&#13;
                },&#13;
            "playTitle": function(params) {&#13;
                    if (params.length === 3) {&#13;
                        presenter.playTitle(params[0],params[1],params[2]);&#13;
                    } else if (params.length === 2) {&#13;
                        presenter.playTitle(params[0],params[1]);&#13;
                    }&#13;
                },&#13;
            "playEnterText": presenter.playEnterText,&#13;
            "playExitText": presenter.playExitText,&#13;
            "getModulesOrder": presenter.getModulesOrder&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.getState = function () {&#13;
        return JSON.stringify({&#13;
            addOnsConfiguration: presenter.configuration.addOnsConfiguration,&#13;
            enterText: presenter.configuration.enterText,&#13;
            exitText: presenter.configuration.exitText,&#13;
&#13;
            isVisible: presenter.configuration.isVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setPlayerController = function(controller) {&#13;
        presenter.playerController = controller;&#13;
    };&#13;
&#13;
    presenter.setState = function (state) {&#13;
        if (ModelValidationUtils.isStringEmpty(state)) {&#13;
            return;&#13;
        }&#13;
&#13;
        var parsedState = JSON.parse(state);&#13;
&#13;
        presenter.configuration.addOnsConfiguration = parsedState.addOnsConfiguration;&#13;
        presenter.configuration.enterText = parsedState.enterText;&#13;
        presenter.configuration.exitText = parsedState.exitText;&#13;
&#13;
        presenter.configuration.isVisible = parsedState.isVisible;&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.cancelSpeechSynthesis = function(){&#13;
        if (window.responsiveVoice) {&#13;
            window.responsiveVoice.cancel();&#13;
        }&#13;
        if ('speechSynthesis' in window) {&#13;
            window.speechSynthesis.cancel();&#13;
        }&#13;
        if(presenter.speechSynthInterval!==null){&#13;
            clearInterval(presenter.intervalId);&#13;
            presenter.intervalId = undefined;&#13;
&#13;
            clearInterval(presenter.intervalResume);&#13;
            presenter.intervalResume = undefined;&#13;
        }&#13;
    };&#13;
&#13;
    presenter.destroy = function () {&#13;
        presenter.$view[0].removeEventListener('DOMNodeRemoved', presenter.destroy);&#13;
        presenter.cancelSpeechSynthesis();&#13;
        presenter.configuration = null;&#13;
        presenter.$view = null;&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>