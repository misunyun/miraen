<?xml version="1.0" encoding="UTF-8" standalone="no"?><addon xmlns="http://icplayer.com" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="Viewer_3D" xsi:schemaLocation="http://icplayer.com ../../tools/addon.xsd">
	<model>
		<property name="OBJ File" nameLabel="Viewer_3D_property_obj_file" type="file"/>
		<property name="MTL File" nameLabel="Viewer_3D_property_mtl_file" type="file"/>
		<property name="Initial Rotation X" nameLabel="Viewer_3D_property_initial_rotation_x" type="string"/>
		<property name="Initial Rotation Y" nameLabel="Viewer_3D_property_initial_rotation_y" type="string"/>
		<property name="Initial Rotation Z" nameLabel="Viewer_3D_property_initial_rotation_z" type="string"/>
		<property name="Model Color" nameLabel="Viewer_3D_property_model_color" type="string"/>
		<property name="Background Color 1" nameLabel="Viewer_3D_property_background_color_1" type="string"/>
		<property name="Background Color 2" nameLabel="Viewer_3D_property_background_color_2" type="string"/>
		<property name="Render Mode" nameLabel="Viewer_3D_property_render_mode" type="{Smooth,Points,Wireframe,Flat}"/>
	</model>
<css>/* https://code.google.com/p/android/issues/detail?id=35474 */&#13;
div.Viewer_3D_frame {&#13;
    overflow: hidden;&#13;
    overflow-x: visible;&#13;
}&#13;
&#13;
div.viewer-3d-wrapper {&#13;
    overflow: hidden;&#13;
    overflow-x: visible;&#13;
    -ms-touch-action: none;&#13;
    touch-action: none;&#13;
}&#13;
&#13;
</css><view>&lt;div class="viewer-3d-wrapper"&gt;&#13;
    &lt;canvas class="3d-viewer-canvas"&gt;&#13;
    &lt;/canvas&gt;&#13;
&lt;/div&gt;&#13;
</view><preview>&lt;div class="viewer-3d-wrapper"&gt;&#13;
    &lt;canvas class="3d-viewer-canvas"&gt;&#13;
    &lt;/canvas&gt;&#13;
&lt;/div&gt;&#13;
</preview><presenter>function AddonViewer_3D_create(){&#13;
    var deferredSyncQueue = window.DecoratorUtils.DeferredSyncQueue(deferredQueueDecoratorChecker);&#13;
&#13;
    var presenter = function () {};&#13;
&#13;
    presenter.RENDER_MODES = {&#13;
        'Smooth': 'SMOOTH',&#13;
        'Points': 'POINTS',&#13;
        'Wireframe': 'WIREFRAME',&#13;
        'Flat': 'FLAT',&#13;
        DEFAULT: 'Smooth'&#13;
    };&#13;
&#13;
    presenter.ERROR_CODES = {&#13;
        'ERR_01': 'Missing OBJ file!',&#13;
        'ERR_02': 'Invalid rotation values!',&#13;
        'ERR_03': 'Invalid model color!',&#13;
        'ERR_04': 'Invalid background color values!'&#13;
    };&#13;
&#13;
    function deferredQueueDecoratorChecker () {&#13;
        return presenter.isLoaded;&#13;
    }&#13;
&#13;
    presenter.getDeferredQueueVariable = function () {&#13;
        return deferredSyncQueue;&#13;
    };&#13;
&#13;
    presenter.run = function (view, model) {&#13;
        presenter.presenterLogic(view, model);&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
    };&#13;
&#13;
    presenter.createPreview = function (view, model) {&#13;
        presenter.presenterLogic(view, model);&#13;
        presenter.setVisibility(true);&#13;
    };&#13;
&#13;
    presenter.setCanvasDimensions = function (width, height) {&#13;
        presenter.$view.find('.3d-viewer-canvas').attr({&#13;
            width: width,&#13;
            height: height&#13;
        });&#13;
    };&#13;
&#13;
    presenter.parseRotation = function (strRotation) {&#13;
        var rotation, parsedRotation;&#13;
&#13;
        if (ModelValidationUtils.isStringEmpty(strRotation)) {&#13;
            rotation = 0;&#13;
        } else {&#13;
            parsedRotation = ModelValidationUtils.validateInteger(strRotation);&#13;
&#13;
            if (!parsedRotation.isValid || parsedRotation.value &lt; 0) {&#13;
                return { isValid: false };&#13;
            } else {&#13;
                rotation = parsedRotation.value;&#13;
            }&#13;
        }&#13;
&#13;
        return { isValid: true, rotation: rotation };&#13;
    };&#13;
&#13;
    presenter.parseInitialRotation = function (model) {&#13;
        var strRotationX = model['Initial Rotation X'],&#13;
            parsedRotationX = presenter.parseRotation(strRotationX),&#13;
            strRotationY = model['Initial Rotation Y'],&#13;
            parsedRotationY = presenter.parseRotation(strRotationY),&#13;
            strRotationZ = model['Initial Rotation Z'],&#13;
            parsedRotationZ = presenter.parseRotation(strRotationZ);&#13;
&#13;
        if (!parsedRotationX.isValid || !parsedRotationY.isValid || !parsedRotationZ.isValid) {&#13;
            return { isValid: false };&#13;
        }&#13;
&#13;
        return { isValid: true, X: parsedRotationX.rotation, Y: parsedRotationY.rotation, Z: parsedRotationZ.rotation };&#13;
    };&#13;
&#13;
    presenter.parseModelColor = function (modelColor) {&#13;
        if (ModelValidationUtils.isStringEmpty(modelColor)) {&#13;
            return { isValid: true, color: '#EEEEEE' };&#13;
        }&#13;
&#13;
        return ModelValidationUtils.validateColor(modelColor, '#EEEEEE');&#13;
    };&#13;
&#13;
    presenter.parseBackgroundColors = function (model) {&#13;
        var backgroundColor1 = model['Background Color 1'],&#13;
            parsedBackgroundColor1,&#13;
            backgroundColor2 = model['Background Color 2'],&#13;
            parsedBackgroundColor2;&#13;
&#13;
        // Background Color 1&#13;
        if (ModelValidationUtils.isStringEmpty(backgroundColor1)) {&#13;
            parsedBackgroundColor1 = { color: "#CCCCCC" };&#13;
        } else {&#13;
            parsedBackgroundColor1 = ModelValidationUtils.validateColor(backgroundColor1, '#CCCCCC');&#13;
            if (!parsedBackgroundColor1.isValid) {&#13;
                return { isValid: false };&#13;
            }&#13;
        }&#13;
&#13;
        // Background Color 1&#13;
        if (ModelValidationUtils.isStringEmpty(backgroundColor2)) {&#13;
            parsedBackgroundColor2 = { color: "#EEEEEE" };&#13;
        } else {&#13;
            parsedBackgroundColor2 = ModelValidationUtils.validateColor(backgroundColor2, '#EEEEEE');&#13;
            if (!parsedBackgroundColor2.isValid) {&#13;
                return { isValid: false };&#13;
            }&#13;
        }&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            color1: parsedBackgroundColor1.color,&#13;
            color2: parsedBackgroundColor2.color&#13;
        };&#13;
    };&#13;
&#13;
    presenter.parseModel = function (model) {&#13;
        if (ModelValidationUtils.isStringEmpty(model['OBJ File'])) {&#13;
            return { isValid: false, errorCode: 'ERR_01' };&#13;
        }&#13;
&#13;
        var MTLFile = model['MTL File'];&#13;
        if (ModelValidationUtils.isStringEmpty(MTLFile)) {&#13;
            MTLFile = '';&#13;
        }&#13;
&#13;
        var parsedInitialRotation = presenter.parseInitialRotation(model);&#13;
        if (!parsedInitialRotation.isValid) {&#13;
            return { isValid: false, errorCode: 'ERR_02' };&#13;
        }&#13;
&#13;
        var parsedModelColor = presenter.parseModelColor(model['Model Color']);&#13;
        if (!parsedModelColor.isValid) {&#13;
            return { isValid: false, errorCode: 'ERR_03' };&#13;
        }&#13;
&#13;
        var parsedBackgroundColors = presenter.parseBackgroundColors(model);&#13;
        if (!parsedBackgroundColors.isValid) {&#13;
            return { isValid: false, errorCode: 'ERR_04' };&#13;
        }&#13;
&#13;
        var renderMode = ModelValidationUtils.validateOption(presenter.RENDER_MODES, model['Render Mode']);&#13;
        var isVisible = ModelValidationUtils.validateBoolean(model["Is Visible"]);&#13;
&#13;
        return {&#13;
            isValid: true,&#13;
            addonID: model.ID,&#13;
            isVisible: isVisible,&#13;
            isCurrentlyVisible: isVisible,&#13;
            files: {&#13;
                OBJ: model['OBJ File'],&#13;
                MTL: MTLFile&#13;
            },&#13;
            initialRotation: {&#13;
                X: parsedInitialRotation.X,&#13;
                Y: parsedInitialRotation.Y,&#13;
                Z: parsedInitialRotation.Z&#13;
            },&#13;
            colors: {&#13;
                model: parsedModelColor.color,&#13;
                background1: parsedBackgroundColors.color1,&#13;
                background2: parsedBackgroundColors.color2&#13;
            },&#13;
            renderMode: renderMode,&#13;
            quality: 'standard',&#13;
            queues: {&#13;
                X: {&#13;
                    name: model.ID + "_X",&#13;
                    isActive: false,&#13;
                    delay: 0,&#13;
                    angle: 0&#13;
                },&#13;
                Y: {&#13;
                    name: model.ID + "_Y",&#13;
                    isActive: false,&#13;
                    delay: 0,&#13;
                    angle: 0&#13;
                },&#13;
                Z: {&#13;
                    name: model.ID + "_Z",&#13;
                    isActive: false,&#13;
                    delay: 0,&#13;
                    angle: 0&#13;
                }&#13;
            }&#13;
        };&#13;
    };&#13;
&#13;
    presenter.setViewerRenderMode = function (viewer) {&#13;
        var renderMode = "smooth";&#13;
&#13;
        switch (presenter.configuration.renderMode) {&#13;
            case 'POINTS':&#13;
                renderMode = "point";&#13;
                break;&#13;
            case 'WIREFRAME':&#13;
                renderMode = "wireframe";&#13;
                break;&#13;
            case 'FLAT':&#13;
                renderMode = 'flat';&#13;
                break;&#13;
        }&#13;
&#13;
        viewer.setParameter('RenderMode', renderMode);&#13;
    };&#13;
&#13;
    presenter.renderObject = function () {&#13;
        var canvas =  presenter.$view.find('.3d-viewer-canvas')[0],&#13;
            viewer = new JSC3D.Viewer(canvas);&#13;
&#13;
        presenter.viewer = viewer;&#13;
        viewer.setParameter('SceneUrl', presenter.configuration.files.OBJ + '.obj');&#13;
        viewer.setParameter('MtlLibUrl', presenter.configuration.files.MTL);&#13;
        viewer.setParameter('InitRotationX', presenter.configuration.initialRotation.X);&#13;
        viewer.setParameter('InitRotationY', presenter.configuration.initialRotation.Y);&#13;
        viewer.setParameter('InitRotationZ', presenter.configuration.initialRotation.Z);&#13;
        viewer.setParameter('ModelColor', presenter.configuration.colors.model);&#13;
        viewer.setParameter('BackgroundColor1', presenter.configuration.colors.background1);&#13;
        viewer.setParameter('BackgroundColor2', presenter.configuration.colors.background2);&#13;
        presenter.setViewerRenderMode(viewer);&#13;
&#13;
        viewer.init();&#13;
&#13;
        $.when(viewer.loadPromise).then(function () {&#13;
            presenter.isLoaded = true;&#13;
&#13;
            deferredSyncQueue.resolve()&#13;
        });&#13;
    };&#13;
&#13;
    presenter.presenterLogic = function (view, model) {&#13;
        presenter.$view = $(view);&#13;
        presenter.model = model;&#13;
        presenter.isLoaded = false;&#13;
&#13;
        presenter.setCanvasDimensions(model.Width, model.Height);&#13;
&#13;
        presenter.configuration = presenter.parseModel(model);&#13;
        if (!presenter.configuration.isValid) {&#13;
            DOMOperationsUtils.showErrorMessage(view, presenter.ERROR_CODES, presenter.configuration.errorCode);&#13;
            return;&#13;
        }&#13;
&#13;
        presenter.renderObject();&#13;
&#13;
        presenter.$view.click(function(e){&#13;
            e.stopPropagation();&#13;
        });&#13;
    };&#13;
&#13;
    presenter.executeCommand = function(name, params) {&#13;
        var commands = {&#13;
            'reset': presenter.reset,&#13;
            'show': presenter.show,&#13;
            'hide': presenter.hide,&#13;
            'rotateX': presenter.rotateXCommand,&#13;
            'rotateY': presenter.rotateYCommand,&#13;
            'rotateZ': presenter.rotateZCommand,&#13;
            'setState': presenter.setStateCommand,&#13;
            'setQuality': presenter.setQualityCommand,&#13;
            'startRotationX': presenter.startRotationXCommand,&#13;
            'stopRotationX': presenter.stopRotationX,&#13;
            'startRotationY': presenter.startRotationYCommand,&#13;
            'stopRotationY': presenter.stopRotationY,&#13;
            'startRotationZ': presenter.startRotationZCommand,&#13;
            'stopRotationZ': presenter.stopRotationZ,&#13;
            'stopAllRotations': presenter.stopAllRotations&#13;
        };&#13;
&#13;
        Commands.dispatch(commands, name, params, presenter);&#13;
    };&#13;
&#13;
    presenter.rotateObject = function (angleX, angleY, angleZ) {&#13;
        presenter.viewer.rotate(angleX, angleY, angleZ);&#13;
        presenter.viewer.update();&#13;
    };&#13;
&#13;
    presenter.validateAngle = function (angle) {&#13;
        var validatedAngle = ModelValidationUtils.validateFloat(angle);&#13;
&#13;
        if (!validatedAngle.isValid) return { isValid: false };&#13;
        if (validatedAngle.value &lt; 0) return { isValid: false };&#13;
&#13;
        return { isValid: true, value: validatedAngle.value };&#13;
    };&#13;
&#13;
    presenter.rotateX = deferredSyncQueue.decorate(function (angle) {&#13;
        var validatedAngle = presenter.validateAngle(angle);&#13;
        if (!validatedAngle.isValid) return;&#13;
&#13;
        presenter.rotateObject(validatedAngle.value, 0, 0);&#13;
    });&#13;
&#13;
    presenter.rotateXCommand = function (params) {&#13;
        presenter.rotateX(params[0]);&#13;
    };&#13;
&#13;
    presenter.rotateY = deferredSyncQueue.decorate(function (angle) {&#13;
        var validatedAngle = presenter.validateAngle(angle);&#13;
        if (!validatedAngle.isValid) return;&#13;
&#13;
        presenter.rotateObject(0, validatedAngle.value, 0);&#13;
    });&#13;
&#13;
    presenter.rotateYCommand = function (params) {&#13;
        presenter.rotateY(params[0]);&#13;
    };&#13;
&#13;
    presenter.rotateZ = deferredSyncQueue.decorate(function (angle) {&#13;
        var validatedAngle = presenter.validateAngle(angle);&#13;
        if (!validatedAngle.isValid) return;&#13;
&#13;
        presenter.rotateObject(0, 0, validatedAngle.value);&#13;
    });&#13;
&#13;
    presenter.rotateZCommand = function (params) {&#13;
        presenter.rotateZ(params[0]);&#13;
    };&#13;
&#13;
    presenter.setQuality = deferredSyncQueue.decorate(function (quality) {&#13;
        if (ModelValidationUtils.isStringEmpty(quality)) return;&#13;
        if (quality !== 'low' &amp;&amp; quality !== 'standard' &amp;&amp; quality !== 'high') return;&#13;
        if (presenter.configuration.quality === quality) return;&#13;
&#13;
        presenter.configuration.quality = quality;&#13;
        presenter.viewer.setDefinition(quality);&#13;
        presenter.viewer.update();&#13;
    });&#13;
&#13;
    presenter.setQualityCommand = function (params) {&#13;
        presenter.setQuality(params[0]);&#13;
    };&#13;
&#13;
    presenter.reset = deferredSyncQueue.decorate(function () {&#13;
        presenter.stopAllRotations();&#13;
        presenter.setQuality('standard');&#13;
&#13;
        presenter.setVisibility(presenter.configuration.isVisible);&#13;
        presenter.configuration.isCurrentlyVisible = presenter.configuration.isVisible;&#13;
&#13;
        presenter.viewer.replaceSceneFromUrl(presenter.configuration.files.OBJ + '.obj');&#13;
        presenter.viewer.update();&#13;
    });&#13;
&#13;
    presenter.setVisibility = function(isVisible) {&#13;
        presenter.$view.css("visibility", isVisible ? "visible" : "hidden");&#13;
    };&#13;
&#13;
    presenter.show = deferredSyncQueue.decorate(function () {&#13;
        if (presenter.configuration.isCurrentlyVisible) return;&#13;
&#13;
        presenter.configuration.isCurrentlyVisible = true;&#13;
        presenter.setVisibility(true);&#13;
    });&#13;
&#13;
    presenter.hide = deferredSyncQueue.decorate(function () {&#13;
        if (!presenter.configuration.isCurrentlyVisible) return;&#13;
&#13;
        presenter.configuration.isCurrentlyVisible = false;&#13;
        presenter.setVisibility(false);&#13;
    });&#13;
&#13;
    presenter.getState = function () {&#13;
        if (!presenter.isLoaded) return;&#13;
&#13;
        return JSON.stringify({&#13;
            isVisible: presenter.configuration.isCurrentlyVisible&#13;
        });&#13;
    };&#13;
&#13;
    presenter.setStateCommand = function (params) {&#13;
        presenter.setState(params[0]);&#13;
    };&#13;
&#13;
    presenter.setState = deferredSyncQueue.decorate(function (state) {&#13;
        if (!state) return;&#13;
&#13;
        var parsedState = JSON.parse(state);&#13;
&#13;
        if (parsedState.isVisible) {&#13;
            presenter.show();&#13;
        } else {&#13;
            presenter.hide();&#13;
        }&#13;
    });&#13;
&#13;
    presenter.validateDelay = function (delay) {&#13;
        var validatedDelay = ModelValidationUtils.validateInteger(delay);&#13;
&#13;
        if (!validatedDelay.isValid) return { isValid: false };&#13;
        if (validatedDelay.value &lt; 0) return { isValid: false };&#13;
&#13;
        return { isValid: true, value: validatedDelay.value };&#13;
    };&#13;
&#13;
    // Generic commands&#13;
&#13;
    presenter.startRotation = deferredSyncQueue.decorate(function (axis, angle, delay) {&#13;
        var validatedAngle = presenter.validateAngle(angle);&#13;
        if (!validatedAngle.isValid) return;&#13;
&#13;
        var validatedDelay = presenter.validateDelay(delay);&#13;
        if (!validatedDelay.isValid) return;&#13;
&#13;
        if (presenter.configuration.queues[axis].isActive) {&#13;
            if (validatedDelay.value == 0) {&#13;
                presenter['stopRotation' + axis]();&#13;
                return;&#13;
            }&#13;
&#13;
            presenter.configuration.queues[axis].delay = validatedDelay.value;&#13;
            presenter.configuration.queues[axis].angle = validatedAngle.value;&#13;
        } else {&#13;
            presenter.configuration.queues[axis].isActive = true;&#13;
            presenter.configuration.queues[axis].delay = validatedDelay.value;&#13;
            presenter.configuration.queues[axis].angle = validatedAngle.value;&#13;
&#13;
            presenter['startRotation' + axis + 'Queue']();&#13;
        }&#13;
    });&#13;
&#13;
    presenter.startRotationQueue = function (axis) {&#13;
        var queue = presenter.configuration.queues[axis].name,&#13;
            delay = presenter.configuration.queues[axis].delay;&#13;
&#13;
        $.doTimeout(queue, delay, function () {&#13;
            var angle = presenter.configuration.queues[axis].angle,&#13;
                angleX = 0, angleY = 0, angleZ = 0;&#13;
&#13;
            switch (axis) {&#13;
                case 'X':&#13;
                    angleX = angle;&#13;
                    break;&#13;
                case 'Y':&#13;
                    angleY = angle;&#13;
                    break;&#13;
                case 'Z':&#13;
                    angleZ = angle;&#13;
                    break;&#13;
            }&#13;
&#13;
            presenter.rotateObject(angleX, angleY, angleZ);&#13;
&#13;
            return true; // continue callback call&#13;
        });&#13;
    };&#13;
&#13;
    presenter.stopRotation = deferredSyncQueue.decorate(function (axis) {&#13;
        if (!presenter.configuration.queues[axis].isActive) return;&#13;
&#13;
        presenter.configuration.queues[axis].isActive = false;&#13;
        presenter.configuration.queues[axis].angle = 0;&#13;
        presenter.configuration.queues[axis].delay = 0;&#13;
&#13;
        presenter['stopRotation' + axis + 'Queue']();&#13;
    });&#13;
&#13;
    presenter.stopRotationQueue = function (axis) {&#13;
        var queue = presenter.configuration.queues[axis].name;&#13;
&#13;
        $.doTimeout(queue);&#13;
    };&#13;
&#13;
    // X-axis specific rotation commands&#13;
&#13;
    presenter.startRotationX = function (angle, delay) {&#13;
        presenter.startRotation('X', angle, delay);&#13;
    };&#13;
&#13;
    presenter.startRotationXCommand = function (params) {&#13;
        presenter.startRotationX(params[0], params[1]);&#13;
    };&#13;
&#13;
    presenter.startRotationXQueue = function () {&#13;
        presenter.startRotationQueue('X');&#13;
    };&#13;
&#13;
    presenter.stopRotationX = function () {&#13;
        presenter.stopRotation('X');&#13;
    };&#13;
&#13;
    presenter.stopRotationXQueue = function () {&#13;
        presenter.startRotationQueue('X');&#13;
    };&#13;
&#13;
    // Y-axis specific rotation commands&#13;
&#13;
    presenter.startRotationY = function (angle, delay) {&#13;
        presenter.startRotation('Y', angle, delay);&#13;
    };&#13;
&#13;
    presenter.startRotationYCommand = function (params) {&#13;
        presenter.startRotationY(params[0], params[1]);&#13;
    };&#13;
&#13;
    presenter.startRotationYQueue = function () {&#13;
        presenter.startRotationQueue('Y');&#13;
    };&#13;
&#13;
    presenter.stopRotationY = function () {&#13;
        presenter.stopRotation('Y');&#13;
    };&#13;
&#13;
    presenter.stopRotationYQueue = function () {&#13;
        presenter.startRotationQueue('Y');&#13;
    };&#13;
&#13;
    // Z-axis specific rotation commands&#13;
&#13;
    presenter.startRotationZ = function (angle, delay) {&#13;
        presenter.startRotation('Z', angle, delay);&#13;
    };&#13;
&#13;
    presenter.startRotationZCommand = function (params) {&#13;
        presenter.startRotationZ(params[0], params[1]);&#13;
    };&#13;
&#13;
    presenter.startRotationZQueue = function () {&#13;
        presenter.startRotationQueue('Z');&#13;
    };&#13;
&#13;
    presenter.stopRotationZ = function () {&#13;
        presenter.stopRotation('Z');&#13;
    };&#13;
&#13;
    presenter.stopRotationZQueue = function () {&#13;
        presenter.startRotationQueue('Z');&#13;
    };&#13;
&#13;
    presenter.stopAllRotations = function () {&#13;
        presenter.stopRotationX();&#13;
        presenter.stopRotationY();&#13;
        presenter.stopRotationZ();&#13;
    };&#13;
&#13;
    return presenter;&#13;
}&#13;
</presenter></addon>